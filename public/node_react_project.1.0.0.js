/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var express = __webpack_require__(1);
	var app = express();
	var variables = __webpack_require__(116);
	
	__webpack_require__(117);
	__webpack_require__(285)(app);
	__webpack_require__(334)(app);
	
	app.listen(variables.EXPRESS_PORT, function() {
	  console.log('listening on port' + variables.EXPRESS_PORT);
	});


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	module.exports = __webpack_require__(2);


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var EventEmitter = __webpack_require__(3).EventEmitter;
	var mixin = __webpack_require__(4);
	var proto = __webpack_require__(5);
	var Route = __webpack_require__(23);
	var Router = __webpack_require__(22);
	var req = __webpack_require__(95);
	var res = __webpack_require__(111);
	
	/**
	 * Expose `createApplication()`.
	 */
	
	exports = module.exports = createApplication;
	
	/**
	 * Create an express application.
	 *
	 * @return {Function}
	 * @api public
	 */
	
	function createApplication() {
	  var app = function(req, res, next) {
	    app.handle(req, res, next);
	  };
	
	  mixin(app, EventEmitter.prototype, false);
	  mixin(app, proto, false);
	
	  app.request = { __proto__: req, app: app };
	  app.response = { __proto__: res, app: app };
	  app.init();
	  return app;
	}
	
	/**
	 * Expose the prototypes.
	 */
	
	exports.application = proto;
	exports.request = req;
	exports.response = res;
	
	/**
	 * Expose constructors.
	 */
	
	exports.Route = Route;
	exports.Router = Router;
	
	/**
	 * Expose middleware
	 */
	
	exports.query = __webpack_require__(39);
	exports.static = __webpack_require__(115);
	
	/**
	 * Replace removed middleware with an appropriate error message.
	 */
	
	[
	  'json',
	  'urlencoded',
	  'bodyParser',
	  'compress',
	  'cookieSession',
	  'session',
	  'logger',
	  'cookieParser',
	  'favicon',
	  'responseTime',
	  'errorHandler',
	  'timeout',
	  'methodOverride',
	  'vhost',
	  'csrf',
	  'directory',
	  'limit',
	  'multipart',
	  'staticCache',
	].forEach(function (name) {
	  Object.defineProperty(exports, name, {
	    get: function () {
	      throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.');
	    },
	    configurable: true
	  });
	});


/***/ },
/* 3 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 4 */
/***/ function(module, exports) {

	/*!
	 * merge-descriptors
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = merge
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var hasOwnProperty = Object.prototype.hasOwnProperty
	
	/**
	 * Merge the property descriptors of `src` into `dest`
	 *
	 * @param {object} dest Object to add descriptors to
	 * @param {object} src Object to clone descriptors from
	 * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
	 * @returns {object} Reference to dest
	 * @public
	 */
	
	function merge(dest, src, redefine) {
	  if (!dest) {
	    throw new TypeError('argument dest is required')
	  }
	
	  if (!src) {
	    throw new TypeError('argument src is required')
	  }
	
	  if (redefine === undefined) {
	    // Default to true
	    redefine = true
	  }
	
	  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
	    if (!redefine && hasOwnProperty.call(dest, name)) {
	      // Skip desriptor
	      return
	    }
	
	    // Copy descriptor
	    var descriptor = Object.getOwnPropertyDescriptor(src, name)
	    Object.defineProperty(dest, name, descriptor)
	  })
	
	  return dest
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var finalhandler = __webpack_require__(7);
	var Router = __webpack_require__(22);
	var methods = __webpack_require__(27);
	var middleware = __webpack_require__(38);
	var query = __webpack_require__(39);
	var debug = __webpack_require__(13)('express:application');
	var View = __webpack_require__(44);
	var http = __webpack_require__(107);
	var compileETag = __webpack_require__(46).compileETag;
	var compileQueryParser = __webpack_require__(46).compileQueryParser;
	var compileTrust = __webpack_require__(46).compileTrust;
	var deprecate = __webpack_require__(30)('express');
	var flatten = __webpack_require__(24);
	var merge = __webpack_require__(29);
	var resolve = __webpack_require__(45).resolve;
	var slice = Array.prototype.slice;
	
	/**
	 * Application prototype.
	 */
	
	var app = exports = module.exports = {};
	
	/**
	 * Variable for trust proxy inheritance back-compat
	 * @private
	 */
	
	var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';
	
	/**
	 * Initialize the server.
	 *
	 *   - setup default configuration
	 *   - setup default middleware
	 *   - setup route reflection methods
	 *
	 * @private
	 */
	
	app.init = function init() {
	  this.cache = {};
	  this.engines = {};
	  this.settings = {};
	
	  this.defaultConfiguration();
	};
	
	/**
	 * Initialize application configuration.
	 * @private
	 */
	
	app.defaultConfiguration = function defaultConfiguration() {
	  var env = process.env.NODE_ENV || 'development';
	
	  // default settings
	  this.enable('x-powered-by');
	  this.set('etag', 'weak');
	  this.set('env', env);
	  this.set('query parser', 'extended');
	  this.set('subdomain offset', 2);
	  this.set('trust proxy', false);
	
	  // trust proxy inherit back-compat
	  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
	    configurable: true,
	    value: true
	  });
	
	  debug('booting in %s mode', env);
	
	  this.on('mount', function onmount(parent) {
	    // inherit trust proxy
	    if (this.settings[trustProxyDefaultSymbol] === true
	      && typeof parent.settings['trust proxy fn'] === 'function') {
	      delete this.settings['trust proxy'];
	      delete this.settings['trust proxy fn'];
	    }
	
	    // inherit protos
	    this.request.__proto__ = parent.request;
	    this.response.__proto__ = parent.response;
	    this.engines.__proto__ = parent.engines;
	    this.settings.__proto__ = parent.settings;
	  });
	
	  // setup locals
	  this.locals = Object.create(null);
	
	  // top-most app is mounted at /
	  this.mountpath = '/';
	
	  // default locals
	  this.locals.settings = this.settings;
	
	  // default configuration
	  this.set('view', View);
	  this.set('views', resolve('views'));
	  this.set('jsonp callback name', 'callback');
	
	  if (env === 'production') {
	    this.enable('view cache');
	  }
	
	  Object.defineProperty(this, 'router', {
	    get: function() {
	      throw new Error('\'app.router\' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');
	    }
	  });
	};
	
	/**
	 * lazily adds the base router if it has not yet been added.
	 *
	 * We cannot add the base router in the defaultConfiguration because
	 * it reads app settings which might be set after that has run.
	 *
	 * @private
	 */
	app.lazyrouter = function lazyrouter() {
	  if (!this._router) {
	    this._router = new Router({
	      caseSensitive: this.enabled('case sensitive routing'),
	      strict: this.enabled('strict routing')
	    });
	
	    this._router.use(query(this.get('query parser fn')));
	    this._router.use(middleware.init(this));
	  }
	};
	
	/**
	 * Dispatch a req, res pair into the application. Starts pipeline processing.
	 *
	 * If no callback is provided, then default error handlers will respond
	 * in the event of an error bubbling through the stack.
	 *
	 * @private
	 */
	
	app.handle = function handle(req, res, callback) {
	  var router = this._router;
	
	  // final handler
	  var done = callback || finalhandler(req, res, {
	    env: this.get('env'),
	    onerror: logerror.bind(this)
	  });
	
	  // no routes
	  if (!router) {
	    debug('no routes defined on app');
	    done();
	    return;
	  }
	
	  router.handle(req, res, done);
	};
	
	/**
	 * Proxy `Router#use()` to add middleware to the app router.
	 * See Router#use() documentation for details.
	 *
	 * If the _fn_ parameter is an express app, then it will be
	 * mounted at the _route_ specified.
	 *
	 * @public
	 */
	
	app.use = function use(fn) {
	  var offset = 0;
	  var path = '/';
	
	  // default path to '/'
	  // disambiguate app.use([fn])
	  if (typeof fn !== 'function') {
	    var arg = fn;
	
	    while (Array.isArray(arg) && arg.length !== 0) {
	      arg = arg[0];
	    }
	
	    // first arg is the path
	    if (typeof arg !== 'function') {
	      offset = 1;
	      path = fn;
	    }
	  }
	
	  var fns = flatten(slice.call(arguments, offset));
	
	  if (fns.length === 0) {
	    throw new TypeError('app.use() requires middleware functions');
	  }
	
	  // setup router
	  this.lazyrouter();
	  var router = this._router;
	
	  fns.forEach(function (fn) {
	    // non-express app
	    if (!fn || !fn.handle || !fn.set) {
	      return router.use(path, fn);
	    }
	
	    debug('.use app under %s', path);
	    fn.mountpath = path;
	    fn.parent = this;
	
	    // restore .app property on req and res
	    router.use(path, function mounted_app(req, res, next) {
	      var orig = req.app;
	      fn.handle(req, res, function (err) {
	        req.__proto__ = orig.request;
	        res.__proto__ = orig.response;
	        next(err);
	      });
	    });
	
	    // mounted an app
	    fn.emit('mount', this);
	  }, this);
	
	  return this;
	};
	
	/**
	 * Proxy to the app `Router#route()`
	 * Returns a new `Route` instance for the _path_.
	 *
	 * Routes are isolated middleware stacks for specific paths.
	 * See the Route api docs for details.
	 *
	 * @public
	 */
	
	app.route = function route(path) {
	  this.lazyrouter();
	  return this._router.route(path);
	};
	
	/**
	 * Register the given template engine callback `fn`
	 * as `ext`.
	 *
	 * By default will `require()` the engine based on the
	 * file extension. For example if you try to render
	 * a "foo.jade" file Express will invoke the following internally:
	 *
	 *     app.engine('jade', require('jade').__express);
	 *
	 * For engines that do not provide `.__express` out of the box,
	 * or if you wish to "map" a different extension to the template engine
	 * you may use this method. For example mapping the EJS template engine to
	 * ".html" files:
	 *
	 *     app.engine('html', require('ejs').renderFile);
	 *
	 * In this case EJS provides a `.renderFile()` method with
	 * the same signature that Express expects: `(path, options, callback)`,
	 * though note that it aliases this method as `ejs.__express` internally
	 * so if you're using ".ejs" extensions you dont need to do anything.
	 *
	 * Some template engines do not follow this convention, the
	 * [Consolidate.js](https://github.com/tj/consolidate.js)
	 * library was created to map all of node's popular template
	 * engines to follow this convention, thus allowing them to
	 * work seamlessly within Express.
	 *
	 * @param {String} ext
	 * @param {Function} fn
	 * @return {app} for chaining
	 * @public
	 */
	
	app.engine = function engine(ext, fn) {
	  if (typeof fn !== 'function') {
	    throw new Error('callback function required');
	  }
	
	  // get file extension
	  var extension = ext[0] !== '.'
	    ? '.' + ext
	    : ext;
	
	  // store engine
	  this.engines[extension] = fn;
	
	  return this;
	};
	
	/**
	 * Proxy to `Router#param()` with one added api feature. The _name_ parameter
	 * can be an array of names.
	 *
	 * See the Router#param() docs for more details.
	 *
	 * @param {String|Array} name
	 * @param {Function} fn
	 * @return {app} for chaining
	 * @public
	 */
	
	app.param = function param(name, fn) {
	  this.lazyrouter();
	
	  if (Array.isArray(name)) {
	    for (var i = 0; i < name.length; i++) {
	      this.param(name[i], fn);
	    }
	
	    return this;
	  }
	
	  this._router.param(name, fn);
	
	  return this;
	};
	
	/**
	 * Assign `setting` to `val`, or return `setting`'s value.
	 *
	 *    app.set('foo', 'bar');
	 *    app.get('foo');
	 *    // => "bar"
	 *
	 * Mounted servers inherit their parent server's settings.
	 *
	 * @param {String} setting
	 * @param {*} [val]
	 * @return {Server} for chaining
	 * @public
	 */
	
	app.set = function set(setting, val) {
	  if (arguments.length === 1) {
	    // app.get(setting)
	    return this.settings[setting];
	  }
	
	  debug('set "%s" to %o', setting, val);
	
	  // set value
	  this.settings[setting] = val;
	
	  // trigger matched settings
	  switch (setting) {
	    case 'etag':
	      this.set('etag fn', compileETag(val));
	      break;
	    case 'query parser':
	      this.set('query parser fn', compileQueryParser(val));
	      break;
	    case 'trust proxy':
	      this.set('trust proxy fn', compileTrust(val));
	
	      // trust proxy inherit back-compat
	      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
	        configurable: true,
	        value: false
	      });
	
	      break;
	  }
	
	  return this;
	};
	
	/**
	 * Return the app's absolute pathname
	 * based on the parent(s) that have
	 * mounted it.
	 *
	 * For example if the application was
	 * mounted as "/admin", which itself
	 * was mounted as "/blog" then the
	 * return value would be "/blog/admin".
	 *
	 * @return {String}
	 * @private
	 */
	
	app.path = function path() {
	  return this.parent
	    ? this.parent.path() + this.mountpath
	    : '';
	};
	
	/**
	 * Check if `setting` is enabled (truthy).
	 *
	 *    app.enabled('foo')
	 *    // => false
	 *
	 *    app.enable('foo')
	 *    app.enabled('foo')
	 *    // => true
	 *
	 * @param {String} setting
	 * @return {Boolean}
	 * @public
	 */
	
	app.enabled = function enabled(setting) {
	  return Boolean(this.set(setting));
	};
	
	/**
	 * Check if `setting` is disabled.
	 *
	 *    app.disabled('foo')
	 *    // => true
	 *
	 *    app.enable('foo')
	 *    app.disabled('foo')
	 *    // => false
	 *
	 * @param {String} setting
	 * @return {Boolean}
	 * @public
	 */
	
	app.disabled = function disabled(setting) {
	  return !this.set(setting);
	};
	
	/**
	 * Enable `setting`.
	 *
	 * @param {String} setting
	 * @return {app} for chaining
	 * @public
	 */
	
	app.enable = function enable(setting) {
	  return this.set(setting, true);
	};
	
	/**
	 * Disable `setting`.
	 *
	 * @param {String} setting
	 * @return {app} for chaining
	 * @public
	 */
	
	app.disable = function disable(setting) {
	  return this.set(setting, false);
	};
	
	/**
	 * Delegate `.VERB(...)` calls to `router.VERB(...)`.
	 */
	
	methods.forEach(function(method){
	  app[method] = function(path){
	    if (method === 'get' && arguments.length === 1) {
	      // app.get(setting)
	      return this.set(path);
	    }
	
	    this.lazyrouter();
	
	    var route = this._router.route(path);
	    route[method].apply(route, slice.call(arguments, 1));
	    return this;
	  };
	});
	
	/**
	 * Special-cased "all" method, applying the given route `path`,
	 * middleware, and callback to _every_ HTTP method.
	 *
	 * @param {String} path
	 * @param {Function} ...
	 * @return {app} for chaining
	 * @public
	 */
	
	app.all = function all(path) {
	  this.lazyrouter();
	
	  var route = this._router.route(path);
	  var args = slice.call(arguments, 1);
	
	  for (var i = 0; i < methods.length; i++) {
	    route[methods[i]].apply(route, args);
	  }
	
	  return this;
	};
	
	// del -> delete alias
	
	app.del = deprecate.function(app.delete, 'app.del: Use app.delete instead');
	
	/**
	 * Render the given view `name` name with `options`
	 * and a callback accepting an error and the
	 * rendered template string.
	 *
	 * Example:
	 *
	 *    app.render('email', { name: 'Tobi' }, function(err, html){
	 *      // ...
	 *    })
	 *
	 * @param {String} name
	 * @param {Object|Function} options or fn
	 * @param {Function} callback
	 * @public
	 */
	
	app.render = function render(name, options, callback) {
	  var cache = this.cache;
	  var done = callback;
	  var engines = this.engines;
	  var opts = options;
	  var renderOptions = {};
	  var view;
	
	  // support callback function as second arg
	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }
	
	  // merge app.locals
	  merge(renderOptions, this.locals);
	
	  // merge options._locals
	  if (opts._locals) {
	    merge(renderOptions, opts._locals);
	  }
	
	  // merge options
	  merge(renderOptions, opts);
	
	  // set .cache unless explicitly provided
	  if (renderOptions.cache == null) {
	    renderOptions.cache = this.enabled('view cache');
	  }
	
	  // primed cache
	  if (renderOptions.cache) {
	    view = cache[name];
	  }
	
	  // view
	  if (!view) {
	    var View = this.get('view');
	
	    view = new View(name, {
	      defaultEngine: this.get('view engine'),
	      root: this.get('views'),
	      engines: engines
	    });
	
	    if (!view.path) {
	      var dirs = Array.isArray(view.root) && view.root.length > 1
	        ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"'
	        : 'directory "' + view.root + '"'
	      var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
	      err.view = view;
	      return done(err);
	    }
	
	    // prime the cache
	    if (renderOptions.cache) {
	      cache[name] = view;
	    }
	  }
	
	  // render
	  tryRender(view, renderOptions, done);
	};
	
	/**
	 * Listen for connections.
	 *
	 * A node `http.Server` is returned, with this
	 * application (which is a `Function`) as its
	 * callback. If you wish to create both an HTTP
	 * and HTTPS server you may do so with the "http"
	 * and "https" modules as shown here:
	 *
	 *    var http = require('http')
	 *      , https = require('https')
	 *      , express = require('express')
	 *      , app = express();
	 *
	 *    http.createServer(app).listen(80);
	 *    https.createServer({ ... }, app).listen(443);
	 *
	 * @return {http.Server}
	 * @public
	 */
	
	app.listen = function listen() {
	  var server = http.createServer(this);
	  return server.listen.apply(server, arguments);
	};
	
	/**
	 * Log error using console.error.
	 *
	 * @param {Error} err
	 * @private
	 */
	
	function logerror(err) {
	  /* istanbul ignore next */
	  if (this.get('env') !== 'test') console.error(err.stack || err.toString());
	}
	
	/**
	 * Try rendering a view.
	 * @private
	 */
	
	function tryRender(view, options, callback) {
	  try {
	    view.render(options, callback);
	  } catch (err) {
	    callback(err);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 6 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	    try {
	        cachedSetTimeout = setTimeout;
	    } catch (e) {
	        cachedSetTimeout = function () {
	            throw new Error('setTimeout is not defined');
	        }
	    }
	    try {
	        cachedClearTimeout = clearTimeout;
	    } catch (e) {
	        cachedClearTimeout = function () {
	            throw new Error('clearTimeout is not defined');
	        }
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        return setTimeout(fun, 0);
	    } else {
	        return cachedSetTimeout.call(null, fun, 0);
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        clearTimeout(marker);
	    } else {
	        cachedClearTimeout.call(null, marker);
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, process, Buffer) {/*!
	 * finalhandler
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var debug = __webpack_require__(13)('finalhandler')
	var escapeHtml = __webpack_require__(16)
	var onFinished = __webpack_require__(17)
	var statuses = __webpack_require__(19)
	var unpipe = __webpack_require__(21)
	
	/**
	 * Module variables.
	 * @private
	 */
	
	/* istanbul ignore next */
	var defer = typeof setImmediate === 'function'
	  ? setImmediate
	  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) }
	var isFinished = onFinished.isFinished
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = finalhandler
	
	/**
	 * Create a function to handle the final response.
	 *
	 * @param {Request} req
	 * @param {Response} res
	 * @param {Object} [options]
	 * @return {Function}
	 * @public
	 */
	
	function finalhandler (req, res, options) {
	  var opts = options || {}
	
	  // get environment
	  var env = opts.env || process.env.NODE_ENV || 'development'
	
	  // get error callback
	  var onerror = opts.onerror
	
	  return function (err) {
	    var headers = Object.create(null)
	    var status
	
	    // ignore 404 on in-flight response
	    if (!err && res._header) {
	      debug('cannot 404 after headers sent')
	      return
	    }
	
	    // unhandled error
	    if (err) {
	      // respect status code from error
	      status = getErrorStatusCode(err) || res.statusCode
	
	      // default status code to 500 if outside valid range
	      if (typeof status !== 'number' || status < 400 || status > 599) {
	        status = 500
	      }
	
	      // respect err.headers
	      if (err.headers && (err.status === status || err.statusCode === status)) {
	        var keys = Object.keys(err.headers)
	        for (var i = 0; i < keys.length; i++) {
	          var key = keys[i]
	          headers[key] = err.headers[key]
	        }
	      }
	
	      // production gets a basic error message
	      var msg = env === 'production'
	        ? statuses[status]
	        : err.stack || err.toString()
	      msg = escapeHtml(msg)
	        .replace(/\n/g, '<br>')
	        .replace(/\x20{2}/g, ' &nbsp;') + '\n'
	    } else {
	      status = 404
	      msg = 'Cannot ' + escapeHtml(req.method) + ' ' + escapeHtml(req.originalUrl || req.url) + '\n'
	    }
	
	    debug('default %s', status)
	
	    // schedule onerror callback
	    if (err && onerror) {
	      defer(onerror, err, req, res)
	    }
	
	    // cannot actually respond
	    if (res._header) {
	      debug('cannot %d after headers sent', status)
	      req.socket.destroy()
	      return
	    }
	
	    // send response
	    send(req, res, status, headers, msg)
	  }
	}
	
	/**
	 * Get status code from Error object.
	 *
	 * @param {Error} err
	 * @return {number}
	 * @private
	 */
	
	function getErrorStatusCode (err) {
	  // check err.status
	  if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {
	    return err.status
	  }
	
	  // check err.statusCode
	  if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {
	    return err.statusCode
	  }
	
	  return undefined
	}
	
	/**
	 * Send response.
	 *
	 * @param {IncomingMessage} req
	 * @param {OutgoingMessage} res
	 * @param {number} status
	 * @param {object} headers
	 * @param {string} body
	 * @private
	 */
	
	function send (req, res, status, headers, body) {
	  function write () {
	    // response status
	    res.statusCode = status
	    res.statusMessage = statuses[status]
	
	    // response headers
	    var keys = Object.keys(headers)
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i]
	      res.setHeader(key, headers[key])
	    }
	
	    // security header for content sniffing
	    res.setHeader('X-Content-Type-Options', 'nosniff')
	
	    // standard headers
	    res.setHeader('Content-Type', 'text/html; charset=utf-8')
	    res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'))
	
	    if (req.method === 'HEAD') {
	      res.end()
	      return
	    }
	
	    res.end(body, 'utf8')
	  }
	
	  if (isFinished(req)) {
	    write()
	    return
	  }
	
	  // unpipe everything from the request
	  unpipe(req)
	
	  // flush the request
	  onFinished(req, write)
	  req.resume()
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8).setImmediate, __webpack_require__(6), __webpack_require__(9).Buffer))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(6).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8).setImmediate, __webpack_require__(8).clearImmediate))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(10)
	var ieee754 = __webpack_require__(11)
	var isArray = __webpack_require__(12)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation
	
	var rootParent = {}
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }
	
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }
	
	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }
	
	  // Unusual.
	  return fromObject(this, arg)
	}
	
	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
	
	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)
	
	  if (isArray(object)) return fromArray(that, object)
	
	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }
	
	  if (object.length) return fromArrayLike(that, object)
	
	  return fromJsonObject(that, object)
	}
	
	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}
	
	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0
	
	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)
	
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}
	
	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }
	
	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent
	
	  return that
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
	
	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break
	
	    ++i
	  }
	
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
	
	  if (list.length === 0) {
	    return new Buffer(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }
	
	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}
	
	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0
	
	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }
	
	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}
	
	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  if (newBuf.length) newBuf.parent = this.parent || this
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }
	
	  return len
	}
	
	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length
	
	  if (end < start) throw new RangeError('end < start')
	
	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return
	
	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
	
	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var BP = Buffer.prototype
	
	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true
	
	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set
	
	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set
	
	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer
	
	  return arr
	}
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer, (function() { return this; }())))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	
	;(function (exports) {
		'use strict';
	
	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array
	
		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)
	
		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}
	
		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr
	
			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}
	
			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
	
			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)
	
			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length
	
			var L = 0
	
			function push (v) {
				arr[L++] = v
			}
	
			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}
	
			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}
	
			return arr
		}
	
		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length
	
			function encode (num) {
				return lookup.charAt(num)
			}
	
			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}
	
			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}
	
			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}
	
			return output
		}
	
		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 11 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 12 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(14);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(15);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 15 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 16 */
/***/ function(module, exports) {

	/*!
	 * escape-html
	 * Copyright(c) 2012-2013 TJ Holowaychuk
	 * Copyright(c) 2015 Andreas Lubbe
	 * Copyright(c) 2015 Tiancheng "Timothy" Gu
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var matchHtmlRegExp = /["'&<>]/;
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = escapeHtml;
	
	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */
	
	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);
	
	  if (!match) {
	    return str;
	  }
	
	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;
	
	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34: // "
	        escape = '&quot;';
	        break;
	      case 38: // &
	        escape = '&amp;';
	        break;
	      case 39: // '
	        escape = '&#39;';
	        break;
	      case 60: // <
	        escape = '&lt;';
	        break;
	      case 62: // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }
	
	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }
	
	    lastIndex = index + 1;
	    html += escape;
	  }
	
	  return lastIndex !== index
	    ? html + str.substring(lastIndex, index)
	    : html;
	}


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, process) {/*!
	 * on-finished
	 * Copyright(c) 2013 Jonathan Ong
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = onFinished
	module.exports.isFinished = isFinished
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var first = __webpack_require__(18)
	
	/**
	 * Variables.
	 * @private
	 */
	
	/* istanbul ignore next */
	var defer = typeof setImmediate === 'function'
	  ? setImmediate
	  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }
	
	/**
	 * Invoke callback when the response has finished, useful for
	 * cleaning up resources afterwards.
	 *
	 * @param {object} msg
	 * @param {function} listener
	 * @return {object}
	 * @public
	 */
	
	function onFinished(msg, listener) {
	  if (isFinished(msg) !== false) {
	    defer(listener, null, msg)
	    return msg
	  }
	
	  // attach the listener to the message
	  attachListener(msg, listener)
	
	  return msg
	}
	
	/**
	 * Determine if message is already finished.
	 *
	 * @param {object} msg
	 * @return {boolean}
	 * @public
	 */
	
	function isFinished(msg) {
	  var socket = msg.socket
	
	  if (typeof msg.finished === 'boolean') {
	    // OutgoingMessage
	    return Boolean(msg.finished || (socket && !socket.writable))
	  }
	
	  if (typeof msg.complete === 'boolean') {
	    // IncomingMessage
	    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))
	  }
	
	  // don't know
	  return undefined
	}
	
	/**
	 * Attach a finished listener to the message.
	 *
	 * @param {object} msg
	 * @param {function} callback
	 * @private
	 */
	
	function attachFinishedListener(msg, callback) {
	  var eeMsg
	  var eeSocket
	  var finished = false
	
	  function onFinish(error) {
	    eeMsg.cancel()
	    eeSocket.cancel()
	
	    finished = true
	    callback(error)
	  }
	
	  // finished on first message event
	  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)
	
	  function onSocket(socket) {
	    // remove listener
	    msg.removeListener('socket', onSocket)
	
	    if (finished) return
	    if (eeMsg !== eeSocket) return
	
	    // finished on first socket event
	    eeSocket = first([[socket, 'error', 'close']], onFinish)
	  }
	
	  if (msg.socket) {
	    // socket already assigned
	    onSocket(msg.socket)
	    return
	  }
	
	  // wait for socket to be assigned
	  msg.on('socket', onSocket)
	
	  if (msg.socket === undefined) {
	    // node.js 0.8 patch
	    patchAssignSocket(msg, onSocket)
	  }
	}
	
	/**
	 * Attach the listener to the message.
	 *
	 * @param {object} msg
	 * @return {function}
	 * @private
	 */
	
	function attachListener(msg, listener) {
	  var attached = msg.__onFinished
	
	  // create a private single listener with queue
	  if (!attached || !attached.queue) {
	    attached = msg.__onFinished = createListener(msg)
	    attachFinishedListener(msg, attached)
	  }
	
	  attached.queue.push(listener)
	}
	
	/**
	 * Create listener on message.
	 *
	 * @param {object} msg
	 * @return {function}
	 * @private
	 */
	
	function createListener(msg) {
	  function listener(err) {
	    if (msg.__onFinished === listener) msg.__onFinished = null
	    if (!listener.queue) return
	
	    var queue = listener.queue
	    listener.queue = null
	
	    for (var i = 0; i < queue.length; i++) {
	      queue[i](err, msg)
	    }
	  }
	
	  listener.queue = []
	
	  return listener
	}
	
	/**
	 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
	 *
	 * @param {ServerResponse} res
	 * @param {function} callback
	 * @private
	 */
	
	function patchAssignSocket(res, callback) {
	  var assignSocket = res.assignSocket
	
	  if (typeof assignSocket !== 'function') return
	
	  // res.on('socket', callback) is broken in 0.8
	  res.assignSocket = function _assignSocket(socket) {
	    assignSocket.call(this, socket)
	    callback(socket)
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8).setImmediate, __webpack_require__(6)))

/***/ },
/* 18 */
/***/ function(module, exports) {

	/*!
	 * ee-first
	 * Copyright(c) 2014 Jonathan Ong
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = first
	
	/**
	 * Get the first event in a set of event emitters and event pairs.
	 *
	 * @param {array} stuff
	 * @param {function} done
	 * @public
	 */
	
	function first(stuff, done) {
	  if (!Array.isArray(stuff))
	    throw new TypeError('arg must be an array of [ee, events...] arrays')
	
	  var cleanups = []
	
	  for (var i = 0; i < stuff.length; i++) {
	    var arr = stuff[i]
	
	    if (!Array.isArray(arr) || arr.length < 2)
	      throw new TypeError('each array member must be [ee, events...]')
	
	    var ee = arr[0]
	
	    for (var j = 1; j < arr.length; j++) {
	      var event = arr[j]
	      var fn = listener(event, callback)
	
	      // listen to the event
	      ee.on(event, fn)
	      // push this listener to the list of cleanups
	      cleanups.push({
	        ee: ee,
	        event: event,
	        fn: fn,
	      })
	    }
	  }
	
	  function callback() {
	    cleanup()
	    done.apply(null, arguments)
	  }
	
	  function cleanup() {
	    var x
	    for (var i = 0; i < cleanups.length; i++) {
	      x = cleanups[i]
	      x.ee.removeListener(x.event, x.fn)
	    }
	  }
	
	  function thunk(fn) {
	    done = fn
	  }
	
	  thunk.cancel = cleanup
	
	  return thunk
	}
	
	/**
	 * Create the event listener.
	 * @private
	 */
	
	function listener(event, done) {
	  return function onevent(arg1) {
	    var args = new Array(arguments.length)
	    var ee = this
	    var err = event === 'error'
	      ? arg1
	      : null
	
	    // copy args to prevent arguments escaping scope
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i]
	    }
	
	    done(err, ee, event, args)
	  }
	}


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * statuses
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var codes = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./codes.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = status
	
	// array of status codes
	status.codes = populateStatusesMap(status, codes)
	
	// status codes for redirects
	status.redirect = {
	  300: true,
	  301: true,
	  302: true,
	  303: true,
	  305: true,
	  307: true,
	  308: true
	}
	
	// status codes for empty bodies
	status.empty = {
	  204: true,
	  205: true,
	  304: true
	}
	
	// status codes for when you should retry the request
	status.retry = {
	  502: true,
	  503: true,
	  504: true
	}
	
	/**
	 * Populate the statuses map for given codes.
	 * @private
	 */
	
	function populateStatusesMap (statuses, codes) {
	  var arr = []
	
	  Object.keys(codes).forEach(function forEachCode (code) {
	    var message = codes[code]
	    var status = Number(code)
	
	    // Populate properties
	    statuses[status] = message
	    statuses[message] = status
	    statuses[message.toLowerCase()] = status
	
	    // Add to array
	    arr.push(status)
	  })
	
	  return arr
	}
	
	/**
	 * Get the status code.
	 *
	 * Given a number, this will throw if it is not a known status
	 * code, otherwise the code will be returned. Given a string,
	 * the string will be parsed for a number and return the code
	 * if valid, otherwise will lookup the code assuming this is
	 * the status message.
	 *
	 * @param {string|number} code
	 * @returns {string}
	 * @public
	 */
	
	function status (code) {
	  if (typeof code === 'number') {
	    if (!status[code]) throw new Error('invalid status code: ' + code)
	    return code
	  }
	
	  if (typeof code !== 'string') {
	    throw new TypeError('code must be a number or string')
	  }
	
	  // '403'
	  var n = parseInt(code, 10)
	  if (!isNaN(n)) {
	    if (!status[n]) throw new Error('invalid status code: ' + n)
	    return n
	  }
	
	  n = status[code.toLowerCase()]
	  if (!n) throw new Error('invalid status message: "' + code + '"')
	  return n
	}


/***/ },
/* 20 */,
/* 21 */
/***/ function(module, exports) {

	/*!
	 * unpipe
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = unpipe
	
	/**
	 * Determine if there are Node.js pipe-like data listeners.
	 * @private
	 */
	
	function hasPipeDataListeners(stream) {
	  var listeners = stream.listeners('data')
	
	  for (var i = 0; i < listeners.length; i++) {
	    if (listeners[i].name === 'ondata') {
	      return true
	    }
	  }
	
	  return false
	}
	
	/**
	 * Unpipe a stream from all destinations.
	 *
	 * @param {object} stream
	 * @public
	 */
	
	function unpipe(stream) {
	  if (!stream) {
	    throw new TypeError('argument stream is required')
	  }
	
	  if (typeof stream.unpipe === 'function') {
	    // new-style
	    stream.unpipe()
	    return
	  }
	
	  // Node.js 0.8 hack
	  if (!hasPipeDataListeners(stream)) {
	    return
	  }
	
	  var listener
	  var listeners = stream.listeners('close')
	
	  for (var i = 0; i < listeners.length; i++) {
	    listener = listeners[i]
	
	    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
	      continue
	    }
	
	    // invoke the listener
	    listener.call(stream)
	  }
	}


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var Route = __webpack_require__(23);
	var Layer = __webpack_require__(25);
	var methods = __webpack_require__(27);
	var mixin = __webpack_require__(29);
	var debug = __webpack_require__(13)('express:router');
	var deprecate = __webpack_require__(30)('express');
	var flatten = __webpack_require__(24);
	var parseUrl = __webpack_require__(31);
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var objectRegExp = /^\[object (\S+)\]$/;
	var slice = Array.prototype.slice;
	var toString = Object.prototype.toString;
	
	/**
	 * Initialize a new `Router` with the given `options`.
	 *
	 * @param {Object} options
	 * @return {Router} which is an callable function
	 * @public
	 */
	
	var proto = module.exports = function(options) {
	  var opts = options || {};
	
	  function router(req, res, next) {
	    router.handle(req, res, next);
	  }
	
	  // mixin Router class functions
	  router.__proto__ = proto;
	
	  router.params = {};
	  router._params = [];
	  router.caseSensitive = opts.caseSensitive;
	  router.mergeParams = opts.mergeParams;
	  router.strict = opts.strict;
	  router.stack = [];
	
	  return router;
	};
	
	/**
	 * Map the given param placeholder `name`(s) to the given callback.
	 *
	 * Parameter mapping is used to provide pre-conditions to routes
	 * which use normalized placeholders. For example a _:user_id_ parameter
	 * could automatically load a user's information from the database without
	 * any additional code,
	 *
	 * The callback uses the same signature as middleware, the only difference
	 * being that the value of the placeholder is passed, in this case the _id_
	 * of the user. Once the `next()` function is invoked, just like middleware
	 * it will continue on to execute the route, or subsequent parameter functions.
	 *
	 * Just like in middleware, you must either respond to the request or call next
	 * to avoid stalling the request.
	 *
	 *  app.param('user_id', function(req, res, next, id){
	 *    User.find(id, function(err, user){
	 *      if (err) {
	 *        return next(err);
	 *      } else if (!user) {
	 *        return next(new Error('failed to load user'));
	 *      }
	 *      req.user = user;
	 *      next();
	 *    });
	 *  });
	 *
	 * @param {String} name
	 * @param {Function} fn
	 * @return {app} for chaining
	 * @public
	 */
	
	proto.param = function param(name, fn) {
	  // param logic
	  if (typeof name === 'function') {
	    deprecate('router.param(fn): Refactor to use path params');
	    this._params.push(name);
	    return;
	  }
	
	  // apply param functions
	  var params = this._params;
	  var len = params.length;
	  var ret;
	
	  if (name[0] === ':') {
	    deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.substr(1)) + ', fn) instead');
	    name = name.substr(1);
	  }
	
	  for (var i = 0; i < len; ++i) {
	    if (ret = params[i](name, fn)) {
	      fn = ret;
	    }
	  }
	
	  // ensure we end up with a
	  // middleware function
	  if ('function' !== typeof fn) {
	    throw new Error('invalid param() call for ' + name + ', got ' + fn);
	  }
	
	  (this.params[name] = this.params[name] || []).push(fn);
	  return this;
	};
	
	/**
	 * Dispatch a req, res into the router.
	 * @private
	 */
	
	proto.handle = function handle(req, res, out) {
	  var self = this;
	
	  debug('dispatching %s %s', req.method, req.url);
	
	  var search = 1 + req.url.indexOf('?');
	  var pathlength = search ? search - 1 : req.url.length;
	  var fqdn = req.url[0] !== '/' && 1 + req.url.substr(0, pathlength).indexOf('://');
	  var protohost = fqdn ? req.url.substr(0, req.url.indexOf('/', 2 + fqdn)) : '';
	  var idx = 0;
	  var removed = '';
	  var slashAdded = false;
	  var paramcalled = {};
	
	  // store options for OPTIONS request
	  // only used if OPTIONS request
	  var options = [];
	
	  // middleware and routes
	  var stack = self.stack;
	
	  // manage inter-router variables
	  var parentParams = req.params;
	  var parentUrl = req.baseUrl || '';
	  var done = restore(out, req, 'baseUrl', 'next', 'params');
	
	  // setup next layer
	  req.next = next;
	
	  // for options requests, respond with a default if nothing else responds
	  if (req.method === 'OPTIONS') {
	    done = wrap(done, function(old, err) {
	      if (err || options.length === 0) return old(err);
	      sendOptionsResponse(res, options, old);
	    });
	  }
	
	  // setup basic req values
	  req.baseUrl = parentUrl;
	  req.originalUrl = req.originalUrl || req.url;
	
	  next();
	
	  function next(err) {
	    var layerError = err === 'route'
	      ? null
	      : err;
	
	    // remove added slash
	    if (slashAdded) {
	      req.url = req.url.substr(1);
	      slashAdded = false;
	    }
	
	    // restore altered req.url
	    if (removed.length !== 0) {
	      req.baseUrl = parentUrl;
	      req.url = protohost + removed + req.url.substr(protohost.length);
	      removed = '';
	    }
	
	    // no more matching layers
	    if (idx >= stack.length) {
	      setImmediate(done, layerError);
	      return;
	    }
	
	    // get pathname of request
	    var path = getPathname(req);
	
	    if (path == null) {
	      return done(layerError);
	    }
	
	    // find next matching layer
	    var layer;
	    var match;
	    var route;
	
	    while (match !== true && idx < stack.length) {
	      layer = stack[idx++];
	      match = matchLayer(layer, path);
	      route = layer.route;
	
	      if (typeof match !== 'boolean') {
	        // hold on to layerError
	        layerError = layerError || match;
	      }
	
	      if (match !== true) {
	        continue;
	      }
	
	      if (!route) {
	        // process non-route handlers normally
	        continue;
	      }
	
	      if (layerError) {
	        // routes do not match with a pending error
	        match = false;
	        continue;
	      }
	
	      var method = req.method;
	      var has_method = route._handles_method(method);
	
	      // build up automatic options response
	      if (!has_method && method === 'OPTIONS') {
	        appendMethods(options, route._options());
	      }
	
	      // don't even bother matching route
	      if (!has_method && method !== 'HEAD') {
	        match = false;
	        continue;
	      }
	    }
	
	    // no match
	    if (match !== true) {
	      return done(layerError);
	    }
	
	    // store route for dispatch on change
	    if (route) {
	      req.route = route;
	    }
	
	    // Capture one-time layer values
	    req.params = self.mergeParams
	      ? mergeParams(layer.params, parentParams)
	      : layer.params;
	    var layerPath = layer.path;
	
	    // this should be done for the layer
	    self.process_params(layer, paramcalled, req, res, function (err) {
	      if (err) {
	        return next(layerError || err);
	      }
	
	      if (route) {
	        return layer.handle_request(req, res, next);
	      }
	
	      trim_prefix(layer, layerError, layerPath, path);
	    });
	  }
	
	  function trim_prefix(layer, layerError, layerPath, path) {
	    var c = path[layerPath.length];
	    if (c && '/' !== c && '.' !== c) return next(layerError);
	
	     // Trim off the part of the url that matches the route
	     // middleware (.use stuff) needs to have the path stripped
	    if (layerPath.length !== 0) {
	      debug('trim prefix (%s) from url %s', layerPath, req.url);
	      removed = layerPath;
	      req.url = protohost + req.url.substr(protohost.length + removed.length);
	
	      // Ensure leading slash
	      if (!fqdn && req.url[0] !== '/') {
	        req.url = '/' + req.url;
	        slashAdded = true;
	      }
	
	      // Setup base URL (no trailing slash)
	      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'
	        ? removed.substring(0, removed.length - 1)
	        : removed);
	    }
	
	    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);
	
	    if (layerError) {
	      layer.handle_error(layerError, req, res, next);
	    } else {
	      layer.handle_request(req, res, next);
	    }
	  }
	};
	
	/**
	 * Process any parameters for the layer.
	 * @private
	 */
	
	proto.process_params = function process_params(layer, called, req, res, done) {
	  var params = this.params;
	
	  // captured parameters from the layer, keys and values
	  var keys = layer.keys;
	
	  // fast track
	  if (!keys || keys.length === 0) {
	    return done();
	  }
	
	  var i = 0;
	  var name;
	  var paramIndex = 0;
	  var key;
	  var paramVal;
	  var paramCallbacks;
	  var paramCalled;
	
	  // process params in order
	  // param callbacks can be async
	  function param(err) {
	    if (err) {
	      return done(err);
	    }
	
	    if (i >= keys.length ) {
	      return done();
	    }
	
	    paramIndex = 0;
	    key = keys[i++];
	
	    if (!key) {
	      return done();
	    }
	
	    name = key.name;
	    paramVal = req.params[name];
	    paramCallbacks = params[name];
	    paramCalled = called[name];
	
	    if (paramVal === undefined || !paramCallbacks) {
	      return param();
	    }
	
	    // param previously called with same value or error occurred
	    if (paramCalled && (paramCalled.match === paramVal
	      || (paramCalled.error && paramCalled.error !== 'route'))) {
	      // restore value
	      req.params[name] = paramCalled.value;
	
	      // next param
	      return param(paramCalled.error);
	    }
	
	    called[name] = paramCalled = {
	      error: null,
	      match: paramVal,
	      value: paramVal
	    };
	
	    paramCallback();
	  }
	
	  // single param callbacks
	  function paramCallback(err) {
	    var fn = paramCallbacks[paramIndex++];
	
	    // store updated value
	    paramCalled.value = req.params[key.name];
	
	    if (err) {
	      // store error
	      paramCalled.error = err;
	      param(err);
	      return;
	    }
	
	    if (!fn) return param();
	
	    try {
	      fn(req, res, paramCallback, paramVal, key.name);
	    } catch (e) {
	      paramCallback(e);
	    }
	  }
	
	  param();
	};
	
	/**
	 * Use the given middleware function, with optional path, defaulting to "/".
	 *
	 * Use (like `.all`) will run for any http METHOD, but it will not add
	 * handlers for those methods so OPTIONS requests will not consider `.use`
	 * functions even if they could respond.
	 *
	 * The other difference is that _route_ path is stripped and not visible
	 * to the handler function. The main effect of this feature is that mounted
	 * handlers can operate without any code changes regardless of the "prefix"
	 * pathname.
	 *
	 * @public
	 */
	
	proto.use = function use(fn) {
	  var offset = 0;
	  var path = '/';
	
	  // default path to '/'
	  // disambiguate router.use([fn])
	  if (typeof fn !== 'function') {
	    var arg = fn;
	
	    while (Array.isArray(arg) && arg.length !== 0) {
	      arg = arg[0];
	    }
	
	    // first arg is the path
	    if (typeof arg !== 'function') {
	      offset = 1;
	      path = fn;
	    }
	  }
	
	  var callbacks = flatten(slice.call(arguments, offset));
	
	  if (callbacks.length === 0) {
	    throw new TypeError('Router.use() requires middleware functions');
	  }
	
	  for (var i = 0; i < callbacks.length; i++) {
	    var fn = callbacks[i];
	
	    if (typeof fn !== 'function') {
	      throw new TypeError('Router.use() requires middleware function but got a ' + gettype(fn));
	    }
	
	    // add the middleware
	    debug('use %s %s', path, fn.name || '<anonymous>');
	
	    var layer = new Layer(path, {
	      sensitive: this.caseSensitive,
	      strict: false,
	      end: false
	    }, fn);
	
	    layer.route = undefined;
	
	    this.stack.push(layer);
	  }
	
	  return this;
	};
	
	/**
	 * Create a new Route for the given path.
	 *
	 * Each route contains a separate middleware stack and VERB handlers.
	 *
	 * See the Route api documentation for details on adding handlers
	 * and middleware to routes.
	 *
	 * @param {String} path
	 * @return {Route}
	 * @public
	 */
	
	proto.route = function route(path) {
	  var route = new Route(path);
	
	  var layer = new Layer(path, {
	    sensitive: this.caseSensitive,
	    strict: this.strict,
	    end: true
	  }, route.dispatch.bind(route));
	
	  layer.route = route;
	
	  this.stack.push(layer);
	  return route;
	};
	
	// create Router#VERB functions
	methods.concat('all').forEach(function(method){
	  proto[method] = function(path){
	    var route = this.route(path)
	    route[method].apply(route, slice.call(arguments, 1));
	    return this;
	  };
	});
	
	// append methods to a list of methods
	function appendMethods(list, addition) {
	  for (var i = 0; i < addition.length; i++) {
	    var method = addition[i];
	    if (list.indexOf(method) === -1) {
	      list.push(method);
	    }
	  }
	}
	
	// get pathname of request
	function getPathname(req) {
	  try {
	    return parseUrl(req).pathname;
	  } catch (err) {
	    return undefined;
	  }
	}
	
	// get type for error message
	function gettype(obj) {
	  var type = typeof obj;
	
	  if (type !== 'object') {
	    return type;
	  }
	
	  // inspect [[Class]] for objects
	  return toString.call(obj)
	    .replace(objectRegExp, '$1');
	}
	
	/**
	 * Match path to a layer.
	 *
	 * @param {Layer} layer
	 * @param {string} path
	 * @private
	 */
	
	function matchLayer(layer, path) {
	  try {
	    return layer.match(path);
	  } catch (err) {
	    return err;
	  }
	}
	
	// merge params with parent params
	function mergeParams(params, parent) {
	  if (typeof parent !== 'object' || !parent) {
	    return params;
	  }
	
	  // make copy of parent for base
	  var obj = mixin({}, parent);
	
	  // simple non-numeric merging
	  if (!(0 in params) || !(0 in parent)) {
	    return mixin(obj, params);
	  }
	
	  var i = 0;
	  var o = 0;
	
	  // determine numeric gaps
	  while (i in params) {
	    i++;
	  }
	
	  while (o in parent) {
	    o++;
	  }
	
	  // offset numeric indices in params before merge
	  for (i--; i >= 0; i--) {
	    params[i + o] = params[i];
	
	    // create holes for the merge when necessary
	    if (i < o) {
	      delete params[i];
	    }
	  }
	
	  return mixin(obj, params);
	}
	
	// restore obj props after function
	function restore(fn, obj) {
	  var props = new Array(arguments.length - 2);
	  var vals = new Array(arguments.length - 2);
	
	  for (var i = 0; i < props.length; i++) {
	    props[i] = arguments[i + 2];
	    vals[i] = obj[props[i]];
	  }
	
	  return function(err){
	    // restore vals
	    for (var i = 0; i < props.length; i++) {
	      obj[props[i]] = vals[i];
	    }
	
	    return fn.apply(this, arguments);
	  };
	}
	
	// send an OPTIONS response
	function sendOptionsResponse(res, options, next) {
	  try {
	    var body = options.join(',');
	    res.set('Allow', body);
	    res.send(body);
	  } catch (err) {
	    next(err);
	  }
	}
	
	// wrap a function
	function wrap(old, fn) {
	  return function proxy() {
	    var args = new Array(arguments.length + 1);
	
	    args[0] = old;
	    for (var i = 0, len = arguments.length; i < len; i++) {
	      args[i + 1] = arguments[i];
	    }
	
	    fn.apply(this, args);
	  };
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8).setImmediate))

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var debug = __webpack_require__(13)('express:router:route');
	var flatten = __webpack_require__(24);
	var Layer = __webpack_require__(25);
	var methods = __webpack_require__(27);
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var slice = Array.prototype.slice;
	var toString = Object.prototype.toString;
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = Route;
	
	/**
	 * Initialize `Route` with the given `path`,
	 *
	 * @param {String} path
	 * @public
	 */
	
	function Route(path) {
	  this.path = path;
	  this.stack = [];
	
	  debug('new %s', path);
	
	  // route handlers for various http methods
	  this.methods = {};
	}
	
	/**
	 * Determine if the route handles a given method.
	 * @private
	 */
	
	Route.prototype._handles_method = function _handles_method(method) {
	  if (this.methods._all) {
	    return true;
	  }
	
	  var name = method.toLowerCase();
	
	  if (name === 'head' && !this.methods['head']) {
	    name = 'get';
	  }
	
	  return Boolean(this.methods[name]);
	};
	
	/**
	 * @return {Array} supported HTTP methods
	 * @private
	 */
	
	Route.prototype._options = function _options() {
	  var methods = Object.keys(this.methods);
	
	  // append automatic head
	  if (this.methods.get && !this.methods.head) {
	    methods.push('head');
	  }
	
	  for (var i = 0; i < methods.length; i++) {
	    // make upper case
	    methods[i] = methods[i].toUpperCase();
	  }
	
	  return methods;
	};
	
	/**
	 * dispatch req, res into this route
	 * @private
	 */
	
	Route.prototype.dispatch = function dispatch(req, res, done) {
	  var idx = 0;
	  var stack = this.stack;
	  if (stack.length === 0) {
	    return done();
	  }
	
	  var method = req.method.toLowerCase();
	  if (method === 'head' && !this.methods['head']) {
	    method = 'get';
	  }
	
	  req.route = this;
	
	  next();
	
	  function next(err) {
	    if (err && err === 'route') {
	      return done();
	    }
	
	    var layer = stack[idx++];
	    if (!layer) {
	      return done(err);
	    }
	
	    if (layer.method && layer.method !== method) {
	      return next(err);
	    }
	
	    if (err) {
	      layer.handle_error(err, req, res, next);
	    } else {
	      layer.handle_request(req, res, next);
	    }
	  }
	};
	
	/**
	 * Add a handler for all HTTP verbs to this route.
	 *
	 * Behaves just like middleware and can respond or call `next`
	 * to continue processing.
	 *
	 * You can use multiple `.all` call to add multiple handlers.
	 *
	 *   function check_something(req, res, next){
	 *     next();
	 *   };
	 *
	 *   function validate_user(req, res, next){
	 *     next();
	 *   };
	 *
	 *   route
	 *   .all(validate_user)
	 *   .all(check_something)
	 *   .get(function(req, res, next){
	 *     res.send('hello world');
	 *   });
	 *
	 * @param {function} handler
	 * @return {Route} for chaining
	 * @api public
	 */
	
	Route.prototype.all = function all() {
	  var handles = flatten(slice.call(arguments));
	
	  for (var i = 0; i < handles.length; i++) {
	    var handle = handles[i];
	
	    if (typeof handle !== 'function') {
	      var type = toString.call(handle);
	      var msg = 'Route.all() requires callback functions but got a ' + type;
	      throw new TypeError(msg);
	    }
	
	    var layer = Layer('/', {}, handle);
	    layer.method = undefined;
	
	    this.methods._all = true;
	    this.stack.push(layer);
	  }
	
	  return this;
	};
	
	methods.forEach(function(method){
	  Route.prototype[method] = function(){
	    var handles = flatten(slice.call(arguments));
	
	    for (var i = 0; i < handles.length; i++) {
	      var handle = handles[i];
	
	      if (typeof handle !== 'function') {
	        var type = toString.call(handle);
	        var msg = 'Route.' + method + '() requires callback functions but got a ' + type;
	        throw new Error(msg);
	      }
	
	      debug('%s %s', method, this.path);
	
	      var layer = Layer('/', {}, handle);
	      layer.method = method;
	
	      this.methods[method] = true;
	      this.stack.push(layer);
	    }
	
	    return this;
	  };
	});


/***/ },
/* 24 */
/***/ function(module, exports) {

	'use strict'
	
	/**
	 * Expose `arrayFlatten`.
	 */
	module.exports = arrayFlatten
	
	/**
	 * Recursive flatten function with depth.
	 *
	 * @param  {Array}  array
	 * @param  {Array}  result
	 * @param  {Number} depth
	 * @return {Array}
	 */
	function flattenWithDepth (array, result, depth) {
	  for (var i = 0; i < array.length; i++) {
	    var value = array[i]
	
	    if (depth > 0 && Array.isArray(value)) {
	      flattenWithDepth(value, result, depth - 1)
	    } else {
	      result.push(value)
	    }
	  }
	
	  return result
	}
	
	/**
	 * Recursive flatten function. Omitting depth is slightly faster.
	 *
	 * @param  {Array} array
	 * @param  {Array} result
	 * @return {Array}
	 */
	function flattenForever (array, result) {
	  for (var i = 0; i < array.length; i++) {
	    var value = array[i]
	
	    if (Array.isArray(value)) {
	      flattenForever(value, result)
	    } else {
	      result.push(value)
	    }
	  }
	
	  return result
	}
	
	/**
	 * Flatten an array, with the ability to define a depth.
	 *
	 * @param  {Array}  array
	 * @param  {Number} depth
	 * @return {Array}
	 */
	function arrayFlatten (array, depth) {
	  if (depth == null) {
	    return flattenForever(array, [])
	  }
	
	  return flattenWithDepth(array, [], depth)
	}


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var pathRegexp = __webpack_require__(26);
	var debug = __webpack_require__(13)('express:router:layer');
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = Layer;
	
	function Layer(path, options, fn) {
	  if (!(this instanceof Layer)) {
	    return new Layer(path, options, fn);
	  }
	
	  debug('new %s', path);
	  var opts = options || {};
	
	  this.handle = fn;
	  this.name = fn.name || '<anonymous>';
	  this.params = undefined;
	  this.path = undefined;
	  this.regexp = pathRegexp(path, this.keys = [], opts);
	
	  if (path === '/' && opts.end === false) {
	    this.regexp.fast_slash = true;
	  }
	}
	
	/**
	 * Handle the error for the layer.
	 *
	 * @param {Error} error
	 * @param {Request} req
	 * @param {Response} res
	 * @param {function} next
	 * @api private
	 */
	
	Layer.prototype.handle_error = function handle_error(error, req, res, next) {
	  var fn = this.handle;
	
	  if (fn.length !== 4) {
	    // not a standard error handler
	    return next(error);
	  }
	
	  try {
	    fn(error, req, res, next);
	  } catch (err) {
	    next(err);
	  }
	};
	
	/**
	 * Handle the request for the layer.
	 *
	 * @param {Request} req
	 * @param {Response} res
	 * @param {function} next
	 * @api private
	 */
	
	Layer.prototype.handle_request = function handle(req, res, next) {
	  var fn = this.handle;
	
	  if (fn.length > 3) {
	    // not a standard request handler
	    return next();
	  }
	
	  try {
	    fn(req, res, next);
	  } catch (err) {
	    next(err);
	  }
	};
	
	/**
	 * Check if this route matches `path`, if so
	 * populate `.params`.
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api private
	 */
	
	Layer.prototype.match = function match(path) {
	  if (path == null) {
	    // no path, nothing matches
	    this.params = undefined;
	    this.path = undefined;
	    return false;
	  }
	
	  if (this.regexp.fast_slash) {
	    // fast path non-ending match for / (everything matches)
	    this.params = {};
	    this.path = '';
	    return true;
	  }
	
	  var m = this.regexp.exec(path);
	
	  if (!m) {
	    this.params = undefined;
	    this.path = undefined;
	    return false;
	  }
	
	  // store values
	  this.params = {};
	  this.path = m[0];
	
	  var keys = this.keys;
	  var params = this.params;
	
	  for (var i = 1; i < m.length; i++) {
	    var key = keys[i - 1];
	    var prop = key.name;
	    var val = decode_param(m[i]);
	
	    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {
	      params[prop] = val;
	    }
	  }
	
	  return true;
	};
	
	/**
	 * Decode param value.
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */
	
	function decode_param(val) {
	  if (typeof val !== 'string' || val.length === 0) {
	    return val;
	  }
	
	  try {
	    return decodeURIComponent(val);
	  } catch (err) {
	    if (err instanceof URIError) {
	      err.message = 'Failed to decode param \'' + val + '\'';
	      err.status = err.statusCode = 400;
	    }
	
	    throw err;
	  }
	}


/***/ },
/* 26 */
/***/ function(module, exports) {

	/**
	 * Expose `pathtoRegexp`.
	 */
	
	module.exports = pathtoRegexp;
	
	/**
	 * Match matching groups in a regular expression.
	 */
	var MATCHING_GROUP_REGEXP = /\((?!\?)/g;
	
	/**
	 * Normalize the given path string,
	 * returning a regular expression.
	 *
	 * An empty array should be passed,
	 * which will contain the placeholder
	 * key names. For example "/user/:id" will
	 * then contain ["id"].
	 *
	 * @param  {String|RegExp|Array} path
	 * @param  {Array} keys
	 * @param  {Object} options
	 * @return {RegExp}
	 * @api private
	 */
	
	function pathtoRegexp(path, keys, options) {
	  options = options || {};
	  keys = keys || [];
	  var strict = options.strict;
	  var end = options.end !== false;
	  var flags = options.sensitive ? '' : 'i';
	  var extraOffset = 0;
	  var keysOffset = keys.length;
	  var i = 0;
	  var name = 0;
	  var m;
	
	  if (path instanceof RegExp) {
	    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
	      keys.push({
	        name: name++,
	        optional: false,
	        offset: m.index
	      });
	    }
	
	    return path;
	  }
	
	  if (Array.isArray(path)) {
	    // Map array parts into regexps and return their source. We also pass
	    // the same keys and options instance into every generation to get
	    // consistent matching groups before we join the sources together.
	    path = path.map(function (value) {
	      return pathtoRegexp(value, keys, options).source;
	    });
	
	    return new RegExp('(?:' + path.join('|') + ')', flags);
	  }
	
	  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))
	    .replace(/\/\(/g, '/(?:')
	    .replace(/([\/\.])/g, '\\$1')
	    .replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {
	      slash = slash || '';
	      format = format || '';
	      capture = capture || '([^\\/' + format + ']+?)';
	      optional = optional || '';
	
	      keys.push({
	        name: key,
	        optional: !!optional,
	        offset: offset + extraOffset
	      });
	
	      var result = ''
	        + (optional ? '' : slash)
	        + '(?:'
	        + format + (optional ? slash : '') + capture
	        + (star ? '((?:[\\/' + format + '].+?)?)' : '')
	        + ')'
	        + optional;
	
	      extraOffset += result.length - match.length;
	
	      return result;
	    })
	    .replace(/\*/g, function (star, index) {
	      var len = keys.length
	
	      while (len-- > keysOffset && keys[len].offset > index) {
	        keys[len].offset += 3; // Replacement length minus asterisk length.
	      }
	
	      return '(.*)';
	    });
	
	  // This is a workaround for handling unnamed matching groups.
	  while (m = MATCHING_GROUP_REGEXP.exec(path)) {
	    var escapeCount = 0;
	    var index = m.index;
	
	    while (path.charAt(--index) === '\\') {
	      escapeCount++;
	    }
	
	    // It's possible to escape the bracket.
	    if (escapeCount % 2 === 1) {
	      continue;
	    }
	
	    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
	      keys.splice(keysOffset + i, 0, {
	        name: name++, // Unnamed matching groups must be consistently linear.
	        optional: false,
	        offset: m.index
	      });
	    }
	
	    i++;
	  }
	
	  // If the path is non-ending, match until the end or a slash.
	  path += (end ? '$' : (path[path.length - 1] === '/' ? '' : '(?=\\/|$)'));
	
	  return new RegExp(path, flags);
	};


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * methods
	 * Copyright(c) 2013-2014 TJ Holowaychuk
	 * Copyright(c) 2015-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var http = __webpack_require__(28);
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = getCurrentNodeMethods() || getBasicNodeMethods();
	
	/**
	 * Get the current Node.js methods.
	 * @private
	 */
	
	function getCurrentNodeMethods() {
	  return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
	    return method.toLowerCase();
	  });
	}
	
	/**
	 * Get the "basic" Node.js methods, a snapshot from Node.js 0.10.
	 * @private
	 */
	
	function getBasicNodeMethods() {
	  return [
	    'get',
	    'post',
	    'put',
	    'head',
	    'delete',
	    'options',
	    'trace',
	    'copy',
	    'lock',
	    'mkcol',
	    'move',
	    'purge',
	    'propfind',
	    'proppatch',
	    'unlock',
	    'report',
	    'mkactivity',
	    'checkout',
	    'merge',
	    'm-search',
	    'notify',
	    'subscribe',
	    'unsubscribe',
	    'patch',
	    'search',
	    'connect'
	  ];
	}


/***/ },
/* 28 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 29 */
/***/ function(module, exports) {

	/**
	 * Merge object b with object a.
	 *
	 *     var a = { foo: 'bar' }
	 *       , b = { bar: 'baz' };
	 *
	 *     merge(a, b);
	 *     // => { foo: 'bar', bar: 'baz' }
	 *
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object}
	 * @api public
	 */
	
	exports = module.exports = function(a, b){
	  if (a && b) {
	    for (var key in b) {
	      a[key] = b[key];
	    }
	  }
	  return a;
	};


/***/ },
/* 30 */
/***/ function(module, exports) {

	/*!
	 * depd
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = depd
	
	/**
	 * Create deprecate for namespace in caller.
	 */
	
	function depd(namespace) {
	  if (!namespace) {
	    throw new TypeError('argument namespace is required')
	  }
	
	  function deprecate(message) {
	    // no-op in browser
	  }
	
	  deprecate._file = undefined
	  deprecate._ignored = true
	  deprecate._namespace = namespace
	  deprecate._traced = false
	  deprecate._warned = Object.create(null)
	
	  deprecate.function = wrapfunction
	  deprecate.property = wrapproperty
	
	  return deprecate
	}
	
	/**
	 * Return a wrapped function in a deprecation message.
	 *
	 * This is a no-op version of the wrapper, which does nothing but call
	 * validation.
	 */
	
	function wrapfunction(fn, message) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('argument fn must be a function')
	  }
	
	  return fn
	}
	
	/**
	 * Wrap property in a deprecation message.
	 *
	 * This is a no-op version of the wrapper, which does nothing but call
	 * validation.
	 */
	
	function wrapproperty(obj, prop, message) {
	  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
	    throw new TypeError('argument obj must be object')
	  }
	
	  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)
	
	  if (!descriptor) {
	    throw new TypeError('must call property on owner object')
	  }
	
	  if (!descriptor.configurable) {
	    throw new TypeError('property must be configurable')
	  }
	
	  return
	}


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * parseurl
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 */
	
	var url = __webpack_require__(32)
	var parse = url.parse
	var Url = url.Url
	
	/**
	 * Pattern for a simple path case.
	 * See: https://github.com/joyent/node/pull/7878
	 */
	
	var simplePathRegExp = /^(\/\/?(?!\/)[^\?#\s]*)(\?[^#\s]*)?$/
	
	/**
	 * Exports.
	 */
	
	module.exports = parseurl
	module.exports.original = originalurl
	
	/**
	 * Parse the `req` url with memoization.
	 *
	 * @param {ServerRequest} req
	 * @return {Object}
	 * @api public
	 */
	
	function parseurl(req) {
	  var url = req.url
	
	  if (url === undefined) {
	    // URL is undefined
	    return undefined
	  }
	
	  var parsed = req._parsedUrl
	
	  if (fresh(url, parsed)) {
	    // Return cached URL parse
	    return parsed
	  }
	
	  // Parse the URL
	  parsed = fastparse(url)
	  parsed._raw = url
	
	  return req._parsedUrl = parsed
	};
	
	/**
	 * Parse the `req` original url with fallback and memoization.
	 *
	 * @param {ServerRequest} req
	 * @return {Object}
	 * @api public
	 */
	
	function originalurl(req) {
	  var url = req.originalUrl
	
	  if (typeof url !== 'string') {
	    // Fallback
	    return parseurl(req)
	  }
	
	  var parsed = req._parsedOriginalUrl
	
	  if (fresh(url, parsed)) {
	    // Return cached URL parse
	    return parsed
	  }
	
	  // Parse the URL
	  parsed = fastparse(url)
	  parsed._raw = url
	
	  return req._parsedOriginalUrl = parsed
	};
	
	/**
	 * Parse the `str` url with fast-path short-cut.
	 *
	 * @param {string} str
	 * @return {Object}
	 * @api private
	 */
	
	function fastparse(str) {
	  // Try fast path regexp
	  // See: https://github.com/joyent/node/pull/7878
	  var simplePath = typeof str === 'string' && simplePathRegExp.exec(str)
	
	  // Construct simple URL
	  if (simplePath) {
	    var pathname = simplePath[1]
	    var search = simplePath[2] || null
	    var url = Url !== undefined
	      ? new Url()
	      : {}
	    url.path = str
	    url.href = str
	    url.pathname = pathname
	    url.search = search
	    url.query = search && search.substr(1)
	
	    return url
	  }
	
	  return parse(str)
	}
	
	/**
	 * Determine if parsed is still fresh for url.
	 *
	 * @param {string} url
	 * @param {object} parsedUrl
	 * @return {boolean}
	 * @api private
	 */
	
	function fresh(url, parsedUrl) {
	  return typeof parsedUrl === 'object'
	    && parsedUrl !== null
	    && (Url === undefined || parsedUrl instanceof Url)
	    && parsedUrl._raw === url
	}


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var punycode = __webpack_require__(33);
	
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	
	exports.Url = Url;
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,
	
	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
	
	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
	
	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(35);
	
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;
	
	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }
	
	  var rest = url;
	
	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	
	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {
	
	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c
	
	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	
	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;
	
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost();
	
	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';
	
	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }
	
	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }
	
	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;
	
	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }
	
	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {
	
	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }
	
	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }
	
	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};
	
	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}
	
	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }
	
	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';
	
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }
	
	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }
	
	  var search = this.search || (query && ('?' + query)) || '';
	
	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
	
	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }
	
	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;
	
	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');
	
	  return protocol + host + pathname + search + hash;
	};
	
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	
	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	
	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}
	
	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	
	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);
	
	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;
	
	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }
	
	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });
	
	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }
	
	    result.href = result.format();
	    return result;
	  }
	
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }
	
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	
	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];
	
	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }
	
	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');
	
	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }
	
	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }
	
	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }
	
	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');
	
	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }
	
	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
	
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }
	
	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }
	
	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	
	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};
	
	function isString(arg) {
	  return typeof arg === "string";
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34)(module), (function() { return this; }())))

/***/ },
/* 34 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(36);
	exports.encode = exports.stringify = __webpack_require__(37);


/***/ },
/* 36 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};


/***/ },
/* 37 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 38 */
/***/ function(module, exports) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Initialization middleware, exposing the
	 * request and response to each other, as well
	 * as defaulting the X-Powered-By header field.
	 *
	 * @param {Function} app
	 * @return {Function}
	 * @api private
	 */
	
	exports.init = function(app){
	  return function expressInit(req, res, next){
	    if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');
	    req.res = res;
	    res.req = req;
	    req.next = next;
	
	    req.__proto__ = app.request;
	    res.__proto__ = app.response;
	
	    res.locals = res.locals || Object.create(null);
	
	    next();
	  };
	};
	


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var parseUrl = __webpack_require__(31);
	var qs = __webpack_require__(40);
	
	/**
	 * @param {Object} options
	 * @return {Function}
	 * @api public
	 */
	
	module.exports = function query(options) {
	  var opts = Object.create(options || null);
	  var queryparse = qs.parse;
	
	  if (typeof options === 'function') {
	    queryparse = options;
	    opts = undefined;
	  }
	
	  if (opts !== undefined && opts.allowPrototypes === undefined) {
	    // back-compat for qs module
	    opts.allowPrototypes = true;
	  }
	
	  return function query(req, res, next){
	    if (!req.query) {
	      var val = parseUrl(req).query;
	      req.query = queryparse(val, opts);
	    }
	
	    next();
	  };
	};


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Stringify = __webpack_require__(41);
	var Parse = __webpack_require__(43);
	
	module.exports = {
	    stringify: Stringify,
	    parse: Parse
	};


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Utils = __webpack_require__(42);
	
	var arrayPrefixGenerators = {
	    brackets: function brackets(prefix) {
	        return prefix + '[]';
	    },
	    indices: function indices(prefix, key) {
	        return prefix + '[' + key + ']';
	    },
	    repeat: function repeat(prefix) {
	        return prefix;
	    }
	};
	
	var defaults = {
	    delimiter: '&',
	    strictNullHandling: false,
	    skipNulls: false,
	    encode: true,
	    encoder: Utils.encode
	};
	
	var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {
	    var obj = object;
	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    } else if (obj instanceof Date) {
	        obj = obj.toISOString();
	    } else if (obj === null) {
	        if (strictNullHandling) {
	            return encoder ? encoder(prefix) : prefix;
	        }
	
	        obj = '';
	    }
	
	    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || Utils.isBuffer(obj)) {
	        if (encoder) {
	            return [encoder(prefix) + '=' + encoder(obj)];
	        }
	        return [prefix + '=' + String(obj)];
	    }
	
	    var values = [];
	
	    if (typeof obj === 'undefined') {
	        return values;
	    }
	
	    var objKeys;
	    if (Array.isArray(filter)) {
	        objKeys = filter;
	    } else {
	        var keys = Object.keys(obj);
	        objKeys = sort ? keys.sort(sort) : keys;
	    }
	
	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];
	
	        if (skipNulls && obj[key] === null) {
	            continue;
	        }
	
	        if (Array.isArray(obj)) {
	            values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
	        } else {
	            values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
	        }
	    }
	
	    return values;
	};
	
	module.exports = function (object, opts) {
	    var obj = object;
	    var options = opts || {};
	    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
	    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
	    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
	    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
	    var encoder = encode ? (typeof options.encoder === 'function' ? options.encoder : defaults.encoder) : null;
	    var sort = typeof options.sort === 'function' ? options.sort : null;
	    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
	    var objKeys;
	    var filter;
	
	    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
	        throw new TypeError('Encoder has to be a function.');
	    }
	
	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    } else if (Array.isArray(options.filter)) {
	        objKeys = filter = options.filter;
	    }
	
	    var keys = [];
	
	    if (typeof obj !== 'object' || obj === null) {
	        return '';
	    }
	
	    var arrayFormat;
	    if (options.arrayFormat in arrayPrefixGenerators) {
	        arrayFormat = options.arrayFormat;
	    } else if ('indices' in options) {
	        arrayFormat = options.indices ? 'indices' : 'repeat';
	    } else {
	        arrayFormat = 'indices';
	    }
	
	    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
	
	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }
	
	    if (sort) {
	        objKeys.sort(sort);
	    }
	
	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];
	
	        if (skipNulls && obj[key] === null) {
	            continue;
	        }
	
	        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
	    }
	
	    return keys.join(delimiter);
	};


/***/ },
/* 42 */
/***/ function(module, exports) {

	'use strict';
	
	var hexTable = (function () {
	    var array = new Array(256);
	    for (var i = 0; i < 256; ++i) {
	        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();
	    }
	
	    return array;
	}());
	
	exports.arrayToObject = function (source, options) {
	    var obj = options.plainObjects ? Object.create(null) : {};
	    for (var i = 0; i < source.length; ++i) {
	        if (typeof source[i] !== 'undefined') {
	            obj[i] = source[i];
	        }
	    }
	
	    return obj;
	};
	
	exports.merge = function (target, source, options) {
	    if (!source) {
	        return target;
	    }
	
	    if (typeof source !== 'object') {
	        if (Array.isArray(target)) {
	            target.push(source);
	        } else if (typeof target === 'object') {
	            target[source] = true;
	        } else {
	            return [target, source];
	        }
	
	        return target;
	    }
	
	    if (typeof target !== 'object') {
	        return [target].concat(source);
	    }
	
	    var mergeTarget = target;
	    if (Array.isArray(target) && !Array.isArray(source)) {
	        mergeTarget = exports.arrayToObject(target, options);
	    }
	
	    return Object.keys(source).reduce(function (acc, key) {
	        var value = source[key];
	
	        if (Object.prototype.hasOwnProperty.call(acc, key)) {
	            acc[key] = exports.merge(acc[key], value, options);
	        } else {
	            acc[key] = value;
	        }
	        return acc;
	    }, mergeTarget);
	};
	
	exports.decode = function (str) {
	    try {
	        return decodeURIComponent(str.replace(/\+/g, ' '));
	    } catch (e) {
	        return str;
	    }
	};
	
	exports.encode = function (str) {
	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }
	
	    var string = typeof str === 'string' ? str : String(str);
	
	    var out = '';
	    for (var i = 0; i < string.length; ++i) {
	        var c = string.charCodeAt(i);
	
	        if (
	            c === 0x2D || // -
	            c === 0x2E || // .
	            c === 0x5F || // _
	            c === 0x7E || // ~
	            (c >= 0x30 && c <= 0x39) || // 0-9
	            (c >= 0x41 && c <= 0x5A) || // a-z
	            (c >= 0x61 && c <= 0x7A) // A-Z
	        ) {
	            out += string.charAt(i);
	            continue;
	        }
	
	        if (c < 0x80) {
	            out = out + hexTable[c];
	            continue;
	        }
	
	        if (c < 0x800) {
	            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }
	
	        if (c < 0xD800 || c >= 0xE000) {
	            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }
	
	        i += 1;
	        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
	        out += hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)];
	    }
	
	    return out;
	};
	
	exports.compact = function (obj, references) {
	    if (typeof obj !== 'object' || obj === null) {
	        return obj;
	    }
	
	    var refs = references || [];
	    var lookup = refs.indexOf(obj);
	    if (lookup !== -1) {
	        return refs[lookup];
	    }
	
	    refs.push(obj);
	
	    if (Array.isArray(obj)) {
	        var compacted = [];
	
	        for (var i = 0; i < obj.length; ++i) {
	            if (obj[i] && typeof obj[i] === 'object') {
	                compacted.push(exports.compact(obj[i], refs));
	            } else if (typeof obj[i] !== 'undefined') {
	                compacted.push(obj[i]);
	            }
	        }
	
	        return compacted;
	    }
	
	    var keys = Object.keys(obj);
	    for (var j = 0; j < keys.length; ++j) {
	        var key = keys[j];
	        obj[key] = exports.compact(obj[key], refs);
	    }
	
	    return obj;
	};
	
	exports.isRegExp = function (obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};
	
	exports.isBuffer = function (obj) {
	    if (obj === null || typeof obj === 'undefined') {
	        return false;
	    }
	
	    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Utils = __webpack_require__(42);
	
	var defaults = {
	    delimiter: '&',
	    depth: 5,
	    arrayLimit: 20,
	    parameterLimit: 1000,
	    strictNullHandling: false,
	    plainObjects: false,
	    allowPrototypes: false,
	    allowDots: false,
	    decoder: Utils.decode
	};
	
	var parseValues = function parseValues(str, options) {
	    var obj = {};
	    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);
	
	    for (var i = 0; i < parts.length; ++i) {
	        var part = parts[i];
	        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;
	
	        if (pos === -1) {
	            obj[options.decoder(part)] = '';
	
	            if (options.strictNullHandling) {
	                obj[options.decoder(part)] = null;
	            }
	        } else {
	            var key = options.decoder(part.slice(0, pos));
	            var val = options.decoder(part.slice(pos + 1));
	
	            if (Object.prototype.hasOwnProperty.call(obj, key)) {
	                obj[key] = [].concat(obj[key]).concat(val);
	            } else {
	                obj[key] = val;
	            }
	        }
	    }
	
	    return obj;
	};
	
	var parseObject = function parseObject(chain, val, options) {
	    if (!chain.length) {
	        return val;
	    }
	
	    var root = chain.shift();
	
	    var obj;
	    if (root === '[]') {
	        obj = [];
	        obj = obj.concat(parseObject(chain, val, options));
	    } else {
	        obj = options.plainObjects ? Object.create(null) : {};
	        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
	        var index = parseInt(cleanRoot, 10);
	        if (
	            !isNaN(index) &&
	            root !== cleanRoot &&
	            String(index) === cleanRoot &&
	            index >= 0 &&
	            (options.parseArrays && index <= options.arrayLimit)
	        ) {
	            obj = [];
	            obj[index] = parseObject(chain, val, options);
	        } else {
	            obj[cleanRoot] = parseObject(chain, val, options);
	        }
	    }
	
	    return obj;
	};
	
	var parseKeys = function parseKeys(givenKey, val, options) {
	    if (!givenKey) {
	        return;
	    }
	
	    // Transform dot notation to bracket notation
	    var key = options.allowDots ? givenKey.replace(/\.([^\.\[]+)/g, '[$1]') : givenKey;
	
	    // The regex chunks
	
	    var parent = /^([^\[\]]*)/;
	    var child = /(\[[^\[\]]*\])/g;
	
	    // Get the parent
	
	    var segment = parent.exec(key);
	
	    // Stash the parent if it exists
	
	    var keys = [];
	    if (segment[1]) {
	        // If we aren't using plain objects, optionally prefix keys
	        // that would overwrite object prototype properties
	        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }
	
	        keys.push(segment[1]);
	    }
	
	    // Loop through children appending to the array until we hit depth
	
	    var i = 0;
	    while ((segment = child.exec(key)) !== null && i < options.depth) {
	        i += 1;
	        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
	            if (!options.allowPrototypes) {
	                continue;
	            }
	        }
	        keys.push(segment[1]);
	    }
	
	    // If there's a remainder, just add whatever is left
	
	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }
	
	    return parseObject(keys, val, options);
	};
	
	module.exports = function (str, opts) {
	    var options = opts || {};
	
	    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
	        throw new TypeError('Decoder has to be a function.');
	    }
	
	    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
	    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
	    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
	    options.parseArrays = options.parseArrays !== false;
	    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
	    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
	    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
	    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
	    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
	    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
	
	    if (str === '' || str === null || typeof str === 'undefined') {
	        return options.plainObjects ? Object.create(null) : {};
	    }
	
	    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
	    var obj = options.plainObjects ? Object.create(null) : {};
	
	    // Iterate over the keys and setup the new object
	
	    var keys = Object.keys(tempObj);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var newObj = parseKeys(key, tempObj[key], options);
	        obj = Utils.merge(obj, newObj, options);
	    }
	
	    return Utils.compact(obj);
	};


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var debug = __webpack_require__(13)('express:view');
	var path = __webpack_require__(45);
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var utils = __webpack_require__(46);
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var dirname = path.dirname;
	var basename = path.basename;
	var extname = path.extname;
	var join = path.join;
	var resolve = path.resolve;
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = View;
	
	/**
	 * Initialize a new `View` with the given `name`.
	 *
	 * Options:
	 *
	 *   - `defaultEngine` the default template engine name
	 *   - `engines` template engine require() cache
	 *   - `root` root path for view lookup
	 *
	 * @param {string} name
	 * @param {object} options
	 * @public
	 */
	
	function View(name, options) {
	  var opts = options || {};
	
	  this.defaultEngine = opts.defaultEngine;
	  this.ext = extname(name);
	  this.name = name;
	  this.root = opts.root;
	
	  if (!this.ext && !this.defaultEngine) {
	    throw new Error('No default engine was specified and no extension was provided.');
	  }
	
	  var fileName = name;
	
	  if (!this.ext) {
	    // get extension from default engine name
	    this.ext = this.defaultEngine[0] !== '.'
	      ? '.' + this.defaultEngine
	      : this.defaultEngine;
	
	    fileName += this.ext;
	  }
	
	  if (!opts.engines[this.ext]) {
	    // load engine
	    opts.engines[this.ext] = __webpack_require__(94)(this.ext.substr(1)).__express;
	  }
	
	  // store loaded engine
	  this.engine = opts.engines[this.ext];
	
	  // lookup path
	  this.path = this.lookup(fileName);
	}
	
	/**
	 * Lookup view by the given `name`
	 *
	 * @param {string} name
	 * @private
	 */
	
	View.prototype.lookup = function lookup(name) {
	  var path;
	  var roots = [].concat(this.root);
	
	  debug('lookup "%s"', name);
	
	  for (var i = 0; i < roots.length && !path; i++) {
	    var root = roots[i];
	
	    // resolve the path
	    var loc = resolve(root, name);
	    var dir = dirname(loc);
	    var file = basename(loc);
	
	    // resolve the file
	    path = this.resolve(dir, file);
	  }
	
	  return path;
	};
	
	/**
	 * Render with the given options.
	 *
	 * @param {object} options
	 * @param {function} callback
	 * @private
	 */
	
	View.prototype.render = function render(options, callback) {
	  debug('render "%s"', this.path);
	  this.engine(this.path, options, callback);
	};
	
	/**
	 * Resolve the file within the given directory.
	 *
	 * @param {string} dir
	 * @param {string} file
	 * @private
	 */
	
	View.prototype.resolve = function resolve(dir, file) {
	  var ext = this.ext;
	
	  // <path>.<ext>
	  var path = join(dir, file);
	  var stat = tryStat(path);
	
	  if (stat && stat.isFile()) {
	    return path;
	  }
	
	  // <path>/index.<ext>
	  path = join(dir, basename(file, ext), 'index' + ext);
	  stat = tryStat(path);
	
	  if (stat && stat.isFile()) {
	    return path;
	  }
	};
	
	/**
	 * Return a stat, maybe.
	 *
	 * @param {string} path
	 * @return {fs.Stats}
	 * @private
	 */
	
	function tryStat(path) {
	  debug('stat "%s"', path);
	
	  try {
	    return fs.statSync(path);
	  } catch (e) {
	    return undefined;
	  }
	}


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }
	
	  return parts;
	}
	
	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};
	
	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;
	
	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();
	
	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }
	
	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }
	
	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)
	
	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');
	
	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};
	
	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';
	
	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');
	
	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }
	
	  return (isAbsolute ? '/' : '') + path;
	};
	
	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};
	
	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};
	
	
	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);
	
	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }
	
	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }
	
	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }
	
	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));
	
	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }
	
	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }
	
	  outputParts = outputParts.concat(toParts.slice(samePartsLength));
	
	  return outputParts.join('/');
	};
	
	exports.sep = '/';
	exports.delimiter = ':';
	
	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];
	
	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }
	
	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }
	
	  return root + dir;
	};
	
	
	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};
	
	
	exports.extname = function(path) {
	  return splitPath(path)[3];
	};
	
	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}
	
	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module dependencies.
	 * @api private
	 */
	
	var contentDisposition = __webpack_require__(47);
	var contentType = __webpack_require__(48);
	var deprecate = __webpack_require__(30)('express');
	var flatten = __webpack_require__(24);
	var mime = __webpack_require__(49).mime;
	var basename = __webpack_require__(45).basename;
	var etag = __webpack_require__(69);
	var proxyaddr = __webpack_require__(91);
	var qs = __webpack_require__(40);
	var querystring = __webpack_require__(35);
	
	/**
	 * Return strong ETag for `body`.
	 *
	 * @param {String|Buffer} body
	 * @param {String} [encoding]
	 * @return {String}
	 * @api private
	 */
	
	exports.etag = function (body, encoding) {
	  var buf = !Buffer.isBuffer(body)
	    ? new Buffer(body, encoding)
	    : body;
	
	  return etag(buf, {weak: false});
	};
	
	/**
	 * Return weak ETag for `body`.
	 *
	 * @param {String|Buffer} body
	 * @param {String} [encoding]
	 * @return {String}
	 * @api private
	 */
	
	exports.wetag = function wetag(body, encoding){
	  var buf = !Buffer.isBuffer(body)
	    ? new Buffer(body, encoding)
	    : body;
	
	  return etag(buf, {weak: true});
	};
	
	/**
	 * Check if `path` looks absolute.
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api private
	 */
	
	exports.isAbsolute = function(path){
	  if ('/' === path[0]) return true;
	  if (':' === path[1] && ('\\' === path[2] || '/' === path[2])) return true; // Windows device path
	  if ('\\\\' === path.substring(0, 2)) return true; // Microsoft Azure absolute path
	};
	
	/**
	 * Flatten the given `arr`.
	 *
	 * @param {Array} arr
	 * @return {Array}
	 * @api private
	 */
	
	exports.flatten = deprecate.function(flatten,
	  'utils.flatten: use array-flatten npm module instead');
	
	/**
	 * Normalize the given `type`, for example "html" becomes "text/html".
	 *
	 * @param {String} type
	 * @return {Object}
	 * @api private
	 */
	
	exports.normalizeType = function(type){
	  return ~type.indexOf('/')
	    ? acceptParams(type)
	    : { value: mime.lookup(type), params: {} };
	};
	
	/**
	 * Normalize `types`, for example "html" becomes "text/html".
	 *
	 * @param {Array} types
	 * @return {Array}
	 * @api private
	 */
	
	exports.normalizeTypes = function(types){
	  var ret = [];
	
	  for (var i = 0; i < types.length; ++i) {
	    ret.push(exports.normalizeType(types[i]));
	  }
	
	  return ret;
	};
	
	/**
	 * Generate Content-Disposition header appropriate for the filename.
	 * non-ascii filenames are urlencoded and a filename* parameter is added
	 *
	 * @param {String} filename
	 * @return {String}
	 * @api private
	 */
	
	exports.contentDisposition = deprecate.function(contentDisposition,
	  'utils.contentDisposition: use content-disposition npm module instead');
	
	/**
	 * Parse accept params `str` returning an
	 * object with `.value`, `.quality` and `.params`.
	 * also includes `.originalIndex` for stable sorting
	 *
	 * @param {String} str
	 * @return {Object}
	 * @api private
	 */
	
	function acceptParams(str, index) {
	  var parts = str.split(/ *; */);
	  var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };
	
	  for (var i = 1; i < parts.length; ++i) {
	    var pms = parts[i].split(/ *= */);
	    if ('q' === pms[0]) {
	      ret.quality = parseFloat(pms[1]);
	    } else {
	      ret.params[pms[0]] = pms[1];
	    }
	  }
	
	  return ret;
	}
	
	/**
	 * Compile "etag" value to function.
	 *
	 * @param  {Boolean|String|Function} val
	 * @return {Function}
	 * @api private
	 */
	
	exports.compileETag = function(val) {
	  var fn;
	
	  if (typeof val === 'function') {
	    return val;
	  }
	
	  switch (val) {
	    case true:
	      fn = exports.wetag;
	      break;
	    case false:
	      break;
	    case 'strong':
	      fn = exports.etag;
	      break;
	    case 'weak':
	      fn = exports.wetag;
	      break;
	    default:
	      throw new TypeError('unknown value for etag function: ' + val);
	  }
	
	  return fn;
	}
	
	/**
	 * Compile "query parser" value to function.
	 *
	 * @param  {String|Function} val
	 * @return {Function}
	 * @api private
	 */
	
	exports.compileQueryParser = function compileQueryParser(val) {
	  var fn;
	
	  if (typeof val === 'function') {
	    return val;
	  }
	
	  switch (val) {
	    case true:
	      fn = querystring.parse;
	      break;
	    case false:
	      fn = newObject;
	      break;
	    case 'extended':
	      fn = parseExtendedQueryString;
	      break;
	    case 'simple':
	      fn = querystring.parse;
	      break;
	    default:
	      throw new TypeError('unknown value for query parser function: ' + val);
	  }
	
	  return fn;
	}
	
	/**
	 * Compile "proxy trust" value to function.
	 *
	 * @param  {Boolean|String|Number|Array|Function} val
	 * @return {Function}
	 * @api private
	 */
	
	exports.compileTrust = function(val) {
	  if (typeof val === 'function') return val;
	
	  if (val === true) {
	    // Support plain true/false
	    return function(){ return true };
	  }
	
	  if (typeof val === 'number') {
	    // Support trusting hop count
	    return function(a, i){ return i < val };
	  }
	
	  if (typeof val === 'string') {
	    // Support comma-separated values
	    val = val.split(/ *, */);
	  }
	
	  return proxyaddr.compile(val || []);
	}
	
	/**
	 * Set the charset in a given Content-Type string.
	 *
	 * @param {String} type
	 * @param {String} charset
	 * @return {String}
	 * @api private
	 */
	
	exports.setCharset = function setCharset(type, charset) {
	  if (!type || !charset) {
	    return type;
	  }
	
	  // parse type
	  var parsed = contentType.parse(type);
	
	  // set charset
	  parsed.parameters.charset = charset;
	
	  // format type
	  return contentType.format(parsed);
	};
	
	/**
	 * Parse an extended query string with qs.
	 *
	 * @return {Object}
	 * @private
	 */
	
	function parseExtendedQueryString(str) {
	  return qs.parse(str, {
	    allowPrototypes: true
	  });
	}
	
	/**
	 * Return new empty object.
	 *
	 * @return {Object}
	 * @api private
	 */
	
	function newObject() {
	  return {};
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * content-disposition
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module exports.
	 */
	
	module.exports = contentDisposition
	module.exports.parse = parse
	
	/**
	 * Module dependencies.
	 */
	
	var basename = __webpack_require__(45).basename
	
	/**
	 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
	 */
	
	var encodeUriAttrCharRegExp = /[\x00-\x20"'\(\)*,\/:;<=>?@\[\\\]\{\}\x7f]/g
	
	/**
	 * RegExp to match percent encoding escape.
	 */
	
	var hexEscapeRegExp = /%[0-9A-Fa-f]{2}/
	var hexEscapeReplaceRegExp = /%([0-9A-Fa-f]{2})/g
	
	/**
	 * RegExp to match non-latin1 characters.
	 */
	
	var nonLatin1RegExp = /[^\x20-\x7e\xa0-\xff]/g
	
	/**
	 * RegExp to match quoted-pair in RFC 2616
	 *
	 * quoted-pair = "\" CHAR
	 * CHAR        = <any US-ASCII character (octets 0 - 127)>
	 */
	
	var qescRegExp = /\\([\u0000-\u007f])/g;
	
	/**
	 * RegExp to match chars that must be quoted-pair in RFC 2616
	 */
	
	var quoteRegExp = /([\\"])/g
	
	/**
	 * RegExp for various RFC 2616 grammar
	 *
	 * parameter     = token "=" ( token | quoted-string )
	 * token         = 1*<any CHAR except CTLs or separators>
	 * separators    = "(" | ")" | "<" | ">" | "@"
	 *               | "," | ";" | ":" | "\" | <">
	 *               | "/" | "[" | "]" | "?" | "="
	 *               | "{" | "}" | SP | HT
	 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	 * qdtext        = <any TEXT except <">>
	 * quoted-pair   = "\" CHAR
	 * CHAR          = <any US-ASCII character (octets 0 - 127)>
	 * TEXT          = <any OCTET except CTLs, but including LWS>
	 * LWS           = [CRLF] 1*( SP | HT )
	 * CRLF          = CR LF
	 * CR            = <US-ASCII CR, carriage return (13)>
	 * LF            = <US-ASCII LF, linefeed (10)>
	 * SP            = <US-ASCII SP, space (32)>
	 * HT            = <US-ASCII HT, horizontal-tab (9)>
	 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	 * OCTET         = <any 8-bit sequence of data>
	 */
	
	var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g
	var textRegExp = /^[\x20-\x7e\x80-\xff]+$/
	var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/
	
	/**
	 * RegExp for various RFC 5987 grammar
	 *
	 * ext-value     = charset  "'" [ language ] "'" value-chars
	 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
	 * mime-charset  = 1*mime-charsetc
	 * mime-charsetc = ALPHA / DIGIT
	 *               / "!" / "#" / "$" / "%" / "&"
	 *               / "+" / "-" / "^" / "_" / "`"
	 *               / "{" / "}" / "~"
	 * language      = ( 2*3ALPHA [ extlang ] )
	 *               / 4ALPHA
	 *               / 5*8ALPHA
	 * extlang       = *3( "-" 3ALPHA )
	 * value-chars   = *( pct-encoded / attr-char )
	 * pct-encoded   = "%" HEXDIG HEXDIG
	 * attr-char     = ALPHA / DIGIT
	 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
	 *               / "^" / "_" / "`" / "|" / "~"
	 */
	
	var extValueRegExp = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+\-\.^_`|~])+)$/
	
	/**
	 * RegExp for various RFC 6266 grammar
	 *
	 * disposition-type = "inline" | "attachment" | disp-ext-type
	 * disp-ext-type    = token
	 * disposition-parm = filename-parm | disp-ext-parm
	 * filename-parm    = "filename" "=" value
	 *                  | "filename*" "=" ext-value
	 * disp-ext-parm    = token "=" value
	 *                  | ext-token "=" ext-value
	 * ext-token        = <the characters in token, followed by "*">
	 */
	
	var dispositionTypeRegExp = /^([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *(?:$|;)/
	
	/**
	 * Create an attachment Content-Disposition header.
	 *
	 * @param {string} [filename]
	 * @param {object} [options]
	 * @param {string} [options.type=attachment]
	 * @param {string|boolean} [options.fallback=true]
	 * @return {string}
	 * @api public
	 */
	
	function contentDisposition(filename, options) {
	  var opts = options || {}
	
	  // get type
	  var type = opts.type || 'attachment'
	
	  // get parameters
	  var params = createparams(filename, opts.fallback)
	
	  // format into string
	  return format(new ContentDisposition(type, params))
	}
	
	/**
	 * Create parameters object from filename and fallback.
	 *
	 * @param {string} [filename]
	 * @param {string|boolean} [fallback=true]
	 * @return {object}
	 * @api private
	 */
	
	function createparams(filename, fallback) {
	  if (filename === undefined) {
	    return
	  }
	
	  var params = {}
	
	  if (typeof filename !== 'string') {
	    throw new TypeError('filename must be a string')
	  }
	
	  // fallback defaults to true
	  if (fallback === undefined) {
	    fallback = true
	  }
	
	  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
	    throw new TypeError('fallback must be a string or boolean')
	  }
	
	  if (typeof fallback === 'string' && nonLatin1RegExp.test(fallback)) {
	    throw new TypeError('fallback must be ISO-8859-1 string')
	  }
	
	  // restrict to file base name
	  var name = basename(filename)
	
	  // determine if name is suitable for quoted string
	  var isQuotedString = textRegExp.test(name)
	
	  // generate fallback name
	  var fallbackName = typeof fallback !== 'string'
	    ? fallback && getlatin1(name)
	    : basename(fallback)
	  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name
	
	  // set extended filename parameter
	  if (hasFallback || !isQuotedString || hexEscapeRegExp.test(name)) {
	    params['filename*'] = name
	  }
	
	  // set filename parameter
	  if (isQuotedString || hasFallback) {
	    params.filename = hasFallback
	      ? fallbackName
	      : name
	  }
	
	  return params
	}
	
	/**
	 * Format object to Content-Disposition header.
	 *
	 * @param {object} obj
	 * @param {string} obj.type
	 * @param {object} [obj.parameters]
	 * @return {string}
	 * @api private
	 */
	
	function format(obj) {
	  var parameters = obj.parameters
	  var type = obj.type
	
	  if (!type || typeof type !== 'string' || !tokenRegExp.test(type)) {
	    throw new TypeError('invalid type')
	  }
	
	  // start with normalized type
	  var string = String(type).toLowerCase()
	
	  // append parameters
	  if (parameters && typeof parameters === 'object') {
	    var param
	    var params = Object.keys(parameters).sort()
	
	    for (var i = 0; i < params.length; i++) {
	      param = params[i]
	
	      var val = param.substr(-1) === '*'
	        ? ustring(parameters[param])
	        : qstring(parameters[param])
	
	      string += '; ' + param + '=' + val
	    }
	  }
	
	  return string
	}
	
	/**
	 * Decode a RFC 6987 field value (gracefully).
	 *
	 * @param {string} str
	 * @return {string}
	 * @api private
	 */
	
	function decodefield(str) {
	  var match = extValueRegExp.exec(str)
	
	  if (!match) {
	    throw new TypeError('invalid extended field value')
	  }
	
	  var charset = match[1].toLowerCase()
	  var encoded = match[2]
	  var value
	
	  // to binary string
	  var binary = encoded.replace(hexEscapeReplaceRegExp, pdecode)
	
	  switch (charset) {
	    case 'iso-8859-1':
	      value = getlatin1(binary)
	      break
	    case 'utf-8':
	      value = new Buffer(binary, 'binary').toString('utf8')
	      break
	    default:
	      throw new TypeError('unsupported charset in extended field')
	  }
	
	  return value
	}
	
	/**
	 * Get ISO-8859-1 version of string.
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */
	
	function getlatin1(val) {
	  // simple Unicode -> ISO-8859-1 transformation
	  return String(val).replace(nonLatin1RegExp, '?')
	}
	
	/**
	 * Parse Content-Disposition header string.
	 *
	 * @param {string} string
	 * @return {object}
	 * @api private
	 */
	
	function parse(string) {
	  if (!string || typeof string !== 'string') {
	    throw new TypeError('argument string is required')
	  }
	
	  var match = dispositionTypeRegExp.exec(string)
	
	  if (!match) {
	    throw new TypeError('invalid type format')
	  }
	
	  // normalize type
	  var index = match[0].length
	  var type = match[1].toLowerCase()
	
	  var key
	  var names = []
	  var params = {}
	  var value
	
	  // calculate index to start at
	  index = paramRegExp.lastIndex = match[0].substr(-1) === ';'
	    ? index - 1
	    : index
	
	  // match parameters
	  while (match = paramRegExp.exec(string)) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format')
	    }
	
	    index += match[0].length
	    key = match[1].toLowerCase()
	    value = match[2]
	
	    if (names.indexOf(key) !== -1) {
	      throw new TypeError('invalid duplicate parameter')
	    }
	
	    names.push(key)
	
	    if (key.indexOf('*') + 1 === key.length) {
	      // decode extended value
	      key = key.slice(0, -1)
	      value = decodefield(value)
	
	      // overwrite existing value
	      params[key] = value
	      continue
	    }
	
	    if (typeof params[key] === 'string') {
	      continue
	    }
	
	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value
	        .substr(1, value.length - 2)
	        .replace(qescRegExp, '$1')
	    }
	
	    params[key] = value
	  }
	
	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format')
	  }
	
	  return new ContentDisposition(type, params)
	}
	
	/**
	 * Percent decode a single character.
	 *
	 * @param {string} str
	 * @param {string} hex
	 * @return {string}
	 * @api private
	 */
	
	function pdecode(str, hex) {
	  return String.fromCharCode(parseInt(hex, 16))
	}
	
	/**
	 * Percent encode a single character.
	 *
	 * @param {string} char
	 * @return {string}
	 * @api private
	 */
	
	function pencode(char) {
	  var hex = String(char)
	    .charCodeAt(0)
	    .toString(16)
	    .toUpperCase()
	  return hex.length === 1
	    ? '%0' + hex
	    : '%' + hex
	}
	
	/**
	 * Quote a string for HTTP.
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */
	
	function qstring(val) {
	  var str = String(val)
	
	  return '"' + str.replace(quoteRegExp, '\\$1') + '"'
	}
	
	/**
	 * Encode a Unicode string for HTTP (RFC 5987).
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */
	
	function ustring(val) {
	  var str = String(val)
	
	  // percent encode as UTF-8
	  var encoded = encodeURIComponent(str)
	    .replace(encodeUriAttrCharRegExp, pencode)
	
	  return 'UTF-8\'\'' + encoded
	}
	
	/**
	 * Class for parsed Content-Disposition header for v8 optimization
	 */
	
	function ContentDisposition(type, parameters) {
	  this.type = type
	  this.parameters = parameters
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 48 */
/***/ function(module, exports) {

	/*!
	 * content-type
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
	 *
	 * parameter     = token "=" ( token / quoted-string )
	 * token         = 1*tchar
	 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	 *               / DIGIT / ALPHA
	 *               ; any VCHAR, except delimiters
	 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
	 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
	 * obs-text      = %x80-FF
	 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
	 */
	var paramRegExp = /; *([!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+) */g
	var textRegExp = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/
	var tokenRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/
	
	/**
	 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
	 *
	 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
	 * obs-text    = %x80-FF
	 */
	var qescRegExp = /\\([\u000b\u0020-\u00ff])/g
	
	/**
	 * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
	 */
	var quoteRegExp = /([\\"])/g
	
	/**
	 * RegExp to match type in RFC 6838
	 *
	 * media-type = type "/" subtype
	 * type       = token
	 * subtype    = token
	 */
	var typeRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+\/[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/
	
	/**
	 * Module exports.
	 * @public
	 */
	
	exports.format = format
	exports.parse = parse
	
	/**
	 * Format object to media type.
	 *
	 * @param {object} obj
	 * @return {string}
	 * @public
	 */
	
	function format(obj) {
	  if (!obj || typeof obj !== 'object') {
	    throw new TypeError('argument obj is required')
	  }
	
	  var parameters = obj.parameters
	  var type = obj.type
	
	  if (!type || !typeRegExp.test(type)) {
	    throw new TypeError('invalid type')
	  }
	
	  var string = type
	
	  // append parameters
	  if (parameters && typeof parameters === 'object') {
	    var param
	    var params = Object.keys(parameters).sort()
	
	    for (var i = 0; i < params.length; i++) {
	      param = params[i]
	
	      if (!tokenRegExp.test(param)) {
	        throw new TypeError('invalid parameter name')
	      }
	
	      string += '; ' + param + '=' + qstring(parameters[param])
	    }
	  }
	
	  return string
	}
	
	/**
	 * Parse media type to object.
	 *
	 * @param {string|object} string
	 * @return {Object}
	 * @public
	 */
	
	function parse(string) {
	  if (!string) {
	    throw new TypeError('argument string is required')
	  }
	
	  if (typeof string === 'object') {
	    // support req/res-like objects as argument
	    string = getcontenttype(string)
	
	    if (typeof string !== 'string') {
	      throw new TypeError('content-type header is missing from object');
	    }
	  }
	
	  if (typeof string !== 'string') {
	    throw new TypeError('argument string is required to be a string')
	  }
	
	  var index = string.indexOf(';')
	  var type = index !== -1
	    ? string.substr(0, index).trim()
	    : string.trim()
	
	  if (!typeRegExp.test(type)) {
	    throw new TypeError('invalid media type')
	  }
	
	  var key
	  var match
	  var obj = new ContentType(type.toLowerCase())
	  var value
	
	  paramRegExp.lastIndex = index
	
	  while (match = paramRegExp.exec(string)) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format')
	    }
	
	    index += match[0].length
	    key = match[1].toLowerCase()
	    value = match[2]
	
	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value
	        .substr(1, value.length - 2)
	        .replace(qescRegExp, '$1')
	    }
	
	    obj.parameters[key] = value
	  }
	
	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format')
	  }
	
	  return obj
	}
	
	/**
	 * Get content-type from req/res objects.
	 *
	 * @param {object}
	 * @return {Object}
	 * @private
	 */
	
	function getcontenttype(obj) {
	  if (typeof obj.getHeader === 'function') {
	    // res-like
	    return obj.getHeader('content-type')
	  }
	
	  if (typeof obj.headers === 'object') {
	    // req-like
	    return obj.headers && obj.headers['content-type']
	  }
	}
	
	/**
	 * Quote a string if necessary.
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */
	
	function qstring(val) {
	  var str = String(val)
	
	  // no need to quote tokens
	  if (tokenRegExp.test(str)) {
	    return str
	  }
	
	  if (str.length > 0 && !textRegExp.test(str)) {
	    throw new TypeError('invalid parameter value')
	  }
	
	  return '"' + str.replace(quoteRegExp, '\\$1') + '"'
	}
	
	/**
	 * Class to represent a content type.
	 * @private
	 */
	function ContentType(type) {
	  this.parameters = Object.create(null)
	  this.type = type
	}


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * send
	 * Copyright(c) 2012 TJ Holowaychuk
	 * Copyright(c) 2014-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var createError = __webpack_require__(50)
	var debug = __webpack_require__(13)('send')
	var deprecate = __webpack_require__(30)('send')
	var destroy = __webpack_require__(53)
	var encodeUrl = __webpack_require__(68)
	var escapeHtml = __webpack_require__(16)
	var etag = __webpack_require__(69)
	var EventEmitter = __webpack_require__(3).EventEmitter
	var fresh = __webpack_require__(87)
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var mime = __webpack_require__(88)
	var ms = __webpack_require__(15)
	var onFinished = __webpack_require__(17)
	var parseRange = __webpack_require__(90)
	var path = __webpack_require__(45)
	var statuses = __webpack_require__(19)
	var Stream = __webpack_require__(54)
	var util = __webpack_require__(77)
	
	/**
	 * Path function references.
	 * @private
	 */
	
	var extname = path.extname
	var join = path.join
	var normalize = path.normalize
	var resolve = path.resolve
	var sep = path.sep
	
	/**
	 * Regular expression for identifying a bytes Range header.
	 * @private
	 */
	
	var BYTES_RANGE_REGEXP = /^ *bytes=/
	
	/**
	 * Maximum value allowed for the max age.
	 * @private
	 */
	
	var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000 // 1 year
	
	/**
	 * Regular expression to match a path with a directory up component.
	 * @private
	 */
	
	var UP_PATH_REGEXP = /(?:^|[\\\/])\.\.(?:[\\\/]|$)/
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = send
	module.exports.mime = mime
	
	/**
	 * Shim EventEmitter.listenerCount for node.js < 0.10
	 */
	
	/* istanbul ignore next */
	var listenerCount = EventEmitter.listenerCount ||
	  function (emitter, type) { return emitter.listeners(type).length }
	
	/**
	 * Return a `SendStream` for `req` and `path`.
	 *
	 * @param {object} req
	 * @param {string} path
	 * @param {object} [options]
	 * @return {SendStream}
	 * @public
	 */
	
	function send (req, path, options) {
	  return new SendStream(req, path, options)
	}
	
	/**
	 * Initialize a `SendStream` with the given `path`.
	 *
	 * @param {Request} req
	 * @param {String} path
	 * @param {object} [options]
	 * @private
	 */
	
	function SendStream (req, path, options) {
	  Stream.call(this)
	
	  var opts = options || {}
	
	  this.options = opts
	  this.path = path
	  this.req = req
	
	  this._acceptRanges = opts.acceptRanges !== undefined
	    ? Boolean(opts.acceptRanges)
	    : true
	
	  this._cacheControl = opts.cacheControl !== undefined
	    ? Boolean(opts.cacheControl)
	    : true
	
	  this._etag = opts.etag !== undefined
	    ? Boolean(opts.etag)
	    : true
	
	  this._dotfiles = opts.dotfiles !== undefined
	    ? opts.dotfiles
	    : 'ignore'
	
	  if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {
	    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"')
	  }
	
	  this._hidden = Boolean(opts.hidden)
	
	  if (opts.hidden !== undefined) {
	    deprecate('hidden: use dotfiles: \'' + (this._hidden ? 'allow' : 'ignore') + '\' instead')
	  }
	
	  // legacy support
	  if (opts.dotfiles === undefined) {
	    this._dotfiles = undefined
	  }
	
	  this._extensions = opts.extensions !== undefined
	    ? normalizeList(opts.extensions, 'extensions option')
	    : []
	
	  this._index = opts.index !== undefined
	    ? normalizeList(opts.index, 'index option')
	    : ['index.html']
	
	  this._lastModified = opts.lastModified !== undefined
	    ? Boolean(opts.lastModified)
	    : true
	
	  this._maxage = opts.maxAge || opts.maxage
	  this._maxage = typeof this._maxage === 'string'
	    ? ms(this._maxage)
	    : Number(this._maxage)
	  this._maxage = !isNaN(this._maxage)
	    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
	    : 0
	
	  this._root = opts.root
	    ? resolve(opts.root)
	    : null
	
	  if (!this._root && opts.from) {
	    this.from(opts.from)
	  }
	}
	
	/**
	 * Inherits from `Stream`.
	 */
	
	util.inherits(SendStream, Stream)
	
	/**
	 * Enable or disable etag generation.
	 *
	 * @param {Boolean} val
	 * @return {SendStream}
	 * @api public
	 */
	
	SendStream.prototype.etag = deprecate.function(function etag (val) {
	  this._etag = Boolean(val)
	  debug('etag %s', this._etag)
	  return this
	}, 'send.etag: pass etag as option')
	
	/**
	 * Enable or disable "hidden" (dot) files.
	 *
	 * @param {Boolean} path
	 * @return {SendStream}
	 * @api public
	 */
	
	SendStream.prototype.hidden = deprecate.function(function hidden (val) {
	  this._hidden = Boolean(val)
	  this._dotfiles = undefined
	  debug('hidden %s', this._hidden)
	  return this
	}, 'send.hidden: use dotfiles option')
	
	/**
	 * Set index `paths`, set to a falsy
	 * value to disable index support.
	 *
	 * @param {String|Boolean|Array} paths
	 * @return {SendStream}
	 * @api public
	 */
	
	SendStream.prototype.index = deprecate.function(function index (paths) {
	  var index = !paths ? [] : normalizeList(paths, 'paths argument')
	  debug('index %o', paths)
	  this._index = index
	  return this
	}, 'send.index: pass index as option')
	
	/**
	 * Set root `path`.
	 *
	 * @param {String} path
	 * @return {SendStream}
	 * @api public
	 */
	
	SendStream.prototype.root = function root (path) {
	  this._root = resolve(String(path))
	  debug('root %s', this._root)
	  return this
	}
	
	SendStream.prototype.from = deprecate.function(SendStream.prototype.root,
	  'send.from: pass root as option')
	
	SendStream.prototype.root = deprecate.function(SendStream.prototype.root,
	  'send.root: pass root as option')
	
	/**
	 * Set max-age to `maxAge`.
	 *
	 * @param {Number} maxAge
	 * @return {SendStream}
	 * @api public
	 */
	
	SendStream.prototype.maxage = deprecate.function(function maxage (maxAge) {
	  this._maxage = typeof maxAge === 'string'
	    ? ms(maxAge)
	    : Number(maxAge)
	  this._maxage = !isNaN(this._maxage)
	    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
	    : 0
	  debug('max-age %d', this._maxage)
	  return this
	}, 'send.maxage: pass maxAge as option')
	
	/**
	 * Emit error with `status`.
	 *
	 * @param {number} status
	 * @param {Error} [error]
	 * @private
	 */
	
	SendStream.prototype.error = function error (status, error) {
	  // emit if listeners instead of responding
	  if (listenerCount(this, 'error') !== 0) {
	    return this.emit('error', createError(error, status, {
	      expose: false
	    }))
	  }
	
	  var res = this.res
	  var msg = statuses[status]
	
	  // clear existing headers
	  clearHeaders(res)
	
	  // add error headers
	  if (error && error.headers) {
	    setHeaders(res, error.headers)
	  }
	
	  // send basic response
	  res.statusCode = status
	  res.setHeader('Content-Type', 'text/plain; charset=UTF-8')
	  res.setHeader('Content-Length', Buffer.byteLength(msg))
	  res.setHeader('X-Content-Type-Options', 'nosniff')
	  res.end(msg)
	}
	
	/**
	 * Check if the pathname ends with "/".
	 *
	 * @return {Boolean}
	 * @api private
	 */
	
	SendStream.prototype.hasTrailingSlash = function hasTrailingSlash () {
	  return this.path[this.path.length - 1] === '/'
	}
	
	/**
	 * Check if this is a conditional GET request.
	 *
	 * @return {Boolean}
	 * @api private
	 */
	
	SendStream.prototype.isConditionalGET = function isConditionalGET () {
	  return this.req.headers['if-none-match'] ||
	    this.req.headers['if-modified-since']
	}
	
	/**
	 * Strip content-* header fields.
	 *
	 * @private
	 */
	
	SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields () {
	  var res = this.res
	  var headers = Object.keys(res._headers || {})
	
	  for (var i = 0; i < headers.length; i++) {
	    var header = headers[i]
	    if (header.substr(0, 8) === 'content-' && header !== 'content-location') {
	      res.removeHeader(header)
	    }
	  }
	}
	
	/**
	 * Respond with 304 not modified.
	 *
	 * @api private
	 */
	
	SendStream.prototype.notModified = function notModified () {
	  var res = this.res
	  debug('not modified')
	  this.removeContentHeaderFields()
	  res.statusCode = 304
	  res.end()
	}
	
	/**
	 * Raise error that headers already sent.
	 *
	 * @api private
	 */
	
	SendStream.prototype.headersAlreadySent = function headersAlreadySent () {
	  var err = new Error('Can\'t set headers after they are sent.')
	  debug('headers already sent')
	  this.error(500, err)
	}
	
	/**
	 * Check if the request is cacheable, aka
	 * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
	 *
	 * @return {Boolean}
	 * @api private
	 */
	
	SendStream.prototype.isCachable = function isCachable () {
	  var statusCode = this.res.statusCode
	  return (statusCode >= 200 && statusCode < 300) ||
	    statusCode === 304
	}
	
	/**
	 * Handle stat() error.
	 *
	 * @param {Error} error
	 * @private
	 */
	
	SendStream.prototype.onStatError = function onStatError (error) {
	  switch (error.code) {
	    case 'ENAMETOOLONG':
	    case 'ENOENT':
	    case 'ENOTDIR':
	      this.error(404, error)
	      break
	    default:
	      this.error(500, error)
	      break
	  }
	}
	
	/**
	 * Check if the cache is fresh.
	 *
	 * @return {Boolean}
	 * @api private
	 */
	
	SendStream.prototype.isFresh = function isFresh () {
	  return fresh(this.req.headers, this.res._headers)
	}
	
	/**
	 * Check if the range is fresh.
	 *
	 * @return {Boolean}
	 * @api private
	 */
	
	SendStream.prototype.isRangeFresh = function isRangeFresh () {
	  var ifRange = this.req.headers['if-range']
	
	  if (!ifRange) {
	    return true
	  }
	
	  return ~ifRange.indexOf('"')
	    ? ~ifRange.indexOf(this.res._headers['etag'])
	    : Date.parse(this.res._headers['last-modified']) <= Date.parse(ifRange)
	}
	
	/**
	 * Redirect to path.
	 *
	 * @param {string} path
	 * @private
	 */
	
	SendStream.prototype.redirect = function redirect (path) {
	  if (listenerCount(this, 'directory') !== 0) {
	    this.emit('directory')
	    return
	  }
	
	  if (this.hasTrailingSlash()) {
	    this.error(403)
	    return
	  }
	
	  var loc = encodeUrl(collapseLeadingSlashes(path + '/'))
	  var msg = 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + '</a>\n'
	  var res = this.res
	
	  // redirect
	  res.statusCode = 301
	  res.setHeader('Content-Type', 'text/html; charset=UTF-8')
	  res.setHeader('Content-Length', Buffer.byteLength(msg))
	  res.setHeader('X-Content-Type-Options', 'nosniff')
	  res.setHeader('Location', loc)
	  res.end(msg)
	}
	
	/**
	 * Pipe to `res.
	 *
	 * @param {Stream} res
	 * @return {Stream} res
	 * @api public
	 */
	
	SendStream.prototype.pipe = function pipe (res) {
	  // root path
	  var root = this._root
	
	  // references
	  this.res = res
	
	  // decode the path
	  var path = decode(this.path)
	  if (path === -1) {
	    this.error(400)
	    return res
	  }
	
	  // null byte(s)
	  if (~path.indexOf('\0')) {
	    this.error(400)
	    return res
	  }
	
	  var parts
	  if (root !== null) {
	    // malicious path
	    if (UP_PATH_REGEXP.test(normalize('.' + sep + path))) {
	      debug('malicious path "%s"', path)
	      this.error(403)
	      return res
	    }
	
	    // join / normalize from optional root dir
	    path = normalize(join(root, path))
	    root = normalize(root + sep)
	
	    // explode path parts
	    parts = path.substr(root.length).split(sep)
	  } else {
	    // ".." is malicious without "root"
	    if (UP_PATH_REGEXP.test(path)) {
	      debug('malicious path "%s"', path)
	      this.error(403)
	      return res
	    }
	
	    // explode path parts
	    parts = normalize(path).split(sep)
	
	    // resolve the path
	    path = resolve(path)
	  }
	
	  // dotfile handling
	  if (containsDotFile(parts)) {
	    var access = this._dotfiles
	
	    // legacy support
	    if (access === undefined) {
	      access = parts[parts.length - 1][0] === '.'
	        ? (this._hidden ? 'allow' : 'ignore')
	        : 'allow'
	    }
	
	    debug('%s dotfile "%s"', access, path)
	    switch (access) {
	      case 'allow':
	        break
	      case 'deny':
	        this.error(403)
	        return res
	      case 'ignore':
	      default:
	        this.error(404)
	        return res
	    }
	  }
	
	  // index file support
	  if (this._index.length && this.path[this.path.length - 1] === '/') {
	    this.sendIndex(path)
	    return res
	  }
	
	  this.sendFile(path)
	  return res
	}
	
	/**
	 * Transfer `path`.
	 *
	 * @param {String} path
	 * @api public
	 */
	
	SendStream.prototype.send = function send (path, stat) {
	  var len = stat.size
	  var options = this.options
	  var opts = {}
	  var res = this.res
	  var req = this.req
	  var ranges = req.headers.range
	  var offset = options.start || 0
	
	  if (res._header) {
	    // impossible to send now
	    this.headersAlreadySent()
	    return
	  }
	
	  debug('pipe "%s"', path)
	
	  // set header fields
	  this.setHeader(path, stat)
	
	  // set content-type
	  this.type(path)
	
	  // conditional GET support
	  if (this.isConditionalGET() && this.isCachable() && this.isFresh()) {
	    this.notModified()
	    return
	  }
	
	  // adjust len to start/end options
	  len = Math.max(0, len - offset)
	  if (options.end !== undefined) {
	    var bytes = options.end - offset + 1
	    if (len > bytes) len = bytes
	  }
	
	  // Range support
	  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
	    // parse
	    ranges = parseRange(len, ranges, {
	      combine: true
	    })
	
	    // If-Range support
	    if (!this.isRangeFresh()) {
	      debug('range stale')
	      ranges = -2
	    }
	
	    // unsatisfiable
	    if (ranges === -1) {
	      debug('range unsatisfiable')
	
	      // Content-Range
	      res.setHeader('Content-Range', contentRange('bytes', len))
	
	      // 416 Requested Range Not Satisfiable
	      return this.error(416, {
	        headers: {'Content-Range': res.getHeader('Content-Range')}
	      })
	    }
	
	    // valid (syntactically invalid/multiple ranges are treated as a regular response)
	    if (ranges !== -2 && ranges.length === 1) {
	      debug('range %j', ranges)
	
	      // Content-Range
	      res.statusCode = 206
	      res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]))
	
	      // adjust for requested range
	      offset += ranges[0].start
	      len = ranges[0].end - ranges[0].start + 1
	    }
	  }
	
	  // clone options
	  for (var prop in options) {
	    opts[prop] = options[prop]
	  }
	
	  // set read options
	  opts.start = offset
	  opts.end = Math.max(offset, offset + len - 1)
	
	  // content-length
	  res.setHeader('Content-Length', len)
	
	  // HEAD support
	  if (req.method === 'HEAD') {
	    res.end()
	    return
	  }
	
	  this.stream(path, opts)
	}
	
	/**
	 * Transfer file for `path`.
	 *
	 * @param {String} path
	 * @api private
	 */
	SendStream.prototype.sendFile = function sendFile (path) {
	  var i = 0
	  var self = this
	
	  debug('stat "%s"', path)
	  fs.stat(path, function onstat (err, stat) {
	    if (err && err.code === 'ENOENT' && !extname(path) && path[path.length - 1] !== sep) {
	      // not found, check extensions
	      return next(err)
	    }
	    if (err) return self.onStatError(err)
	    if (stat.isDirectory()) return self.redirect(self.path)
	    self.emit('file', path, stat)
	    self.send(path, stat)
	  })
	
	  function next (err) {
	    if (self._extensions.length <= i) {
	      return err
	        ? self.onStatError(err)
	        : self.error(404)
	    }
	
	    var p = path + '.' + self._extensions[i++]
	
	    debug('stat "%s"', p)
	    fs.stat(p, function (err, stat) {
	      if (err) return next(err)
	      if (stat.isDirectory()) return next()
	      self.emit('file', p, stat)
	      self.send(p, stat)
	    })
	  }
	}
	
	/**
	 * Transfer index for `path`.
	 *
	 * @param {String} path
	 * @api private
	 */
	SendStream.prototype.sendIndex = function sendIndex (path) {
	  var i = -1
	  var self = this
	
	  function next (err) {
	    if (++i >= self._index.length) {
	      if (err) return self.onStatError(err)
	      return self.error(404)
	    }
	
	    var p = join(path, self._index[i])
	
	    debug('stat "%s"', p)
	    fs.stat(p, function (err, stat) {
	      if (err) return next(err)
	      if (stat.isDirectory()) return next()
	      self.emit('file', p, stat)
	      self.send(p, stat)
	    })
	  }
	
	  next()
	}
	
	/**
	 * Stream `path` to the response.
	 *
	 * @param {String} path
	 * @param {Object} options
	 * @api private
	 */
	
	SendStream.prototype.stream = function stream (path, options) {
	  // TODO: this is all lame, refactor meeee
	  var finished = false
	  var self = this
	  var res = this.res
	
	  // pipe
	  var stream = fs.createReadStream(path, options)
	  this.emit('stream', stream)
	  stream.pipe(res)
	
	  // response finished, done with the fd
	  onFinished(res, function onfinished () {
	    finished = true
	    destroy(stream)
	  })
	
	  // error handling code-smell
	  stream.on('error', function onerror (err) {
	    // request already finished
	    if (finished) return
	
	    // clean up stream
	    finished = true
	    destroy(stream)
	
	    // error
	    self.onStatError(err)
	  })
	
	  // end
	  stream.on('end', function onend () {
	    self.emit('end')
	  })
	}
	
	/**
	 * Set content-type based on `path`
	 * if it hasn't been explicitly set.
	 *
	 * @param {String} path
	 * @api private
	 */
	
	SendStream.prototype.type = function type (path) {
	  var res = this.res
	
	  if (res.getHeader('Content-Type')) return
	
	  var type = mime.lookup(path)
	
	  if (!type) {
	    debug('no content-type')
	    return
	  }
	
	  var charset = mime.charsets.lookup(type)
	
	  debug('content-type %s', type)
	  res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''))
	}
	
	/**
	 * Set response header fields, most
	 * fields may be pre-defined.
	 *
	 * @param {String} path
	 * @param {Object} stat
	 * @api private
	 */
	
	SendStream.prototype.setHeader = function setHeader (path, stat) {
	  var res = this.res
	
	  this.emit('headers', res, path, stat)
	
	  if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {
	    debug('accept ranges')
	    res.setHeader('Accept-Ranges', 'bytes')
	  }
	
	  if (this._cacheControl && !res.getHeader('Cache-Control')) {
	    var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000)
	    debug('cache-control %s', cacheControl)
	    res.setHeader('Cache-Control', cacheControl)
	  }
	
	  if (this._lastModified && !res.getHeader('Last-Modified')) {
	    var modified = stat.mtime.toUTCString()
	    debug('modified %s', modified)
	    res.setHeader('Last-Modified', modified)
	  }
	
	  if (this._etag && !res.getHeader('ETag')) {
	    var val = etag(stat)
	    debug('etag %s', val)
	    res.setHeader('ETag', val)
	  }
	}
	
	/**
	 * Clear all headers from a response.
	 *
	 * @param {object} res
	 * @private
	 */
	
	function clearHeaders (res) {
	  res._headers = {}
	  res._headerNames = {}
	}
	
	/**
	 * Collapse all leading slashes into a single slash
	 *
	 * @param {string} str
	 * @private
	 */
	function collapseLeadingSlashes (str) {
	  for (var i = 0; i < str.length; i++) {
	    if (str[i] !== '/') {
	      break
	    }
	  }
	
	  return i > 1
	    ? '/' + str.substr(i)
	    : str
	}
	
	/**
	 * Determine if path parts contain a dotfile.
	 *
	 * @api private
	 */
	
	function containsDotFile (parts) {
	  for (var i = 0; i < parts.length; i++) {
	    if (parts[i][0] === '.') {
	      return true
	    }
	  }
	
	  return false
	}
	
	/**
	 * Create a Content-Range header.
	 *
	 * @param {string} type
	 * @param {number} size
	 * @param {array} [range]
	 */
	
	function contentRange (type, size, range) {
	  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size
	}
	
	/**
	 * decodeURIComponent.
	 *
	 * Allows V8 to only deoptimize this fn instead of all
	 * of send().
	 *
	 * @param {String} path
	 * @api private
	 */
	
	function decode (path) {
	  try {
	    return decodeURIComponent(path)
	  } catch (err) {
	    return -1
	  }
	}
	
	/**
	 * Normalize the index option into an array.
	 *
	 * @param {boolean|string|array} val
	 * @param {string} name
	 * @private
	 */
	
	function normalizeList (val, name) {
	  var list = [].concat(val || [])
	
	  for (var i = 0; i < list.length; i++) {
	    if (typeof list[i] !== 'string') {
	      throw new TypeError(name + ' must be array of strings or false')
	    }
	  }
	
	  return list
	}
	
	/**
	 * Set an object of headers on a response.
	 *
	 * @param {object} res
	 * @param {object} headers
	 * @private
	 */
	
	function setHeaders (res, headers) {
	  var keys = Object.keys(headers)
	
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i]
	    res.setHeader(key, headers[key])
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * http-errors
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var setPrototypeOf = __webpack_require__(51)
	var statuses = __webpack_require__(19)
	var inherits = __webpack_require__(52)
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = createError
	module.exports.HttpError = createHttpErrorConstructor()
	
	// Populate exports for all constructors
	populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError)
	
	/**
	 * Create a new HTTP Error.
	 *
	 * @returns {Error}
	 * @public
	 */
	
	function createError () {
	  // so much arity going on ~_~
	  var err
	  var msg
	  var status = 500
	  var props = {}
	  for (var i = 0; i < arguments.length; i++) {
	    var arg = arguments[i]
	    if (arg instanceof Error) {
	      err = arg
	      status = err.status || err.statusCode || status
	      continue
	    }
	    switch (typeof arg) {
	      case 'string':
	        msg = arg
	        break
	      case 'number':
	        status = arg
	        break
	      case 'object':
	        props = arg
	        break
	    }
	  }
	
	  if (typeof status !== 'number' || !statuses[status]) {
	    status = 500
	  }
	
	  // constructor
	  var HttpError = createError[status]
	
	  if (!err) {
	    // create error
	    err = HttpError
	      ? new HttpError(msg)
	      : new Error(msg || statuses[status])
	    Error.captureStackTrace(err, createError)
	  }
	
	  if (!HttpError || !(err instanceof HttpError)) {
	    // add properties to generic error
	    err.expose = status < 500
	    err.status = err.statusCode = status
	  }
	
	  for (var key in props) {
	    if (key !== 'status' && key !== 'statusCode') {
	      err[key] = props[key]
	    }
	  }
	
	  return err
	}
	
	/**
	 * Create HTTP error abstract base class.
	 * @private
	 */
	
	function createHttpErrorConstructor () {
	  function HttpError () {
	    throw new TypeError('cannot construct abstract class')
	  }
	
	  inherits(HttpError, Error)
	
	  return HttpError
	}
	
	/**
	 * Create a constructor for a client error.
	 * @private
	 */
	
	function createClientErrorConstructor (HttpError, name, code) {
	  var className = name.match(/Error$/) ? name : name + 'Error'
	
	  function ClientError (message) {
	    // create the error object
	    var err = new Error(message != null ? message : statuses[code])
	
	    // capture a stack trace to the construction point
	    Error.captureStackTrace(err, ClientError)
	
	    // adjust the [[Prototype]]
	    setPrototypeOf(err, ClientError.prototype)
	
	    // redefine the error name
	    Object.defineProperty(err, 'name', {
	      enumerable: false,
	      configurable: true,
	      value: className,
	      writable: true
	    })
	
	    return err
	  }
	
	  inherits(ClientError, HttpError)
	
	  ClientError.prototype.status = code
	  ClientError.prototype.statusCode = code
	  ClientError.prototype.expose = true
	
	  return ClientError
	}
	
	/**
	 * Create a constructor for a server error.
	 * @private
	 */
	
	function createServerErrorConstructor (HttpError, name, code) {
	  var className = name.match(/Error$/) ? name : name + 'Error'
	
	  function ServerError (message) {
	    // create the error object
	    var err = new Error(message != null ? message : statuses[code])
	
	    // capture a stack trace to the construction point
	    Error.captureStackTrace(err, ServerError)
	
	    // adjust the [[Prototype]]
	    setPrototypeOf(err, ServerError.prototype)
	
	    // redefine the error name
	    Object.defineProperty(err, 'name', {
	      enumerable: false,
	      configurable: true,
	      value: className,
	      writable: true
	    })
	
	    return err
	  }
	
	  inherits(ServerError, HttpError)
	
	  ServerError.prototype.status = code
	  ServerError.prototype.statusCode = code
	  ServerError.prototype.expose = false
	
	  return ServerError
	}
	
	/**
	 * Populate the exports object with constructors for every error class.
	 * @private
	 */
	
	function populateConstructorExports (exports, codes, HttpError) {
	  codes.forEach(function forEachCode (code) {
	    var CodeError
	    var name = toIdentifier(statuses[code])
	
	    switch (String(code).charAt(0)) {
	      case '4':
	        CodeError = createClientErrorConstructor(HttpError, name, code)
	        break
	      case '5':
	        CodeError = createServerErrorConstructor(HttpError, name, code)
	        break
	    }
	
	    if (CodeError) {
	      // export the constructor
	      exports[code] = CodeError
	      exports[name] = CodeError
	    }
	  })
	
	  // backwards-compatibility
	  exports["I'mateapot"] = exports.ImATeapot
	}
	
	/**
	 * Convert a string of words to a JavaScript identifier.
	 * @private
	 */
	
	function toIdentifier (str) {
	  return str.split(' ').map(function (token) {
	    return token.slice(0, 1).toUpperCase() + token.slice(1)
	  }).join('').replace(/[^ _0-9a-z]/gi, '')
	}


/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = Object.setPrototypeOf || ({__proto__:[]} instanceof Array ? setProtoOf : mixinProperties);
	
	function setProtoOf(obj, proto) {
		obj.__proto__ = proto;
	}
	
	function mixinProperties(obj, proto) {
		for (var prop in proto) {
			obj[prop] = proto[prop];
		}
	}


/***/ },
/* 52 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * destroy
	 * Copyright(c) 2014 Jonathan Ong
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var ReadStream = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).ReadStream
	var Stream = __webpack_require__(54)
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = destroy
	
	/**
	 * Destroy a stream.
	 *
	 * @param {object} stream
	 * @public
	 */
	
	function destroy(stream) {
	  if (stream instanceof ReadStream) {
	    return destroyReadStream(stream)
	  }
	
	  if (!(stream instanceof Stream)) {
	    return stream
	  }
	
	  if (typeof stream.destroy === 'function') {
	    stream.destroy()
	  }
	
	  return stream
	}
	
	/**
	 * Destroy a ReadStream.
	 *
	 * @param {object} stream
	 * @private
	 */
	
	function destroyReadStream(stream) {
	  stream.destroy()
	
	  if (typeof stream.close === 'function') {
	    // node.js core bug work-around
	    stream.on('open', onOpenClose)
	  }
	
	  return stream
	}
	
	/**
	 * On open handler to close stream.
	 * @private
	 */
	
	function onOpenClose() {
	  if (typeof this.fd === 'number') {
	    // actually close down the fd
	    this.close()
	  }
	}


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Stream;
	
	var EE = __webpack_require__(3).EventEmitter;
	var inherits = __webpack_require__(52);
	
	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(55);
	Stream.Writable = __webpack_require__(64);
	Stream.Duplex = __webpack_require__(65);
	Stream.Transform = __webpack_require__(66);
	Stream.PassThrough = __webpack_require__(67);
	
	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;
	
	
	
	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.
	
	function Stream() {
	  EE.call(this);
	}
	
	Stream.prototype.pipe = function(dest, options) {
	  var source = this;
	
	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }
	
	  source.on('data', ondata);
	
	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }
	
	  dest.on('drain', ondrain);
	
	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }
	
	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    dest.end();
	  }
	
	
	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    if (typeof dest.destroy === 'function') dest.destroy();
	  }
	
	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }
	
	  source.on('error', onerror);
	  dest.on('error', onerror);
	
	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);
	
	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);
	
	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);
	
	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);
	
	    dest.removeListener('close', cleanup);
	  }
	
	  source.on('end', cleanup);
	  source.on('close', cleanup);
	
	  dest.on('close', cleanup);
	
	  dest.emit('pipe', source);
	
	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(56);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(60);
	exports.Duplex = __webpack_require__(61);
	exports.Transform = __webpack_require__(62);
	exports.PassThrough = __webpack_require__(63);


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Readable;
	
	/*<replacement>*/
	var isArray = __webpack_require__(57);
	/*</replacement>*/
	
	
	/*<replacement>*/
	var Buffer = __webpack_require__(9).Buffer;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	var EE = __webpack_require__(3).EventEmitter;
	
	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	var Stream = __webpack_require__(54);
	
	/*<replacement>*/
	var util = __webpack_require__(58);
	util.inherits = __webpack_require__(52);
	/*</replacement>*/
	
	var StringDecoder;
	
	util.inherits(Readable, Stream);
	
	function ReadableState(options, stream) {
	  options = options || {};
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = false;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // In streams that never have any data, and do push(null) right away,
	  // the consumer can miss the 'end' event if they do some I/O before
	  // consuming the stream.  So, we don't emit('end') until some reading
	  // happens.
	  this.calledRead = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(59).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  if (!(this instanceof Readable))
	    return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;
	
	  if (typeof chunk === 'string' && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null || chunk === undefined) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);
	
	      // update the buffer info.
	      state.length += state.objectMode ? 1 : chunk.length;
	      if (addToFront) {
	        state.buffer.unshift(chunk);
	      } else {
	        state.reading = false;
	        state.buffer.push(chunk);
	      }
	
	      if (state.needReadable)
	        emitReadable(stream);
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(59).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	};
	
	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}
	
	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;
	
	  if (state.objectMode)
	    return n === 0 ? 0 : 1;
	
	  if (n === null || isNaN(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }
	
	  if (n <= 0)
	    return 0;
	
	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);
	
	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }
	
	  return n;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  var state = this._readableState;
	  state.calledRead = true;
	  var nOrig = n;
	  var ret;
	
	  if (typeof n !== 'number' || n > 0)
	    state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    ret = null;
	
	    // In cases where the decoder did not receive enough data
	    // to produce a full chunk, then immediately received an
	    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
	    // howMuchToRead will see this and coerce the amount to
	    // read to zero (because it's looking at the length of the
	    // first <Buffer > in state.buffer), and we'll end up here.
	    //
	    // This can only happen via state.decoder -- no other venue
	    // exists for pushing a zero-length chunk into state.buffer
	    // and triggering this behavior. In this case, we return our
	    // remaining data and end the stream, if appropriate.
	    if (state.length > 0 && state.decoder) {
	      ret = fromList(n, state);
	      state.length -= ret.length;
	    }
	
	    if (state.length === 0)
	      endReadable(this);
	
	    return ret;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length - n <= state.highWaterMark)
	    doRead = true;
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading)
	    doRead = false;
	
	  if (doRead) {
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }
	
	  // If _read called its callback synchronously, then `reading`
	  // will be false, and we need to re-evaluate how much data we
	  // can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);
	
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;
	
	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  }
	
	  state.length -= n;
	
	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;
	
	  // If we happened to read() exactly the remaining amount in the
	  // buffer, and the EOF has been seen at this point, then make sure
	  // that we emit 'end' on the very next tick.
	  if (state.ended && !state.endEmitted && state.length === 0)
	    endReadable(this);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	
	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // if we've ended and we have some data left, then emit
	  // 'readable' now to make sure it gets picked up.
	  if (state.length > 0)
	    emitReadable(stream);
	  else
	    endReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (state.emittedReadable)
	    return;
	
	  state.emittedReadable = true;
	  if (state.sync)
	    process.nextTick(function() {
	      emitReadable_(stream);
	    });
	  else
	    emitReadable_(stream);
	}
	
	function emitReadable_(stream) {
	  stream.emit('readable');
	}
	
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};
	
	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    if (readable !== src) return;
	    cleanup();
	  }
	
	  function onend() {
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  function cleanup() {
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (!dest._writableState || dest._writableState.needDrain)
	      ondrain();
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];
	
	
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    // the handler that waits for readable events after all
	    // the data gets sucked out in flow.
	    // This would be easier to follow with a .once() handler
	    // in flow(), but that is too slow.
	    this.on('readable', pipeOnReadable);
	
	    state.flowing = true;
	    process.nextTick(function() {
	      flow(src);
	    });
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function() {
	    var dest = this;
	    var state = src._readableState;
	    state.awaitDrain--;
	    if (state.awaitDrain === 0)
	      flow(src);
	  };
	}
	
	function flow(src) {
	  var state = src._readableState;
	  var chunk;
	  state.awaitDrain = 0;
	
	  function write(dest, i, list) {
	    var written = dest.write(chunk);
	    if (false === written) {
	      state.awaitDrain++;
	    }
	  }
	
	  while (state.pipesCount && null !== (chunk = src.read())) {
	
	    if (state.pipesCount === 1)
	      write(state.pipes, 0, null);
	    else
	      forEach(state.pipes, write);
	
	    src.emit('data', chunk);
	
	    // if anyone needs a drain, then we have to wait for that.
	    if (state.awaitDrain > 0)
	      return;
	  }
	
	  // if every destination was unpiped, either before entering this
	  // function, or in the while loop, then stop flowing.
	  //
	  // NB: This is a pretty rare edge case.
	  if (state.pipesCount === 0) {
	    state.flowing = false;
	
	    // if there were data event listeners added, then switch to old mode.
	    if (EE.listenerCount(src, 'data') > 0)
	      emitDataEvents(src);
	    return;
	  }
	
	  // at this point, no one needed a drain, so we just ran out of data
	  // on the next readable event, start it over again.
	  state.ranOut = true;
	}
	
	function pipeOnReadable() {
	  if (this._readableState.ranOut) {
	    this._readableState.ranOut = false;
	    flow(this);
	  }
	}
	
	
	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;
	
	    if (!dest)
	      dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }
	
	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;
	
	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  if (ev === 'data' && !this._readableState.flowing)
	    emitDataEvents(this);
	
	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        this.read(0);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  emitDataEvents(this);
	  this.read(0);
	  this.emit('resume');
	};
	
	Readable.prototype.pause = function() {
	  emitDataEvents(this, true);
	  this.emit('pause');
	};
	
	function emitDataEvents(stream, startPaused) {
	  var state = stream._readableState;
	
	  if (state.flowing) {
	    // https://github.com/isaacs/readable-stream/issues/16
	    throw new Error('Cannot switch to old mode now.');
	  }
	
	  var paused = startPaused || false;
	  var readable = false;
	
	  // convert to an old-style stream.
	  stream.readable = true;
	  stream.pipe = Stream.prototype.pipe;
	  stream.on = stream.addListener = Stream.prototype.on;
	
	  stream.on('readable', function() {
	    readable = true;
	
	    var c;
	    while (!paused && (null !== (c = stream.read())))
	      stream.emit('data', c);
	
	    if (c === null) {
	      readable = false;
	      stream._readableState.needReadable = true;
	    }
	  });
	
	  stream.pause = function() {
	    paused = true;
	    this.emit('pause');
	  };
	
	  stream.resume = function() {
	    paused = false;
	    if (readable)
	      process.nextTick(function() {
	        stream.emit('readable');
	      });
	    else
	      this.read(0);
	    this.emit('resume');
	  };
	
	  // now make it start, just in case it hadn't already.
	  stream.emit('readable');
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function() {
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function(chunk) {
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	
	    // don't skip over falsy values in objectMode
	    //if (state.objectMode && util.isNullOrUndefined(chunk))
	    if (state.objectMode && (chunk === null || chunk === undefined))
	      return;
	    else if (!state.objectMode && (!chunk || !chunk.length))
	      return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (typeof stream[i] === 'function' &&
	        typeof this[i] === 'undefined') {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;
	
	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;
	
	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);
	
	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);
	
	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);
	
	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();
	
	        c += cpy;
	      }
	    }
	  }
	
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');
	
	  if (!state.endEmitted && state.calledRead) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 57 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	
	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = Buffer.isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(9).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.
	
	module.exports = Writable;
	
	/*<replacement>*/
	var Buffer = __webpack_require__(9).Buffer;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	
	/*<replacement>*/
	var util = __webpack_require__(58);
	util.inherits = __webpack_require__(52);
	/*</replacement>*/
	
	var Stream = __webpack_require__(54);
	
	util.inherits(Writable, Stream);
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}
	
	function WritableState(options, stream) {
	  options = options || {};
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.buffer = [];
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}
	
	function Writable(options) {
	  var Duplex = __webpack_require__(61);
	
	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};
	
	
	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;
	
	  if (typeof cb !== 'function')
	    cb = function() {};
	
	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb))
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	
	  return ret;
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      typeof chunk === 'string') {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;
	
	  if (state.writing)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, len, chunk, encoding, cb);
	
	  return ret;
	}
	
	function doWrite(stream, state, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      cb(er);
	    });
	  else
	    cb(er);
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);
	
	    if (!finished && !state.bufferProcessing && state.buffer.length)
	      clearBuffer(stream, state);
	
	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  cb();
	  if (finished)
	    finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	
	  for (var c = 0; c < state.buffer.length; c++) {
	    var entry = state.buffer[c];
	    var chunk = entry.chunk;
	    var encoding = entry.encoding;
	    var cb = entry.callback;
	    var len = state.objectMode ? 1 : chunk.length;
	
	    doWrite(stream, state, len, chunk, encoding, cb);
	
	    // if we didn't call the onwrite immediately, then
	    // it means that we need to wait until it does.
	    // also, that means that the chunk and cb are currently
	    // being processed, so move the buffer counter past them.
	    if (state.writing) {
	      c++;
	      break;
	    }
	  }
	
	  state.bufferProcessing = false;
	  if (c < state.buffer.length)
	    state.buffer = state.buffer.slice(c);
	  else
	    state.buffer.length = 0;
	}
	
	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};
	
	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (typeof chunk !== 'undefined' && chunk !== null)
	    this.write(chunk, encoding);
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};
	
	
	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    state.finished = true;
	    stream.emit('finish');
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/
	
	
	/*<replacement>*/
	var util = __webpack_require__(58);
	util.inherits = __webpack_require__(52);
	/*</replacement>*/
	
	var Readable = __webpack_require__(56);
	var Writable = __webpack_require__(60);
	
	util.inherits(Duplex, Readable);
	
	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});
	
	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false)
	    this.readable = false;
	
	  if (options && options.writable === false)
	    this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(61);
	
	/*<replacement>*/
	var util = __webpack_require__(58);
	util.inherits = __webpack_require__(52);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	
	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (data !== null && data !== undefined)
	    stream.push(data);
	
	  if (cb)
	    cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	
	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);
	
	  Duplex.call(this, options);
	
	  var ts = this._transformState = new TransformState(options, this);
	
	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  this.once('finish', function() {
	    if ('function' === typeof this._flush)
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}
	
	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};
	
	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;
	
	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	
	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var rs = stream._readableState;
	  var ts = stream._transformState;
	
	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');
	
	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');
	
	  return stream.push(null);
	}


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(62);
	
	/*<replacement>*/
	var util = __webpack_require__(58);
	util.inherits = __webpack_require__(52);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(60)


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(61)


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(62)


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(63)


/***/ },
/* 68 */
/***/ function(module, exports) {

	/*!
	 * encodeurl
	 * Copyright(c) 2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = encodeUrl
	
	/**
	 * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
	 * and including invalid escape sequences.
	 * @private
	 */
	
	var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]))+/g
	
	/**
	 * RegExp to match unmatched surrogate pair.
	 * @private
	 */
	
	var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g
	
	/**
	 * String to replace unmatched surrogate pair with.
	 * @private
	 */
	
	var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2'
	
	/**
	 * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
	 *
	 * This function will take an already-encoded URL and encode all the non-URL
	 * code points. This function will not encode the "%" character unless it is
	 * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
	 * be encoded as `%25foo`).
	 *
	 * This encode is meant to be "safe" and does not throw errors. It will try as
	 * hard as it can to properly encode the given URL, including replacing any raw,
	 * unpaired surrogate pairs with the Unicode replacement character prior to
	 * encoding.
	 *
	 * @param {string} url
	 * @return {string}
	 * @public
	 */
	
	function encodeUrl (url) {
	  return String(url)
	    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
	    .replace(ENCODE_CHARS_REGEXP, encodeURI)
	}


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * etag
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = etag
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var crypto = __webpack_require__(70)
	var Stats = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).Stats
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var base64PadCharRegExp = /=+$/
	var toString = Object.prototype.toString
	
	/**
	 * Generate an entity tag.
	 *
	 * @param {Buffer|string} entity
	 * @return {string}
	 * @private
	 */
	
	function entitytag(entity) {
	  if (entity.length === 0) {
	    // fast-path empty
	    return '"0-1B2M2Y8AsgTpgAmY7PhCfg"'
	  }
	
	  // compute hash of entity
	  var hash = crypto
	    .createHash('md5')
	    .update(entity, 'utf8')
	    .digest('base64')
	    .replace(base64PadCharRegExp, '')
	
	  // compute length of entity
	  var len = typeof entity === 'string'
	    ? Buffer.byteLength(entity, 'utf8')
	    : entity.length
	
	  return '"' + len.toString(16) + '-' + hash + '"'
	}
	
	/**
	 * Create a simple ETag.
	 *
	 * @param {string|Buffer|Stats} entity
	 * @param {object} [options]
	 * @param {boolean} [options.weak]
	 * @return {String}
	 * @public
	 */
	
	function etag(entity, options) {
	  if (entity == null) {
	    throw new TypeError('argument entity is required')
	  }
	
	  // support fs.Stats object
	  var isStats = isstats(entity)
	  var weak = options && typeof options.weak === 'boolean'
	    ? options.weak
	    : isStats
	
	  // validate argument
	  if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
	    throw new TypeError('argument entity must be string, Buffer, or fs.Stats')
	  }
	
	  // generate entity tag
	  var tag = isStats
	    ? stattag(entity)
	    : entitytag(entity)
	
	  return weak
	    ? 'W/' + tag
	    : tag
	}
	
	/**
	 * Determine if object is a Stats object.
	 *
	 * @param {object} obj
	 * @return {boolean}
	 * @api private
	 */
	
	function isstats(obj) {
	  // genuine fs.Stats
	  if (typeof Stats === 'function' && obj instanceof Stats) {
	    return true
	  }
	
	  // quack quack
	  return obj && typeof obj === 'object'
	    && 'ctime' in obj && toString.call(obj.ctime) === '[object Date]'
	    && 'mtime' in obj && toString.call(obj.mtime) === '[object Date]'
	    && 'ino' in obj && typeof obj.ino === 'number'
	    && 'size' in obj && typeof obj.size === 'number'
	}
	
	/**
	 * Generate a tag for a stat.
	 *
	 * @param {object} stat
	 * @return {string}
	 * @private
	 */
	
	function stattag(stat) {
	  var mtime = stat.mtime.getTime().toString(16)
	  var size = stat.size.toString(16)
	
	  return '"' + size + '-' + mtime + '"'
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var rng = __webpack_require__(71)
	
	function error () {
	  var m = [].slice.call(arguments).join(' ')
	  throw new Error([
	    m,
	    'we accept pull requests',
	    'http://github.com/dominictarr/crypto-browserify'
	    ].join('\n'))
	}
	
	exports.createHash = __webpack_require__(73)
	
	exports.createHmac = __webpack_require__(84)
	
	exports.randomBytes = function(size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)))
	    } catch (err) { callback(err) }
	  } else {
	    return new Buffer(rng(size))
	  }
	}
	
	function each(a, f) {
	  for(var i in a)
	    f(a[i], i)
	}
	
	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']
	}
	
	var p = __webpack_require__(85)(exports)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync
	
	
	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials'
	, 'createCipher'
	, 'createCipheriv'
	, 'createDecipher'
	, 'createDecipheriv'
	, 'createSign'
	, 'createVerify'
	, 'createDiffieHellman'
	], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet')
	  }
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function() {
	  var g = ('undefined' === typeof window ? global : window) || {}
	  _crypto = (
	    g.crypto || g.msCrypto || __webpack_require__(72)
	  )
	  module.exports = function(size) {
	    // Modern Browsers
	    if(_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */
	    
	      _crypto.getRandomValues(bytes);
	      return bytes;
	    }
	    else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size)
	    }
	    else
	      throw new Error(
	        'secure random number generation not supported by this browser\n'+
	        'use chrome, FireFox or Internet Explorer 11'
	      )
	  }
	}())
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(9).Buffer))

/***/ },
/* 72 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(74)
	
	var md5 = toConstructor(__webpack_require__(81))
	var rmd160 = toConstructor(__webpack_require__(83))
	
	function toConstructor (fn) {
	  return function () {
	    var buffers = []
	    var m= {
	      update: function (data, enc) {
	        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)
	        buffers.push(data)
	        return this
	      },
	      digest: function (enc) {
	        var buf = Buffer.concat(buffers)
	        var r = fn(buf)
	        buffers = null
	        return enc ? r.toString(enc) : r
	      }
	    }
	    return m
	  }
	}
	
	module.exports = function (alg) {
	  if('md5' === alg) return new md5()
	  if('rmd160' === alg) return new rmd160()
	  return createHash(alg)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function (alg) {
	  var Alg = exports[alg]
	  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
	  return new Alg()
	}
	
	var Buffer = __webpack_require__(9).Buffer
	var Hash   = __webpack_require__(75)(Buffer)
	
	exports.sha1 = __webpack_require__(76)(Buffer, Hash)
	exports.sha256 = __webpack_require__(79)(Buffer, Hash)
	exports.sha512 = __webpack_require__(80)(Buffer, Hash)


/***/ },
/* 75 */
/***/ function(module, exports) {

	module.exports = function (Buffer) {
	
	  //prototype class for hash functions
	  function Hash (blockSize, finalSize) {
	    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize
	    this._blockSize = blockSize
	    this._len = 0
	    this._s = 0
	  }
	
	  Hash.prototype.init = function () {
	    this._s = 0
	    this._len = 0
	  }
	
	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8"
	      data = new Buffer(data, enc)
	    }
	
	    var l = this._len += data.length
	    var s = this._s = (this._s || 0)
	    var f = 0
	    var buffer = this._block
	
	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	      var ch = (t - f)
	
	      for (var i = 0; i < ch; i++) {
	        buffer[(s % this._blockSize) + i] = data[i + f]
	      }
	
	      s += ch
	      f += ch
	
	      if ((s % this._blockSize) === 0) {
	        this._update(buffer)
	      }
	    }
	    this._s = s
	
	    return this
	  }
	
	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8
	
	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80
	
	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1)
	
	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block)
	      this._block.fill(0)
	    }
	
	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4)
	
	    var hash = this._update(this._block) || this._hash()
	
	    return enc ? hash.toString(enc) : hash
	  }
	
	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass')
	  }
	
	  return Hash
	}


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */
	
	var inherits = __webpack_require__(77).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var A = 0|0
	  var B = 4|0
	  var C = 8|0
	  var D = 12|0
	  var E = 16|0
	
	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)
	
	  var POOL = []
	
	  function Sha1 () {
	    if(POOL.length)
	      return POOL.pop().init()
	
	    if(!(this instanceof Sha1)) return new Sha1()
	    this._w = W
	    Hash.call(this, 16*4, 14*4)
	
	    this._h = null
	    this.init()
	  }
	
	  inherits(Sha1, Hash)
	
	  Sha1.prototype.init = function () {
	    this._a = 0x67452301
	    this._b = 0xefcdab89
	    this._c = 0x98badcfe
	    this._d = 0x10325476
	    this._e = 0xc3d2e1f0
	
	    Hash.prototype.init.call(this)
	    return this
	  }
	
	  Sha1.prototype._POOL = POOL
	  Sha1.prototype._update = function (X) {
	
	    var a, b, c, d, e, _a, _b, _c, _d, _e
	
	    a = _a = this._a
	    b = _b = this._b
	    c = _c = this._c
	    d = _d = this._d
	    e = _e = this._e
	
	    var w = this._w
	
	    for(var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j*4)
	        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)
	
	      var t = add(
	        add(rol(a, 5), sha1_ft(j, b, c, d)),
	        add(add(e, W), sha1_kt(j))
	      )
	
	      e = d
	      d = c
	      c = rol(b, 30)
	      b = a
	      a = t
	    }
	
	    this._a = add(a, _a)
	    this._b = add(b, _b)
	    this._c = add(c, _c)
	    this._d = add(d, _d)
	    this._e = add(e, _e)
	  }
	
	  Sha1.prototype._hash = function () {
	    if(POOL.length < 100) POOL.push(this)
	    var H = new Buffer(20)
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a|0, A)
	    H.writeInt32BE(this._b|0, B)
	    H.writeInt32BE(this._c|0, C)
	    H.writeInt32BE(this._d|0, D)
	    H.writeInt32BE(this._e|0, E)
	    return H
	  }
	
	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	  }
	
	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
	           (t < 60) ? -1894007588 : -899497514;
	  }
	
	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return (x + y ) | 0
	  //lets see how this goes on testling.
	  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  //  return (msw << 16) | (lsw & 0xFFFF);
	  }
	
	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt));
	  }
	
	  return Sha1
	}


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(78);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(52);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(6)))

/***/ },
/* 78 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */
	
	var inherits = __webpack_require__(77).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var K = [
	      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	    ]
	
	  var W = new Array(64)
	
	  function Sha256() {
	    this.init()
	
	    this._w = W //new Array(64)
	
	    Hash.call(this, 16*4, 14*4)
	  }
	
	  inherits(Sha256, Hash)
	
	  Sha256.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, n) {
	    return (X >>> n) | (X << (32 - n));
	  }
	
	  function R (X, n) {
	    return (X >>> n);
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  function Sigma0256 (x) {
	    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
	  }
	
	  function Sigma1256 (x) {
	    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
	  }
	
	  function Gamma0256 (x) {
	    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
	  }
	
	  function Gamma1256 (x) {
	    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
	  }
	
	  Sha256.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var T1, T2
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16
	        ? M.readInt32BE(j * 4)
	        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]
	
	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w
	
	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
	    }
	
	    this._a = (a + this._a) | 0
	    this._b = (b + this._b) | 0
	    this._c = (c + this._c) | 0
	    this._d = (d + this._d) | 0
	    this._e = (e + this._e) | 0
	    this._f = (f + this._f) | 0
	    this._g = (g + this._g) | 0
	    this._h = (h + this._h) | 0
	
	  };
	
	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32)
	
	    H.writeInt32BE(this._a,  0)
	    H.writeInt32BE(this._b,  4)
	    H.writeInt32BE(this._c,  8)
	    H.writeInt32BE(this._d, 12)
	    H.writeInt32BE(this._e, 16)
	    H.writeInt32BE(this._f, 20)
	    H.writeInt32BE(this._g, 24)
	    H.writeInt32BE(this._h, 28)
	
	    return H
	  }
	
	  return Sha256
	
	}


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(77).inherits
	
	module.exports = function (Buffer, Hash) {
	  var K = [
	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	  ]
	
	  var W = new Array(160)
	
	  function Sha512() {
	    this.init()
	    this._w = W
	
	    Hash.call(this, 128, 112)
	  }
	
	  inherits(Sha512, Hash)
	
	  Sha512.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._al = 0xf3bcc908|0
	    this._bl = 0x84caa73b|0
	    this._cl = 0xfe94f82b|0
	    this._dl = 0x5f1d36f1|0
	    this._el = 0xade682d1|0
	    this._fl = 0x2b3e6c1f|0
	    this._gl = 0xfb41bd6b|0
	    this._hl = 0x137e2179|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, Xl, n) {
	    return (X >>> n) | (Xl << (32 - n))
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  Sha512.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var al, bl, cl, dl, el, fl, gl, hl
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    al = this._al | 0
	    bl = this._bl | 0
	    cl = this._cl | 0
	    dl = this._dl | 0
	    el = this._el | 0
	    fl = this._fl | 0
	    gl = this._gl | 0
	    hl = this._hl | 0
	
	    for (var i = 0; i < 80; i++) {
	      var j = i * 2
	
	      var Wi, Wil
	
	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4)
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)
	
	      } else {
	        var x  = W[j - 15*2]
	        var xl = W[j - 15*2 + 1]
	        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)
	
	        x  = W[j - 2*2]
	        xl = W[j - 2*2 + 1]
	        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)
	
	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[j - 7*2]
	        var Wi7l = W[j - 7*2 + 1]
	
	        var Wi16  = W[j - 16*2]
	        var Wi16l = W[j - 16*2 + 1]
	
	        Wil = gamma0l + Wi7l
	        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
	        Wil = Wil + gamma1l
	        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
	        Wil = Wil + Wi16l
	        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)
	
	        W[j] = Wi
	        W[j + 1] = Wil
	      }
	
	      var maj = Maj(a, b, c)
	      var majl = Maj(al, bl, cl)
	
	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)
	
	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j]
	      var Kil = K[j + 1]
	
	      var ch = Ch(e, f, g)
	      var chl = Ch(el, fl, gl)
	
	      var t1l = hl + sigma1l
	      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
	      t1l = t1l + chl
	      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
	      t1l = t1l + Kil
	      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
	      t1l = t1l + Wil
	      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)
	
	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl
	      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)
	
	      h  = g
	      hl = gl
	      g  = f
	      gl = fl
	      f  = e
	      fl = el
	      el = (dl + t1l) | 0
	      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	      d  = c
	      dl = cl
	      c  = b
	      cl = bl
	      b  = a
	      bl = al
	      al = (t1l + t2l) | 0
	      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
	    }
	
	    this._al = (this._al + al) | 0
	    this._bl = (this._bl + bl) | 0
	    this._cl = (this._cl + cl) | 0
	    this._dl = (this._dl + dl) | 0
	    this._el = (this._el + el) | 0
	    this._fl = (this._fl + fl) | 0
	    this._gl = (this._gl + gl) | 0
	    this._hl = (this._hl + hl) | 0
	
	    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
	    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
	    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
	    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
	    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
	    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
	    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
	  }
	
	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64)
	
	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset)
	      H.writeInt32BE(l, offset + 4)
	    }
	
	    writeInt64BE(this._a, this._al, 0)
	    writeInt64BE(this._b, this._bl, 8)
	    writeInt64BE(this._c, this._cl, 16)
	    writeInt64BE(this._d, this._dl, 24)
	    writeInt64BE(this._e, this._el, 32)
	    writeInt64BE(this._f, this._fl, 40)
	    writeInt64BE(this._g, this._gl, 48)
	    writeInt64BE(this._h, this._hl, 56)
	
	    return H
	  }
	
	  return Sha512
	
	}


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */
	
	var helpers = __webpack_require__(82);
	
	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;
	
	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;
	
	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;
	
	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);
	
	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);
	
	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);
	
	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);
	
	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);
	
	}
	
	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}
	
	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}
	
	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}
	
	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;
	
	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }
	
	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}
	
	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}
	
	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}
	
	module.exports = { hash: hash };
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = ripemd160
	
	
	
	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cdric Mesnil. All rights reserved.
	
	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
	
	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	// Constants table
	var zl = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
	var zr = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
	var sl = [
	     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
	var sr = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];
	
	var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];
	
	var bytesToWords = function (bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32);
	  }
	  return words;
	};
	
	var wordsToBytes = function (words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	  }
	  return bytes;
	};
	
	var processBlock = function (H, M, offset) {
	
	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];
	
	    // Swap
	    M[offset_i] = (
	        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	    );
	  }
	
	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;
	
	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = (al +  M[offset+zl[i]])|0;
	    if (i<16){
	        t +=  f1(bl,cl,dl) + hl[0];
	    } else if (i<32) {
	        t +=  f2(bl,cl,dl) + hl[1];
	    } else if (i<48) {
	        t +=  f3(bl,cl,dl) + hl[2];
	    } else if (i<64) {
	        t +=  f4(bl,cl,dl) + hl[3];
	    } else {// if (i<80) {
	        t +=  f5(bl,cl,dl) + hl[4];
	    }
	    t = t|0;
	    t =  rotl(t,sl[i]);
	    t = (t+el)|0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;
	
	    t = (ar + M[offset+zr[i]])|0;
	    if (i<16){
	        t +=  f5(br,cr,dr) + hr[0];
	    } else if (i<32) {
	        t +=  f4(br,cr,dr) + hr[1];
	    } else if (i<48) {
	        t +=  f3(br,cr,dr) + hr[2];
	    } else if (i<64) {
	        t +=  f2(br,cr,dr) + hr[3];
	    } else {// if (i<80) {
	        t +=  f1(br,cr,dr) + hr[4];
	    }
	    t = t|0;
	    t =  rotl(t,sr[i]) ;
	    t = (t+er)|0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t    = (H[1] + cl + dr)|0;
	  H[1] = (H[2] + dl + er)|0;
	  H[2] = (H[3] + el + ar)|0;
	  H[3] = (H[4] + al + br)|0;
	  H[4] = (H[0] + bl + cr)|0;
	  H[0] =  t;
	};
	
	function f1(x, y, z) {
	  return ((x) ^ (y) ^ (z));
	}
	
	function f2(x, y, z) {
	  return (((x)&(y)) | ((~x)&(z)));
	}
	
	function f3(x, y, z) {
	  return (((x) | (~(y))) ^ (z));
	}
	
	function f4(x, y, z) {
	  return (((x) & (z)) | ((y)&(~(z))));
	}
	
	function f5(x, y, z) {
	  return ((x) ^ ((y) |(~(z))));
	}
	
	function rotl(x,n) {
	  return (x<<n) | (x>>>(32-n));
	}
	
	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
	
	  if (typeof message == 'string')
	    message = new Buffer(message, 'utf8');
	
	  var m = bytesToWords(message);
	
	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;
	
	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	  );
	
	  for (var i=0 ; i<m.length; i += 16) {
	    processBlock(H, m, i);
	  }
	
	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	      // Shortcut
	    var H_i = H[i];
	
	    // Swap
	    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	  }
	
	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}
	
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(73)
	
	var zeroBuffer = new Buffer(128)
	zeroBuffer.fill(0)
	
	module.exports = Hmac
	
	function Hmac (alg, key) {
	  if(!(this instanceof Hmac)) return new Hmac(alg, key)
	  this._opad = opad
	  this._alg = alg
	
	  var blocksize = (alg === 'sha512') ? 128 : 64
	
	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key
	
	  if(key.length > blocksize) {
	    key = createHash(alg).update(key).digest()
	  } else if(key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize)
	  }
	
	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)
	
	  for(var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }
	
	  this._hash = createHash(alg).update(ipad)
	}
	
	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)
	  return this
	}
	
	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()
	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var pbkdf2Export = __webpack_require__(86)
	
	module.exports = function (crypto, exports) {
	  exports = exports || {}
	
	  var exported = pbkdf2Export(crypto)
	
	  exports.pbkdf2 = exported.pbkdf2
	  exports.pbkdf2Sync = exported.pbkdf2Sync
	
	  return exports
	}


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function(crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest
	      digest = undefined
	    }
	
	    if ('function' !== typeof callback)
	      throw new Error('No callback provided to pbkdf2')
	
	    setTimeout(function() {
	      var result
	
	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	      } catch (e) {
	        return callback(e)
	      }
	
	      callback(undefined, result)
	    })
	  }
	
	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations)
	      throw new TypeError('Iterations not a number')
	
	    if (iterations < 0)
	      throw new TypeError('Bad iterations')
	
	    if ('number' !== typeof keylen)
	      throw new TypeError('Key length not a number')
	
	    if (keylen < 0)
	      throw new TypeError('Bad key length')
	
	    digest = digest || 'sha1'
	
	    if (!Buffer.isBuffer(password)) password = new Buffer(password)
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)
	
	    var hLen, l = 1, r, T
	    var DK = new Buffer(keylen)
	    var block1 = new Buffer(salt.length + 4)
	    salt.copy(block1, 0, 0, salt.length)
	
	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length)
	
	      var U = crypto.createHmac(digest, password).update(block1).digest()
	
	      if (!hLen) {
	        hLen = U.length
	        T = new Buffer(hLen)
	        l = Math.ceil(keylen / hLen)
	        r = keylen - (l - 1) * hLen
	
	        if (keylen > (Math.pow(2, 32) - 1) * hLen)
	          throw new TypeError('keylen exceeds maximum length')
	      }
	
	      U.copy(T, 0, 0, hLen)
	
	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest()
	
	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k]
	        }
	      }
	
	      var destPos = (i - 1) * hLen
	      var len = (i == l ? r : hLen)
	      T.copy(DK, destPos, 0, len)
	    }
	
	    return DK
	  }
	
	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 87 */
/***/ function(module, exports) {

	
	/**
	 * Expose `fresh()`.
	 */
	
	module.exports = fresh;
	
	/**
	 * Check freshness of `req` and `res` headers.
	 *
	 * When the cache is "fresh" __true__ is returned,
	 * otherwise __false__ is returned to indicate that
	 * the cache is now stale.
	 *
	 * @param {Object} req
	 * @param {Object} res
	 * @return {Boolean}
	 * @api public
	 */
	
	function fresh(req, res) {
	  // defaults
	  var etagMatches = true;
	  var notModified = true;
	
	  // fields
	  var modifiedSince = req['if-modified-since'];
	  var noneMatch = req['if-none-match'];
	  var lastModified = res['last-modified'];
	  var etag = res['etag'];
	  var cc = req['cache-control'];
	
	  // unconditional request
	  if (!modifiedSince && !noneMatch) return false;
	
	  // check for no-cache cache request directive
	  if (cc && cc.indexOf('no-cache') !== -1) return false;  
	
	  // parse if-none-match
	  if (noneMatch) noneMatch = noneMatch.split(/ *, */);
	
	  // if-none-match
	  if (noneMatch) {
	    etagMatches = noneMatch.some(function (match) {
	      return match === '*' || match === etag || match === 'W/' + etag;
	    });
	  }
	
	  // if-modified-since
	  if (modifiedSince) {
	    modifiedSince = new Date(modifiedSince);
	    lastModified = new Date(lastModified);
	    notModified = lastModified <= modifiedSince;
	  }
	
	  return !! (etagMatches && notModified);
	}


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var path = __webpack_require__(45);
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	
	function Mime() {
	  // Map of extension -> mime type
	  this.types = Object.create(null);
	
	  // Map of mime type -> extension
	  this.extensions = Object.create(null);
	}
	
	/**
	 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
	 * to an array of extensions associated with the type.  The first extension is
	 * used as the default extension for the type.
	 *
	 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
	 *
	 * @param map (Object) type definitions
	 */
	Mime.prototype.define = function (map) {
	  for (var type in map) {
	    var exts = map[type];
	    for (var i = 0; i < exts.length; i++) {
	      if (process.env.DEBUG_MIME && this.types[exts]) {
	        console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
	          this.types[exts] + ' to ' + type);
	      }
	
	      this.types[exts[i]] = type;
	    }
	
	    // Default extension is the first one we encounter
	    if (!this.extensions[type]) {
	      this.extensions[type] = exts[0];
	    }
	  }
	};
	
	/**
	 * Load an Apache2-style ".types" file
	 *
	 * This may be called multiple times (it's expected).  Where files declare
	 * overlapping types/extensions, the last file wins.
	 *
	 * @param file (String) path of file to load.
	 */
	Mime.prototype.load = function(file) {
	  this._loading = file;
	  // Read file and split into lines
	  var map = {},
	      content = fs.readFileSync(file, 'ascii'),
	      lines = content.split(/[\r\n]+/);
	
	  lines.forEach(function(line) {
	    // Clean up whitespace/comments, and split into fields
	    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
	    map[fields.shift()] = fields;
	  });
	
	  this.define(map);
	
	  this._loading = null;
	};
	
	/**
	 * Lookup a mime type based on extension
	 */
	Mime.prototype.lookup = function(path, fallback) {
	  var ext = path.replace(/.*[\.\/\\]/, '').toLowerCase();
	
	  return this.types[ext] || fallback || this.default_type;
	};
	
	/**
	 * Return file extension associated with a mime type
	 */
	Mime.prototype.extension = function(mimeType) {
	  var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
	  return this.extensions[type];
	};
	
	// Default instance
	var mime = new Mime();
	
	// Define built-in types
	mime.define(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./types.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
	
	// Default type
	mime.default_type = mime.lookup('bin');
	
	//
	// Additional API specific to the default instance
	//
	
	mime.Mime = Mime;
	
	/**
	 * Lookup a charset based on mime type.
	 */
	mime.charsets = {
	  lookup: function(mimeType, fallback) {
	    // Assume text types are utf8
	    return (/^text\//).test(mimeType) ? 'UTF-8' : fallback;
	  }
	};
	
	module.exports = mime;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 89 */,
/* 90 */
/***/ function(module, exports) {

	/*!
	 * range-parser
	 * Copyright(c) 2012-2014 TJ Holowaychuk
	 * Copyright(c) 2015-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = rangeParser
	
	/**
	 * Parse "Range" header `str` relative to the given file `size`.
	 *
	 * @param {Number} size
	 * @param {String} str
	 * @param {Object} [options]
	 * @return {Array}
	 * @public
	 */
	
	function rangeParser (size, str, options) {
	  var index = str.indexOf('=')
	
	  if (index === -1) {
	    return -2
	  }
	
	  // split the range string
	  var arr = str.slice(index + 1).split(',')
	  var ranges = []
	
	  // add ranges type
	  ranges.type = str.slice(0, index)
	
	  // parse all ranges
	  for (var i = 0; i < arr.length; i++) {
	    var range = arr[i].split('-')
	    var start = parseInt(range[0], 10)
	    var end = parseInt(range[1], 10)
	
	    // -nnn
	    if (isNaN(start)) {
	      start = size - end
	      end = size - 1
	    // nnn-
	    } else if (isNaN(end)) {
	      end = size - 1
	    }
	
	    // limit last-byte-pos to current length
	    if (end > size - 1) {
	      end = size - 1
	    }
	
	    // invalid or unsatisifiable
	    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
	      continue
	    }
	
	    // add range
	    ranges.push({
	      start: start,
	      end: end
	    })
	  }
	
	  if (ranges.length < 1) {
	    // unsatisifiable
	    return -1
	  }
	
	  return options && options.combine
	    ? combineRanges(ranges)
	    : ranges
	}
	
	/**
	 * Combine overlapping & adjacent ranges.
	 * @private
	 */
	
	function combineRanges (ranges) {
	  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)
	
	  for (var j = 0, i = 1; i < ordered.length; i++) {
	    var range = ordered[i]
	    var current = ordered[j]
	
	    if (range.start > current.end + 1) {
	      // next range
	      ordered[++j] = range
	    } else if (range.end > current.end) {
	      // extend range
	      current.end = range.end
	      current.index = Math.min(current.index, range.index)
	    }
	  }
	
	  // trim ordered array
	  ordered.length = j + 1
	
	  // generate combined range
	  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex)
	
	  // copy ranges type
	  combined.type = ranges.type
	
	  return combined
	}
	
	/**
	 * Map function to add index value to ranges.
	 * @private
	 */
	
	function mapWithIndex (range, index) {
	  return {
	    start: range.start,
	    end: range.end,
	    index: index
	  }
	}
	
	/**
	 * Map function to remove index value from ranges.
	 * @private
	 */
	
	function mapWithoutIndex (range) {
	  return {
	    start: range.start,
	    end: range.end
	  }
	}
	
	/**
	 * Sort function to sort ranges by index.
	 * @private
	 */
	
	function sortByRangeIndex (a, b) {
	  return a.index - b.index
	}
	
	/**
	 * Sort function to sort ranges by start position.
	 * @private
	 */
	
	function sortByRangeStart (a, b) {
	  return a.start - b.start
	}


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * proxy-addr
	 * Copyright(c) 2014-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module exports.
	 */
	
	module.exports = proxyaddr;
	module.exports.all = alladdrs;
	module.exports.compile = compile;
	
	/**
	 * Module dependencies.
	 */
	
	var forwarded = __webpack_require__(92);
	var ipaddr = __webpack_require__(93);
	
	/**
	 * Variables.
	 */
	
	var digitre = /^[0-9]+$/;
	var isip = ipaddr.isValid;
	var parseip = ipaddr.parse;
	
	/**
	 * Pre-defined IP ranges.
	 */
	
	var ipranges = {
	  linklocal: ['169.254.0.0/16', 'fe80::/10'],
	  loopback: ['127.0.0.1/8', '::1/128'],
	  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
	};
	
	/**
	 * Get all addresses in the request, optionally stopping
	 * at the first untrusted.
	 *
	 * @param {Object} request
	 * @param {Function|Array|String} [trust]
	 * @api public
	 */
	
	function alladdrs(req, trust) {
	  // get addresses
	  var addrs = forwarded(req);
	
	  if (!trust) {
	    // Return all addresses
	    return addrs;
	  }
	
	  if (typeof trust !== 'function') {
	    trust = compile(trust);
	  }
	
	  for (var i = 0; i < addrs.length - 1; i++) {
	    if (trust(addrs[i], i)) continue;
	
	    addrs.length = i + 1;
	  }
	
	  return addrs;
	}
	
	/**
	 * Compile argument into trust function.
	 *
	 * @param {Array|String} val
	 * @api private
	 */
	
	function compile(val) {
	  if (!val) {
	    throw new TypeError('argument is required');
	  }
	
	  var trust = typeof val === 'string'
	    ? [val]
	    : val;
	
	  if (!Array.isArray(trust)) {
	    throw new TypeError('unsupported trust argument');
	  }
	
	  for (var i = 0; i < trust.length; i++) {
	    val = trust[i];
	
	    if (!ipranges.hasOwnProperty(val)) {
	      continue;
	    }
	
	    // Splice in pre-defined range
	    val = ipranges[val];
	    trust.splice.apply(trust, [i, 1].concat(val));
	    i += val.length - 1;
	  }
	
	  return compileTrust(compileRangeSubnets(trust));
	}
	
	/**
	 * Compile `arr` elements into range subnets.
	 *
	 * @param {Array} arr
	 * @api private
	 */
	
	function compileRangeSubnets(arr) {
	  var rangeSubnets = new Array(arr.length);
	
	  for (var i = 0; i < arr.length; i++) {
	    rangeSubnets[i] = parseipNotation(arr[i]);
	  }
	
	  return rangeSubnets;
	}
	
	/**
	 * Compile range subnet array into trust function.
	 *
	 * @param {Array} rangeSubnets
	 * @api private
	 */
	
	function compileTrust(rangeSubnets) {
	  // Return optimized function based on length
	  var len = rangeSubnets.length;
	  return len === 0
	    ? trustNone
	    : len === 1
	    ? trustSingle(rangeSubnets[0])
	    : trustMulti(rangeSubnets);
	}
	
	/**
	 * Parse IP notation string into range subnet.
	 *
	 * @param {String} note
	 * @api private
	 */
	
	function parseipNotation(note) {
	  var pos = note.lastIndexOf('/');
	  var str = pos !== -1
	    ? note.substring(0, pos)
	    : note;
	
	  if (!isip(str)) {
	    throw new TypeError('invalid IP address: ' + str);
	  }
	
	  var ip = parseip(str);
	
	  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
	    // Store as IPv4
	    ip = ip.toIPv4Address();
	  }
	
	  var max = ip.kind() === 'ipv6'
	    ? 128
	    : 32;
	
	  var range = pos !== -1
	    ? note.substring(pos + 1, note.length)
	    : null;
	
	  if (range === null) {
	    range = max;
	  } else if (digitre.test(range)) {
	    range = parseInt(range, 10);
	  } else if (ip.kind() === 'ipv4' && isip(range)) {
	    range = parseNetmask(range);
	  } else {
	    range = null;
	  }
	
	  if (range <= 0 || range > max) {
	    throw new TypeError('invalid range on address: ' + note);
	  }
	
	  return [ip, range];
	}
	
	/**
	 * Parse netmask string into CIDR range.
	 *
	 * @param {String} netmask
	 * @api private
	 */
	
	function parseNetmask(netmask) {
	  var ip = parseip(netmask);
	  var kind = ip.kind();
	
	  return kind === 'ipv4'
	    ? ip.prefixLengthFromSubnetMask()
	    : null;
	}
	
	/**
	 * Determine address of proxied request.
	 *
	 * @param {Object} request
	 * @param {Function|Array|String} trust
	 * @api public
	 */
	
	function proxyaddr(req, trust) {
	  if (!req) {
	    throw new TypeError('req argument is required');
	  }
	
	  if (!trust) {
	    throw new TypeError('trust argument is required');
	  }
	
	  var addrs = alladdrs(req, trust);
	  var addr = addrs[addrs.length - 1];
	
	  return addr;
	}
	
	/**
	 * Static trust function to trust nothing.
	 *
	 * @api private
	 */
	
	function trustNone() {
	  return false;
	}
	
	/**
	 * Compile trust function for multiple subnets.
	 *
	 * @param {Array} subnets
	 * @api private
	 */
	
	function trustMulti(subnets) {
	  return function trust(addr) {
	    if (!isip(addr)) return false;
	
	    var ip = parseip(addr);
	    var ipconv;
	    var kind = ip.kind();
	
	    for (var i = 0; i < subnets.length; i++) {
	      var subnet = subnets[i];
	      var subnetip = subnet[0];
	      var subnetkind = subnetip.kind();
	      var subnetrange = subnet[1];
	      var trusted = ip;
	
	      if (kind !== subnetkind) {
	        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
	          // Incompatible IP addresses
	          continue;
	        }
	
	        if (!ipconv) {
	          // Convert IP to match subnet IP kind
	          ipconv = subnetkind === 'ipv4'
	            ? ip.toIPv4Address()
	            : ip.toIPv4MappedAddress();
	        }
	
	        trusted = ipconv;
	      }
	
	      if (trusted.match(subnetip, subnetrange)) {
	        return true;
	      }
	    }
	
	    return false;
	  };
	}
	
	/**
	 * Compile trust function for single subnet.
	 *
	 * @param {Object} subnet
	 * @api private
	 */
	
	function trustSingle(subnet) {
	  var subnetip = subnet[0];
	  var subnetkind = subnetip.kind();
	  var subnetisipv4 = subnetkind === 'ipv4';
	  var subnetrange = subnet[1];
	
	  return function trust(addr) {
	    if (!isip(addr)) return false;
	
	    var ip = parseip(addr);
	    var kind = ip.kind();
	
	    if (kind !== subnetkind) {
	      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
	        // Incompatible IP addresses
	        return false;
	      }
	
	      // Convert IP to match subnet IP kind
	      ip = subnetisipv4
	        ? ip.toIPv4Address()
	        : ip.toIPv4MappedAddress();
	    }
	
	    return ip.match(subnetip, subnetrange);
	  };
	}


/***/ },
/* 92 */
/***/ function(module, exports) {

	/*!
	 * forwarded
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	/**
	 * Module exports.
	 */
	
	module.exports = forwarded
	
	/**
	 * Get all addresses in the request, using the `X-Forwarded-For` header.
	 *
	 * @param {Object} req
	 * @api public
	 */
	
	function forwarded(req) {
	  if (!req) {
	    throw new TypeError('argument req is required')
	  }
	
	  // simple header parsing
	  var proxyAddrs = (req.headers['x-forwarded-for'] || '')
	    .split(/ *, */)
	    .filter(Boolean)
	    .reverse()
	  var socketAddr = req.connection.remoteAddress
	  var addrs = [socketAddr].concat(proxyAddrs)
	
	  // return all addresses
	  return addrs
	}


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {(function() {
	  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root;
	
	  ipaddr = {};
	
	  root = this;
	
	  if ((typeof module !== "undefined" && module !== null) && module.exports) {
	    module.exports = ipaddr;
	  } else {
	    root['ipaddr'] = ipaddr;
	  }
	
	  matchCIDR = function(first, second, partSize, cidrBits) {
	    var part, shift;
	    if (first.length !== second.length) {
	      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
	    }
	    part = 0;
	    while (cidrBits > 0) {
	      shift = partSize - cidrBits;
	      if (shift < 0) {
	        shift = 0;
	      }
	      if (first[part] >> shift !== second[part] >> shift) {
	        return false;
	      }
	      cidrBits -= partSize;
	      part += 1;
	    }
	    return true;
	  };
	
	  ipaddr.subnetMatch = function(address, rangeList, defaultName) {
	    var rangeName, rangeSubnets, subnet, _i, _len;
	    if (defaultName == null) {
	      defaultName = 'unicast';
	    }
	    for (rangeName in rangeList) {
	      rangeSubnets = rangeList[rangeName];
	      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
	        rangeSubnets = [rangeSubnets];
	      }
	      for (_i = 0, _len = rangeSubnets.length; _i < _len; _i++) {
	        subnet = rangeSubnets[_i];
	        if (address.match.apply(address, subnet)) {
	          return rangeName;
	        }
	      }
	    }
	    return defaultName;
	  };
	
	  ipaddr.IPv4 = (function() {
	    function IPv4(octets) {
	      var octet, _i, _len;
	      if (octets.length !== 4) {
	        throw new Error("ipaddr: ipv4 octet count should be 4");
	      }
	      for (_i = 0, _len = octets.length; _i < _len; _i++) {
	        octet = octets[_i];
	        if (!((0 <= octet && octet <= 255))) {
	          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
	        }
	      }
	      this.octets = octets;
	    }
	
	    IPv4.prototype.kind = function() {
	      return 'ipv4';
	    };
	
	    IPv4.prototype.toString = function() {
	      return this.octets.join(".");
	    };
	
	    IPv4.prototype.toByteArray = function() {
	      return this.octets.slice(0);
	    };
	
	    IPv4.prototype.match = function(other, cidrRange) {
	      var _ref;
	      if (cidrRange === void 0) {
	        _ref = other, other = _ref[0], cidrRange = _ref[1];
	      }
	      if (other.kind() !== 'ipv4') {
	        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
	      }
	      return matchCIDR(this.octets, other.octets, 8, cidrRange);
	    };
	
	    IPv4.prototype.SpecialRanges = {
	      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
	      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
	      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
	      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
	      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
	      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
	      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
	    };
	
	    IPv4.prototype.range = function() {
	      return ipaddr.subnetMatch(this, this.SpecialRanges);
	    };
	
	    IPv4.prototype.toIPv4MappedAddress = function() {
	      return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
	    };
	
	    IPv4.prototype.prefixLengthFromSubnetMask = function() {
	      var cidr, i, octet, stop, zeros, zerotable, _i;
	      zerotable = {
	        0: 8,
	        128: 7,
	        192: 6,
	        224: 5,
	        240: 4,
	        248: 3,
	        252: 2,
	        254: 1,
	        255: 0
	      };
	      cidr = 0;
	      stop = false;
	      for (i = _i = 3; _i >= 0; i = _i += -1) {
	        octet = this.octets[i];
	        if (octet in zerotable) {
	          zeros = zerotable[octet];
	          if (stop && zeros !== 0) {
	            return null;
	          }
	          if (zeros !== 8) {
	            stop = true;
	          }
	          cidr += zeros;
	        } else {
	          return null;
	        }
	      }
	      return 32 - cidr;
	    };
	
	    return IPv4;
	
	  })();
	
	  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
	
	  ipv4Regexes = {
	    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
	    longValue: new RegExp("^" + ipv4Part + "$", 'i')
	  };
	
	  ipaddr.IPv4.parser = function(string) {
	    var match, parseIntAuto, part, shift, value;
	    parseIntAuto = function(string) {
	      if (string[0] === "0" && string[1] !== "x") {
	        return parseInt(string, 8);
	      } else {
	        return parseInt(string);
	      }
	    };
	    if (match = string.match(ipv4Regexes.fourOctet)) {
	      return (function() {
	        var _i, _len, _ref, _results;
	        _ref = match.slice(1, 6);
	        _results = [];
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          part = _ref[_i];
	          _results.push(parseIntAuto(part));
	        }
	        return _results;
	      })();
	    } else if (match = string.match(ipv4Regexes.longValue)) {
	      value = parseIntAuto(match[1]);
	      if (value > 0xffffffff || value < 0) {
	        throw new Error("ipaddr: address outside defined range");
	      }
	      return ((function() {
	        var _i, _results;
	        _results = [];
	        for (shift = _i = 0; _i <= 24; shift = _i += 8) {
	          _results.push((value >> shift) & 0xff);
	        }
	        return _results;
	      })()).reverse();
	    } else {
	      return null;
	    }
	  };
	
	  ipaddr.IPv6 = (function() {
	    function IPv6(parts) {
	      var i, part, _i, _j, _len, _ref;
	      if (parts.length === 16) {
	        this.parts = [];
	        for (i = _i = 0; _i <= 14; i = _i += 2) {
	          this.parts.push((parts[i] << 8) | parts[i + 1]);
	        }
	      } else if (parts.length === 8) {
	        this.parts = parts;
	      } else {
	        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
	      }
	      _ref = this.parts;
	      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
	        part = _ref[_j];
	        if (!((0 <= part && part <= 0xffff))) {
	          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
	        }
	      }
	    }
	
	    IPv6.prototype.kind = function() {
	      return 'ipv6';
	    };
	
	    IPv6.prototype.toString = function() {
	      var compactStringParts, part, pushPart, state, stringParts, _i, _len;
	      stringParts = (function() {
	        var _i, _len, _ref, _results;
	        _ref = this.parts;
	        _results = [];
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          part = _ref[_i];
	          _results.push(part.toString(16));
	        }
	        return _results;
	      }).call(this);
	      compactStringParts = [];
	      pushPart = function(part) {
	        return compactStringParts.push(part);
	      };
	      state = 0;
	      for (_i = 0, _len = stringParts.length; _i < _len; _i++) {
	        part = stringParts[_i];
	        switch (state) {
	          case 0:
	            if (part === '0') {
	              pushPart('');
	            } else {
	              pushPart(part);
	            }
	            state = 1;
	            break;
	          case 1:
	            if (part === '0') {
	              state = 2;
	            } else {
	              pushPart(part);
	            }
	            break;
	          case 2:
	            if (part !== '0') {
	              pushPart('');
	              pushPart(part);
	              state = 3;
	            }
	            break;
	          case 3:
	            pushPart(part);
	        }
	      }
	      if (state === 2) {
	        pushPart('');
	        pushPart('');
	      }
	      return compactStringParts.join(":");
	    };
	
	    IPv6.prototype.toByteArray = function() {
	      var bytes, part, _i, _len, _ref;
	      bytes = [];
	      _ref = this.parts;
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        part = _ref[_i];
	        bytes.push(part >> 8);
	        bytes.push(part & 0xff);
	      }
	      return bytes;
	    };
	
	    IPv6.prototype.toNormalizedString = function() {
	      var part;
	      return ((function() {
	        var _i, _len, _ref, _results;
	        _ref = this.parts;
	        _results = [];
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          part = _ref[_i];
	          _results.push(part.toString(16));
	        }
	        return _results;
	      }).call(this)).join(":");
	    };
	
	    IPv6.prototype.match = function(other, cidrRange) {
	      var _ref;
	      if (cidrRange === void 0) {
	        _ref = other, other = _ref[0], cidrRange = _ref[1];
	      }
	      if (other.kind() !== 'ipv6') {
	        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
	      }
	      return matchCIDR(this.parts, other.parts, 16, cidrRange);
	    };
	
	    IPv6.prototype.SpecialRanges = {
	      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
	      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
	      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
	      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
	      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
	      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
	      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
	      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
	      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
	      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
	      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
	    };
	
	    IPv6.prototype.range = function() {
	      return ipaddr.subnetMatch(this, this.SpecialRanges);
	    };
	
	    IPv6.prototype.isIPv4MappedAddress = function() {
	      return this.range() === 'ipv4Mapped';
	    };
	
	    IPv6.prototype.toIPv4Address = function() {
	      var high, low, _ref;
	      if (!this.isIPv4MappedAddress()) {
	        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
	      }
	      _ref = this.parts.slice(-2), high = _ref[0], low = _ref[1];
	      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
	    };
	
	    return IPv6;
	
	  })();
	
	  ipv6Part = "(?:[0-9a-f]+::?)+";
	
	  ipv6Regexes = {
	    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?$", 'i'),
	    transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + ("" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$"), 'i')
	  };
	
	  expandIPv6 = function(string, parts) {
	    var colonCount, lastColon, part, replacement, replacementCount;
	    if (string.indexOf('::') !== string.lastIndexOf('::')) {
	      return null;
	    }
	    colonCount = 0;
	    lastColon = -1;
	    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
	      colonCount++;
	    }
	    if (string.substr(0, 2) === '::') {
	      colonCount--;
	    }
	    if (string.substr(-2, 2) === '::') {
	      colonCount--;
	    }
	    if (colonCount > parts) {
	      return null;
	    }
	    replacementCount = parts - colonCount;
	    replacement = ':';
	    while (replacementCount--) {
	      replacement += '0:';
	    }
	    string = string.replace('::', replacement);
	    if (string[0] === ':') {
	      string = string.slice(1);
	    }
	    if (string[string.length - 1] === ':') {
	      string = string.slice(0, -1);
	    }
	    return (function() {
	      var _i, _len, _ref, _results;
	      _ref = string.split(":");
	      _results = [];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        part = _ref[_i];
	        _results.push(parseInt(part, 16));
	      }
	      return _results;
	    })();
	  };
	
	  ipaddr.IPv6.parser = function(string) {
	    var match, octet, octets, parts, _i, _len;
	    if (string.match(ipv6Regexes['native'])) {
	      return expandIPv6(string, 8);
	    } else if (match = string.match(ipv6Regexes['transitional'])) {
	      parts = expandIPv6(match[1].slice(0, -1), 6);
	      if (parts) {
	        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
	        for (_i = 0, _len = octets.length; _i < _len; _i++) {
	          octet = octets[_i];
	          if (!((0 <= octet && octet <= 255))) {
	            return null;
	          }
	        }
	        parts.push(octets[0] << 8 | octets[1]);
	        parts.push(octets[2] << 8 | octets[3]);
	        return parts;
	      }
	    }
	    return null;
	  };
	
	  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
	    return this.parser(string) !== null;
	  };
	
	  ipaddr.IPv4.isValid = function(string) {
	    var e;
	    try {
	      new this(this.parser(string));
	      return true;
	    } catch (_error) {
	      e = _error;
	      return false;
	    }
	  };
	
	  ipaddr.IPv6.isValid = function(string) {
	    var e;
	    if (typeof string === "string" && string.indexOf(":") === -1) {
	      return false;
	    }
	    try {
	      new this(this.parser(string));
	      return true;
	    } catch (_error) {
	      e = _error;
	      return false;
	    }
	  };
	
	  ipaddr.IPv4.parse = ipaddr.IPv6.parse = function(string) {
	    var parts;
	    parts = this.parser(string);
	    if (parts === null) {
	      throw new Error("ipaddr: string is not formatted like ip address");
	    }
	    return new this(parts);
	  };
	
	  ipaddr.IPv4.parseCIDR = function(string) {
	    var maskLength, match;
	    if (match = string.match(/^(.+)\/(\d+)$/)) {
	      maskLength = parseInt(match[2]);
	      if (maskLength >= 0 && maskLength <= 32) {
	        return [this.parse(match[1]), maskLength];
	      }
	    }
	    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
	  };
	
	  ipaddr.IPv6.parseCIDR = function(string) {
	    var maskLength, match;
	    if (match = string.match(/^(.+)\/(\d+)$/)) {
	      maskLength = parseInt(match[2]);
	      if (maskLength >= 0 && maskLength <= 128) {
	        return [this.parse(match[1]), maskLength];
	      }
	    }
	    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
	  };
	
	  ipaddr.isValid = function(string) {
	    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
	  };
	
	  ipaddr.parse = function(string) {
	    if (ipaddr.IPv6.isValid(string)) {
	      return ipaddr.IPv6.parse(string);
	    } else if (ipaddr.IPv4.isValid(string)) {
	      return ipaddr.IPv4.parse(string);
	    } else {
	      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
	    }
	  };
	
	  ipaddr.parseCIDR = function(string) {
	    var e;
	    try {
	      return ipaddr.IPv6.parseCIDR(string);
	    } catch (_error) {
	      e = _error;
	      try {
	        return ipaddr.IPv4.parseCIDR(string);
	      } catch (_error) {
	        e = _error;
	        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
	      }
	    }
	  };
	
	  ipaddr.fromByteArray = function(bytes) {
	    var length;
	    length = bytes.length;
	    if (length === 4) {
	      return new ipaddr.IPv4(bytes);
	    } else if (length === 16) {
	      return new ipaddr.IPv6(bytes);
	    } else {
	      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
	    }
	  };
	
	  ipaddr.process = function(string) {
	    var addr;
	    addr = this.parse(string);
	    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
	      return addr.toIPv4Address();
	    } else {
	      return addr;
	    }
	  };
	
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34)(module)))

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./application": 5,
		"./application.js": 5,
		"./express": 2,
		"./express.js": 2,
		"./middleware/init": 38,
		"./middleware/init.js": 38,
		"./middleware/query": 39,
		"./middleware/query.js": 39,
		"./request": 95,
		"./request.js": 95,
		"./response": 111,
		"./response.js": 111,
		"./router/index": 22,
		"./router/index.js": 22,
		"./router/layer": 25,
		"./router/layer.js": 25,
		"./router/route": 23,
		"./router/route.js": 23,
		"./utils": 46,
		"./utils.js": 46,
		"./view": 44,
		"./view.js": 44
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 94;


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var accepts = __webpack_require__(96);
	var deprecate = __webpack_require__(30)('express');
	var isIP = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"net\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).isIP;
	var typeis = __webpack_require__(105);
	var http = __webpack_require__(107);
	var fresh = __webpack_require__(87);
	var parseRange = __webpack_require__(90);
	var parse = __webpack_require__(31);
	var proxyaddr = __webpack_require__(91);
	
	/**
	 * Request prototype.
	 */
	
	var req = exports = module.exports = {
	  __proto__: http.IncomingMessage.prototype
	};
	
	/**
	 * Return request header.
	 *
	 * The `Referrer` header field is special-cased,
	 * both `Referrer` and `Referer` are interchangeable.
	 *
	 * Examples:
	 *
	 *     req.get('Content-Type');
	 *     // => "text/plain"
	 *
	 *     req.get('content-type');
	 *     // => "text/plain"
	 *
	 *     req.get('Something');
	 *     // => undefined
	 *
	 * Aliased as `req.header()`.
	 *
	 * @param {String} name
	 * @return {String}
	 * @public
	 */
	
	req.get =
	req.header = function header(name) {
	  if (!name) {
	    throw new TypeError('name argument is required to req.get');
	  }
	
	  if (typeof name !== 'string') {
	    throw new TypeError('name must be a string to req.get');
	  }
	
	  var lc = name.toLowerCase();
	
	  switch (lc) {
	    case 'referer':
	    case 'referrer':
	      return this.headers.referrer
	        || this.headers.referer;
	    default:
	      return this.headers[lc];
	  }
	};
	
	/**
	 * To do: update docs.
	 *
	 * Check if the given `type(s)` is acceptable, returning
	 * the best match when true, otherwise `undefined`, in which
	 * case you should respond with 406 "Not Acceptable".
	 *
	 * The `type` value may be a single MIME type string
	 * such as "application/json", an extension name
	 * such as "json", a comma-delimited list such as "json, html, text/plain",
	 * an argument list such as `"json", "html", "text/plain"`,
	 * or an array `["json", "html", "text/plain"]`. When a list
	 * or array is given, the _best_ match, if any is returned.
	 *
	 * Examples:
	 *
	 *     // Accept: text/html
	 *     req.accepts('html');
	 *     // => "html"
	 *
	 *     // Accept: text/*, application/json
	 *     req.accepts('html');
	 *     // => "html"
	 *     req.accepts('text/html');
	 *     // => "text/html"
	 *     req.accepts('json, text');
	 *     // => "json"
	 *     req.accepts('application/json');
	 *     // => "application/json"
	 *
	 *     // Accept: text/*, application/json
	 *     req.accepts('image/png');
	 *     req.accepts('png');
	 *     // => undefined
	 *
	 *     // Accept: text/*;q=.5, application/json
	 *     req.accepts(['html', 'json']);
	 *     req.accepts('html', 'json');
	 *     req.accepts('html, json');
	 *     // => "json"
	 *
	 * @param {String|Array} type(s)
	 * @return {String|Array|Boolean}
	 * @public
	 */
	
	req.accepts = function(){
	  var accept = accepts(this);
	  return accept.types.apply(accept, arguments);
	};
	
	/**
	 * Check if the given `encoding`s are accepted.
	 *
	 * @param {String} ...encoding
	 * @return {String|Array}
	 * @public
	 */
	
	req.acceptsEncodings = function(){
	  var accept = accepts(this);
	  return accept.encodings.apply(accept, arguments);
	};
	
	req.acceptsEncoding = deprecate.function(req.acceptsEncodings,
	  'req.acceptsEncoding: Use acceptsEncodings instead');
	
	/**
	 * Check if the given `charset`s are acceptable,
	 * otherwise you should respond with 406 "Not Acceptable".
	 *
	 * @param {String} ...charset
	 * @return {String|Array}
	 * @public
	 */
	
	req.acceptsCharsets = function(){
	  var accept = accepts(this);
	  return accept.charsets.apply(accept, arguments);
	};
	
	req.acceptsCharset = deprecate.function(req.acceptsCharsets,
	  'req.acceptsCharset: Use acceptsCharsets instead');
	
	/**
	 * Check if the given `lang`s are acceptable,
	 * otherwise you should respond with 406 "Not Acceptable".
	 *
	 * @param {String} ...lang
	 * @return {String|Array}
	 * @public
	 */
	
	req.acceptsLanguages = function(){
	  var accept = accepts(this);
	  return accept.languages.apply(accept, arguments);
	};
	
	req.acceptsLanguage = deprecate.function(req.acceptsLanguages,
	  'req.acceptsLanguage: Use acceptsLanguages instead');
	
	/**
	 * Parse Range header field, capping to the given `size`.
	 *
	 * Unspecified ranges such as "0-" require knowledge of your resource length. In
	 * the case of a byte range this is of course the total number of bytes. If the
	 * Range header field is not given `undefined` is returned, `-1` when unsatisfiable,
	 * and `-2` when syntactically invalid.
	 *
	 * When ranges are returned, the array has a "type" property which is the type of
	 * range that is required (most commonly, "bytes"). Each array element is an object
	 * with a "start" and "end" property for the portion of the range.
	 *
	 * The "combine" option can be set to `true` and overlapping & adjacent ranges
	 * will be combined into a single range.
	 *
	 * NOTE: remember that ranges are inclusive, so for example "Range: users=0-3"
	 * should respond with 4 users when available, not 3.
	 *
	 * @param {number} size
	 * @param {object} [options]
	 * @param {boolean} [options.combine=false]
	 * @return {number|array}
	 * @public
	 */
	
	req.range = function range(size, options) {
	  var range = this.get('Range');
	  if (!range) return;
	  return parseRange(size, range, options);
	};
	
	/**
	 * Return the value of param `name` when present or `defaultValue`.
	 *
	 *  - Checks route placeholders, ex: _/user/:id_
	 *  - Checks body params, ex: id=12, {"id":12}
	 *  - Checks query string params, ex: ?id=12
	 *
	 * To utilize request bodies, `req.body`
	 * should be an object. This can be done by using
	 * the `bodyParser()` middleware.
	 *
	 * @param {String} name
	 * @param {Mixed} [defaultValue]
	 * @return {String}
	 * @public
	 */
	
	req.param = function param(name, defaultValue) {
	  var params = this.params || {};
	  var body = this.body || {};
	  var query = this.query || {};
	
	  var args = arguments.length === 1
	    ? 'name'
	    : 'name, default';
	  deprecate('req.param(' + args + '): Use req.params, req.body, or req.query instead');
	
	  if (null != params[name] && params.hasOwnProperty(name)) return params[name];
	  if (null != body[name]) return body[name];
	  if (null != query[name]) return query[name];
	
	  return defaultValue;
	};
	
	/**
	 * Check if the incoming request contains the "Content-Type"
	 * header field, and it contains the give mime `type`.
	 *
	 * Examples:
	 *
	 *      // With Content-Type: text/html; charset=utf-8
	 *      req.is('html');
	 *      req.is('text/html');
	 *      req.is('text/*');
	 *      // => true
	 *
	 *      // When Content-Type is application/json
	 *      req.is('json');
	 *      req.is('application/json');
	 *      req.is('application/*');
	 *      // => true
	 *
	 *      req.is('html');
	 *      // => false
	 *
	 * @param {String|Array} types...
	 * @return {String|false|null}
	 * @public
	 */
	
	req.is = function is(types) {
	  var arr = types;
	
	  // support flattened arguments
	  if (!Array.isArray(types)) {
	    arr = new Array(arguments.length);
	    for (var i = 0; i < arr.length; i++) {
	      arr[i] = arguments[i];
	    }
	  }
	
	  return typeis(this, arr);
	};
	
	/**
	 * Return the protocol string "http" or "https"
	 * when requested with TLS. When the "trust proxy"
	 * setting trusts the socket address, the
	 * "X-Forwarded-Proto" header field will be trusted
	 * and used if present.
	 *
	 * If you're running behind a reverse proxy that
	 * supplies https for you this may be enabled.
	 *
	 * @return {String}
	 * @public
	 */
	
	defineGetter(req, 'protocol', function protocol(){
	  var proto = this.connection.encrypted
	    ? 'https'
	    : 'http';
	  var trust = this.app.get('trust proxy fn');
	
	  if (!trust(this.connection.remoteAddress, 0)) {
	    return proto;
	  }
	
	  // Note: X-Forwarded-Proto is normally only ever a
	  //       single value, but this is to be safe.
	  proto = this.get('X-Forwarded-Proto') || proto;
	  return proto.split(/\s*,\s*/)[0];
	});
	
	/**
	 * Short-hand for:
	 *
	 *    req.protocol === 'https'
	 *
	 * @return {Boolean}
	 * @public
	 */
	
	defineGetter(req, 'secure', function secure(){
	  return this.protocol === 'https';
	});
	
	/**
	 * Return the remote address from the trusted proxy.
	 *
	 * The is the remote address on the socket unless
	 * "trust proxy" is set.
	 *
	 * @return {String}
	 * @public
	 */
	
	defineGetter(req, 'ip', function ip(){
	  var trust = this.app.get('trust proxy fn');
	  return proxyaddr(this, trust);
	});
	
	/**
	 * When "trust proxy" is set, trusted proxy addresses + client.
	 *
	 * For example if the value were "client, proxy1, proxy2"
	 * you would receive the array `["client", "proxy1", "proxy2"]`
	 * where "proxy2" is the furthest down-stream and "proxy1" and
	 * "proxy2" were trusted.
	 *
	 * @return {Array}
	 * @public
	 */
	
	defineGetter(req, 'ips', function ips() {
	  var trust = this.app.get('trust proxy fn');
	  var addrs = proxyaddr.all(this, trust);
	  return addrs.slice(1).reverse();
	});
	
	/**
	 * Return subdomains as an array.
	 *
	 * Subdomains are the dot-separated parts of the host before the main domain of
	 * the app. By default, the domain of the app is assumed to be the last two
	 * parts of the host. This can be changed by setting "subdomain offset".
	 *
	 * For example, if the domain is "tobi.ferrets.example.com":
	 * If "subdomain offset" is not set, req.subdomains is `["ferrets", "tobi"]`.
	 * If "subdomain offset" is 3, req.subdomains is `["tobi"]`.
	 *
	 * @return {Array}
	 * @public
	 */
	
	defineGetter(req, 'subdomains', function subdomains() {
	  var hostname = this.hostname;
	
	  if (!hostname) return [];
	
	  var offset = this.app.get('subdomain offset');
	  var subdomains = !isIP(hostname)
	    ? hostname.split('.').reverse()
	    : [hostname];
	
	  return subdomains.slice(offset);
	});
	
	/**
	 * Short-hand for `url.parse(req.url).pathname`.
	 *
	 * @return {String}
	 * @public
	 */
	
	defineGetter(req, 'path', function path() {
	  return parse(this).pathname;
	});
	
	/**
	 * Parse the "Host" header field to a hostname.
	 *
	 * When the "trust proxy" setting trusts the socket
	 * address, the "X-Forwarded-Host" header field will
	 * be trusted.
	 *
	 * @return {String}
	 * @public
	 */
	
	defineGetter(req, 'hostname', function hostname(){
	  var trust = this.app.get('trust proxy fn');
	  var host = this.get('X-Forwarded-Host');
	
	  if (!host || !trust(this.connection.remoteAddress, 0)) {
	    host = this.get('Host');
	  }
	
	  if (!host) return;
	
	  // IPv6 literal support
	  var offset = host[0] === '['
	    ? host.indexOf(']') + 1
	    : 0;
	  var index = host.indexOf(':', offset);
	
	  return index !== -1
	    ? host.substring(0, index)
	    : host;
	});
	
	// TODO: change req.host to return host in next major
	
	defineGetter(req, 'host', deprecate.function(function host(){
	  return this.hostname;
	}, 'req.host: Use req.hostname instead'));
	
	/**
	 * Check if the request is fresh, aka
	 * Last-Modified and/or the ETag
	 * still match.
	 *
	 * @return {Boolean}
	 * @public
	 */
	
	defineGetter(req, 'fresh', function(){
	  var method = this.method;
	  var s = this.res.statusCode;
	
	  // GET or HEAD for weak freshness validation only
	  if ('GET' !== method && 'HEAD' !== method) return false;
	
	  // 2xx or 304 as per rfc2616 14.26
	  if ((s >= 200 && s < 300) || 304 === s) {
	    return fresh(this.headers, (this.res._headers || {}));
	  }
	
	  return false;
	});
	
	/**
	 * Check if the request is stale, aka
	 * "Last-Modified" and / or the "ETag" for the
	 * resource has changed.
	 *
	 * @return {Boolean}
	 * @public
	 */
	
	defineGetter(req, 'stale', function stale(){
	  return !this.fresh;
	});
	
	/**
	 * Check if the request was an _XMLHttpRequest_.
	 *
	 * @return {Boolean}
	 * @public
	 */
	
	defineGetter(req, 'xhr', function xhr(){
	  var val = this.get('X-Requested-With') || '';
	  return val.toLowerCase() === 'xmlhttprequest';
	});
	
	/**
	 * Helper function for creating a getter on an object.
	 *
	 * @param {Object} obj
	 * @param {String} name
	 * @param {Function} getter
	 * @private
	 */
	function defineGetter(obj, name, getter) {
	  Object.defineProperty(obj, name, {
	    configurable: true,
	    enumerable: true,
	    get: getter
	  });
	};


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * accepts
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var Negotiator = __webpack_require__(97)
	var mime = __webpack_require__(102)
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = Accepts
	
	/**
	 * Create a new Accepts object for the given req.
	 *
	 * @param {object} req
	 * @public
	 */
	
	function Accepts(req) {
	  if (!(this instanceof Accepts))
	    return new Accepts(req)
	
	  this.headers = req.headers
	  this.negotiator = new Negotiator(req)
	}
	
	/**
	 * Check if the given `type(s)` is acceptable, returning
	 * the best match when true, otherwise `undefined`, in which
	 * case you should respond with 406 "Not Acceptable".
	 *
	 * The `type` value may be a single mime type string
	 * such as "application/json", the extension name
	 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
	 * or array is given the _best_ match, if any is returned.
	 *
	 * Examples:
	 *
	 *     // Accept: text/html
	 *     this.types('html');
	 *     // => "html"
	 *
	 *     // Accept: text/*, application/json
	 *     this.types('html');
	 *     // => "html"
	 *     this.types('text/html');
	 *     // => "text/html"
	 *     this.types('json', 'text');
	 *     // => "json"
	 *     this.types('application/json');
	 *     // => "application/json"
	 *
	 *     // Accept: text/*, application/json
	 *     this.types('image/png');
	 *     this.types('png');
	 *     // => undefined
	 *
	 *     // Accept: text/*;q=.5, application/json
	 *     this.types(['html', 'json']);
	 *     this.types('html', 'json');
	 *     // => "json"
	 *
	 * @param {String|Array} types...
	 * @return {String|Array|Boolean}
	 * @public
	 */
	
	Accepts.prototype.type =
	Accepts.prototype.types = function (types_) {
	  var types = types_
	
	  // support flattened arguments
	  if (types && !Array.isArray(types)) {
	    types = new Array(arguments.length)
	    for (var i = 0; i < types.length; i++) {
	      types[i] = arguments[i]
	    }
	  }
	
	  // no types, return all requested types
	  if (!types || types.length === 0) {
	    return this.negotiator.mediaTypes()
	  }
	
	  if (!this.headers.accept) return types[0];
	  var mimes = types.map(extToMime);
	  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
	  var first = accepts[0];
	  if (!first) return false;
	  return types[mimes.indexOf(first)];
	}
	
	/**
	 * Return accepted encodings or best fit based on `encodings`.
	 *
	 * Given `Accept-Encoding: gzip, deflate`
	 * an array sorted by quality is returned:
	 *
	 *     ['gzip', 'deflate']
	 *
	 * @param {String|Array} encodings...
	 * @return {String|Array}
	 * @public
	 */
	
	Accepts.prototype.encoding =
	Accepts.prototype.encodings = function (encodings_) {
	  var encodings = encodings_
	
	  // support flattened arguments
	  if (encodings && !Array.isArray(encodings)) {
	    encodings = new Array(arguments.length)
	    for (var i = 0; i < encodings.length; i++) {
	      encodings[i] = arguments[i]
	    }
	  }
	
	  // no encodings, return all requested encodings
	  if (!encodings || encodings.length === 0) {
	    return this.negotiator.encodings()
	  }
	
	  return this.negotiator.encodings(encodings)[0] || false
	}
	
	/**
	 * Return accepted charsets or best fit based on `charsets`.
	 *
	 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
	 * an array sorted by quality is returned:
	 *
	 *     ['utf-8', 'utf-7', 'iso-8859-1']
	 *
	 * @param {String|Array} charsets...
	 * @return {String|Array}
	 * @public
	 */
	
	Accepts.prototype.charset =
	Accepts.prototype.charsets = function (charsets_) {
	  var charsets = charsets_
	
	  // support flattened arguments
	  if (charsets && !Array.isArray(charsets)) {
	    charsets = new Array(arguments.length)
	    for (var i = 0; i < charsets.length; i++) {
	      charsets[i] = arguments[i]
	    }
	  }
	
	  // no charsets, return all requested charsets
	  if (!charsets || charsets.length === 0) {
	    return this.negotiator.charsets()
	  }
	
	  return this.negotiator.charsets(charsets)[0] || false
	}
	
	/**
	 * Return accepted languages or best fit based on `langs`.
	 *
	 * Given `Accept-Language: en;q=0.8, es, pt`
	 * an array sorted by quality is returned:
	 *
	 *     ['es', 'pt', 'en']
	 *
	 * @param {String|Array} langs...
	 * @return {Array|String}
	 * @public
	 */
	
	Accepts.prototype.lang =
	Accepts.prototype.langs =
	Accepts.prototype.language =
	Accepts.prototype.languages = function (languages_) {
	  var languages = languages_
	
	  // support flattened arguments
	  if (languages && !Array.isArray(languages)) {
	    languages = new Array(arguments.length)
	    for (var i = 0; i < languages.length; i++) {
	      languages[i] = arguments[i]
	    }
	  }
	
	  // no languages, return all requested languages
	  if (!languages || languages.length === 0) {
	    return this.negotiator.languages()
	  }
	
	  return this.negotiator.languages(languages)[0] || false
	}
	
	/**
	 * Convert extnames to mime.
	 *
	 * @param {String} type
	 * @return {String}
	 * @private
	 */
	
	function extToMime(type) {
	  return type.indexOf('/') === -1
	    ? mime.lookup(type)
	    : type
	}
	
	/**
	 * Check if mime is valid.
	 *
	 * @param {String} type
	 * @return {String}
	 * @private
	 */
	
	function validMime(type) {
	  return typeof type === 'string';
	}


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * negotiator
	 * Copyright(c) 2012 Federico Romero
	 * Copyright(c) 2012-2014 Isaac Z. Schlueter
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Cached loaded submodules.
	 * @private
	 */
	
	var modules = Object.create(null);
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = Negotiator;
	module.exports.Negotiator = Negotiator;
	
	/**
	 * Create a Negotiator instance from a request.
	 * @param {object} request
	 * @public
	 */
	
	function Negotiator(request) {
	  if (!(this instanceof Negotiator)) {
	    return new Negotiator(request);
	  }
	
	  this.request = request;
	}
	
	Negotiator.prototype.charset = function charset(available) {
	  var set = this.charsets(available);
	  return set && set[0];
	};
	
	Negotiator.prototype.charsets = function charsets(available) {
	  var preferredCharsets = loadModule('charset').preferredCharsets;
	  return preferredCharsets(this.request.headers['accept-charset'], available);
	};
	
	Negotiator.prototype.encoding = function encoding(available) {
	  var set = this.encodings(available);
	  return set && set[0];
	};
	
	Negotiator.prototype.encodings = function encodings(available) {
	  var preferredEncodings = loadModule('encoding').preferredEncodings;
	  return preferredEncodings(this.request.headers['accept-encoding'], available);
	};
	
	Negotiator.prototype.language = function language(available) {
	  var set = this.languages(available);
	  return set && set[0];
	};
	
	Negotiator.prototype.languages = function languages(available) {
	  var preferredLanguages = loadModule('language').preferredLanguages;
	  return preferredLanguages(this.request.headers['accept-language'], available);
	};
	
	Negotiator.prototype.mediaType = function mediaType(available) {
	  var set = this.mediaTypes(available);
	  return set && set[0];
	};
	
	Negotiator.prototype.mediaTypes = function mediaTypes(available) {
	  var preferredMediaTypes = loadModule('mediaType').preferredMediaTypes;
	  return preferredMediaTypes(this.request.headers.accept, available);
	};
	
	// Backwards compatibility
	Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
	Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
	Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
	Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
	Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
	Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
	Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
	Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
	
	/**
	 * Load the given module.
	 * @private
	 */
	
	function loadModule(moduleName) {
	  var module = modules[moduleName];
	
	  if (module !== undefined) {
	    return module;
	  }
	
	  // This uses a switch for static require analysis
	  switch (moduleName) {
	    case 'charset':
	      module = __webpack_require__(98);
	      break;
	    case 'encoding':
	      module = __webpack_require__(99);
	      break;
	    case 'language':
	      module = __webpack_require__(100);
	      break;
	    case 'mediaType':
	      module = __webpack_require__(101);
	      break;
	    default:
	      throw new Error('Cannot find module \'' + moduleName + '\'');
	  }
	
	  // Store to prevent invoking require()
	  modules[moduleName] = module;
	
	  return module;
	}


/***/ },
/* 98 */
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = preferredCharsets;
	module.exports.preferredCharsets = preferredCharsets;
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
	
	/**
	 * Parse the Accept-Charset header.
	 * @private
	 */
	
	function parseAcceptCharset(accept) {
	  var accepts = accept.split(',');
	
	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var charset = parseCharset(accepts[i].trim(), i);
	
	    if (charset) {
	      accepts[j++] = charset;
	    }
	  }
	
	  // trim accepts
	  accepts.length = j;
	
	  return accepts;
	}
	
	/**
	 * Parse a charset from the Accept-Charset header.
	 * @private
	 */
	
	function parseCharset(str, i) {
	  var match = simpleCharsetRegExp.exec(str);
	  if (!match) return null;
	
	  var charset = match[1];
	  var q = 1;
	  if (match[2]) {
	    var params = match[2].split(';')
	    for (var i = 0; i < params.length; i ++) {
	      var p = params[i].trim().split('=');
	      if (p[0] === 'q') {
	        q = parseFloat(p[1]);
	        break;
	      }
	    }
	  }
	
	  return {
	    charset: charset,
	    q: q,
	    i: i
	  };
	}
	
	/**
	 * Get the priority of a charset.
	 * @private
	 */
	
	function getCharsetPriority(charset, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};
	
	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(charset, accepted[i], index);
	
	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }
	
	  return priority;
	}
	
	/**
	 * Get the specificity of the charset.
	 * @private
	 */
	
	function specify(charset, spec, index) {
	  var s = 0;
	  if(spec.charset.toLowerCase() === charset.toLowerCase()){
	    s |= 1;
	  } else if (spec.charset !== '*' ) {
	    return null
	  }
	
	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  }
	}
	
	/**
	 * Get the preferred charsets from an Accept-Charset header.
	 * @public
	 */
	
	function preferredCharsets(accept, provided) {
	  // RFC 2616 sec 14.2: no header = *
	  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');
	
	  if (!provided) {
	    // sorted list of all charsets
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullCharset);
	  }
	
	  var priorities = provided.map(function getPriority(type, index) {
	    return getCharsetPriority(type, accepts, index);
	  });
	
	  // sorted list of accepted charsets
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}
	
	/**
	 * Compare two specs.
	 * @private
	 */
	
	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}
	
	/**
	 * Get full charset string.
	 * @private
	 */
	
	function getFullCharset(spec) {
	  return spec.charset;
	}
	
	/**
	 * Check if a spec has any quality.
	 * @private
	 */
	
	function isQuality(spec) {
	  return spec.q > 0;
	}


/***/ },
/* 99 */
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = preferredEncodings;
	module.exports.preferredEncodings = preferredEncodings;
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
	
	/**
	 * Parse the Accept-Encoding header.
	 * @private
	 */
	
	function parseAcceptEncoding(accept) {
	  var accepts = accept.split(',');
	  var hasIdentity = false;
	  var minQuality = 1;
	
	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var encoding = parseEncoding(accepts[i].trim(), i);
	
	    if (encoding) {
	      accepts[j++] = encoding;
	      hasIdentity = hasIdentity || specify('identity', encoding);
	      minQuality = Math.min(minQuality, encoding.q || 1);
	    }
	  }
	
	  if (!hasIdentity) {
	    /*
	     * If identity doesn't explicitly appear in the accept-encoding header,
	     * it's added to the list of acceptable encoding with the lowest q
	     */
	    accepts[j++] = {
	      encoding: 'identity',
	      q: minQuality,
	      i: i
	    };
	  }
	
	  // trim accepts
	  accepts.length = j;
	
	  return accepts;
	}
	
	/**
	 * Parse an encoding from the Accept-Encoding header.
	 * @private
	 */
	
	function parseEncoding(str, i) {
	  var match = simpleEncodingRegExp.exec(str);
	  if (!match) return null;
	
	  var encoding = match[1];
	  var q = 1;
	  if (match[2]) {
	    var params = match[2].split(';');
	    for (var i = 0; i < params.length; i ++) {
	      var p = params[i].trim().split('=');
	      if (p[0] === 'q') {
	        q = parseFloat(p[1]);
	        break;
	      }
	    }
	  }
	
	  return {
	    encoding: encoding,
	    q: q,
	    i: i
	  };
	}
	
	/**
	 * Get the priority of an encoding.
	 * @private
	 */
	
	function getEncodingPriority(encoding, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};
	
	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(encoding, accepted[i], index);
	
	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }
	
	  return priority;
	}
	
	/**
	 * Get the specificity of the encoding.
	 * @private
	 */
	
	function specify(encoding, spec, index) {
	  var s = 0;
	  if(spec.encoding.toLowerCase() === encoding.toLowerCase()){
	    s |= 1;
	  } else if (spec.encoding !== '*' ) {
	    return null
	  }
	
	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  }
	};
	
	/**
	 * Get the preferred encodings from an Accept-Encoding header.
	 * @public
	 */
	
	function preferredEncodings(accept, provided) {
	  var accepts = parseAcceptEncoding(accept || '');
	
	  if (!provided) {
	    // sorted list of all encodings
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullEncoding);
	  }
	
	  var priorities = provided.map(function getPriority(type, index) {
	    return getEncodingPriority(type, accepts, index);
	  });
	
	  // sorted list of accepted encodings
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}
	
	/**
	 * Compare two specs.
	 * @private
	 */
	
	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}
	
	/**
	 * Get full encoding string.
	 * @private
	 */
	
	function getFullEncoding(spec) {
	  return spec.encoding;
	}
	
	/**
	 * Check if a spec has any quality.
	 * @private
	 */
	
	function isQuality(spec) {
	  return spec.q > 0;
	}


/***/ },
/* 100 */
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = preferredLanguages;
	module.exports.preferredLanguages = preferredLanguages;
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
	
	/**
	 * Parse the Accept-Language header.
	 * @private
	 */
	
	function parseAcceptLanguage(accept) {
	  var accepts = accept.split(',');
	
	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var langauge = parseLanguage(accepts[i].trim(), i);
	
	    if (langauge) {
	      accepts[j++] = langauge;
	    }
	  }
	
	  // trim accepts
	  accepts.length = j;
	
	  return accepts;
	}
	
	/**
	 * Parse a language from the Accept-Language header.
	 * @private
	 */
	
	function parseLanguage(str, i) {
	  var match = simpleLanguageRegExp.exec(str);
	  if (!match) return null;
	
	  var prefix = match[1],
	      suffix = match[2],
	      full = prefix;
	
	  if (suffix) full += "-" + suffix;
	
	  var q = 1;
	  if (match[3]) {
	    var params = match[3].split(';')
	    for (var i = 0; i < params.length; i ++) {
	      var p = params[i].split('=');
	      if (p[0] === 'q') q = parseFloat(p[1]);
	    }
	  }
	
	  return {
	    prefix: prefix,
	    suffix: suffix,
	    q: q,
	    i: i,
	    full: full
	  };
	}
	
	/**
	 * Get the priority of a language.
	 * @private
	 */
	
	function getLanguagePriority(language, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};
	
	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(language, accepted[i], index);
	
	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }
	
	  return priority;
	}
	
	/**
	 * Get the specificity of the language.
	 * @private
	 */
	
	function specify(language, spec, index) {
	  var p = parseLanguage(language)
	  if (!p) return null;
	  var s = 0;
	  if(spec.full.toLowerCase() === p.full.toLowerCase()){
	    s |= 4;
	  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
	    s |= 2;
	  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
	    s |= 1;
	  } else if (spec.full !== '*' ) {
	    return null
	  }
	
	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  }
	};
	
	/**
	 * Get the preferred languages from an Accept-Language header.
	 * @public
	 */
	
	function preferredLanguages(accept, provided) {
	  // RFC 2616 sec 14.4: no header = *
	  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');
	
	  if (!provided) {
	    // sorted list of all languages
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullLanguage);
	  }
	
	  var priorities = provided.map(function getPriority(type, index) {
	    return getLanguagePriority(type, accepts, index);
	  });
	
	  // sorted list of accepted languages
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}
	
	/**
	 * Compare two specs.
	 * @private
	 */
	
	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}
	
	/**
	 * Get full language string.
	 * @private
	 */
	
	function getFullLanguage(spec) {
	  return spec.full;
	}
	
	/**
	 * Check if a spec has any quality.
	 * @private
	 */
	
	function isQuality(spec) {
	  return spec.q > 0;
	}


/***/ },
/* 101 */
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = preferredMediaTypes;
	module.exports.preferredMediaTypes = preferredMediaTypes;
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
	
	/**
	 * Parse the Accept header.
	 * @private
	 */
	
	function parseAccept(accept) {
	  var accepts = splitMediaTypes(accept);
	
	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var mediaType = parseMediaType(accepts[i].trim(), i);
	
	    if (mediaType) {
	      accepts[j++] = mediaType;
	    }
	  }
	
	  // trim accepts
	  accepts.length = j;
	
	  return accepts;
	}
	
	/**
	 * Parse a media type from the Accept header.
	 * @private
	 */
	
	function parseMediaType(str, i) {
	  var match = simpleMediaTypeRegExp.exec(str);
	  if (!match) return null;
	
	  var params = Object.create(null);
	  var q = 1;
	  var subtype = match[2];
	  var type = match[1];
	
	  if (match[3]) {
	    var kvps = splitParameters(match[3]).map(splitKeyValuePair);
	
	    for (var j = 0; j < kvps.length; j++) {
	      var pair = kvps[j];
	      var key = pair[0].toLowerCase();
	      var val = pair[1];
	
	      // get the value, unwrapping quotes
	      var value = val && val[0] === '"' && val[val.length - 1] === '"'
	        ? val.substr(1, val.length - 2)
	        : val;
	
	      if (key === 'q') {
	        q = parseFloat(value);
	        break;
	      }
	
	      // store parameter
	      params[key] = value;
	    }
	  }
	
	  return {
	    type: type,
	    subtype: subtype,
	    params: params,
	    q: q,
	    i: i
	  };
	}
	
	/**
	 * Get the priority of a media type.
	 * @private
	 */
	
	function getMediaTypePriority(type, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};
	
	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(type, accepted[i], index);
	
	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }
	
	  return priority;
	}
	
	/**
	 * Get the specificity of the media type.
	 * @private
	 */
	
	function specify(type, spec, index) {
	  var p = parseMediaType(type);
	  var s = 0;
	
	  if (!p) {
	    return null;
	  }
	
	  if(spec.type.toLowerCase() == p.type.toLowerCase()) {
	    s |= 4
	  } else if(spec.type != '*') {
	    return null;
	  }
	
	  if(spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
	    s |= 2
	  } else if(spec.subtype != '*') {
	    return null;
	  }
	
	  var keys = Object.keys(spec.params);
	  if (keys.length > 0) {
	    if (keys.every(function (k) {
	      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
	    })) {
	      s |= 1
	    } else {
	      return null
	    }
	  }
	
	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s,
	  }
	}
	
	/**
	 * Get the preferred media types from an Accept header.
	 * @public
	 */
	
	function preferredMediaTypes(accept, provided) {
	  // RFC 2616 sec 14.2: no header = */*
	  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');
	
	  if (!provided) {
	    // sorted list of all types
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullType);
	  }
	
	  var priorities = provided.map(function getPriority(type, index) {
	    return getMediaTypePriority(type, accepts, index);
	  });
	
	  // sorted list of accepted types
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}
	
	/**
	 * Compare two specs.
	 * @private
	 */
	
	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}
	
	/**
	 * Get full type string.
	 * @private
	 */
	
	function getFullType(spec) {
	  return spec.type + '/' + spec.subtype;
	}
	
	/**
	 * Check if a spec has any quality.
	 * @private
	 */
	
	function isQuality(spec) {
	  return spec.q > 0;
	}
	
	/**
	 * Count the number of quotes in a string.
	 * @private
	 */
	
	function quoteCount(string) {
	  var count = 0;
	  var index = 0;
	
	  while ((index = string.indexOf('"', index)) !== -1) {
	    count++;
	    index++;
	  }
	
	  return count;
	}
	
	/**
	 * Split a key value pair.
	 * @private
	 */
	
	function splitKeyValuePair(str) {
	  var index = str.indexOf('=');
	  var key;
	  var val;
	
	  if (index === -1) {
	    key = str;
	  } else {
	    key = str.substr(0, index);
	    val = str.substr(index + 1);
	  }
	
	  return [key, val];
	}
	
	/**
	 * Split an Accept header into media types.
	 * @private
	 */
	
	function splitMediaTypes(accept) {
	  var accepts = accept.split(',');
	
	  for (var i = 1, j = 0; i < accepts.length; i++) {
	    if (quoteCount(accepts[j]) % 2 == 0) {
	      accepts[++j] = accepts[i];
	    } else {
	      accepts[j] += ',' + accepts[i];
	    }
	  }
	
	  // trim accepts
	  accepts.length = j + 1;
	
	  return accepts;
	}
	
	/**
	 * Split a string of parameters.
	 * @private
	 */
	
	function splitParameters(str) {
	  var parameters = str.split(';');
	
	  for (var i = 1, j = 0; i < parameters.length; i++) {
	    if (quoteCount(parameters[j]) % 2 == 0) {
	      parameters[++j] = parameters[i];
	    } else {
	      parameters[j] += ';' + parameters[i];
	    }
	  }
	
	  // trim parameters
	  parameters.length = j + 1;
	
	  for (var i = 0; i < parameters.length; i++) {
	    parameters[i] = parameters[i].trim();
	  }
	
	  return parameters;
	}


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * mime-types
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var db = __webpack_require__(103)
	var extname = __webpack_require__(45).extname
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var extractTypeRegExp = /^\s*([^;\s]*)(?:;|\s|$)/
	var textTypeRegExp = /^text\//i
	
	/**
	 * Module exports.
	 * @public
	 */
	
	exports.charset = charset
	exports.charsets = { lookup: charset }
	exports.contentType = contentType
	exports.extension = extension
	exports.extensions = Object.create(null)
	exports.lookup = lookup
	exports.types = Object.create(null)
	
	// Populate the extensions/types maps
	populateMaps(exports.extensions, exports.types)
	
	/**
	 * Get the default charset for a MIME type.
	 *
	 * @param {string} type
	 * @return {boolean|string}
	 */
	
	function charset(type) {
	  if (!type || typeof type !== 'string') {
	    return false
	  }
	
	  // TODO: use media-typer
	  var match = extractTypeRegExp.exec(type)
	  var mime = match && db[match[1].toLowerCase()]
	
	  if (mime && mime.charset) {
	    return mime.charset
	  }
	
	  // default text/* to utf-8
	  if (match && textTypeRegExp.test(match[1])) {
	    return 'UTF-8'
	  }
	
	  return false
	}
	
	/**
	 * Create a full Content-Type header given a MIME type or extension.
	 *
	 * @param {string} str
	 * @return {boolean|string}
	 */
	
	function contentType(str) {
	  // TODO: should this even be in this module?
	  if (!str || typeof str !== 'string') {
	    return false
	  }
	
	  var mime = str.indexOf('/') === -1
	    ? exports.lookup(str)
	    : str
	
	  if (!mime) {
	    return false
	  }
	
	  // TODO: use content-type or other module
	  if (mime.indexOf('charset') === -1) {
	    var charset = exports.charset(mime)
	    if (charset) mime += '; charset=' + charset.toLowerCase()
	  }
	
	  return mime
	}
	
	/**
	 * Get the default extension for a MIME type.
	 *
	 * @param {string} type
	 * @return {boolean|string}
	 */
	
	function extension(type) {
	  if (!type || typeof type !== 'string') {
	    return false
	  }
	
	  // TODO: use media-typer
	  var match = extractTypeRegExp.exec(type)
	
	  // get extensions
	  var exts = match && exports.extensions[match[1].toLowerCase()]
	
	  if (!exts || !exts.length) {
	    return false
	  }
	
	  return exts[0]
	}
	
	/**
	 * Lookup the MIME type for a file path/extension.
	 *
	 * @param {string} path
	 * @return {boolean|string}
	 */
	
	function lookup(path) {
	  if (!path || typeof path !== 'string') {
	    return false
	  }
	
	  // get the extension ("ext" or ".ext" or full path)
	  var extension = extname('x.' + path)
	    .toLowerCase()
	    .substr(1)
	
	  if (!extension) {
	    return false
	  }
	
	  return exports.types[extension] || false
	}
	
	/**
	 * Populate the extensions and types maps.
	 * @private
	 */
	
	function populateMaps(extensions, types) {
	  // source preference (least -> most)
	  var preference = ['nginx', 'apache', undefined, 'iana']
	
	  Object.keys(db).forEach(function forEachMimeType(type) {
	    var mime = db[type]
	    var exts = mime.extensions
	
	    if (!exts || !exts.length) {
	      return
	    }
	
	    // mime -> extensions
	    extensions[type] = exts
	
	    // extension -> mime
	    for (var i = 0; i < exts.length; i++) {
	      var extension = exts[i]
	
	      if (types[extension]) {
	        var from = preference.indexOf(db[types[extension]].source)
	        var to = preference.indexOf(mime.source)
	
	        if (types[extension] !== 'application/octet-stream'
	          && from > to || (from === to && types[extension].substr(0, 12) === 'application/')) {
	          // skip the remapping
	          continue
	        }
	      }
	
	      // set the extension -> mime
	      types[extension] = type
	    }
	  })
	}


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * mime-db
	 * Copyright(c) 2014 Jonathan Ong
	 * MIT Licensed
	 */
	
	/**
	 * Module exports.
	 */
	
	module.exports = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./db.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))


/***/ },
/* 104 */,
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * type-is
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var typer = __webpack_require__(106)
	var mime = __webpack_require__(102)
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = typeofrequest
	module.exports.is = typeis
	module.exports.hasBody = hasbody
	module.exports.normalize = normalize
	module.exports.match = mimeMatch
	
	/**
	 * Compare a `value` content-type with `types`.
	 * Each `type` can be an extension like `html`,
	 * a special shortcut like `multipart` or `urlencoded`,
	 * or a mime type.
	 *
	 * If no types match, `false` is returned.
	 * Otherwise, the first `type` that matches is returned.
	 *
	 * @param {String} value
	 * @param {Array} types
	 * @public
	 */
	
	function typeis (value, types_) {
	  var i
	  var types = types_
	
	  // remove parameters and normalize
	  var val = tryNormalizeType(value)
	
	  // no type or invalid
	  if (!val) {
	    return false
	  }
	
	  // support flattened arguments
	  if (types && !Array.isArray(types)) {
	    types = new Array(arguments.length - 1)
	    for (i = 0; i < types.length; i++) {
	      types[i] = arguments[i + 1]
	    }
	  }
	
	  // no types, return the content type
	  if (!types || !types.length) {
	    return val
	  }
	
	  var type
	  for (i = 0; i < types.length; i++) {
	    if (mimeMatch(normalize(type = types[i]), val)) {
	      return type[0] === '+' || type.indexOf('*') !== -1
	        ? val
	        : type
	    }
	  }
	
	  // no matches
	  return false
	}
	
	/**
	 * Check if a request has a request body.
	 * A request with a body __must__ either have `transfer-encoding`
	 * or `content-length` headers set.
	 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
	 *
	 * @param {Object} request
	 * @return {Boolean}
	 * @public
	 */
	
	function hasbody (req) {
	  return req.headers['transfer-encoding'] !== undefined ||
	    !isNaN(req.headers['content-length'])
	}
	
	/**
	 * Check if the incoming request contains the "Content-Type"
	 * header field, and it contains any of the give mime `type`s.
	 * If there is no request body, `null` is returned.
	 * If there is no content type, `false` is returned.
	 * Otherwise, it returns the first `type` that matches.
	 *
	 * Examples:
	 *
	 *     // With Content-Type: text/html; charset=utf-8
	 *     this.is('html'); // => 'html'
	 *     this.is('text/html'); // => 'text/html'
	 *     this.is('text/*', 'application/json'); // => 'text/html'
	 *
	 *     // When Content-Type is application/json
	 *     this.is('json', 'urlencoded'); // => 'json'
	 *     this.is('application/json'); // => 'application/json'
	 *     this.is('html', 'application/*'); // => 'application/json'
	 *
	 *     this.is('html'); // => false
	 *
	 * @param {String|Array} types...
	 * @return {String|false|null}
	 * @public
	 */
	
	function typeofrequest (req, types_) {
	  var types = types_
	
	  // no body
	  if (!hasbody(req)) {
	    return null
	  }
	
	  // support flattened arguments
	  if (arguments.length > 2) {
	    types = new Array(arguments.length - 1)
	    for (var i = 0; i < types.length; i++) {
	      types[i] = arguments[i + 1]
	    }
	  }
	
	  // request content type
	  var value = req.headers['content-type']
	
	  return typeis(value, types)
	}
	
	/**
	 * Normalize a mime type.
	 * If it's a shorthand, expand it to a valid mime type.
	 *
	 * In general, you probably want:
	 *
	 *   var type = is(req, ['urlencoded', 'json', 'multipart']);
	 *
	 * Then use the appropriate body parsers.
	 * These three are the most common request body types
	 * and are thus ensured to work.
	 *
	 * @param {String} type
	 * @private
	 */
	
	function normalize (type) {
	  if (typeof type !== 'string') {
	    // invalid type
	    return false
	  }
	
	  switch (type) {
	    case 'urlencoded':
	      return 'application/x-www-form-urlencoded'
	    case 'multipart':
	      return 'multipart/*'
	  }
	
	  if (type[0] === '+') {
	    // "+json" -> "*/*+json" expando
	    return '*/*' + type
	  }
	
	  return type.indexOf('/') === -1
	    ? mime.lookup(type)
	    : type
	}
	
	/**
	 * Check if `expected` mime type
	 * matches `actual` mime type with
	 * wildcard and +suffix support.
	 *
	 * @param {String} expected
	 * @param {String} actual
	 * @return {Boolean}
	 * @private
	 */
	
	function mimeMatch (expected, actual) {
	  // invalid type
	  if (expected === false) {
	    return false
	  }
	
	  // split types
	  var actualParts = actual.split('/')
	  var expectedParts = expected.split('/')
	
	  // invalid format
	  if (actualParts.length !== 2 || expectedParts.length !== 2) {
	    return false
	  }
	
	  // validate type
	  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
	    return false
	  }
	
	  // validate suffix wildcard
	  if (expectedParts[1].substr(0, 2) === '*+') {
	    return expectedParts[1].length <= actualParts[1].length + 1 &&
	      expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)
	  }
	
	  // validate subtype
	  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
	    return false
	  }
	
	  return true
	}
	
	/**
	 * Normalize a type and remove parameters.
	 *
	 * @param {string} value
	 * @return {string}
	 * @private
	 */
	
	function normalizeType (value) {
	  // parse the type
	  var type = typer.parse(value)
	
	  // remove the parameters
	  type.parameters = undefined
	
	  // reformat it
	  return typer.format(type)
	}
	
	/**
	 * Try to normalize a type and remove parameters.
	 *
	 * @param {string} value
	 * @return {string}
	 * @private
	 */
	
	function tryNormalizeType (value) {
	  try {
	    return normalizeType(value)
	  } catch (err) {
	    return null
	  }
	}


/***/ },
/* 106 */
/***/ function(module, exports) {

	/*!
	 * media-typer
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	/**
	 * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
	 *
	 * parameter     = token "=" ( token | quoted-string )
	 * token         = 1*<any CHAR except CTLs or separators>
	 * separators    = "(" | ")" | "<" | ">" | "@"
	 *               | "," | ";" | ":" | "\" | <">
	 *               | "/" | "[" | "]" | "?" | "="
	 *               | "{" | "}" | SP | HT
	 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	 * qdtext        = <any TEXT except <">>
	 * quoted-pair   = "\" CHAR
	 * CHAR          = <any US-ASCII character (octets 0 - 127)>
	 * TEXT          = <any OCTET except CTLs, but including LWS>
	 * LWS           = [CRLF] 1*( SP | HT )
	 * CRLF          = CR LF
	 * CR            = <US-ASCII CR, carriage return (13)>
	 * LF            = <US-ASCII LF, linefeed (10)>
	 * SP            = <US-ASCII SP, space (32)>
	 * SHT           = <US-ASCII HT, horizontal-tab (9)>
	 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	 * OCTET         = <any 8-bit sequence of data>
	 */
	var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
	var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/
	var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/
	
	/**
	 * RegExp to match quoted-pair in RFC 2616
	 *
	 * quoted-pair = "\" CHAR
	 * CHAR        = <any US-ASCII character (octets 0 - 127)>
	 */
	var qescRegExp = /\\([\u0000-\u007f])/g;
	
	/**
	 * RegExp to match chars that must be quoted-pair in RFC 2616
	 */
	var quoteRegExp = /([\\"])/g;
	
	/**
	 * RegExp to match type in RFC 6838
	 *
	 * type-name = restricted-name
	 * subtype-name = restricted-name
	 * restricted-name = restricted-name-first *126restricted-name-chars
	 * restricted-name-first  = ALPHA / DIGIT
	 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
	 *                          "$" / "&" / "-" / "^" / "_"
	 * restricted-name-chars =/ "." ; Characters before first dot always
	 *                              ; specify a facet name
	 * restricted-name-chars =/ "+" ; Characters after last plus always
	 *                              ; specify a structured syntax suffix
	 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
	 * DIGIT =  %x30-39             ; 0-9
	 */
	var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/
	var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/
	var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
	
	/**
	 * Module exports.
	 */
	
	exports.format = format
	exports.parse = parse
	
	/**
	 * Format object to media type.
	 *
	 * @param {object} obj
	 * @return {string}
	 * @api public
	 */
	
	function format(obj) {
	  if (!obj || typeof obj !== 'object') {
	    throw new TypeError('argument obj is required')
	  }
	
	  var parameters = obj.parameters
	  var subtype = obj.subtype
	  var suffix = obj.suffix
	  var type = obj.type
	
	  if (!type || !typeNameRegExp.test(type)) {
	    throw new TypeError('invalid type')
	  }
	
	  if (!subtype || !subtypeNameRegExp.test(subtype)) {
	    throw new TypeError('invalid subtype')
	  }
	
	  // format as type/subtype
	  var string = type + '/' + subtype
	
	  // append +suffix
	  if (suffix) {
	    if (!typeNameRegExp.test(suffix)) {
	      throw new TypeError('invalid suffix')
	    }
	
	    string += '+' + suffix
	  }
	
	  // append parameters
	  if (parameters && typeof parameters === 'object') {
	    var param
	    var params = Object.keys(parameters).sort()
	
	    for (var i = 0; i < params.length; i++) {
	      param = params[i]
	
	      if (!tokenRegExp.test(param)) {
	        throw new TypeError('invalid parameter name')
	      }
	
	      string += '; ' + param + '=' + qstring(parameters[param])
	    }
	  }
	
	  return string
	}
	
	/**
	 * Parse media type to object.
	 *
	 * @param {string|object} string
	 * @return {Object}
	 * @api public
	 */
	
	function parse(string) {
	  if (!string) {
	    throw new TypeError('argument string is required')
	  }
	
	  // support req/res-like objects as argument
	  if (typeof string === 'object') {
	    string = getcontenttype(string)
	  }
	
	  if (typeof string !== 'string') {
	    throw new TypeError('argument string is required to be a string')
	  }
	
	  var index = string.indexOf(';')
	  var type = index !== -1
	    ? string.substr(0, index)
	    : string
	
	  var key
	  var match
	  var obj = splitType(type)
	  var params = {}
	  var value
	
	  paramRegExp.lastIndex = index
	
	  while (match = paramRegExp.exec(string)) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format')
	    }
	
	    index += match[0].length
	    key = match[1].toLowerCase()
	    value = match[2]
	
	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value
	        .substr(1, value.length - 2)
	        .replace(qescRegExp, '$1')
	    }
	
	    params[key] = value
	  }
	
	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format')
	  }
	
	  obj.parameters = params
	
	  return obj
	}
	
	/**
	 * Get content-type from req/res objects.
	 *
	 * @param {object}
	 * @return {Object}
	 * @api private
	 */
	
	function getcontenttype(obj) {
	  if (typeof obj.getHeader === 'function') {
	    // res-like
	    return obj.getHeader('content-type')
	  }
	
	  if (typeof obj.headers === 'object') {
	    // req-like
	    return obj.headers && obj.headers['content-type']
	  }
	}
	
	/**
	 * Quote a string if necessary.
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */
	
	function qstring(val) {
	  var str = String(val)
	
	  // no need to quote tokens
	  if (tokenRegExp.test(str)) {
	    return str
	  }
	
	  if (str.length > 0 && !textRegExp.test(str)) {
	    throw new TypeError('invalid parameter value')
	  }
	
	  return '"' + str.replace(quoteRegExp, '\\$1') + '"'
	}
	
	/**
	 * Simply "type/subtype+siffx" into parts.
	 *
	 * @param {string} string
	 * @return {Object}
	 * @api private
	 */
	
	function splitType(string) {
	  var match = typeRegExp.exec(string.toLowerCase())
	
	  if (!match) {
	    throw new TypeError('invalid media type')
	  }
	
	  var type = match[1]
	  var subtype = match[2]
	  var suffix
	
	  // suffix after last +
	  var index = subtype.lastIndexOf('+')
	  if (index !== -1) {
	    suffix = subtype.substr(index + 1)
	    subtype = subtype.substr(0, index)
	  }
	
	  var obj = {
	    type: type,
	    subtype: subtype,
	    suffix: suffix
	  }
	
	  return obj
	}


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var http = module.exports;
	var EventEmitter = __webpack_require__(3).EventEmitter;
	var Request = __webpack_require__(108);
	var url = __webpack_require__(32)
	
	http.request = function (params, cb) {
	    if (typeof params === 'string') {
	        params = url.parse(params)
	    }
	    if (!params) params = {};
	    if (!params.host && !params.port) {
	        params.port = parseInt(window.location.port, 10);
	    }
	    if (!params.host && params.hostname) {
	        params.host = params.hostname;
	    }
	
	    if (!params.protocol) {
	        if (params.scheme) {
	            params.protocol = params.scheme + ':';
	        } else {
	            params.protocol = window.location.protocol;
	        }
	    }
	
	    if (!params.host) {
	        params.host = window.location.hostname || window.location.host;
	    }
	    if (/:/.test(params.host)) {
	        if (!params.port) {
	            params.port = params.host.split(':')[1];
	        }
	        params.host = params.host.split(':')[0];
	    }
	    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;
	    
	    var req = new Request(new xhrHttp, params);
	    if (cb) req.on('response', cb);
	    return req;
	};
	
	http.get = function (params, cb) {
	    params.method = 'GET';
	    var req = http.request(params, cb);
	    req.end();
	    return req;
	};
	
	http.Agent = function () {};
	http.Agent.defaultMaxSockets = 4;
	
	var xhrHttp = (function () {
	    if (typeof window === 'undefined') {
	        throw new Error('no window object present');
	    }
	    else if (window.XMLHttpRequest) {
	        return window.XMLHttpRequest;
	    }
	    else if (window.ActiveXObject) {
	        var axs = [
	            'Msxml2.XMLHTTP.6.0',
	            'Msxml2.XMLHTTP.3.0',
	            'Microsoft.XMLHTTP'
	        ];
	        for (var i = 0; i < axs.length; i++) {
	            try {
	                var ax = new(window.ActiveXObject)(axs[i]);
	                return function () {
	                    if (ax) {
	                        var ax_ = ax;
	                        ax = null;
	                        return ax_;
	                    }
	                    else {
	                        return new(window.ActiveXObject)(axs[i]);
	                    }
	                };
	            }
	            catch (e) {}
	        }
	        throw new Error('ajax not supported in this browser')
	    }
	    else {
	        throw new Error('ajax not supported in this browser');
	    }
	})();
	
	http.STATUS_CODES = {
	    100 : 'Continue',
	    101 : 'Switching Protocols',
	    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
	    200 : 'OK',
	    201 : 'Created',
	    202 : 'Accepted',
	    203 : 'Non-Authoritative Information',
	    204 : 'No Content',
	    205 : 'Reset Content',
	    206 : 'Partial Content',
	    207 : 'Multi-Status',               // RFC 4918
	    300 : 'Multiple Choices',
	    301 : 'Moved Permanently',
	    302 : 'Moved Temporarily',
	    303 : 'See Other',
	    304 : 'Not Modified',
	    305 : 'Use Proxy',
	    307 : 'Temporary Redirect',
	    400 : 'Bad Request',
	    401 : 'Unauthorized',
	    402 : 'Payment Required',
	    403 : 'Forbidden',
	    404 : 'Not Found',
	    405 : 'Method Not Allowed',
	    406 : 'Not Acceptable',
	    407 : 'Proxy Authentication Required',
	    408 : 'Request Time-out',
	    409 : 'Conflict',
	    410 : 'Gone',
	    411 : 'Length Required',
	    412 : 'Precondition Failed',
	    413 : 'Request Entity Too Large',
	    414 : 'Request-URI Too Large',
	    415 : 'Unsupported Media Type',
	    416 : 'Requested Range Not Satisfiable',
	    417 : 'Expectation Failed',
	    418 : 'I\'m a teapot',              // RFC 2324
	    422 : 'Unprocessable Entity',       // RFC 4918
	    423 : 'Locked',                     // RFC 4918
	    424 : 'Failed Dependency',          // RFC 4918
	    425 : 'Unordered Collection',       // RFC 4918
	    426 : 'Upgrade Required',           // RFC 2817
	    428 : 'Precondition Required',      // RFC 6585
	    429 : 'Too Many Requests',          // RFC 6585
	    431 : 'Request Header Fields Too Large',// RFC 6585
	    500 : 'Internal Server Error',
	    501 : 'Not Implemented',
	    502 : 'Bad Gateway',
	    503 : 'Service Unavailable',
	    504 : 'Gateway Time-out',
	    505 : 'HTTP Version Not Supported',
	    506 : 'Variant Also Negotiates',    // RFC 2295
	    507 : 'Insufficient Storage',       // RFC 4918
	    509 : 'Bandwidth Limit Exceeded',
	    510 : 'Not Extended',               // RFC 2774
	    511 : 'Network Authentication Required' // RFC 6585
	};

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(54);
	var Response = __webpack_require__(109);
	var Base64 = __webpack_require__(110);
	var inherits = __webpack_require__(52);
	
	var Request = module.exports = function (xhr, params) {
	    var self = this;
	    self.writable = true;
	    self.xhr = xhr;
	    self.body = [];
	    
	    self.uri = (params.protocol || 'http:') + '//'
	        + params.host
	        + (params.port ? ':' + params.port : '')
	        + (params.path || '/')
	    ;
	    
	    if (typeof params.withCredentials === 'undefined') {
	        params.withCredentials = true;
	    }
	
	    try { xhr.withCredentials = params.withCredentials }
	    catch (e) {}
	    
	    if (params.responseType) try { xhr.responseType = params.responseType }
	    catch (e) {}
	    
	    xhr.open(
	        params.method || 'GET',
	        self.uri,
	        true
	    );
	
	    xhr.onerror = function(event) {
	        self.emit('error', new Error('Network error'));
	    };
	
	    self._headers = {};
	    
	    if (params.headers) {
	        var keys = objectKeys(params.headers);
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (!self.isSafeRequestHeader(key)) continue;
	            var value = params.headers[key];
	            self.setHeader(key, value);
	        }
	    }
	    
	    if (params.auth) {
	        //basic auth
	        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
	    }
	
	    var res = new Response;
	    res.on('close', function () {
	        self.emit('close');
	    });
	    
	    res.on('ready', function () {
	        self.emit('response', res);
	    });
	
	    res.on('error', function (err) {
	        self.emit('error', err);
	    });
	    
	    xhr.onreadystatechange = function () {
	        // Fix for IE9 bug
	        // SCRIPT575: Could not complete the operation due to error c00c023f
	        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
	        if (xhr.__aborted) return;
	        res.handle(xhr);
	    };
	};
	
	inherits(Request, Stream);
	
	Request.prototype.setHeader = function (key, value) {
	    this._headers[key.toLowerCase()] = value
	};
	
	Request.prototype.getHeader = function (key) {
	    return this._headers[key.toLowerCase()]
	};
	
	Request.prototype.removeHeader = function (key) {
	    delete this._headers[key.toLowerCase()]
	};
	
	Request.prototype.write = function (s) {
	    this.body.push(s);
	};
	
	Request.prototype.destroy = function (s) {
	    this.xhr.__aborted = true;
	    this.xhr.abort();
	    this.emit('close');
	};
	
	Request.prototype.end = function (s) {
	    if (s !== undefined) this.body.push(s);
	
	    var keys = objectKeys(this._headers);
	    for (var i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        var value = this._headers[key];
	        if (isArray(value)) {
	            for (var j = 0; j < value.length; j++) {
	                this.xhr.setRequestHeader(key, value[j]);
	            }
	        }
	        else this.xhr.setRequestHeader(key, value)
	    }
	
	    if (this.body.length === 0) {
	        this.xhr.send('');
	    }
	    else if (typeof this.body[0] === 'string') {
	        this.xhr.send(this.body.join(''));
	    }
	    else if (isArray(this.body[0])) {
	        var body = [];
	        for (var i = 0; i < this.body.length; i++) {
	            body.push.apply(body, this.body[i]);
	        }
	        this.xhr.send(body);
	    }
	    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
	        var len = 0;
	        for (var i = 0; i < this.body.length; i++) {
	            len += this.body[i].length;
	        }
	        var body = new(this.body[0].constructor)(len);
	        var k = 0;
	        
	        for (var i = 0; i < this.body.length; i++) {
	            var b = this.body[i];
	            for (var j = 0; j < b.length; j++) {
	                body[k++] = b[j];
	            }
	        }
	        this.xhr.send(body);
	    }
	    else if (isXHR2Compatible(this.body[0])) {
	        this.xhr.send(this.body[0]);
	    }
	    else {
	        var body = '';
	        for (var i = 0; i < this.body.length; i++) {
	            body += this.body[i].toString();
	        }
	        this.xhr.send(body);
	    }
	};
	
	// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
	Request.unsafeHeaders = [
	    "accept-charset",
	    "accept-encoding",
	    "access-control-request-headers",
	    "access-control-request-method",
	    "connection",
	    "content-length",
	    "cookie",
	    "cookie2",
	    "content-transfer-encoding",
	    "date",
	    "expect",
	    "host",
	    "keep-alive",
	    "origin",
	    "referer",
	    "te",
	    "trailer",
	    "transfer-encoding",
	    "upgrade",
	    "user-agent",
	    "via"
	];
	
	Request.prototype.isSafeRequestHeader = function (headerName) {
	    if (!headerName) return false;
	    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
	};
	
	var objectKeys = Object.keys || function (obj) {
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    return keys;
	};
	
	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};
	
	var indexOf = function (xs, x) {
	    if (xs.indexOf) return xs.indexOf(x);
	    for (var i = 0; i < xs.length; i++) {
	        if (xs[i] === x) return i;
	    }
	    return -1;
	};
	
	var isXHR2Compatible = function (obj) {
	    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
	    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
	    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
	};


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(54);
	var util = __webpack_require__(77);
	
	var Response = module.exports = function (res) {
	    this.offset = 0;
	    this.readable = true;
	};
	
	util.inherits(Response, Stream);
	
	var capable = {
	    streaming : true,
	    status2 : true
	};
	
	function parseHeaders (res) {
	    var lines = res.getAllResponseHeaders().split(/\r?\n/);
	    var headers = {};
	    for (var i = 0; i < lines.length; i++) {
	        var line = lines[i];
	        if (line === '') continue;
	        
	        var m = line.match(/^([^:]+):\s*(.*)/);
	        if (m) {
	            var key = m[1].toLowerCase(), value = m[2];
	            
	            if (headers[key] !== undefined) {
	            
	                if (isArray(headers[key])) {
	                    headers[key].push(value);
	                }
	                else {
	                    headers[key] = [ headers[key], value ];
	                }
	            }
	            else {
	                headers[key] = value;
	            }
	        }
	        else {
	            headers[line] = true;
	        }
	    }
	    return headers;
	}
	
	Response.prototype.getResponse = function (xhr) {
	    var respType = String(xhr.responseType).toLowerCase();
	    if (respType === 'blob') return xhr.responseBlob || xhr.response;
	    if (respType === 'arraybuffer') return xhr.response;
	    return xhr.responseText;
	}
	
	Response.prototype.getHeader = function (key) {
	    return this.headers[key.toLowerCase()];
	};
	
	Response.prototype.handle = function (res) {
	    if (res.readyState === 2 && capable.status2) {
	        try {
	            this.statusCode = res.status;
	            this.headers = parseHeaders(res);
	        }
	        catch (err) {
	            capable.status2 = false;
	        }
	        
	        if (capable.status2) {
	            this.emit('ready');
	        }
	    }
	    else if (capable.streaming && res.readyState === 3) {
	        try {
	            if (!this.statusCode) {
	                this.statusCode = res.status;
	                this.headers = parseHeaders(res);
	                this.emit('ready');
	            }
	        }
	        catch (err) {}
	        
	        try {
	            this._emitData(res);
	        }
	        catch (err) {
	            capable.streaming = false;
	        }
	    }
	    else if (res.readyState === 4) {
	        if (!this.statusCode) {
	            this.statusCode = res.status;
	            this.emit('ready');
	        }
	        this._emitData(res);
	        
	        if (res.error) {
	            this.emit('error', this.getResponse(res));
	        }
	        else this.emit('end');
	        
	        this.emit('close');
	    }
	};
	
	Response.prototype._emitData = function (res) {
	    var respBody = this.getResponse(res);
	    if (respBody.toString().match(/ArrayBuffer/)) {
	        this.emit('data', new Uint8Array(respBody, this.offset));
	        this.offset = respBody.byteLength;
	        return;
	    }
	    if (respBody.length > this.offset) {
	        this.emit('data', respBody.slice(this.offset));
	        this.offset = respBody.length;
	    }
	};
	
	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	;(function () {
	
	  var object =  true ? exports : this; // #8: web workers
	  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	
	  function InvalidCharacterError(message) {
	    this.message = message;
	  }
	  InvalidCharacterError.prototype = new Error;
	  InvalidCharacterError.prototype.name = 'InvalidCharacterError';
	
	  // encoder
	  // [https://gist.github.com/999166] by [https://github.com/nignag]
	  object.btoa || (
	  object.btoa = function (input) {
	    for (
	      // initialize result and counter
	      var block, charCode, idx = 0, map = chars, output = '';
	      // if the next input index does not exist:
	      //   change the mapping table to "="
	      //   check if d has no fractional digits
	      input.charAt(idx | 0) || (map = '=', idx % 1);
	      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
	    ) {
	      charCode = input.charCodeAt(idx += 3/4);
	      if (charCode > 0xFF) {
	        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
	      }
	      block = block << 8 | charCode;
	    }
	    return output;
	  });
	
	  // decoder
	  // [https://gist.github.com/1020396] by [https://github.com/atk]
	  object.atob || (
	  object.atob = function (input) {
	    input = input.replace(/=+$/, '');
	    if (input.length % 4 == 1) {
	      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
	    }
	    for (
	      // initialize result and counters
	      var bc = 0, bs, buffer, idx = 0, output = '';
	      // get next character
	      buffer = input.charAt(idx++);
	      // character found in table? initialize bit storage and add its ascii value;
	      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
	        // and if not first of each 4 characters,
	        // convert the first 8 bits to one ascii character
	        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
	    ) {
	      // try to find character in table (0-63, not found => -1)
	      buffer = chars.indexOf(buffer);
	    }
	    return output;
	  });
	
	}());


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, setImmediate) {/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var contentDisposition = __webpack_require__(47);
	var deprecate = __webpack_require__(30)('express');
	var encodeUrl = __webpack_require__(68);
	var escapeHtml = __webpack_require__(16);
	var http = __webpack_require__(107);
	var isAbsolute = __webpack_require__(46).isAbsolute;
	var onFinished = __webpack_require__(17);
	var path = __webpack_require__(45);
	var merge = __webpack_require__(29);
	var sign = __webpack_require__(112).sign;
	var normalizeType = __webpack_require__(46).normalizeType;
	var normalizeTypes = __webpack_require__(46).normalizeTypes;
	var setCharset = __webpack_require__(46).setCharset;
	var statusCodes = http.STATUS_CODES;
	var cookie = __webpack_require__(113);
	var send = __webpack_require__(49);
	var extname = path.extname;
	var mime = send.mime;
	var resolve = path.resolve;
	var vary = __webpack_require__(114);
	
	/**
	 * Response prototype.
	 */
	
	var res = module.exports = {
	  __proto__: http.ServerResponse.prototype
	};
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var charsetRegExp = /;\s*charset\s*=/;
	
	/**
	 * Set status `code`.
	 *
	 * @param {Number} code
	 * @return {ServerResponse}
	 * @public
	 */
	
	res.status = function status(code) {
	  this.statusCode = code;
	  return this;
	};
	
	/**
	 * Set Link header field with the given `links`.
	 *
	 * Examples:
	 *
	 *    res.links({
	 *      next: 'http://api.example.com/users?page=2',
	 *      last: 'http://api.example.com/users?page=5'
	 *    });
	 *
	 * @param {Object} links
	 * @return {ServerResponse}
	 * @public
	 */
	
	res.links = function(links){
	  var link = this.get('Link') || '';
	  if (link) link += ', ';
	  return this.set('Link', link + Object.keys(links).map(function(rel){
	    return '<' + links[rel] + '>; rel="' + rel + '"';
	  }).join(', '));
	};
	
	/**
	 * Send a response.
	 *
	 * Examples:
	 *
	 *     res.send(new Buffer('wahoo'));
	 *     res.send({ some: 'json' });
	 *     res.send('<p>some html</p>');
	 *
	 * @param {string|number|boolean|object|Buffer} body
	 * @public
	 */
	
	res.send = function send(body) {
	  var chunk = body;
	  var encoding;
	  var len;
	  var req = this.req;
	  var type;
	
	  // settings
	  var app = this.app;
	
	  // allow status / body
	  if (arguments.length === 2) {
	    // res.send(body, status) backwards compat
	    if (typeof arguments[0] !== 'number' && typeof arguments[1] === 'number') {
	      deprecate('res.send(body, status): Use res.status(status).send(body) instead');
	      this.statusCode = arguments[1];
	    } else {
	      deprecate('res.send(status, body): Use res.status(status).send(body) instead');
	      this.statusCode = arguments[0];
	      chunk = arguments[1];
	    }
	  }
	
	  // disambiguate res.send(status) and res.send(status, num)
	  if (typeof chunk === 'number' && arguments.length === 1) {
	    // res.send(status) will set status message as text string
	    if (!this.get('Content-Type')) {
	      this.type('txt');
	    }
	
	    deprecate('res.send(status): Use res.sendStatus(status) instead');
	    this.statusCode = chunk;
	    chunk = statusCodes[chunk];
	  }
	
	  switch (typeof chunk) {
	    // string defaulting to html
	    case 'string':
	      if (!this.get('Content-Type')) {
	        this.type('html');
	      }
	      break;
	    case 'boolean':
	    case 'number':
	    case 'object':
	      if (chunk === null) {
	        chunk = '';
	      } else if (Buffer.isBuffer(chunk)) {
	        if (!this.get('Content-Type')) {
	          this.type('bin');
	        }
	      } else {
	        return this.json(chunk);
	      }
	      break;
	  }
	
	  // write strings in utf-8
	  if (typeof chunk === 'string') {
	    encoding = 'utf8';
	    type = this.get('Content-Type');
	
	    // reflect this in content-type
	    if (typeof type === 'string') {
	      this.set('Content-Type', setCharset(type, 'utf-8'));
	    }
	  }
	
	  // populate Content-Length
	  if (chunk !== undefined) {
	    if (!Buffer.isBuffer(chunk)) {
	      // convert chunk to Buffer; saves later double conversions
	      chunk = new Buffer(chunk, encoding);
	      encoding = undefined;
	    }
	
	    len = chunk.length;
	    this.set('Content-Length', len);
	  }
	
	  // populate ETag
	  var etag;
	  var generateETag = len !== undefined && app.get('etag fn');
	  if (typeof generateETag === 'function' && !this.get('ETag')) {
	    if ((etag = generateETag(chunk, encoding))) {
	      this.set('ETag', etag);
	    }
	  }
	
	  // freshness
	  if (req.fresh) this.statusCode = 304;
	
	  // strip irrelevant headers
	  if (204 === this.statusCode || 304 === this.statusCode) {
	    this.removeHeader('Content-Type');
	    this.removeHeader('Content-Length');
	    this.removeHeader('Transfer-Encoding');
	    chunk = '';
	  }
	
	  if (req.method === 'HEAD') {
	    // skip body for HEAD
	    this.end();
	  } else {
	    // respond
	    this.end(chunk, encoding);
	  }
	
	  return this;
	};
	
	/**
	 * Send JSON response.
	 *
	 * Examples:
	 *
	 *     res.json(null);
	 *     res.json({ user: 'tj' });
	 *
	 * @param {string|number|boolean|object} obj
	 * @public
	 */
	
	res.json = function json(obj) {
	  var val = obj;
	
	  // allow status / body
	  if (arguments.length === 2) {
	    // res.json(body, status) backwards compat
	    if (typeof arguments[1] === 'number') {
	      deprecate('res.json(obj, status): Use res.status(status).json(obj) instead');
	      this.statusCode = arguments[1];
	    } else {
	      deprecate('res.json(status, obj): Use res.status(status).json(obj) instead');
	      this.statusCode = arguments[0];
	      val = arguments[1];
	    }
	  }
	
	  // settings
	  var app = this.app;
	  var replacer = app.get('json replacer');
	  var spaces = app.get('json spaces');
	  var body = stringify(val, replacer, spaces);
	
	  // content-type
	  if (!this.get('Content-Type')) {
	    this.set('Content-Type', 'application/json');
	  }
	
	  return this.send(body);
	};
	
	/**
	 * Send JSON response with JSONP callback support.
	 *
	 * Examples:
	 *
	 *     res.jsonp(null);
	 *     res.jsonp({ user: 'tj' });
	 *
	 * @param {string|number|boolean|object} obj
	 * @public
	 */
	
	res.jsonp = function jsonp(obj) {
	  var val = obj;
	
	  // allow status / body
	  if (arguments.length === 2) {
	    // res.json(body, status) backwards compat
	    if (typeof arguments[1] === 'number') {
	      deprecate('res.jsonp(obj, status): Use res.status(status).json(obj) instead');
	      this.statusCode = arguments[1];
	    } else {
	      deprecate('res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead');
	      this.statusCode = arguments[0];
	      val = arguments[1];
	    }
	  }
	
	  // settings
	  var app = this.app;
	  var replacer = app.get('json replacer');
	  var spaces = app.get('json spaces');
	  var body = stringify(val, replacer, spaces);
	  var callback = this.req.query[app.get('jsonp callback name')];
	
	  // content-type
	  if (!this.get('Content-Type')) {
	    this.set('X-Content-Type-Options', 'nosniff');
	    this.set('Content-Type', 'application/json');
	  }
	
	  // fixup callback
	  if (Array.isArray(callback)) {
	    callback = callback[0];
	  }
	
	  // jsonp
	  if (typeof callback === 'string' && callback.length !== 0) {
	    this.charset = 'utf-8';
	    this.set('X-Content-Type-Options', 'nosniff');
	    this.set('Content-Type', 'text/javascript');
	
	    // restrict callback charset
	    callback = callback.replace(/[^\[\]\w$.]/g, '');
	
	    // replace chars not allowed in JavaScript that are in JSON
	    body = body
	      .replace(/\u2028/g, '\\u2028')
	      .replace(/\u2029/g, '\\u2029');
	
	    // the /**/ is a specific security mitigation for "Rosetta Flash JSONP abuse"
	    // the typeof check is just to reduce client error noise
	    body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
	  }
	
	  return this.send(body);
	};
	
	/**
	 * Send given HTTP status code.
	 *
	 * Sets the response status to `statusCode` and the body of the
	 * response to the standard description from node's http.STATUS_CODES
	 * or the statusCode number if no description.
	 *
	 * Examples:
	 *
	 *     res.sendStatus(200);
	 *
	 * @param {number} statusCode
	 * @public
	 */
	
	res.sendStatus = function sendStatus(statusCode) {
	  var body = statusCodes[statusCode] || String(statusCode);
	
	  this.statusCode = statusCode;
	  this.type('txt');
	
	  return this.send(body);
	};
	
	/**
	 * Transfer the file at the given `path`.
	 *
	 * Automatically sets the _Content-Type_ response header field.
	 * The callback `callback(err)` is invoked when the transfer is complete
	 * or when an error occurs. Be sure to check `res.sentHeader`
	 * if you wish to attempt responding, as the header and some data
	 * may have already been transferred.
	 *
	 * Options:
	 *
	 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
	 *   - `root`     root directory for relative filenames
	 *   - `headers`  object of headers to serve with file
	 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
	 *
	 * Other options are passed along to `send`.
	 *
	 * Examples:
	 *
	 *  The following example illustrates how `res.sendFile()` may
	 *  be used as an alternative for the `static()` middleware for
	 *  dynamic situations. The code backing `res.sendFile()` is actually
	 *  the same code, so HTTP cache support etc is identical.
	 *
	 *     app.get('/user/:uid/photos/:file', function(req, res){
	 *       var uid = req.params.uid
	 *         , file = req.params.file;
	 *
	 *       req.user.mayViewFilesFrom(uid, function(yes){
	 *         if (yes) {
	 *           res.sendFile('/uploads/' + uid + '/' + file);
	 *         } else {
	 *           res.send(403, 'Sorry! you cant see that.');
	 *         }
	 *       });
	 *     });
	 *
	 * @public
	 */
	
	res.sendFile = function sendFile(path, options, callback) {
	  var done = callback;
	  var req = this.req;
	  var res = this;
	  var next = req.next;
	  var opts = options || {};
	
	  if (!path) {
	    throw new TypeError('path argument is required to res.sendFile');
	  }
	
	  // support function as second arg
	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }
	
	  if (!opts.root && !isAbsolute(path)) {
	    throw new TypeError('path must be absolute or specify root to res.sendFile');
	  }
	
	  // create file stream
	  var pathname = encodeURI(path);
	  var file = send(req, pathname, opts);
	
	  // transfer
	  sendfile(res, file, opts, function (err) {
	    if (done) return done(err);
	    if (err && err.code === 'EISDIR') return next();
	
	    // next() all but write errors
	    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
	      next(err);
	    }
	  });
	};
	
	/**
	 * Transfer the file at the given `path`.
	 *
	 * Automatically sets the _Content-Type_ response header field.
	 * The callback `callback(err)` is invoked when the transfer is complete
	 * or when an error occurs. Be sure to check `res.sentHeader`
	 * if you wish to attempt responding, as the header and some data
	 * may have already been transferred.
	 *
	 * Options:
	 *
	 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
	 *   - `root`     root directory for relative filenames
	 *   - `headers`  object of headers to serve with file
	 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
	 *
	 * Other options are passed along to `send`.
	 *
	 * Examples:
	 *
	 *  The following example illustrates how `res.sendfile()` may
	 *  be used as an alternative for the `static()` middleware for
	 *  dynamic situations. The code backing `res.sendfile()` is actually
	 *  the same code, so HTTP cache support etc is identical.
	 *
	 *     app.get('/user/:uid/photos/:file', function(req, res){
	 *       var uid = req.params.uid
	 *         , file = req.params.file;
	 *
	 *       req.user.mayViewFilesFrom(uid, function(yes){
	 *         if (yes) {
	 *           res.sendfile('/uploads/' + uid + '/' + file);
	 *         } else {
	 *           res.send(403, 'Sorry! you cant see that.');
	 *         }
	 *       });
	 *     });
	 *
	 * @public
	 */
	
	res.sendfile = function (path, options, callback) {
	  var done = callback;
	  var req = this.req;
	  var res = this;
	  var next = req.next;
	  var opts = options || {};
	
	  // support function as second arg
	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }
	
	  // create file stream
	  var file = send(req, path, opts);
	
	  // transfer
	  sendfile(res, file, opts, function (err) {
	    if (done) return done(err);
	    if (err && err.code === 'EISDIR') return next();
	
	    // next() all but write errors
	    if (err && err.code !== 'ECONNABORT' && err.syscall !== 'write') {
	      next(err);
	    }
	  });
	};
	
	res.sendfile = deprecate.function(res.sendfile,
	  'res.sendfile: Use res.sendFile instead');
	
	/**
	 * Transfer the file at the given `path` as an attachment.
	 *
	 * Optionally providing an alternate attachment `filename`,
	 * and optional callback `callback(err)`. The callback is invoked
	 * when the data transfer is complete, or when an error has
	 * ocurred. Be sure to check `res.headersSent` if you plan to respond.
	 *
	 * This method uses `res.sendfile()`.
	 *
	 * @public
	 */
	
	res.download = function download(path, filename, callback) {
	  var done = callback;
	  var name = filename;
	
	  // support function as second arg
	  if (typeof filename === 'function') {
	    done = filename;
	    name = null;
	  }
	
	  // set Content-Disposition when file is sent
	  var headers = {
	    'Content-Disposition': contentDisposition(name || path)
	  };
	
	  // Resolve the full path for sendFile
	  var fullPath = resolve(path);
	
	  return this.sendFile(fullPath, { headers: headers }, done);
	};
	
	/**
	 * Set _Content-Type_ response header with `type` through `mime.lookup()`
	 * when it does not contain "/", or set the Content-Type to `type` otherwise.
	 *
	 * Examples:
	 *
	 *     res.type('.html');
	 *     res.type('html');
	 *     res.type('json');
	 *     res.type('application/json');
	 *     res.type('png');
	 *
	 * @param {String} type
	 * @return {ServerResponse} for chaining
	 * @public
	 */
	
	res.contentType =
	res.type = function contentType(type) {
	  var ct = type.indexOf('/') === -1
	    ? mime.lookup(type)
	    : type;
	
	  return this.set('Content-Type', ct);
	};
	
	/**
	 * Respond to the Acceptable formats using an `obj`
	 * of mime-type callbacks.
	 *
	 * This method uses `req.accepted`, an array of
	 * acceptable types ordered by their quality values.
	 * When "Accept" is not present the _first_ callback
	 * is invoked, otherwise the first match is used. When
	 * no match is performed the server responds with
	 * 406 "Not Acceptable".
	 *
	 * Content-Type is set for you, however if you choose
	 * you may alter this within the callback using `res.type()`
	 * or `res.set('Content-Type', ...)`.
	 *
	 *    res.format({
	 *      'text/plain': function(){
	 *        res.send('hey');
	 *      },
	 *
	 *      'text/html': function(){
	 *        res.send('<p>hey</p>');
	 *      },
	 *
	 *      'appliation/json': function(){
	 *        res.send({ message: 'hey' });
	 *      }
	 *    });
	 *
	 * In addition to canonicalized MIME types you may
	 * also use extnames mapped to these types:
	 *
	 *    res.format({
	 *      text: function(){
	 *        res.send('hey');
	 *      },
	 *
	 *      html: function(){
	 *        res.send('<p>hey</p>');
	 *      },
	 *
	 *      json: function(){
	 *        res.send({ message: 'hey' });
	 *      }
	 *    });
	 *
	 * By default Express passes an `Error`
	 * with a `.status` of 406 to `next(err)`
	 * if a match is not made. If you provide
	 * a `.default` callback it will be invoked
	 * instead.
	 *
	 * @param {Object} obj
	 * @return {ServerResponse} for chaining
	 * @public
	 */
	
	res.format = function(obj){
	  var req = this.req;
	  var next = req.next;
	
	  var fn = obj.default;
	  if (fn) delete obj.default;
	  var keys = Object.keys(obj);
	
	  var key = keys.length > 0
	    ? req.accepts(keys)
	    : false;
	
	  this.vary("Accept");
	
	  if (key) {
	    this.set('Content-Type', normalizeType(key).value);
	    obj[key](req, this, next);
	  } else if (fn) {
	    fn();
	  } else {
	    var err = new Error('Not Acceptable');
	    err.status = err.statusCode = 406;
	    err.types = normalizeTypes(keys).map(function(o){ return o.value });
	    next(err);
	  }
	
	  return this;
	};
	
	/**
	 * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
	 *
	 * @param {String} filename
	 * @return {ServerResponse}
	 * @public
	 */
	
	res.attachment = function attachment(filename) {
	  if (filename) {
	    this.type(extname(filename));
	  }
	
	  this.set('Content-Disposition', contentDisposition(filename));
	
	  return this;
	};
	
	/**
	 * Append additional header `field` with value `val`.
	 *
	 * Example:
	 *
	 *    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
	 *    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
	 *    res.append('Warning', '199 Miscellaneous warning');
	 *
	 * @param {String} field
	 * @param {String|Array} val
	 * @return {ServerResponse} for chaining
	 * @public
	 */
	
	res.append = function append(field, val) {
	  var prev = this.get(field);
	  var value = val;
	
	  if (prev) {
	    // concat the new and prev vals
	    value = Array.isArray(prev) ? prev.concat(val)
	      : Array.isArray(val) ? [prev].concat(val)
	      : [prev, val];
	  }
	
	  return this.set(field, value);
	};
	
	/**
	 * Set header `field` to `val`, or pass
	 * an object of header fields.
	 *
	 * Examples:
	 *
	 *    res.set('Foo', ['bar', 'baz']);
	 *    res.set('Accept', 'application/json');
	 *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
	 *
	 * Aliased as `res.header()`.
	 *
	 * @param {String|Object} field
	 * @param {String|Array} val
	 * @return {ServerResponse} for chaining
	 * @public
	 */
	
	res.set =
	res.header = function header(field, val) {
	  if (arguments.length === 2) {
	    var value = Array.isArray(val)
	      ? val.map(String)
	      : String(val);
	
	    // add charset to content-type
	    if (field.toLowerCase() === 'content-type' && !charsetRegExp.test(value)) {
	      var charset = mime.charsets.lookup(value.split(';')[0]);
	      if (charset) value += '; charset=' + charset.toLowerCase();
	    }
	
	    this.setHeader(field, value);
	  } else {
	    for (var key in field) {
	      this.set(key, field[key]);
	    }
	  }
	  return this;
	};
	
	/**
	 * Get value for header `field`.
	 *
	 * @param {String} field
	 * @return {String}
	 * @public
	 */
	
	res.get = function(field){
	  return this.getHeader(field);
	};
	
	/**
	 * Clear cookie `name`.
	 *
	 * @param {String} name
	 * @param {Object} [options]
	 * @return {ServerResponse} for chaining
	 * @public
	 */
	
	res.clearCookie = function clearCookie(name, options) {
	  var opts = merge({ expires: new Date(1), path: '/' }, options);
	
	  return this.cookie(name, '', opts);
	};
	
	/**
	 * Set cookie `name` to `value`, with the given `options`.
	 *
	 * Options:
	 *
	 *    - `maxAge`   max-age in milliseconds, converted to `expires`
	 *    - `signed`   sign the cookie
	 *    - `path`     defaults to "/"
	 *
	 * Examples:
	 *
	 *    // "Remember Me" for 15 minutes
	 *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
	 *
	 *    // save as above
	 *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
	 *
	 * @param {String} name
	 * @param {String|Object} value
	 * @param {Options} options
	 * @return {ServerResponse} for chaining
	 * @public
	 */
	
	res.cookie = function (name, value, options) {
	  var opts = merge({}, options);
	  var secret = this.req.secret;
	  var signed = opts.signed;
	
	  if (signed && !secret) {
	    throw new Error('cookieParser("secret") required for signed cookies');
	  }
	
	  var val = typeof value === 'object'
	    ? 'j:' + JSON.stringify(value)
	    : String(value);
	
	  if (signed) {
	    val = 's:' + sign(val, secret);
	  }
	
	  if ('maxAge' in opts) {
	    opts.expires = new Date(Date.now() + opts.maxAge);
	    opts.maxAge /= 1000;
	  }
	
	  if (opts.path == null) {
	    opts.path = '/';
	  }
	
	  this.append('Set-Cookie', cookie.serialize(name, String(val), opts));
	
	  return this;
	};
	
	/**
	 * Set the location header to `url`.
	 *
	 * The given `url` can also be "back", which redirects
	 * to the _Referrer_ or _Referer_ headers or "/".
	 *
	 * Examples:
	 *
	 *    res.location('/foo/bar').;
	 *    res.location('http://example.com');
	 *    res.location('../login');
	 *
	 * @param {String} url
	 * @return {ServerResponse} for chaining
	 * @public
	 */
	
	res.location = function location(url) {
	  var loc = url;
	
	  // "back" is an alias for the referrer
	  if (url === 'back') {
	    loc = this.req.get('Referrer') || '/';
	  }
	
	  // set location
	  return this.set('Location', encodeUrl(loc));
	};
	
	/**
	 * Redirect to the given `url` with optional response `status`
	 * defaulting to 302.
	 *
	 * The resulting `url` is determined by `res.location()`, so
	 * it will play nicely with mounted apps, relative paths,
	 * `"back"` etc.
	 *
	 * Examples:
	 *
	 *    res.redirect('/foo/bar');
	 *    res.redirect('http://example.com');
	 *    res.redirect(301, 'http://example.com');
	 *    res.redirect('../login'); // /blog/post/1 -> /blog/login
	 *
	 * @public
	 */
	
	res.redirect = function redirect(url) {
	  var address = url;
	  var body;
	  var status = 302;
	
	  // allow status / url
	  if (arguments.length === 2) {
	    if (typeof arguments[0] === 'number') {
	      status = arguments[0];
	      address = arguments[1];
	    } else {
	      deprecate('res.redirect(url, status): Use res.redirect(status, url) instead');
	      status = arguments[1];
	    }
	  }
	
	  // Set location header
	  address = this.location(address).get('Location');
	
	  // Support text/{plain,html} by default
	  this.format({
	    text: function(){
	      body = statusCodes[status] + '. Redirecting to ' + address;
	    },
	
	    html: function(){
	      var u = escapeHtml(address);
	      body = '<p>' + statusCodes[status] + '. Redirecting to <a href="' + u + '">' + u + '</a></p>';
	    },
	
	    default: function(){
	      body = '';
	    }
	  });
	
	  // Respond
	  this.statusCode = status;
	  this.set('Content-Length', Buffer.byteLength(body));
	
	  if (this.req.method === 'HEAD') {
	    this.end();
	  } else {
	    this.end(body);
	  }
	};
	
	/**
	 * Add `field` to Vary. If already present in the Vary set, then
	 * this call is simply ignored.
	 *
	 * @param {Array|String} field
	 * @return {ServerResponse} for chaining
	 * @public
	 */
	
	res.vary = function(field){
	  // checks for back-compat
	  if (!field || (Array.isArray(field) && !field.length)) {
	    deprecate('res.vary(): Provide a field name');
	    return this;
	  }
	
	  vary(this, field);
	
	  return this;
	};
	
	/**
	 * Render `view` with the given `options` and optional callback `fn`.
	 * When a callback function is given a response will _not_ be made
	 * automatically, otherwise a response of _200_ and _text/html_ is given.
	 *
	 * Options:
	 *
	 *  - `cache`     boolean hinting to the engine it should cache
	 *  - `filename`  filename of the view being rendered
	 *
	 * @public
	 */
	
	res.render = function render(view, options, callback) {
	  var app = this.req.app;
	  var done = callback;
	  var opts = options || {};
	  var req = this.req;
	  var self = this;
	
	  // support callback function as second arg
	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }
	
	  // merge res.locals
	  opts._locals = self.locals;
	
	  // default callback to respond
	  done = done || function (err, str) {
	    if (err) return req.next(err);
	    self.send(str);
	  };
	
	  // render
	  app.render(view, opts, done);
	};
	
	// pipe the send file stream
	function sendfile(res, file, options, callback) {
	  var done = false;
	  var streaming;
	
	  // request aborted
	  function onaborted() {
	    if (done) return;
	    done = true;
	
	    var err = new Error('Request aborted');
	    err.code = 'ECONNABORTED';
	    callback(err);
	  }
	
	  // directory
	  function ondirectory() {
	    if (done) return;
	    done = true;
	
	    var err = new Error('EISDIR, read');
	    err.code = 'EISDIR';
	    callback(err);
	  }
	
	  // errors
	  function onerror(err) {
	    if (done) return;
	    done = true;
	    callback(err);
	  }
	
	  // ended
	  function onend() {
	    if (done) return;
	    done = true;
	    callback();
	  }
	
	  // file
	  function onfile() {
	    streaming = false;
	  }
	
	  // finished
	  function onfinish(err) {
	    if (err && err.code === 'ECONNRESET') return onaborted();
	    if (err) return onerror(err);
	    if (done) return;
	
	    setImmediate(function () {
	      if (streaming !== false && !done) {
	        onaborted();
	        return;
	      }
	
	      if (done) return;
	      done = true;
	      callback();
	    });
	  }
	
	  // streaming
	  function onstream() {
	    streaming = true;
	  }
	
	  file.on('directory', ondirectory);
	  file.on('end', onend);
	  file.on('error', onerror);
	  file.on('file', onfile);
	  file.on('stream', onstream);
	  onFinished(res, onfinish);
	
	  if (options.headers) {
	    // set headers on successful transfer
	    file.on('headers', function headers(res) {
	      var obj = options.headers;
	      var keys = Object.keys(obj);
	
	      for (var i = 0; i < keys.length; i++) {
	        var k = keys[i];
	        res.setHeader(k, obj[k]);
	      }
	    });
	  }
	
	  // pipe
	  file.pipe(res);
	}
	
	/**
	 * Stringify JSON, like JSON.stringify, but v8 optimized.
	 * @private
	 */
	
	function stringify(value, replacer, spaces) {
	  // v8 checks arguments.length for optimizing simple call
	  // https://bugs.chromium.org/p/v8/issues/detail?id=4730
	  return replacer || spaces
	    ? JSON.stringify(value, replacer, spaces)
	    : JSON.stringify(value);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer, __webpack_require__(8).setImmediate))

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var crypto = __webpack_require__(70);
	
	/**
	 * Sign the given `val` with `secret`.
	 *
	 * @param {String} val
	 * @param {String} secret
	 * @return {String}
	 * @api private
	 */
	
	exports.sign = function(val, secret){
	  if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
	  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
	  return val + '.' + crypto
	    .createHmac('sha256', secret)
	    .update(val)
	    .digest('base64')
	    .replace(/\=+$/, '');
	};
	
	/**
	 * Unsign and decode the given `val` with `secret`,
	 * returning `false` if the signature is invalid.
	 *
	 * @param {String} val
	 * @param {String} secret
	 * @return {String|Boolean}
	 * @api private
	 */
	
	exports.unsign = function(val, secret){
	  if ('string' != typeof val) throw new TypeError("Signed cookie string must be provided.");
	  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
	  var str = val.slice(0, val.lastIndexOf('.'))
	    , mac = exports.sign(str, secret);
	  
	  return sha1(mac) == sha1(val) ? str : false;
	};
	
	/**
	 * Private
	 */
	
	function sha1(str){
	  return crypto.createHash('sha1').update(str).digest('hex');
	}


/***/ },
/* 113 */
/***/ function(module, exports) {

	/*!
	 * cookie
	 * Copyright(c) 2012-2014 Roman Shtylman
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module exports.
	 * @public
	 */
	
	exports.parse = parse;
	exports.serialize = serialize;
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var decode = decodeURIComponent;
	var encode = encodeURIComponent;
	var pairSplitRegExp = /; */;
	
	/**
	 * RegExp to match field-content in RFC 7230 sec 3.2
	 *
	 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
	 * field-vchar   = VCHAR / obs-text
	 * obs-text      = %x80-FF
	 */
	
	var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
	
	/**
	 * Parse a cookie header.
	 *
	 * Parse the given cookie header string into an object
	 * The object has the various cookies as keys(names) => values
	 *
	 * @param {string} str
	 * @param {object} [options]
	 * @return {object}
	 * @public
	 */
	
	function parse(str, options) {
	  if (typeof str !== 'string') {
	    throw new TypeError('argument str must be a string');
	  }
	
	  var obj = {}
	  var opt = options || {};
	  var pairs = str.split(pairSplitRegExp);
	  var dec = opt.decode || decode;
	
	  for (var i = 0; i < pairs.length; i++) {
	    var pair = pairs[i];
	    var eq_idx = pair.indexOf('=');
	
	    // skip things that don't look like key=value
	    if (eq_idx < 0) {
	      continue;
	    }
	
	    var key = pair.substr(0, eq_idx).trim()
	    var val = pair.substr(++eq_idx, pair.length).trim();
	
	    // quoted values
	    if ('"' == val[0]) {
	      val = val.slice(1, -1);
	    }
	
	    // only assign once
	    if (undefined == obj[key]) {
	      obj[key] = tryDecode(val, dec);
	    }
	  }
	
	  return obj;
	}
	
	/**
	 * Serialize data into a cookie header.
	 *
	 * Serialize the a name value pair into a cookie string suitable for
	 * http headers. An optional options object specified cookie parameters.
	 *
	 * serialize('foo', 'bar', { httpOnly: true })
	 *   => "foo=bar; httpOnly"
	 *
	 * @param {string} name
	 * @param {string} val
	 * @param {object} [options]
	 * @return {string}
	 * @public
	 */
	
	function serialize(name, val, options) {
	  var opt = options || {};
	  var enc = opt.encode || encode;
	
	  if (typeof enc !== 'function') {
	    throw new TypeError('option encode is invalid');
	  }
	
	  if (!fieldContentRegExp.test(name)) {
	    throw new TypeError('argument name is invalid');
	  }
	
	  var value = enc(val);
	
	  if (value && !fieldContentRegExp.test(value)) {
	    throw new TypeError('argument val is invalid');
	  }
	
	  var str = name + '=' + value;
	
	  if (null != opt.maxAge) {
	    var maxAge = opt.maxAge - 0;
	    if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
	    str += '; Max-Age=' + Math.floor(maxAge);
	  }
	
	  if (opt.domain) {
	    if (!fieldContentRegExp.test(opt.domain)) {
	      throw new TypeError('option domain is invalid');
	    }
	
	    str += '; Domain=' + opt.domain;
	  }
	
	  if (opt.path) {
	    if (!fieldContentRegExp.test(opt.path)) {
	      throw new TypeError('option path is invalid');
	    }
	
	    str += '; Path=' + opt.path;
	  }
	
	  if (opt.expires) {
	    if (typeof opt.expires.toUTCString !== 'function') {
	      throw new TypeError('option expires is invalid');
	    }
	
	    str += '; Expires=' + opt.expires.toUTCString();
	  }
	
	  if (opt.httpOnly) {
	    str += '; HttpOnly';
	  }
	
	  if (opt.secure) {
	    str += '; Secure';
	  }
	
	  if (opt.sameSite) {
	    var sameSite = typeof opt.sameSite === 'string'
	      ? opt.sameSite.toLowerCase() : opt.sameSite;
	
	    switch (sameSite) {
	      case true:
	        str += '; SameSite=Strict';
	        break;
	      case 'lax':
	        str += '; SameSite=Lax';
	        break;
	      case 'strict':
	        str += '; SameSite=Strict';
	        break;
	      default:
	        throw new TypeError('option sameSite is invalid');
	    }
	  }
	
	  return str;
	}
	
	/**
	 * Try decoding a string using a decoding function.
	 *
	 * @param {string} str
	 * @param {function} decode
	 * @private
	 */
	
	function tryDecode(str, decode) {
	  try {
	    return decode(str);
	  } catch (e) {
	    return str;
	  }
	}


/***/ },
/* 114 */
/***/ function(module, exports) {

	/*!
	 * vary
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module exports.
	 */
	
	module.exports = vary;
	module.exports.append = append;
	
	/**
	 * RegExp to match field-name in RFC 7230 sec 3.2
	 *
	 * field-name    = token
	 * token         = 1*tchar
	 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	 *               / DIGIT / ALPHA
	 *               ; any VCHAR, except delimiters
	 */
	
	var fieldNameRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/
	
	/**
	 * Append a field to a vary header.
	 *
	 * @param {String} header
	 * @param {String|Array} field
	 * @return {String}
	 * @api public
	 */
	
	function append(header, field) {
	  if (typeof header !== 'string') {
	    throw new TypeError('header argument is required');
	  }
	
	  if (!field) {
	    throw new TypeError('field argument is required');
	  }
	
	  // get fields array
	  var fields = !Array.isArray(field)
	    ? parse(String(field))
	    : field;
	
	  // assert on invalid field names
	  for (var i = 0; i < fields.length; i++) {
	    if (!fieldNameRegExp.test(fields[i])) {
	      throw new TypeError('field argument contains an invalid header name');
	    }
	  }
	
	  // existing, unspecified vary
	  if (header === '*') {
	    return header;
	  }
	
	  // enumerate current values
	  var val = header;
	  var vals = parse(header.toLowerCase());
	
	  // unspecified vary
	  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
	    return '*';
	  }
	
	  for (var i = 0; i < fields.length; i++) {
	    var fld = fields[i].toLowerCase();
	
	    // append value (case-preserving)
	    if (vals.indexOf(fld) === -1) {
	      vals.push(fld);
	      val = val
	        ? val + ', ' + fields[i]
	        : fields[i];
	    }
	  }
	
	  return val;
	}
	
	/**
	 * Parse a vary header into an array.
	 *
	 * @param {String} header
	 * @return {Array}
	 * @api private
	 */
	
	function parse(header) {
	  return header.trim().split(/ *, */);
	}
	
	/**
	 * Mark that a request is varied on a header field.
	 *
	 * @param {Object} res
	 * @param {String|Array} field
	 * @api public
	 */
	
	function vary(res, field) {
	  if (!res || !res.getHeader || !res.setHeader) {
	    // quack quack
	    throw new TypeError('res argument is required');
	  }
	
	  // get existing header
	  var val = res.getHeader('Vary') || ''
	  var header = Array.isArray(val)
	    ? val.join(', ')
	    : String(val);
	
	  // set new header
	  if ((val = append(header, field))) {
	    res.setHeader('Vary', val);
	  }
	}


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * serve-static
	 * Copyright(c) 2010 Sencha Inc.
	 * Copyright(c) 2011 TJ Holowaychuk
	 * Copyright(c) 2014-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var encodeUrl = __webpack_require__(68)
	var escapeHtml = __webpack_require__(16)
	var parseUrl = __webpack_require__(31)
	var resolve = __webpack_require__(45).resolve
	var send = __webpack_require__(49)
	var url = __webpack_require__(32)
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = serveStatic
	module.exports.mime = send.mime
	
	/**
	 * @param {string} root
	 * @param {object} [options]
	 * @return {function}
	 * @public
	 */
	
	function serveStatic (root, options) {
	  if (!root) {
	    throw new TypeError('root path required')
	  }
	
	  if (typeof root !== 'string') {
	    throw new TypeError('root path must be a string')
	  }
	
	  // copy options object
	  var opts = Object.create(options || null)
	
	  // fall-though
	  var fallthrough = opts.fallthrough !== false
	
	  // default redirect
	  var redirect = opts.redirect !== false
	
	  // headers listener
	  var setHeaders = opts.setHeaders
	
	  if (setHeaders && typeof setHeaders !== 'function') {
	    throw new TypeError('option setHeaders must be function')
	  }
	
	  // setup options for send
	  opts.maxage = opts.maxage || opts.maxAge || 0
	  opts.root = resolve(root)
	
	  // construct directory listener
	  var onDirectory = redirect
	    ? createRedirectDirectoryListener()
	    : createNotFoundDirectoryListener()
	
	  return function serveStatic (req, res, next) {
	    if (req.method !== 'GET' && req.method !== 'HEAD') {
	      if (fallthrough) {
	        return next()
	      }
	
	      // method not allowed
	      res.statusCode = 405
	      res.setHeader('Allow', 'GET, HEAD')
	      res.setHeader('Content-Length', '0')
	      res.end()
	      return
	    }
	
	    var forwardError = !fallthrough
	    var originalUrl = parseUrl.original(req)
	    var path = parseUrl(req).pathname
	
	    // make sure redirect occurs at mount
	    if (path === '/' && originalUrl.pathname.substr(-1) !== '/') {
	      path = ''
	    }
	
	    // create send stream
	    var stream = send(req, path, opts)
	
	    // add directory handler
	    stream.on('directory', onDirectory)
	
	    // add headers listener
	    if (setHeaders) {
	      stream.on('headers', setHeaders)
	    }
	
	    // add file listener for fallthrough
	    if (fallthrough) {
	      stream.on('file', function onFile () {
	        // once file is determined, always forward error
	        forwardError = true
	      })
	    }
	
	    // forward errors
	    stream.on('error', function error (err) {
	      if (forwardError || !(err.statusCode < 500)) {
	        next(err)
	        return
	      }
	
	      next()
	    })
	
	    // pipe
	    stream.pipe(res)
	  }
	}
	
	/**
	 * Collapse all leading slashes into a single slash
	 * @private
	 */
	function collapseLeadingSlashes (str) {
	  for (var i = 0; i < str.length; i++) {
	    if (str[i] !== '/') {
	      break
	    }
	  }
	
	  return i > 1
	    ? '/' + str.substr(i)
	    : str
	}
	
	/**
	 * Create a directory listener that just 404s.
	 * @private
	 */
	
	function createNotFoundDirectoryListener () {
	  return function notFound () {
	    this.error(404)
	  }
	}
	
	/**
	 * Create a directory listener that performs a redirect.
	 * @private
	 */
	
	function createRedirectDirectoryListener () {
	  return function redirect () {
	    if (this.hasTrailingSlash()) {
	      this.error(404)
	      return
	    }
	
	    // get original URL
	    var originalUrl = parseUrl.original(this.req)
	
	    // append trailing slash
	    originalUrl.path = null
	    originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/')
	
	    // reformat the URL
	    var loc = encodeUrl(url.format(originalUrl))
	    var msg = 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + '</a>\n'
	    var res = this.res
	
	    // send redirect response
	    res.statusCode = 301
	    res.setHeader('Content-Type', 'text/html; charset=UTF-8')
	    res.setHeader('Content-Length', Buffer.byteLength(msg))
	    res.setHeader('X-Content-Type-Options', 'nosniff')
	    res.setHeader('Location', loc)
	    res.end(msg)
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 116 */
/***/ function(module, exports) {

	module.exports = {
	  EXPRESS_PORT: 5000,
	  MONGODB: {
	    PORT: '',
	    URI: 'mongodb://localhost/node-react-app'
	  }
	};


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var mongoose = __webpack_require__(118);
	var config = __webpack_require__(116);
	// mongoose.Promise = global.Promise;
	mongoose.connect(config.MONGODB.URI);
	
	
	var db = mongoose.connection;
	  db.on('error', console.error.bind(console, 'connection error'));
	  db.once('open', function() {
	  console.log('Connected to mongoDB');
	});


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/* eslint-env browser */
	
	/**
	 * The [MongooseError](#error_MongooseError) constructor.
	 *
	 * @method Error
	 * @api public
	 */
	
	exports.Error = __webpack_require__(119);
	
	/**
	 * The Mongoose [Schema](#schema_Schema) constructor
	 *
	 * ####Example:
	 *
	 *     var mongoose = require('mongoose');
	 *     var Schema = mongoose.Schema;
	 *     var CatSchema = new Schema(..);
	 *
	 * @method Schema
	 * @api public
	 */
	
	exports.Schema = __webpack_require__(128);
	
	/**
	 * The various Mongoose Types.
	 *
	 * ####Example:
	 *
	 *     var mongoose = require('mongoose');
	 *     var array = mongoose.Types.Array;
	 *
	 * ####Types:
	 *
	 * - [ObjectId](#types-objectid-js)
	 * - [Buffer](#types-buffer-js)
	 * - [SubDocument](#types-embedded-js)
	 * - [Array](#types-array-js)
	 * - [DocumentArray](#types-documentarray-js)
	 *
	 * Using this exposed access to the `ObjectId` type, we can construct ids on demand.
	 *
	 *     var ObjectId = mongoose.Types.ObjectId;
	 *     var id1 = new ObjectId;
	 *
	 * @property Types
	 * @api public
	 */
	exports.Types = __webpack_require__(258);
	
	/**
	 * The Mongoose [VirtualType](#virtualtype_VirtualType) constructor
	 *
	 * @method VirtualType
	 * @api public
	 */
	exports.VirtualType = __webpack_require__(269);
	
	/**
	 * The various Mongoose SchemaTypes.
	 *
	 * ####Note:
	 *
	 * _Alias of mongoose.Schema.Types for backwards compatibility._
	 *
	 * @property SchemaTypes
	 * @see Schema.SchemaTypes #schema_Schema.Types
	 * @api public
	 */
	
	exports.SchemaType = __webpack_require__(231);
	
	/**
	 * Internal utils
	 *
	 * @property utils
	 * @api private
	 */
	
	exports.utils = __webpack_require__(223);
	
	/**
	 * The Mongoose browser [Document](#document-js) constructor.
	 *
	 * @method Document
	 * @api public
	 */
	exports.Document = __webpack_require__(253)();
	
	/*!
	 * Module exports.
	 */
	
	if (typeof window !== 'undefined') {
	  window.mongoose = module.exports;
	  window.Buffer = Buffer;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * MongooseError constructor
	 *
	 * @param {String} msg Error message
	 * @inherits Error https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error
	 */
	
	function MongooseError(msg) {
	  Error.call(this);
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.message = msg;
	  this.name = 'MongooseError';
	}
	
	/*!
	 * Inherits from Error.
	 */
	
	MongooseError.prototype = Object.create(Error.prototype);
	MongooseError.prototype.constructor = Error;
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = MongooseError;
	
	/**
	 * The default built-in validator error messages.
	 *
	 * @see Error.messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	MongooseError.messages = __webpack_require__(120);
	
	// backward compat
	MongooseError.Messages = MongooseError.messages;
	
	/*!
	 * Expose subclasses
	 */
	
	MongooseError.CastError = __webpack_require__(121);
	MongooseError.ValidationError = __webpack_require__(122);
	MongooseError.ValidatorError = __webpack_require__(123);
	MongooseError.VersionError = __webpack_require__(124);
	MongooseError.OverwriteModelError = __webpack_require__(125);
	MongooseError.MissingSchemaError = __webpack_require__(126);
	MongooseError.DivergentArrayError = __webpack_require__(127);


/***/ },
/* 120 */
/***/ function(module, exports) {

	
	/**
	 * The default built-in validator error messages. These may be customized.
	 *
	 *     // customize within each schema or globally like so
	 *     var mongoose = require('mongoose');
	 *     mongoose.Error.messages.String.enum  = "Your custom message for {PATH}.";
	 *
	 * As you might have noticed, error messages support basic templating
	 *
	 * - `{PATH}` is replaced with the invalid document path
	 * - `{VALUE}` is replaced with the invalid value
	 * - `{TYPE}` is replaced with the validator type such as "regexp", "min", or "user defined"
	 * - `{MIN}` is replaced with the declared min value for the Number.min validator
	 * - `{MAX}` is replaced with the declared max value for the Number.max validator
	 *
	 * Click the "show code" link below to see all defaults.
	 *
	 * @static messages
	 * @receiver MongooseError
	 * @api public
	 */
	
	var msg = module.exports = exports = {};
	
	msg.general = {};
	msg.general.default = 'Validator failed for path `{PATH}` with value `{VALUE}`';
	msg.general.required = 'Path `{PATH}` is required.';
	
	msg.Number = {};
	msg.Number.min = 'Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).';
	msg.Number.max = 'Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).';
	
	msg.Date = {};
	msg.Date.min = 'Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).';
	msg.Date.max = 'Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).';
	
	msg.String = {};
	msg.String.enum = '`{VALUE}` is not a valid enum value for path `{PATH}`.';
	msg.String.match = 'Path `{PATH}` is invalid ({VALUE}).';
	msg.String.minlength = 'Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).';
	msg.String.maxlength = 'Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).';


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(119);
	
	/**
	 * Casting Error constructor.
	 *
	 * @param {String} type
	 * @param {String} value
	 * @inherits MongooseError
	 * @api private
	 */
	
	function CastError(type, value, path, reason) {
	  MongooseError.call(this, 'Cast to ' + type + ' failed for value "' + value + '" at path "' + path + '"');
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.name = 'CastError';
	  this.kind = type;
	  this.value = value;
	  this.path = path;
	  this.reason = reason;
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	CastError.prototype = Object.create(MongooseError.prototype);
	CastError.prototype.constructor = MongooseError;
	
	
	/*!
	 * exports
	 */
	
	module.exports = CastError;


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module requirements
	 */
	
	var MongooseError = __webpack_require__(119);
	
	/**
	 * Document Validation Error
	 *
	 * @api private
	 * @param {Document} instance
	 * @inherits MongooseError
	 */
	
	function ValidationError(instance) {
	  if (instance && instance.constructor.name === 'model') {
	    MongooseError.call(this, instance.constructor.modelName + ' validation failed');
	  } else {
	    MongooseError.call(this, 'Validation failed');
	  }
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.name = 'ValidationError';
	  this.errors = {};
	  if (instance) {
	    instance.errors = this.errors;
	  }
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	ValidationError.prototype = Object.create(MongooseError.prototype);
	ValidationError.prototype.constructor = MongooseError;
	
	
	/**
	 * Console.log helper
	 */
	
	ValidationError.prototype.toString = function() {
	  var ret = this.name + ': ';
	  var msgs = [];
	
	  Object.keys(this.errors).forEach(function(key) {
	    if (this === this.errors[key]) {
	      return;
	    }
	    msgs.push(String(this.errors[key]));
	  }, this);
	
	  return ret + msgs.join(', ');
	};
	
	/*!
	 * Module exports
	 */
	
	module.exports = exports = ValidationError;


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(119);
	
	/**
	 * Schema validator error
	 *
	 * @param {Object} properties
	 * @inherits MongooseError
	 * @api private
	 */
	
	function ValidatorError(properties) {
	  var msg = properties.message;
	  if (!msg) {
	    msg = MongooseError.messages.general.default;
	  }
	
	  var message = this.formatMessage(msg, properties);
	  MongooseError.call(this, message);
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.properties = properties;
	  this.name = 'ValidatorError';
	  this.kind = properties.type;
	  this.path = properties.path;
	  this.value = properties.value;
	}
	
	/*!
	 * Inherits from MongooseError
	 */
	
	ValidatorError.prototype = Object.create(MongooseError.prototype);
	ValidatorError.prototype.constructor = MongooseError;
	
	/*!
	 * The object used to define this validator. Not enumerable to hide
	 * it from `require('util').inspect()` output re: gh-3925
	 */
	
	Object.defineProperty(ValidatorError.prototype, 'properties', {
	  enumerable: false,
	  writable: true,
	  value: null
	});
	
	/*!
	 * Formats error messages
	 */
	
	ValidatorError.prototype.formatMessage = function(msg, properties) {
	  var propertyNames = Object.keys(properties);
	  for (var i = 0; i < propertyNames.length; ++i) {
	    var propertyName = propertyNames[i];
	    if (propertyName === 'message') {
	      continue;
	    }
	    msg = msg.replace('{' + propertyName.toUpperCase() + '}', properties[propertyName]);
	  }
	  return msg;
	};
	
	/*!
	 * toString helper
	 */
	
	ValidatorError.prototype.toString = function() {
	  return this.message;
	};
	
	/*!
	 * exports
	 */
	
	module.exports = ValidatorError;


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(119);
	
	/**
	 * Version Error constructor.
	 *
	 * @inherits MongooseError
	 * @api private
	 */
	
	function VersionError(doc) {
	  MongooseError.call(this, 'No matching document found for id "' + doc._id +
	    '"');
	  this.name = 'VersionError';
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	VersionError.prototype = Object.create(MongooseError.prototype);
	VersionError.prototype.constructor = MongooseError;
	
	/*!
	 * exports
	 */
	
	module.exports = VersionError;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(119);
	
	/*!
	 * OverwriteModel Error constructor.
	 *
	 * @inherits MongooseError
	 */
	
	function OverwriteModelError(name) {
	  MongooseError.call(this, 'Cannot overwrite `' + name + '` model once compiled.');
	  Error.captureStackTrace && Error.captureStackTrace(this, arguments.callee);
	  this.name = 'OverwriteModelError';
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	OverwriteModelError.prototype = Object.create(MongooseError.prototype);
	OverwriteModelError.prototype.constructor = MongooseError;
	
	/*!
	 * exports
	 */
	
	module.exports = OverwriteModelError;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(119);
	
	/*!
	 * MissingSchema Error constructor.
	 *
	 * @inherits MongooseError
	 */
	
	function MissingSchemaError(name) {
	  var msg = 'Schema hasn\'t been registered for model "' + name + '".\n'
	          + 'Use mongoose.model(name, schema)';
	  MongooseError.call(this, msg);
	  Error.captureStackTrace && Error.captureStackTrace(this, arguments.callee);
	  this.name = 'MissingSchemaError';
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	MissingSchemaError.prototype = Object.create(MongooseError.prototype);
	MissingSchemaError.prototype.constructor = MongooseError;
	
	/*!
	 * exports
	 */
	
	module.exports = MissingSchemaError;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(119);
	
	/*!
	 * DivergentArrayError constructor.
	 *
	 * @inherits MongooseError
	 */
	
	function DivergentArrayError(paths) {
	  var msg = 'For your own good, using `document.save()` to update an array '
	          + 'which was selected using an $elemMatch projection OR '
	          + 'populated using skip, limit, query conditions, or exclusion of '
	          + 'the _id field when the operation results in a $pop or $set of '
	          + 'the entire array is not supported. The following '
	          + 'path(s) would have been modified unsafely:\n'
	          + '  ' + paths.join('\n  ') + '\n'
	          + 'Use Model.update() to update these arrays instead.';
	          // TODO write up a docs page (FAQ) and link to it
	
	  MongooseError.call(this, msg);
	  Error.captureStackTrace && Error.captureStackTrace(this, arguments.callee);
	  this.name = 'DivergentArrayError';
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	DivergentArrayError.prototype = Object.create(MongooseError.prototype);
	DivergentArrayError.prototype.constructor = MongooseError;
	
	
	/*!
	 * exports
	 */
	
	module.exports = DivergentArrayError;


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module dependencies.
	 */
	
	var readPref = __webpack_require__(129).ReadPreference;
	var EventEmitter = __webpack_require__(3).EventEmitter;
	var VirtualType = __webpack_require__(269);
	var utils = __webpack_require__(223);
	var MongooseTypes;
	var Kareem = __webpack_require__(270);
	var async = __webpack_require__(271);
	
	var IS_KAREEM_HOOK = {
	  count: true,
	  find: true,
	  findOne: true,
	  findOneAndUpdate: true,
	  findOneAndRemove: true,
	  insertMany: true,
	  update: true
	};
	
	/**
	 * Schema constructor.
	 *
	 * ####Example:
	 *
	 *     var child = new Schema({ name: String });
	 *     var schema = new Schema({ name: String, age: Number, children: [child] });
	 *     var Tree = mongoose.model('Tree', schema);
	 *
	 *     // setting schema options
	 *     new Schema({ name: String }, { _id: false, autoIndex: false })
	 *
	 * ####Options:
	 *
	 * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)
	 * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true
	 * - [capped](/docs/guide.html#capped): bool - defaults to false
	 * - [collection](/docs/guide.html#collection): string - no default
	 * - [emitIndexErrors](/docs/guide.html#emitIndexErrors): bool - defaults to false.
	 * - [id](/docs/guide.html#id): bool - defaults to true
	 * - [_id](/docs/guide.html#_id): bool - defaults to true
	 * - `minimize`: bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true
	 * - [read](/docs/guide.html#read): string
	 * - [safe](/docs/guide.html#safe): bool - defaults to true.
	 * - [shardKey](/docs/guide.html#shardKey): bool - defaults to `null`
	 * - [strict](/docs/guide.html#strict): bool - defaults to true
	 * - [toJSON](/docs/guide.html#toJSON) - object - no default
	 * - [toObject](/docs/guide.html#toObject) - object - no default
	 * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'
	 * - [useNestedStrict](/docs/guide.html#useNestedStrict) - boolean - defaults to false
	 * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`
	 * - [versionKey](/docs/guide.html#versionKey): string - defaults to "__v"
	 *
	 * ####Note:
	 *
	 * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._
	 *
	 * @param {Object} definition
	 * @param {Object} [options]
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `init`: Emitted after the schema is compiled into a `Model`.
	 * @api public
	 */
	
	function Schema(obj, options) {
	  if (!(this instanceof Schema)) {
	    return new Schema(obj, options);
	  }
	
	  this.paths = {};
	  this.subpaths = {};
	  this.virtuals = {};
	  this.singleNestedPaths = {};
	  this.nested = {};
	  this.inherits = {};
	  this.callQueue = [];
	  this._indexes = [];
	  this.methods = {};
	  this.statics = {};
	  this.tree = {};
	  this._requiredpaths = undefined;
	  this.discriminatorMapping = undefined;
	  this._indexedpaths = undefined;
	  this.query = {};
	  this.childSchemas = [];
	
	  this.s = {
	    hooks: new Kareem(),
	    kareemHooks: IS_KAREEM_HOOK
	  };
	
	  this.options = this.defaultOptions(options);
	
	  // build paths
	  if (obj) {
	    this.add(obj);
	  }
	
	  // check if _id's value is a subdocument (gh-2276)
	  var _idSubDoc = obj && obj._id && utils.isObject(obj._id);
	
	  // ensure the documents get an auto _id unless disabled
	  var auto_id = !this.paths['_id'] &&
	      (!this.options.noId && this.options._id) && !_idSubDoc;
	
	  if (auto_id) {
	    obj = {_id: {auto: true}};
	    obj._id[this.options.typeKey] = Schema.ObjectId;
	    this.add(obj);
	  }
	
	  // ensure the documents receive an id getter unless disabled
	  var autoid = !this.paths['id'] &&
	      (!this.options.noVirtualId && this.options.id);
	  if (autoid) {
	    this.virtual('id').get(idGetter);
	  }
	
	  for (var i = 0; i < this._defaultMiddleware.length; ++i) {
	    var m = this._defaultMiddleware[i];
	    this[m.kind](m.hook, !!m.isAsync, m.fn);
	  }
	
	  if (this.options.timestamps) {
	    this.setupTimestamp(this.options.timestamps);
	  }
	}
	
	/*!
	 * Returns this documents _id cast to a string.
	 */
	
	function idGetter() {
	  if (this.$__._id) {
	    return this.$__._id;
	  }
	
	  this.$__._id = this._id == null
	      ? null
	      : String(this._id);
	  return this.$__._id;
	}
	
	/*!
	 * Inherit from EventEmitter.
	 */
	Schema.prototype = Object.create(EventEmitter.prototype);
	Schema.prototype.constructor = Schema;
	Schema.prototype.instanceOfSchema = true;
	
	/**
	 * Default middleware attached to a schema. Cannot be changed.
	 *
	 * This field is used to make sure discriminators don't get multiple copies of
	 * built-in middleware. Declared as a constant because changing this at runtime
	 * may lead to instability with Model.prototype.discriminator().
	 *
	 * @api private
	 * @property _defaultMiddleware
	 */
	Object.defineProperty(Schema.prototype, '_defaultMiddleware', {
	  configurable: false,
	  enumerable: false,
	  writable: false,
	  value: [
	    {
	      kind: 'pre',
	      hook: 'save',
	      fn: function(next, options) {
	        var _this = this;
	        // Nested docs have their own presave
	        if (this.ownerDocument) {
	          return next();
	        }
	
	        var hasValidateBeforeSaveOption = options &&
	            (typeof options === 'object') &&
	            ('validateBeforeSave' in options);
	
	        var shouldValidate;
	        if (hasValidateBeforeSaveOption) {
	          shouldValidate = !!options.validateBeforeSave;
	        } else {
	          shouldValidate = this.schema.options.validateBeforeSave;
	        }
	
	        // Validate
	        if (shouldValidate) {
	          // HACK: use $__original_validate to avoid promises so bluebird doesn't
	          // complain
	          if (this.$__original_validate) {
	            this.$__original_validate({__noPromise: true}, function(error) {
	              return _this.schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {
	                next(error);
	              });
	            });
	          } else {
	            this.validate({__noPromise: true}, function(error) {
	              return _this.schema.s.hooks.execPost('save:error', _this, [ _this], { error: error }, function(error) {
	                next(error);
	              });
	            });
	          }
	        } else {
	          next();
	        }
	      }
	    },
	    {
	      kind: 'pre',
	      hook: 'save',
	      isAsync: true,
	      fn: function(next, done) {
	        var _this = this;
	        var subdocs = this.$__getAllSubdocs();
	
	        if (!subdocs.length || this.$__preSavingFromParent) {
	          done();
	          next();
	          return;
	        }
	
	        async.each(subdocs, function(subdoc, cb) {
	          subdoc.$__preSavingFromParent = true;
	          subdoc.save(function(err) {
	            cb(err);
	          });
	        }, function(error) {
	          for (var i = 0; i < subdocs.length; ++i) {
	            delete subdocs[i].$__preSavingFromParent;
	          }
	          if (error) {
	            return _this.schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {
	              done(error);
	            });
	          }
	          next();
	          done();
	        });
	      }
	    },
	    {
	      kind: 'pre',
	      hook: 'validate',
	      isAsync: true,
	      fn: function(next, done) {
	        // Hack to ensure that we always wrap validate() in a promise
	        next();
	        done();
	      }
	    },
	    {
	      kind: 'pre',
	      hook: 'remove',
	      isAsync: true,
	      fn: function(next, done) {
	        if (this.ownerDocument) {
	          done();
	          next();
	          return;
	        }
	
	        var subdocs = this.$__getAllSubdocs();
	
	        if (!subdocs.length || this.$__preSavingFromParent) {
	          done();
	          next();
	          return;
	        }
	
	        async.each(subdocs, function(subdoc, cb) {
	          subdoc.remove({ noop: true }, function(err) {
	            cb(err);
	          });
	        }, function(error) {
	          if (error) {
	            done(error);
	            return;
	          }
	          next();
	          done();
	        });
	      }
	    }
	  ]
	});
	
	/**
	 * Schema as flat paths
	 *
	 * ####Example:
	 *     {
	 *         '_id'        : SchemaType,
	 *       , 'nested.key' : SchemaType,
	 *     }
	 *
	 * @api private
	 * @property paths
	 */
	
	Schema.prototype.paths;
	
	/**
	 * Schema as a tree
	 *
	 * ####Example:
	 *     {
	 *         '_id'     : ObjectId
	 *       , 'nested'  : {
	 *             'key' : String
	 *         }
	 *     }
	 *
	 * @api private
	 * @property tree
	 */
	
	Schema.prototype.tree;
	
	/**
	 * Returns default options for this schema, merged with `options`.
	 *
	 * @param {Object} options
	 * @return {Object}
	 * @api private
	 */
	
	Schema.prototype.defaultOptions = function(options) {
	  if (options && options.safe === false) {
	    options.safe = {w: 0};
	  }
	
	  if (options && options.safe && options.safe.w === 0) {
	    // if you turn off safe writes, then versioning goes off as well
	    options.versionKey = false;
	  }
	
	  options = utils.options({
	    strict: true,
	    bufferCommands: true,
	    capped: false, // { size, max, autoIndexId }
	    versionKey: '__v',
	    discriminatorKey: '__t',
	    minimize: true,
	    autoIndex: null,
	    shardKey: null,
	    read: null,
	    validateBeforeSave: true,
	    // the following are only applied at construction time
	    noId: false, // deprecated, use { _id: false }
	    _id: true,
	    noVirtualId: false, // deprecated, use { id: false }
	    id: true,
	    typeKey: 'type'
	  }, options);
	
	  if (options.read) {
	    options.read = readPref(options.read);
	  }
	
	  return options;
	};
	
	/**
	 * Adds key path / schema type pairs to this schema.
	 *
	 * ####Example:
	 *
	 *     var ToySchema = new Schema;
	 *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });
	 *
	 * @param {Object} obj
	 * @param {String} prefix
	 * @api public
	 */
	
	Schema.prototype.add = function add(obj, prefix) {
	  prefix = prefix || '';
	  var keys = Object.keys(obj);
	
	  for (var i = 0; i < keys.length; ++i) {
	    var key = keys[i];
	
	    if (obj[key] == null) {
	      throw new TypeError('Invalid value for schema path `' + prefix + key + '`');
	    }
	
	    if (Array.isArray(obj[key]) && obj[key].length === 1 && obj[key][0] == null) {
	      throw new TypeError('Invalid value for schema Array path `' + prefix + key + '`');
	    }
	
	    if (utils.isObject(obj[key]) &&
	        (!obj[key].constructor || utils.getFunctionName(obj[key].constructor) === 'Object') &&
	        (!obj[key][this.options.typeKey] || (this.options.typeKey === 'type' && obj[key].type.type))) {
	      if (Object.keys(obj[key]).length) {
	        // nested object { last: { name: String }}
	        this.nested[prefix + key] = true;
	        this.add(obj[key], prefix + key + '.');
	      } else {
	        this.path(prefix + key, obj[key]); // mixed type
	      }
	    } else {
	      this.path(prefix + key, obj[key]);
	    }
	  }
	};
	
	/**
	 * Reserved document keys.
	 *
	 * Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.
	 *
	 *      on, emit, _events, db, get, set, init, isNew, errors, schema, options, modelName, collection, _pres, _posts, toObject
	 *
	 * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.
	 *
	 *      var schema = new Schema(..);
	 *      schema.methods.init = function () {} // potentially breaking
	 */
	
	Schema.reserved = Object.create(null);
	var reserved = Schema.reserved;
	// EventEmitter
	reserved.emit =
	reserved.on =
	reserved.once =
	reserved.listeners =
	reserved.removeListener =
	// document properties and functions
	reserved.collection =
	reserved.db =
	reserved.errors =
	reserved.init =
	reserved.isModified =
	reserved.isNew =
	reserved.get =
	reserved.modelName =
	reserved.save =
	reserved.schema =
	reserved.set =
	reserved.toObject =
	reserved.validate =
	// hooks.js
	reserved._pres = reserved._posts = 1;
	
	/*!
	 * Document keys to print warnings for
	 */
	
	var warnings = {};
	warnings.increment = '`increment` should not be used as a schema path name ' +
	    'unless you have disabled versioning.';
	
	/**
	 * Gets/sets schema paths.
	 *
	 * Sets a path (if arity 2)
	 * Gets a path (if arity 1)
	 *
	 * ####Example
	 *
	 *     schema.path('name') // returns a SchemaType
	 *     schema.path('name', Number) // changes the schemaType of `name` to Number
	 *
	 * @param {String} path
	 * @param {Object} constructor
	 * @api public
	 */
	
	Schema.prototype.path = function(path, obj) {
	  if (obj === undefined) {
	    if (this.paths[path]) {
	      return this.paths[path];
	    }
	    if (this.subpaths[path]) {
	      return this.subpaths[path];
	    }
	    if (this.singleNestedPaths[path]) {
	      return this.singleNestedPaths[path];
	    }
	
	    // subpaths?
	    return /\.\d+\.?.*$/.test(path)
	        ? getPositionalPath(this, path)
	        : undefined;
	  }
	
	  // some path names conflict with document methods
	  if (reserved[path]) {
	    throw new Error('`' + path + '` may not be used as a schema pathname');
	  }
	
	  if (warnings[path]) {
	    console.log('WARN: ' + warnings[path]);
	  }
	
	  // update the tree
	  var subpaths = path.split(/\./),
	      last = subpaths.pop(),
	      branch = this.tree;
	
	  subpaths.forEach(function(sub, i) {
	    if (!branch[sub]) {
	      branch[sub] = {};
	    }
	    if (typeof branch[sub] !== 'object') {
	      var msg = 'Cannot set nested path `' + path + '`. '
	          + 'Parent path `'
	          + subpaths.slice(0, i).concat([sub]).join('.')
	          + '` already set to type ' + branch[sub].name
	          + '.';
	      throw new Error(msg);
	    }
	    branch = branch[sub];
	  });
	
	  branch[last] = utils.clone(obj);
	
	  this.paths[path] = Schema.interpretAsType(path, obj, this.options);
	
	  if (this.paths[path].$isSingleNested) {
	    for (var key in this.paths[path].schema.paths) {
	      this.singleNestedPaths[path + '.' + key] =
	          this.paths[path].schema.paths[key];
	    }
	    for (key in this.paths[path].schema.singleNestedPaths) {
	      this.singleNestedPaths[path + '.' + key] =
	          this.paths[path].schema.singleNestedPaths[key];
	    }
	
	    this.childSchemas.push(this.paths[path].schema);
	  } else if (this.paths[path].$isMongooseDocumentArray) {
	    this.childSchemas.push(this.paths[path].schema);
	  }
	  return this;
	};
	
	/**
	 * Converts type arguments into Mongoose Types.
	 *
	 * @param {String} path
	 * @param {Object} obj constructor
	 * @api private
	 */
	
	Schema.interpretAsType = function(path, obj, options) {
	  if (obj.constructor) {
	    var constructorName = utils.getFunctionName(obj.constructor);
	    if (constructorName !== 'Object') {
	      var oldObj = obj;
	      obj = {};
	      obj[options.typeKey] = oldObj;
	    }
	  }
	
	  // Get the type making sure to allow keys named "type"
	  // and default to mixed if not specified.
	  // { type: { type: String, default: 'freshcut' } }
	  var type = obj[options.typeKey] && (options.typeKey !== 'type' || !obj.type.type)
	      ? obj[options.typeKey]
	      : {};
	
	  if (utils.getFunctionName(type.constructor) === 'Object' || type === 'mixed') {
	    return new MongooseTypes.Mixed(path, obj);
	  }
	
	  if (Array.isArray(type) || Array === type || type === 'array') {
	    // if it was specified through { type } look for `cast`
	    var cast = (Array === type || type === 'array')
	        ? obj.cast
	        : type[0];
	
	    if (cast && cast.instanceOfSchema) {
	      return new MongooseTypes.DocumentArray(path, cast, obj);
	    }
	
	    if (Array.isArray(cast)) {
	      return new MongooseTypes.Array(path, Schema.interpretAsType(path, cast, options), obj);
	    }
	
	    if (typeof cast === 'string') {
	      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];
	    } else if (cast && (!cast[options.typeKey] || (options.typeKey === 'type' && cast.type.type))
	        && utils.getFunctionName(cast.constructor) === 'Object'
	        && Object.keys(cast).length) {
	      // The `minimize` and `typeKey` options propagate to child schemas
	      // declared inline, like `{ arr: [{ val: { $type: String } }] }`.
	      // See gh-3560
	      var childSchemaOptions = {minimize: options.minimize};
	      if (options.typeKey) {
	        childSchemaOptions.typeKey = options.typeKey;
	      }
	      var childSchema = new Schema(cast, childSchemaOptions);
	      return new MongooseTypes.DocumentArray(path, childSchema, obj);
	    }
	
	    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj);
	  }
	
	  if (type && type.instanceOfSchema) {
	    return new MongooseTypes.Embedded(type, path, obj);
	  }
	
	  var name;
	  if (Buffer.isBuffer(type)) {
	    name = 'Buffer';
	  } else {
	    name = typeof type === 'string'
	        ? type
	      // If not string, `type` is a function. Outside of IE, function.name
	      // gives you the function name. In IE, you need to compute it
	        : type.schemaName || utils.getFunctionName(type);
	  }
	
	  if (name) {
	    name = name.charAt(0).toUpperCase() + name.substring(1);
	  }
	
	  if (undefined == MongooseTypes[name]) {
	    throw new TypeError('Undefined type `' + name + '` at `' + path +
	        '`\n  Did you try nesting Schemas? ' +
	        'You can only nest using refs or arrays.');
	  }
	
	  return new MongooseTypes[name](path, obj);
	};
	
	/**
	 * Iterates the schemas paths similar to Array#forEach.
	 *
	 * The callback is passed the pathname and schemaType as arguments on each iteration.
	 *
	 * @param {Function} fn callback function
	 * @return {Schema} this
	 * @api public
	 */
	
	Schema.prototype.eachPath = function(fn) {
	  var keys = Object.keys(this.paths),
	      len = keys.length;
	
	  for (var i = 0; i < len; ++i) {
	    fn(keys[i], this.paths[keys[i]]);
	  }
	
	  return this;
	};
	
	/**
	 * Returns an Array of path strings that are required by this schema.
	 *
	 * @api public
	 * @param {Boolean} invalidate refresh the cache
	 * @return {Array}
	 */
	
	Schema.prototype.requiredPaths = function requiredPaths(invalidate) {
	  if (this._requiredpaths && !invalidate) {
	    return this._requiredpaths;
	  }
	
	  var paths = Object.keys(this.paths),
	      i = paths.length,
	      ret = [];
	
	  while (i--) {
	    var path = paths[i];
	    if (this.paths[path].isRequired) {
	      ret.push(path);
	    }
	  }
	  this._requiredpaths = ret;
	  return this._requiredpaths;
	};
	
	/**
	 * Returns indexes from fields and schema-level indexes (cached).
	 *
	 * @api private
	 * @return {Array}
	 */
	
	Schema.prototype.indexedPaths = function indexedPaths() {
	  if (this._indexedpaths) {
	    return this._indexedpaths;
	  }
	  this._indexedpaths = this.indexes();
	  return this._indexedpaths;
	};
	
	/**
	 * Returns the pathType of `path` for this schema.
	 *
	 * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.
	 *
	 * @param {String} path
	 * @return {String}
	 * @api public
	 */
	
	Schema.prototype.pathType = function(path) {
	  if (path in this.paths) {
	    return 'real';
	  }
	  if (path in this.virtuals) {
	    return 'virtual';
	  }
	  if (path in this.nested) {
	    return 'nested';
	  }
	  if (path in this.subpaths) {
	    return 'real';
	  }
	  if (path in this.singleNestedPaths) {
	    return 'real';
	  }
	
	  if (/\.\d+\.|\.\d+$/.test(path)) {
	    return getPositionalPathType(this, path);
	  }
	  return 'adhocOrUndefined';
	};
	
	/**
	 * Returns true iff this path is a child of a mixed schema.
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api private
	 */
	
	Schema.prototype.hasMixedParent = function(path) {
	  var subpaths = path.split(/\./g);
	  path = '';
	  for (var i = 0; i < subpaths.length; ++i) {
	    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];
	    if (path in this.paths &&
	        this.paths[path] instanceof MongooseTypes.Mixed) {
	      return true;
	    }
	  }
	
	  return false;
	};
	
	/**
	 * Setup updatedAt and createdAt timestamps to documents if enabled
	 *
	 * @param {Boolean|Object} timestamps timestamps options
	 * @api private
	 */
	Schema.prototype.setupTimestamp = function(timestamps) {
	  if (timestamps) {
	    var createdAt = timestamps.createdAt || 'createdAt',
	        updatedAt = timestamps.updatedAt || 'updatedAt',
	        schemaAdditions = {};
	
	    schemaAdditions[updatedAt] = Date;
	
	    if (!this.paths[createdAt]) {
	      schemaAdditions[createdAt] = Date;
	    }
	
	    this.add(schemaAdditions);
	
	    this.pre('save', function(next) {
	      var defaultTimestamp = new Date();
	      var auto_id = this._id && this._id.auto;
	
	      if (!this[createdAt] && this.isSelected(createdAt)) {
	        this[createdAt] = auto_id ? this._id.getTimestamp() : defaultTimestamp;
	      }
	
	      if (this.isNew || this.isModified()) {
	        this[updatedAt] = this.isNew ? this[createdAt] : defaultTimestamp;
	      }
	
	      next();
	    });
	
	    var genUpdates = function() {
	      var now = new Date();
	      var updates = {$set: {}, $setOnInsert: {}};
	      updates.$set[updatedAt] = now;
	      updates.$setOnInsert[createdAt] = now;
	
	      return updates;
	    };
	
	    this.methods.initializeTimestamps = function() {
	      if (!this[createdAt]) {
	        this[createdAt] = new Date();
	      }
	      if (!this[updatedAt]) {
	        this[updatedAt] = new Date();
	      }
	      return this;
	    };
	
	    this.pre('findOneAndUpdate', function(next) {
	      this.findOneAndUpdate({}, genUpdates());
	      next();
	    });
	
	    this.pre('update', function(next) {
	      this.update({}, genUpdates());
	      next();
	    });
	  }
	};
	
	/*!
	 * ignore
	 */
	
	function getPositionalPathType(self, path) {
	  var subpaths = path.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
	  if (subpaths.length < 2) {
	    return self.paths[subpaths[0]];
	  }
	
	  var val = self.path(subpaths[0]);
	  var isNested = false;
	  if (!val) {
	    return val;
	  }
	
	  var last = subpaths.length - 1,
	      subpath,
	      i = 1;
	
	  for (; i < subpaths.length; ++i) {
	    isNested = false;
	    subpath = subpaths[i];
	
	    if (i === last && val && !val.schema && !/\D/.test(subpath)) {
	      if (val instanceof MongooseTypes.Array) {
	        // StringSchema, NumberSchema, etc
	        val = val.caster;
	      } else {
	        val = undefined;
	      }
	      break;
	    }
	
	    // ignore if its just a position segment: path.0.subpath
	    if (!/\D/.test(subpath)) {
	      continue;
	    }
	
	    if (!(val && val.schema)) {
	      val = undefined;
	      break;
	    }
	
	    var type = val.schema.pathType(subpath);
	    isNested = (type === 'nested');
	    val = val.schema.path(subpath);
	  }
	
	  self.subpaths[path] = val;
	  if (val) {
	    return 'real';
	  }
	  if (isNested) {
	    return 'nested';
	  }
	  return 'adhocOrUndefined';
	}
	
	
	/*!
	 * ignore
	 */
	
	function getPositionalPath(self, path) {
	  getPositionalPathType(self, path);
	  return self.subpaths[path];
	}
	
	/**
	 * Adds a method call to the queue.
	 *
	 * @param {String} name name of the document method to call later
	 * @param {Array} args arguments to pass to the method
	 * @api public
	 */
	
	Schema.prototype.queue = function(name, args) {
	  this.callQueue.push([name, args]);
	  return this;
	};
	
	/**
	 * Defines a pre hook for the document.
	 *
	 * ####Example
	 *
	 *     var toySchema = new Schema(..);
	 *
	 *     toySchema.pre('save', function (next) {
	 *       if (!this.created) this.created = new Date;
	 *       next();
	 *     })
	 *
	 *     toySchema.pre('validate', function (next) {
	 *       if (this.name !== 'Woody') this.name = 'Woody';
	 *       next();
	 *     })
	 *
	 * @param {String} method
	 * @param {Function} callback
	 * @see hooks.js https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3
	 * @api public
	 */
	
	Schema.prototype.pre = function() {
	  var name = arguments[0];
	  if (IS_KAREEM_HOOK[name]) {
	    this.s.hooks.pre.apply(this.s.hooks, arguments);
	    return this;
	  }
	  return this.queue('pre', arguments);
	};
	
	/**
	 * Defines a post hook for the document
	 *
	 *     var schema = new Schema(..);
	 *     schema.post('save', function (doc) {
	 *       console.log('this fired after a document was saved');
	 *     });
	 *
	 *     shema.post('find', function(docs) {
	 *       console.log('this fired after you run a find query');
	 *     });
	 *
	 *     var Model = mongoose.model('Model', schema);
	 *
	 *     var m = new Model(..);
	 *     m.save(function(err) {
	 *       console.log('this fires after the `post` hook');
	 *     });
	 *
	 *     m.find(function(err, docs) {
	 *       console.log('this fires after the post find hook');
	 *     });
	 *
	 * @param {String} method name of the method to hook
	 * @param {Function} fn callback
	 * @see middleware http://mongoosejs.com/docs/middleware.html
	 * @see hooks.js https://www.npmjs.com/package/hooks-fixed
	 * @see kareem http://npmjs.org/package/kareem
	 * @api public
	 */
	
	Schema.prototype.post = function(method, fn) {
	  if (IS_KAREEM_HOOK[method]) {
	    this.s.hooks.post.apply(this.s.hooks, arguments);
	    return this;
	  }
	  // assuming that all callbacks with arity < 2 are synchronous post hooks
	  if (fn.length < 2) {
	    return this.queue('on', [arguments[0], function(doc) {
	      return fn.call(doc, doc);
	    }]);
	  }
	
	  if (fn.length === 3) {
	    this.s.hooks.post(method + ':error', fn);
	    return this;
	  }
	
	  return this.queue('post', [arguments[0], function(next) {
	    // wrap original function so that the callback goes last,
	    // for compatibility with old code that is using synchronous post hooks
	    var _this = this;
	    var args = Array.prototype.slice.call(arguments, 1);
	    fn.call(this, this, function(err) {
	      return next.apply(_this, [err].concat(args));
	    });
	  }]);
	};
	
	/**
	 * Registers a plugin for this schema.
	 *
	 * @param {Function} plugin callback
	 * @param {Object} [opts]
	 * @see plugins
	 * @api public
	 */
	
	Schema.prototype.plugin = function(fn, opts) {
	  fn(this, opts);
	  return this;
	};
	
	/**
	 * Adds an instance method to documents constructed from Models compiled from this schema.
	 *
	 * ####Example
	 *
	 *     var schema = kittySchema = new Schema(..);
	 *
	 *     schema.method('meow', function () {
	 *       console.log('meeeeeoooooooooooow');
	 *     })
	 *
	 *     var Kitty = mongoose.model('Kitty', schema);
	 *
	 *     var fizz = new Kitty;
	 *     fizz.meow(); // meeeeeooooooooooooow
	 *
	 * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.
	 *
	 *     schema.method({
	 *         purr: function () {}
	 *       , scratch: function () {}
	 *     });
	 *
	 *     // later
	 *     fizz.purr();
	 *     fizz.scratch();
	 *
	 * @param {String|Object} method name
	 * @param {Function} [fn]
	 * @api public
	 */
	
	Schema.prototype.method = function(name, fn) {
	  if (typeof name !== 'string') {
	    for (var i in name) {
	      this.methods[i] = name[i];
	    }
	  } else {
	    this.methods[name] = fn;
	  }
	  return this;
	};
	
	/**
	 * Adds static "class" methods to Models compiled from this schema.
	 *
	 * ####Example
	 *
	 *     var schema = new Schema(..);
	 *     schema.static('findByName', function (name, callback) {
	 *       return this.find({ name: name }, callback);
	 *     });
	 *
	 *     var Drink = mongoose.model('Drink', schema);
	 *     Drink.findByName('sanpellegrino', function (err, drinks) {
	 *       //
	 *     });
	 *
	 * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.
	 *
	 * @param {String|Object} name
	 * @param {Function} [fn]
	 * @api public
	 */
	
	Schema.prototype.static = function(name, fn) {
	  if (typeof name !== 'string') {
	    for (var i in name) {
	      this.statics[i] = name[i];
	    }
	  } else {
	    this.statics[name] = fn;
	  }
	  return this;
	};
	
	/**
	 * Defines an index (most likely compound) for this schema.
	 *
	 * ####Example
	 *
	 *     schema.index({ first: 1, last: -1 })
	 *
	 * @param {Object} fields
	 * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#createIndex)
	 * @param {String} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.
	 * @api public
	 */
	
	Schema.prototype.index = function(fields, options) {
	  options || (options = {});
	
	  if (options.expires) {
	    utils.expires(options);
	  }
	
	  this._indexes.push([fields, options]);
	  return this;
	};
	
	/**
	 * Sets/gets a schema option.
	 *
	 * ####Example
	 *
	 *     schema.set('strict'); // 'true' by default
	 *     schema.set('strict', false); // Sets 'strict' to false
	 *     schema.set('strict'); // 'false'
	 *
	 * @param {String} key option name
	 * @param {Object} [value] if not passed, the current option value is returned
	 * @see Schema ./
	 * @api public
	 */
	
	Schema.prototype.set = function(key, value, _tags) {
	  if (arguments.length === 1) {
	    return this.options[key];
	  }
	
	  switch (key) {
	    case 'read':
	      this.options[key] = readPref(value, _tags);
	      break;
	    case 'safe':
	      this.options[key] = value === false
	          ? {w: 0}
	          : value;
	      break;
	    case 'timestamps':
	      this.setupTimestamp(value);
	      this.options[key] = value;
	      break;
	    default:
	      this.options[key] = value;
	  }
	
	  return this;
	};
	
	/**
	 * Gets a schema option.
	 *
	 * @param {String} key option name
	 * @api public
	 */
	
	Schema.prototype.get = function(key) {
	  return this.options[key];
	};
	
	/**
	 * The allowed index types
	 *
	 * @static indexTypes
	 * @receiver Schema
	 * @api public
	 */
	
	var indexTypes = '2d 2dsphere hashed text'.split(' ');
	
	Object.defineProperty(Schema, 'indexTypes', {
	  get: function() {
	    return indexTypes;
	  },
	  set: function() {
	    throw new Error('Cannot overwrite Schema.indexTypes');
	  }
	});
	
	/**
	 * Compiles indexes from fields and schema-level indexes
	 *
	 * @api public
	 */
	
	Schema.prototype.indexes = function() {
	  'use strict';
	
	  var indexes = [];
	  var seenPrefix = {};
	
	  var collectIndexes = function(schema, prefix) {
	    if (seenPrefix[prefix]) {
	      return;
	    }
	    seenPrefix[prefix] = true;
	
	    prefix = prefix || '';
	    var key, path, index, field, isObject, options, type;
	    var keys = Object.keys(schema.paths);
	
	    for (var i = 0; i < keys.length; ++i) {
	      key = keys[i];
	      path = schema.paths[key];
	
	      if ((path instanceof MongooseTypes.DocumentArray) || path.$isSingleNested) {
	        collectIndexes(path.schema, key + '.');
	      } else {
	        index = path._index;
	
	        if (index !== false && index !== null && index !== undefined) {
	          field = {};
	          isObject = utils.isObject(index);
	          options = isObject ? index : {};
	          type = typeof index === 'string' ? index :
	              isObject ? index.type :
	                  false;
	
	          if (type && ~Schema.indexTypes.indexOf(type)) {
	            field[prefix + key] = type;
	          } else if (options.text) {
	            field[prefix + key] = 'text';
	            delete options.text;
	          } else {
	            field[prefix + key] = 1;
	          }
	
	          delete options.type;
	          if (!('background' in options)) {
	            options.background = true;
	          }
	
	          indexes.push([field, options]);
	        }
	      }
	    }
	
	    if (prefix) {
	      fixSubIndexPaths(schema, prefix);
	    } else {
	      schema._indexes.forEach(function(index) {
	        if (!('background' in index[1])) {
	          index[1].background = true;
	        }
	      });
	      indexes = indexes.concat(schema._indexes);
	    }
	  };
	
	  collectIndexes(this);
	  return indexes;
	
	  /*!
	   * Checks for indexes added to subdocs using Schema.index().
	   * These indexes need their paths prefixed properly.
	   *
	   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]
	   */
	
	  function fixSubIndexPaths(schema, prefix) {
	    var subindexes = schema._indexes,
	        len = subindexes.length,
	        indexObj,
	        newindex,
	        klen,
	        keys,
	        key,
	        i = 0,
	        j;
	
	    for (i = 0; i < len; ++i) {
	      indexObj = subindexes[i][0];
	      keys = Object.keys(indexObj);
	      klen = keys.length;
	      newindex = {};
	
	      // use forward iteration, order matters
	      for (j = 0; j < klen; ++j) {
	        key = keys[j];
	        newindex[prefix + key] = indexObj[key];
	      }
	
	      indexes.push([newindex, subindexes[i][1]]);
	    }
	  }
	};
	
	/**
	 * Creates a virtual type with the given name.
	 *
	 * @param {String} name
	 * @param {Object} [options]
	 * @return {VirtualType}
	 */
	
	Schema.prototype.virtual = function(name, options) {
	  if (options && options.ref) {
	    if (!options.localField) {
	      throw new Error('Reference virtuals require `localField` option');
	    }
	
	    if (!options.foreignField) {
	      throw new Error('Reference virtuals require `foreignField` option');
	    }
	
	    this.pre('init', function(next, obj) {
	      if (name in obj) {
	        if (!this.$$populatedVirtuals) {
	          this.$$populatedVirtuals = {};
	        }
	
	        if (options.justOne) {
	          this.$$populatedVirtuals[name] = Array.isArray(obj[name]) ?
	            obj[name][0] :
	            obj[name];
	        } else {
	          this.$$populatedVirtuals[name] = Array.isArray(obj[name]) ?
	            obj[name] :
	            obj[name] == null ? [] : [obj[name]];
	        }
	
	        delete obj[name];
	      }
	      next();
	    });
	
	    var virtual = this.virtual(name);
	    virtual.options = options;
	    return virtual.
	      get(function() {
	        if (!this.$$populatedVirtuals) {
	          this.$$populatedVirtuals = {};
	        }
	        if (name in this.$$populatedVirtuals) {
	          return this.$$populatedVirtuals[name];
	        }
	        return null;
	      }).
	      set(function(v) {
	        if (!this.$$populatedVirtuals) {
	          this.$$populatedVirtuals = {};
	        }
	        this.$$populatedVirtuals[name] = v;
	      });
	  }
	
	  var virtuals = this.virtuals;
	  var parts = name.split('.');
	  virtuals[name] = parts.reduce(function(mem, part, i) {
	    mem[part] || (mem[part] = (i === parts.length - 1)
	        ? new VirtualType(options, name)
	        : {});
	    return mem[part];
	  }, this.tree);
	  return virtuals[name];
	};
	
	/**
	 * Returns the virtual type with the given `name`.
	 *
	 * @param {String} name
	 * @return {VirtualType}
	 */
	
	Schema.prototype.virtualpath = function(name) {
	  return this.virtuals[name];
	};
	
	/**
	 * Removes the given `path` (or [`paths`]).
	 *
	 * @param {String|Array} path
	 *
	 * @api public
	 */
	Schema.prototype.remove = function(path) {
	  if (typeof path === 'string') {
	    path = [path];
	  }
	  if (Array.isArray(path)) {
	    path.forEach(function(name) {
	      if (this.path(name)) {
	        delete this.paths[name];
	
	        var pieces = name.split('.');
	        var last = pieces.pop();
	        var branch = this.tree;
	        for (var i = 0; i < pieces.length; ++i) {
	          branch = branch[pieces[i]];
	        }
	        delete branch[last];
	      }
	    }, this);
	  }
	};
	
	/*!
	 * ignore
	 */
	
	Schema.prototype._getSchema = function(path) {
	  var _this = this;
	  var pathschema = _this.path(path);
	
	  if (pathschema) {
	    return pathschema;
	  }
	
	  function search(parts, schema) {
	    var p = parts.length + 1,
	        foundschema,
	        trypath;
	
	    while (p--) {
	      trypath = parts.slice(0, p).join('.');
	      foundschema = schema.path(trypath);
	      if (foundschema) {
	        if (foundschema.caster) {
	          // array of Mixed?
	          if (foundschema.caster instanceof MongooseTypes.Mixed) {
	            return foundschema.caster;
	          }
	
	          // Now that we found the array, we need to check if there
	          // are remaining document paths to look up for casting.
	          // Also we need to handle array.$.path since schema.path
	          // doesn't work for that.
	          // If there is no foundschema.schema we are dealing with
	          // a path like array.$
	          if (p !== parts.length && foundschema.schema) {
	            if (parts[p] === '$') {
	              // comments.$.comments.$.title
	              return search(parts.slice(p + 1), foundschema.schema);
	            }
	            // this is the last path of the selector
	            return search(parts.slice(p), foundschema.schema);
	          }
	        }
	        return foundschema;
	      }
	    }
	  }
	
	  // look for arrays
	  return search(path.split('.'), _this);
	};
	
	/*!
	 * ignore
	 */
	
	Schema.prototype._getPathType = function(path) {
	  var _this = this;
	  var pathschema = _this.path(path);
	
	  if (pathschema) {
	    return 'real';
	  }
	
	  function search(parts, schema) {
	    var p = parts.length + 1,
	        foundschema,
	        trypath;
	
	    while (p--) {
	      trypath = parts.slice(0, p).join('.');
	      foundschema = schema.path(trypath);
	      if (foundschema) {
	        if (foundschema.caster) {
	          // array of Mixed?
	          if (foundschema.caster instanceof MongooseTypes.Mixed) {
	            return { schema: foundschema, pathType: 'mixed' };
	          }
	
	          // Now that we found the array, we need to check if there
	          // are remaining document paths to look up for casting.
	          // Also we need to handle array.$.path since schema.path
	          // doesn't work for that.
	          // If there is no foundschema.schema we are dealing with
	          // a path like array.$
	          if (p !== parts.length && foundschema.schema) {
	            if (parts[p] === '$') {
	              if (p === parts.length - 1) {
	                return { schema: foundschema, pathType: 'nested' };
	              }
	              // comments.$.comments.$.title
	              return search(parts.slice(p + 1), foundschema.schema);
	            }
	            // this is the last path of the selector
	            return search(parts.slice(p), foundschema.schema);
	          }
	          return {
	            schema: foundschema,
	            pathType: foundschema.$isSingleNested ? 'nested' : 'array'
	          };
	        }
	        return { schema: foundschema, pathType: 'real' };
	      } else if (p === parts.length && schema.nested[trypath]) {
	        return { schema: schema, pathType: 'nested' };
	      }
	    }
	    return { schema: foundschema || schema, pathType: 'undefined' };
	  }
	
	  // look for arrays
	  return search(path.split('.'), _this);
	};
	
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = Schema;
	
	// require down here because of reference issues
	
	/**
	 * The various built-in Mongoose Schema Types.
	 *
	 * ####Example:
	 *
	 *     var mongoose = require('mongoose');
	 *     var ObjectId = mongoose.Schema.Types.ObjectId;
	 *
	 * ####Types:
	 *
	 * - [String](#schema-string-js)
	 * - [Number](#schema-number-js)
	 * - [Boolean](#schema-boolean-js) | Bool
	 * - [Array](#schema-array-js)
	 * - [Buffer](#schema-buffer-js)
	 * - [Date](#schema-date-js)
	 * - [ObjectId](#schema-objectid-js) | Oid
	 * - [Mixed](#schema-mixed-js)
	 *
	 * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.
	 *
	 *     var Mixed = mongoose.Schema.Types.Mixed;
	 *     new mongoose.Schema({ _user: Mixed })
	 *
	 * @api public
	 */
	
	Schema.Types = MongooseTypes = __webpack_require__(272);
	
	/*!
	 * ignore
	 */
	
	exports.ObjectId = MongooseTypes.ObjectId;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * ignore
	 */
	
	var driver;
	
	if (typeof window === 'undefined') {
	  driver = __webpack_require__(130)(global.MONGOOSE_DRIVER_PATH || './node-mongodb-native');
	} else {
	  driver = __webpack_require__(152);
	}
	
	/*!
	 * ignore
	 */
	
	module.exports = driver;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./browser/ReadPreference": 132,
		"./browser/ReadPreference.js": 132,
		"./browser/binary": 133,
		"./browser/binary.js": 133,
		"./browser/index": 152,
		"./browser/index.js": 152,
		"./browser/objectid": 153,
		"./browser/objectid.js": 153,
		"./index": 129,
		"./index.js": 129,
		"./node-mongodb-native/ReadPreference": 154,
		"./node-mongodb-native/ReadPreference.js": 154,
		"./node-mongodb-native/binary": 219,
		"./node-mongodb-native/binary.js": 219,
		"./node-mongodb-native/collection": 220,
		"./node-mongodb-native/collection.js": 220,
		"./node-mongodb-native/connection": 261,
		"./node-mongodb-native/connection.js": 261,
		"./node-mongodb-native/index": 267,
		"./node-mongodb-native/index.js": 267,
		"./node-mongodb-native/objectid": 268,
		"./node-mongodb-native/objectid.js": 268
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 130;


/***/ },
/* 131 */,
/* 132 */
/***/ function(module, exports) {

	/*!
	 * ignore
	 */
	
	module.exports = function() {};


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var Binary = __webpack_require__(134).Binary;
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = Binary;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// "use strict"
	
	var writeIEEE754 = __webpack_require__(135).writeIEEE754,
		readIEEE754 = __webpack_require__(135).readIEEE754,
	  Map = __webpack_require__(136),
		Long = __webpack_require__(137).Long,
	  Double = __webpack_require__(138).Double,
	  Timestamp = __webpack_require__(139).Timestamp,
	  ObjectID = __webpack_require__(140).ObjectID,
	  BSONRegExp = __webpack_require__(142).BSONRegExp,
	  Symbol = __webpack_require__(143).Symbol,
	  Code = __webpack_require__(144).Code,
	  MinKey = __webpack_require__(145).MinKey,
	  MaxKey = __webpack_require__(146).MaxKey,
	  DBRef = __webpack_require__(147).DBRef,
	  Binary = __webpack_require__(148).Binary;
	
	// Parts of the parser
	var deserialize = __webpack_require__(149),
		serializer = __webpack_require__(150),
		calculateObjectSize = __webpack_require__(151);
	
	/**
	 * @ignore
	 * @api private
	 */
	// Max Size
	var MAXSIZE = (1024*1024*17);
	// Max Document Buffer size
	var buffer = new Buffer(MAXSIZE);
	
	var BSON = function() {
	}
	
	/**
	 * Serialize a Javascript object.
	 *
	 * @param {Object} object the Javascript object to serialize.
	 * @param {Boolean} checkKeys the serializer will check if keys are valid.
	 * @param {Boolean} asBuffer return the serialized object as a Buffer object **(ignore)**.
	 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false)**.
	 * @return {Buffer} returns the Buffer object containing the serialized object.
	 * @api public
	 */
	BSON.prototype.serialize = function serialize(object, checkKeys, asBuffer, serializeFunctions, index, ignoreUndefined) {
		// Attempt to serialize
		var serializationIndex = serializer(buffer, object, checkKeys, index || 0, 0, serializeFunctions, ignoreUndefined);
		// Create the final buffer
		var finishedBuffer = new Buffer(serializationIndex);
		// Copy into the finished buffer
		buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);
		// Return the buffer
		return finishedBuffer;
	}
	
	/**
	 * Serialize a Javascript object using a predefined Buffer and index into the buffer, useful when pre-allocating the space for serialization.
	 *
	 * @param {Object} object the Javascript object to serialize.
	 * @param {Boolean} checkKeys the serializer will check if keys are valid.
	 * @param {Buffer} buffer the Buffer you pre-allocated to store the serialized BSON object.
	 * @param {Number} index the index in the buffer where we wish to start serializing into.
	 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false)**.
	 * @return {Number} returns the new write index in the Buffer.
	 * @api public
	 */
	BSON.prototype.serializeWithBufferAndIndex = function(object, checkKeys, finalBuffer, startIndex, serializeFunctions, ignoreUndefined) {
		// Attempt to serialize
		var serializationIndex = serializer(buffer, object, checkKeys, startIndex || 0, 0, serializeFunctions, ignoreUndefined);
		buffer.copy(finalBuffer, startIndex, 0, serializationIndex);
		// Return the index
		return startIndex + serializationIndex - 1;
	}
	
	/**
	 * Deserialize data as BSON.
	 *
	 * Options
	 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
	 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
	 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
	 *  - **promoteLongs** {Boolean, default:true}, when deserializing a Long will fit it into a Number if it's smaller than 53 bits
	 *
	 * @param {Buffer} buffer the buffer containing the serialized set of BSON documents.
	 * @param {Object} [options] additional options used for the deserialization.
	 * @param {Boolean} [isArray] ignore used for recursive parsing.
	 * @return {Object} returns the deserialized Javascript Object.
	 * @api public
	 */
	BSON.prototype.deserialize = function(data, options) {
	  return deserialize(data, options);
	}
	
	/**
	 * Calculate the bson size for a passed in Javascript object.
	 *
	 * @param {Object} object the Javascript object to calculate the BSON byte size for.
	 * @param {Boolean} [serializeFunctions] serialize all functions in the object **(default:false)**.
	 * @return {Number} returns the number of bytes the BSON object will take up.
	 * @api public
	 */
	BSON.prototype.calculateObjectSize = function(object, serializeFunctions, ignoreUndefined) {
	  return calculateObjectSize(object, serializeFunctions, ignoreUndefined);
	}
	
	/**
	 * Deserialize stream data as BSON documents.
	 *
	 * Options
	 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
	 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
	 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
	 *  - **promoteLongs** {Boolean, default:true}, when deserializing a Long will fit it into a Number if it's smaller than 53 bits
	 *
	 * @param {Buffer} data the buffer containing the serialized set of BSON documents.
	 * @param {Number} startIndex the start index in the data Buffer where the deserialization is to start.
	 * @param {Number} numberOfDocuments number of documents to deserialize.
	 * @param {Array} documents an array where to store the deserialized documents.
	 * @param {Number} docStartIndex the index in the documents array from where to start inserting documents.
	 * @param {Object} [options] additional options used for the deserialization.
	 * @return {Number} returns the next index in the buffer after deserialization **x** numbers of documents.
	 * @api public
	 */
	BSON.prototype.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
	  // if(numberOfDocuments !== documents.length) throw new Error("Number of expected results back is less than the number of documents");
	  options = options != null ? options : {};
	  var index = startIndex;
	  // Loop over all documents
	  for(var i = 0; i < numberOfDocuments; i++) {
	    // Find size of the document
	    var size = data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24;
	    // Update options with index
	    options['index'] = index;
	    // Parse the document at this point
	    documents[docStartIndex + i] = this.deserialize(data, options);
	    // Adjust index by the document size
	    index = index + size;
	  }
	
	  // Return object containing end index of parsing and list of documents
	  return index;
	}
	
	/**
	 * @ignore
	 * @api private
	 */
	// BSON MAX VALUES
	BSON.BSON_INT32_MAX = 0x7FFFFFFF;
	BSON.BSON_INT32_MIN = -0x80000000;
	
	BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
	BSON.BSON_INT64_MIN = -Math.pow(2, 63);
	
	// JS MAX PRECISE VALUES
	BSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.
	BSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.
	
	// Internal long versions
	var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000);  // Any integer up to 2^53 can be precisely represented by a double.
	var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000);  // Any integer down to -2^53 can be precisely represented by a double.
	
	/**
	 * Number BSON Type
	 *
	 * @classconstant BSON_DATA_NUMBER
	 **/
	BSON.BSON_DATA_NUMBER = 1;
	/**
	 * String BSON Type
	 *
	 * @classconstant BSON_DATA_STRING
	 **/
	BSON.BSON_DATA_STRING = 2;
	/**
	 * Object BSON Type
	 *
	 * @classconstant BSON_DATA_OBJECT
	 **/
	BSON.BSON_DATA_OBJECT = 3;
	/**
	 * Array BSON Type
	 *
	 * @classconstant BSON_DATA_ARRAY
	 **/
	BSON.BSON_DATA_ARRAY = 4;
	/**
	 * Binary BSON Type
	 *
	 * @classconstant BSON_DATA_BINARY
	 **/
	BSON.BSON_DATA_BINARY = 5;
	/**
	 * ObjectID BSON Type
	 *
	 * @classconstant BSON_DATA_OID
	 **/
	BSON.BSON_DATA_OID = 7;
	/**
	 * Boolean BSON Type
	 *
	 * @classconstant BSON_DATA_BOOLEAN
	 **/
	BSON.BSON_DATA_BOOLEAN = 8;
	/**
	 * Date BSON Type
	 *
	 * @classconstant BSON_DATA_DATE
	 **/
	BSON.BSON_DATA_DATE = 9;
	/**
	 * null BSON Type
	 *
	 * @classconstant BSON_DATA_NULL
	 **/
	BSON.BSON_DATA_NULL = 10;
	/**
	 * RegExp BSON Type
	 *
	 * @classconstant BSON_DATA_REGEXP
	 **/
	BSON.BSON_DATA_REGEXP = 11;
	/**
	 * Code BSON Type
	 *
	 * @classconstant BSON_DATA_CODE
	 **/
	BSON.BSON_DATA_CODE = 13;
	/**
	 * Symbol BSON Type
	 *
	 * @classconstant BSON_DATA_SYMBOL
	 **/
	BSON.BSON_DATA_SYMBOL = 14;
	/**
	 * Code with Scope BSON Type
	 *
	 * @classconstant BSON_DATA_CODE_W_SCOPE
	 **/
	BSON.BSON_DATA_CODE_W_SCOPE = 15;
	/**
	 * 32 bit Integer BSON Type
	 *
	 * @classconstant BSON_DATA_INT
	 **/
	BSON.BSON_DATA_INT = 16;
	/**
	 * Timestamp BSON Type
	 *
	 * @classconstant BSON_DATA_TIMESTAMP
	 **/
	BSON.BSON_DATA_TIMESTAMP = 17;
	/**
	 * Long BSON Type
	 *
	 * @classconstant BSON_DATA_LONG
	 **/
	BSON.BSON_DATA_LONG = 18;
	/**
	 * MinKey BSON Type
	 *
	 * @classconstant BSON_DATA_MIN_KEY
	 **/
	BSON.BSON_DATA_MIN_KEY = 0xff;
	/**
	 * MaxKey BSON Type
	 *
	 * @classconstant BSON_DATA_MAX_KEY
	 **/
	BSON.BSON_DATA_MAX_KEY = 0x7f;
	
	/**
	 * Binary Default Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_DEFAULT
	 **/
	BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
	/**
	 * Binary Function Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_FUNCTION
	 **/
	BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
	/**
	 * Binary Byte Array Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY
	 **/
	BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
	/**
	 * Binary UUID Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_UUID
	 **/
	BSON.BSON_BINARY_SUBTYPE_UUID = 3;
	/**
	 * Binary MD5 Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_MD5
	 **/
	BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
	/**
	 * Binary User Defined Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED
	 **/
	BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
	
	// Return BSON
	module.exports = BSON;
	module.exports.Code = Code;
	module.exports.Map = Map;
	module.exports.Symbol = Symbol;
	module.exports.BSON = BSON;
	module.exports.DBRef = DBRef;
	module.exports.Binary = Binary;
	module.exports.ObjectID = ObjectID;
	module.exports.Long = Long;
	module.exports.Timestamp = Timestamp;
	module.exports.Double = Double;
	module.exports.MinKey = MinKey;
	module.exports.MaxKey = MaxKey;
	module.exports.BSONRegExp = BSONRegExp;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 135 */
/***/ function(module, exports) {

	// Copyright (c) 2008, Fair Oaks Labs, Inc.
	// All rights reserved.
	// 
	// Redistribution and use in source and binary forms, with or without
	// modification, are permitted provided that the following conditions are met:
	// 
	//  * Redistributions of source code must retain the above copyright notice,
	//    this list of conditions and the following disclaimer.
	// 
	//  * Redistributions in binary form must reproduce the above copyright notice,
	//    this list of conditions and the following disclaimer in the documentation
	//    and/or other materials provided with the distribution.
	// 
	//  * Neither the name of Fair Oaks Labs, Inc. nor the names of its contributors
	//    may be used to endorse or promote products derived from this software
	//    without specific prior written permission.
	// 
	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
	// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	// POSSIBILITY OF SUCH DAMAGE.
	//
	//
	// Modifications to writeIEEE754 to support negative zeroes made by Brian White
	
	var readIEEE754 = function(buffer, offset, endian, mLen, nBytes) {
	  var e, m,
	      bBE = (endian === 'big'),
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      nBits = -7,
	      i = bBE ? 0 : (nBytes - 1),
	      d = bBE ? 1 : -1,
	      s = buffer[offset + i];
	
	  i += d;
	
	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
	
	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
	
	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity);
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
	};
	
	var writeIEEE754 = function(buffer, value, offset, endian, mLen, nBytes) {
	  var e, m, c,
	      bBE = (endian === 'big'),
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
	      i = bBE ? (nBytes-1) : 0,
	      d = bBE ? -1 : 1,
	      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
	
	  value = Math.abs(value);
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e+eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
	
	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
	
	  buffer[offset + i - d] |= s * 128;
	};
	
	exports.readIEEE754 = readIEEE754;
	exports.writeIEEE754 = writeIEEE754;

/***/ },
/* 136 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict"
	
	// We have an ES6 Map available, return the native instance
	if(typeof global.Map !== 'undefined') {
	  module.exports = global.Map;
	  module.exports.Map = global.Map;
	} else {
	  // We will return a polyfill
	  var Map = function(array) {
	    this._keys = [];
	    this._values = {};
	
	    for(var i = 0; i < array.length; i++) {
	      if(array[i] == null) continue;  // skip null and undefined
	      var entry = array[i];
	      var key = entry[0];
	      var value = entry[1];
	      // Add the key to the list of keys in order
	      this._keys.push(key);
	      // Add the key and value to the values dictionary with a point
	      // to the location in the ordered keys list
	      this._values[key] = {v: value, i: this._keys.length - 1};
	    }
	  }
	
	  Map.prototype.clear = function() {
	    this._keys = [];
	    this._values = {};
	  }
	
	  Map.prototype.delete = function(key) {
	    var value = this._values[key];
	    if(value == null) return false;
	    // Delete entry
	    delete this._values[key];
	    // Remove the key from the ordered keys list
	    this._keys.splice(value.i, 1);
	    return true;
	  }
	
	  Map.prototype.entries = function() {
	    var self = this;
	    var index = 0;
	
	    return {
	      next: function() {
	        var key = self._keys[index++];
	        return {
	          value: key !== undefined ? [key, self._values[key].v] : undefined,
	          done: key !== undefined ? false : true
	        }
	      }
	    };
	  }
	
	  Map.prototype.forEach = function(callback, self) {
	    self = self || this;
	
	    for(var i = 0; i < this._keys.length; i++) {
	      var key = this._keys[i];
	      // Call the forEach callback
	      callback.call(self, this._values[key].v, key, self);
	    }
	  }
	
	  Map.prototype.get = function(key) {
	    return this._values[key] ? this._values[key].v : undefined;
	  }
	
	  Map.prototype.has = function(key) {
	    return this._values[key] != null;
	  }
	
	  Map.prototype.keys = function(key) {
	    var self = this;
	    var index = 0;
	
	    return {
	      next: function() {
	        var key = self._keys[index++];
	        return {
	          value: key !== undefined ? key : undefined,
	          done: key !== undefined ? false : true
	        }
	      }
	    };
	  }
	
	  Map.prototype.set = function(key, value) {
	    if(this._values[key]) {
	      this._values[key].v = value;
	      return this;
	    }
	
	    // Add the key to the list of keys in order
	    this._keys.push(key);
	    // Add the key and value to the values dictionary with a point
	    // to the location in the ordered keys list
	    this._values[key] = {v: value, i: this._keys.length - 1};
	    return this;
	  }
	
	  Map.prototype.values = function(key, value) {
	    var self = this;
	    var index = 0;
	
	    return {
	      next: function() {
	        var key = self._keys[index++];
	        return {
	          value: key !== undefined ? self._values[key].v : undefined,
	          done: key !== undefined ? false : true
	        }
	      }
	    };
	  }
	
	  // Last ismaster
	  Object.defineProperty(Map.prototype, 'size', {
	    enumerable:true,
	    get: function() { return this._keys.length; }
	  });
	
	  module.exports = Map;
	  module.exports.Map = Map;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 137 */
/***/ function(module, exports) {

	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//     http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// Copyright 2009 Google Inc. All Rights Reserved
	
	/**
	 * Defines a Long class for representing a 64-bit two's-complement
	 * integer value, which faithfully simulates the behavior of a Java "Long". This
	 * implementation is derived from LongLib in GWT.
	 *
	 * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
	 * values as *signed* integers.  See the from* functions below for more
	 * convenient ways of constructing Longs.
	 *
	 * The internal representation of a Long is the two given signed, 32-bit values.
	 * We use 32-bit pieces because these are the size of integers on which
	 * Javascript performs bit-operations.  For operations like addition and
	 * multiplication, we split each number into 16-bit pieces, which can easily be
	 * multiplied within Javascript's floating-point representation without overflow
	 * or change in sign.
	 *
	 * In the algorithms below, we frequently reduce the negative case to the
	 * positive case by negating the input(s) and then post-processing the result.
	 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
	 * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
	 * a positive number, it overflows back into a negative).  Not handling this
	 * case would often result in infinite recursion.
	 *
	 * @class
	 * @param {number} low  the low (signed) 32 bits of the Long.
	 * @param {number} high the high (signed) 32 bits of the Long.
	 * @return {Long}
	 */
	function Long(low, high) {
	  if(!(this instanceof Long)) return new Long(low, high);
	  
	  this._bsontype = 'Long';
	  /**
	   * @type {number}
	   * @ignore
	   */
	  this.low_ = low | 0;  // force into 32 signed bits.
	
	  /**
	   * @type {number}
	   * @ignore
	   */
	  this.high_ = high | 0;  // force into 32 signed bits.
	};
	
	/**
	 * Return the int value.
	 *
	 * @method
	 * @return {number} the value, assuming it is a 32-bit integer.
	 */
	Long.prototype.toInt = function() {
	  return this.low_;
	};
	
	/**
	 * Return the Number value.
	 *
	 * @method
	 * @return {number} the closest floating-point representation to this value.
	 */
	Long.prototype.toNumber = function() {
	  return this.high_ * Long.TWO_PWR_32_DBL_ +
	         this.getLowBitsUnsigned();
	};
	
	/**
	 * Return the JSON value.
	 *
	 * @method
	 * @return {string} the JSON representation.
	 */
	Long.prototype.toJSON = function() {
	  return this.toString();
	}
	
	/**
	 * Return the String value.
	 *
	 * @method
	 * @param {number} [opt_radix] the radix in which the text should be written.
	 * @return {string} the textual representation of this value.
	 */
	Long.prototype.toString = function(opt_radix) {
	  var radix = opt_radix || 10;
	  if (radix < 2 || 36 < radix) {
	    throw Error('radix out of range: ' + radix);
	  }
	
	  if (this.isZero()) {
	    return '0';
	  }
	
	  if (this.isNegative()) {
	    if (this.equals(Long.MIN_VALUE)) {
	      // We need to change the Long value before it can be negated, so we remove
	      // the bottom-most digit in this base and then recurse to do the rest.
	      var radixLong = Long.fromNumber(radix);
	      var div = this.div(radixLong);
	      var rem = div.multiply(radixLong).subtract(this);
	      return div.toString(radix) + rem.toInt().toString(radix);
	    } else {
	      return '-' + this.negate().toString(radix);
	    }
	  }
	
	  // Do several (6) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = Long.fromNumber(Math.pow(radix, 6));
	
	  var rem = this;
	  var result = '';
	  while (true) {
	    var remDiv = rem.div(radixToPower);
	    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
	    var digits = intval.toString(radix);
	
	    rem = remDiv;
	    if (rem.isZero()) {
	      return digits + result;
	    } else {
	      while (digits.length < 6) {
	        digits = '0' + digits;
	      }
	      result = '' + digits + result;
	    }
	  }
	};
	
	/**
	 * Return the high 32-bits value.
	 *
	 * @method
	 * @return {number} the high 32-bits as a signed value.
	 */
	Long.prototype.getHighBits = function() {
	  return this.high_;
	};
	
	/**
	 * Return the low 32-bits value.
	 *
	 * @method
	 * @return {number} the low 32-bits as a signed value.
	 */
	Long.prototype.getLowBits = function() {
	  return this.low_;
	};
	
	/**
	 * Return the low unsigned 32-bits value.
	 *
	 * @method
	 * @return {number} the low 32-bits as an unsigned value.
	 */
	Long.prototype.getLowBitsUnsigned = function() {
	  return (this.low_ >= 0) ?
	      this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;
	};
	
	/**
	 * Returns the number of bits needed to represent the absolute value of this Long.
	 *
	 * @method
	 * @return {number} Returns the number of bits needed to represent the absolute value of this Long.
	 */
	Long.prototype.getNumBitsAbs = function() {
	  if (this.isNegative()) {
	    if (this.equals(Long.MIN_VALUE)) {
	      return 64;
	    } else {
	      return this.negate().getNumBitsAbs();
	    }
	  } else {
	    var val = this.high_ != 0 ? this.high_ : this.low_;
	    for (var bit = 31; bit > 0; bit--) {
	      if ((val & (1 << bit)) != 0) {
	        break;
	      }
	    }
	    return this.high_ != 0 ? bit + 33 : bit + 1;
	  }
	};
	
	/**
	 * Return whether this value is zero.
	 *
	 * @method
	 * @return {boolean} whether this value is zero.
	 */
	Long.prototype.isZero = function() {
	  return this.high_ == 0 && this.low_ == 0;
	};
	
	/**
	 * Return whether this value is negative.
	 *
	 * @method
	 * @return {boolean} whether this value is negative.
	 */
	Long.prototype.isNegative = function() {
	  return this.high_ < 0;
	};
	
	/**
	 * Return whether this value is odd.
	 *
	 * @method
	 * @return {boolean} whether this value is odd.
	 */
	Long.prototype.isOdd = function() {
	  return (this.low_ & 1) == 1;
	};
	
	/**
	 * Return whether this Long equals the other
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long equals the other
	 */
	Long.prototype.equals = function(other) {
	  return (this.high_ == other.high_) && (this.low_ == other.low_);
	};
	
	/**
	 * Return whether this Long does not equal the other.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long does not equal the other.
	 */
	Long.prototype.notEquals = function(other) {
	  return (this.high_ != other.high_) || (this.low_ != other.low_);
	};
	
	/**
	 * Return whether this Long is less than the other.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long is less than the other.
	 */
	Long.prototype.lessThan = function(other) {
	  return this.compare(other) < 0;
	};
	
	/**
	 * Return whether this Long is less than or equal to the other.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long is less than or equal to the other.
	 */
	Long.prototype.lessThanOrEqual = function(other) {
	  return this.compare(other) <= 0;
	};
	
	/**
	 * Return whether this Long is greater than the other.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long is greater than the other.
	 */
	Long.prototype.greaterThan = function(other) {
	  return this.compare(other) > 0;
	};
	
	/**
	 * Return whether this Long is greater than or equal to the other.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long is greater than or equal to the other.
	 */
	Long.prototype.greaterThanOrEqual = function(other) {
	  return this.compare(other) >= 0;
	};
	
	/**
	 * Compares this Long with the given one.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} 0 if they are the same, 1 if the this is greater, and -1 if the given one is greater.
	 */
	Long.prototype.compare = function(other) {
	  if (this.equals(other)) {
	    return 0;
	  }
	
	  var thisNeg = this.isNegative();
	  var otherNeg = other.isNegative();
	  if (thisNeg && !otherNeg) {
	    return -1;
	  }
	  if (!thisNeg && otherNeg) {
	    return 1;
	  }
	
	  // at this point, the signs are the same, so subtraction will not overflow
	  if (this.subtract(other).isNegative()) {
	    return -1;
	  } else {
	    return 1;
	  }
	};
	
	/**
	 * The negation of this value.
	 *
	 * @method
	 * @return {Long} the negation of this value.
	 */
	Long.prototype.negate = function() {
	  if (this.equals(Long.MIN_VALUE)) {
	    return Long.MIN_VALUE;
	  } else {
	    return this.not().add(Long.ONE);
	  }
	};
	
	/**
	 * Returns the sum of this and the given Long.
	 *
	 * @method
	 * @param {Long} other Long to add to this one.
	 * @return {Long} the sum of this and the given Long.
	 */
	Long.prototype.add = function(other) {
	  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
	
	  var a48 = this.high_ >>> 16;
	  var a32 = this.high_ & 0xFFFF;
	  var a16 = this.low_ >>> 16;
	  var a00 = this.low_ & 0xFFFF;
	
	  var b48 = other.high_ >>> 16;
	  var b32 = other.high_ & 0xFFFF;
	  var b16 = other.low_ >>> 16;
	  var b00 = other.low_ & 0xFFFF;
	
	  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	  c00 += a00 + b00;
	  c16 += c00 >>> 16;
	  c00 &= 0xFFFF;
	  c16 += a16 + b16;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c32 += a32 + b32;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c48 += a48 + b48;
	  c48 &= 0xFFFF;
	  return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
	};
	
	/**
	 * Returns the difference of this and the given Long.
	 *
	 * @method
	 * @param {Long} other Long to subtract from this.
	 * @return {Long} the difference of this and the given Long.
	 */
	Long.prototype.subtract = function(other) {
	  return this.add(other.negate());
	};
	
	/**
	 * Returns the product of this and the given Long.
	 *
	 * @method
	 * @param {Long} other Long to multiply with this.
	 * @return {Long} the product of this and the other.
	 */
	Long.prototype.multiply = function(other) {
	  if (this.isZero()) {
	    return Long.ZERO;
	  } else if (other.isZero()) {
	    return Long.ZERO;
	  }
	
	  if (this.equals(Long.MIN_VALUE)) {
	    return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
	  } else if (other.equals(Long.MIN_VALUE)) {
	    return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
	  }
	
	  if (this.isNegative()) {
	    if (other.isNegative()) {
	      return this.negate().multiply(other.negate());
	    } else {
	      return this.negate().multiply(other).negate();
	    }
	  } else if (other.isNegative()) {
	    return this.multiply(other.negate()).negate();
	  }
	
	  // If both Longs are small, use float multiplication
	  if (this.lessThan(Long.TWO_PWR_24_) &&
	      other.lessThan(Long.TWO_PWR_24_)) {
	    return Long.fromNumber(this.toNumber() * other.toNumber());
	  }
	
	  // Divide each Long into 4 chunks of 16 bits, and then add up 4x4 products.
	  // We can skip products that would overflow.
	
	  var a48 = this.high_ >>> 16;
	  var a32 = this.high_ & 0xFFFF;
	  var a16 = this.low_ >>> 16;
	  var a00 = this.low_ & 0xFFFF;
	
	  var b48 = other.high_ >>> 16;
	  var b32 = other.high_ & 0xFFFF;
	  var b16 = other.low_ >>> 16;
	  var b00 = other.low_ & 0xFFFF;
	
	  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	  c00 += a00 * b00;
	  c16 += c00 >>> 16;
	  c00 &= 0xFFFF;
	  c16 += a16 * b00;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c16 += a00 * b16;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c32 += a32 * b00;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c32 += a16 * b16;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c32 += a00 * b32;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
	  c48 &= 0xFFFF;
	  return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
	};
	
	/**
	 * Returns this Long divided by the given one.
	 *
	 * @method
	 * @param {Long} other Long by which to divide.
	 * @return {Long} this Long divided by the given one.
	 */
	Long.prototype.div = function(other) {
	  if (other.isZero()) {
	    throw Error('division by zero');
	  } else if (this.isZero()) {
	    return Long.ZERO;
	  }
	
	  if (this.equals(Long.MIN_VALUE)) {
	    if (other.equals(Long.ONE) ||
	        other.equals(Long.NEG_ONE)) {
	      return Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
	    } else if (other.equals(Long.MIN_VALUE)) {
	      return Long.ONE;
	    } else {
	      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
	      var halfThis = this.shiftRight(1);
	      var approx = halfThis.div(other).shiftLeft(1);
	      if (approx.equals(Long.ZERO)) {
	        return other.isNegative() ? Long.ONE : Long.NEG_ONE;
	      } else {
	        var rem = this.subtract(other.multiply(approx));
	        var result = approx.add(rem.div(other));
	        return result;
	      }
	    }
	  } else if (other.equals(Long.MIN_VALUE)) {
	    return Long.ZERO;
	  }
	
	  if (this.isNegative()) {
	    if (other.isNegative()) {
	      return this.negate().div(other.negate());
	    } else {
	      return this.negate().div(other).negate();
	    }
	  } else if (other.isNegative()) {
	    return this.div(other.negate()).negate();
	  }
	
	  // Repeat the following until the remainder is less than other:  find a
	  // floating-point that approximates remainder / other *from below*, add this
	  // into the result, and subtract it from the remainder.  It is critical that
	  // the approximate value is less than or equal to the real value so that the
	  // remainder never becomes negative.
	  var res = Long.ZERO;
	  var rem = this;
	  while (rem.greaterThanOrEqual(other)) {
	    // Approximate the result of division. This may be a little greater or
	    // smaller than the actual value.
	    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
	
	    // We will tweak the approximate result by changing it in the 48-th digit or
	    // the smallest non-fractional digit, whichever is larger.
	    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
	    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);
	
	    // Decrease the approximation until it is smaller than the remainder.  Note
	    // that if it is too large, the product overflows and is negative.
	    var approxRes = Long.fromNumber(approx);
	    var approxRem = approxRes.multiply(other);
	    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
	      approx -= delta;
	      approxRes = Long.fromNumber(approx);
	      approxRem = approxRes.multiply(other);
	    }
	
	    // We know the answer can't be zero... and actually, zero would cause
	    // infinite recursion since we would make no progress.
	    if (approxRes.isZero()) {
	      approxRes = Long.ONE;
	    }
	
	    res = res.add(approxRes);
	    rem = rem.subtract(approxRem);
	  }
	  return res;
	};
	
	/**
	 * Returns this Long modulo the given one.
	 *
	 * @method
	 * @param {Long} other Long by which to mod.
	 * @return {Long} this Long modulo the given one.
	 */
	Long.prototype.modulo = function(other) {
	  return this.subtract(this.div(other).multiply(other));
	};
	
	/**
	 * The bitwise-NOT of this value.
	 *
	 * @method
	 * @return {Long} the bitwise-NOT of this value.
	 */
	Long.prototype.not = function() {
	  return Long.fromBits(~this.low_, ~this.high_);
	};
	
	/**
	 * Returns the bitwise-AND of this Long and the given one.
	 *
	 * @method
	 * @param {Long} other the Long with which to AND.
	 * @return {Long} the bitwise-AND of this and the other.
	 */
	Long.prototype.and = function(other) {
	  return Long.fromBits(this.low_ & other.low_, this.high_ & other.high_);
	};
	
	/**
	 * Returns the bitwise-OR of this Long and the given one.
	 *
	 * @method
	 * @param {Long} other the Long with which to OR.
	 * @return {Long} the bitwise-OR of this and the other.
	 */
	Long.prototype.or = function(other) {
	  return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_);
	};
	
	/**
	 * Returns the bitwise-XOR of this Long and the given one.
	 *
	 * @method
	 * @param {Long} other the Long with which to XOR.
	 * @return {Long} the bitwise-XOR of this and the other.
	 */
	Long.prototype.xor = function(other) {
	  return Long.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
	};
	
	/**
	 * Returns this Long with bits shifted to the left by the given amount.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Long} this shifted to the left by the given amount.
	 */
	Long.prototype.shiftLeft = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var low = this.low_;
	    if (numBits < 32) {
	      var high = this.high_;
	      return Long.fromBits(
	                 low << numBits,
	                 (high << numBits) | (low >>> (32 - numBits)));
	    } else {
	      return Long.fromBits(0, low << (numBits - 32));
	    }
	  }
	};
	
	/**
	 * Returns this Long with bits shifted to the right by the given amount.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Long} this shifted to the right by the given amount.
	 */
	Long.prototype.shiftRight = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var high = this.high_;
	    if (numBits < 32) {
	      var low = this.low_;
	      return Long.fromBits(
	                 (low >>> numBits) | (high << (32 - numBits)),
	                 high >> numBits);
	    } else {
	      return Long.fromBits(
	                 high >> (numBits - 32),
	                 high >= 0 ? 0 : -1);
	    }
	  }
	};
	
	/**
	 * Returns this Long with bits shifted to the right by the given amount, with the new top bits matching the current sign bit.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Long} this shifted to the right by the given amount, with zeros placed into the new leading bits.
	 */
	Long.prototype.shiftRightUnsigned = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var high = this.high_;
	    if (numBits < 32) {
	      var low = this.low_;
	      return Long.fromBits(
	                 (low >>> numBits) | (high << (32 - numBits)),
	                 high >>> numBits);
	    } else if (numBits == 32) {
	      return Long.fromBits(high, 0);
	    } else {
	      return Long.fromBits(high >>> (numBits - 32), 0);
	    }
	  }
	};
	
	/**
	 * Returns a Long representing the given (32-bit) integer value.
	 *
	 * @method
	 * @param {number} value the 32-bit integer in question.
	 * @return {Long} the corresponding Long value.
	 */
	Long.fromInt = function(value) {
	  if (-128 <= value && value < 128) {
	    var cachedObj = Long.INT_CACHE_[value];
	    if (cachedObj) {
	      return cachedObj;
	    }
	  }
	
	  var obj = new Long(value | 0, value < 0 ? -1 : 0);
	  if (-128 <= value && value < 128) {
	    Long.INT_CACHE_[value] = obj;
	  }
	  return obj;
	};
	
	/**
	 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
	 *
	 * @method
	 * @param {number} value the number in question.
	 * @return {Long} the corresponding Long value.
	 */
	Long.fromNumber = function(value) {
	  if (isNaN(value) || !isFinite(value)) {
	    return Long.ZERO;
	  } else if (value <= -Long.TWO_PWR_63_DBL_) {
	    return Long.MIN_VALUE;
	  } else if (value + 1 >= Long.TWO_PWR_63_DBL_) {
	    return Long.MAX_VALUE;
	  } else if (value < 0) {
	    return Long.fromNumber(-value).negate();
	  } else {
	    return new Long(
	               (value % Long.TWO_PWR_32_DBL_) | 0,
	               (value / Long.TWO_PWR_32_DBL_) | 0);
	  }
	};
	
	/**
	 * Returns a Long representing the 64-bit integer that comes by concatenating the given high and low bits. Each is assumed to use 32 bits.
	 *
	 * @method
	 * @param {number} lowBits the low 32-bits.
	 * @param {number} highBits the high 32-bits.
	 * @return {Long} the corresponding Long value.
	 */
	Long.fromBits = function(lowBits, highBits) {
	  return new Long(lowBits, highBits);
	};
	
	/**
	 * Returns a Long representation of the given string, written using the given radix.
	 *
	 * @method
	 * @param {string} str the textual representation of the Long.
	 * @param {number} opt_radix the radix in which the text is written.
	 * @return {Long} the corresponding Long value.
	 */
	Long.fromString = function(str, opt_radix) {
	  if (str.length == 0) {
	    throw Error('number format error: empty string');
	  }
	
	  var radix = opt_radix || 10;
	  if (radix < 2 || 36 < radix) {
	    throw Error('radix out of range: ' + radix);
	  }
	
	  if (str.charAt(0) == '-') {
	    return Long.fromString(str.substring(1), radix).negate();
	  } else if (str.indexOf('-') >= 0) {
	    throw Error('number format error: interior "-" character: ' + str);
	  }
	
	  // Do several (8) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = Long.fromNumber(Math.pow(radix, 8));
	
	  var result = Long.ZERO;
	  for (var i = 0; i < str.length; i += 8) {
	    var size = Math.min(8, str.length - i);
	    var value = parseInt(str.substring(i, i + size), radix);
	    if (size < 8) {
	      var power = Long.fromNumber(Math.pow(radix, size));
	      result = result.multiply(power).add(Long.fromNumber(value));
	    } else {
	      result = result.multiply(radixToPower);
	      result = result.add(Long.fromNumber(value));
	    }
	  }
	  return result;
	};
	
	// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
	// from* methods on which they depend.
	
	
	/**
	 * A cache of the Long representations of small integer values.
	 * @type {Object}
	 * @ignore
	 */
	Long.INT_CACHE_ = {};
	
	// NOTE: the compiler should inline these constant values below and then remove
	// these variables, so there should be no runtime penalty for these.
	
	/**
	 * Number used repeated below in calculations.  This must appear before the
	 * first call to any from* function below.
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_16_DBL_ = 1 << 16;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_24_DBL_ = 1 << 24;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_32_DBL_ = Long.TWO_PWR_16_DBL_ * Long.TWO_PWR_16_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_31_DBL_ = Long.TWO_PWR_32_DBL_ / 2;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_48_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_16_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_64_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_32_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_63_DBL_ = Long.TWO_PWR_64_DBL_ / 2;
	
	/** @type {Long} */
	Long.ZERO = Long.fromInt(0);
	
	/** @type {Long} */
	Long.ONE = Long.fromInt(1);
	
	/** @type {Long} */
	Long.NEG_ONE = Long.fromInt(-1);
	
	/** @type {Long} */
	Long.MAX_VALUE =
	    Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);
	
	/** @type {Long} */
	Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0);
	
	/**
	 * @type {Long}
	 * @ignore
	 */
	Long.TWO_PWR_24_ = Long.fromInt(1 << 24);
	
	/**
	 * Expose.
	 */
	module.exports = Long;
	module.exports.Long = Long;

/***/ },
/* 138 */
/***/ function(module, exports) {

	/**
	 * A class representation of the BSON Double type.
	 *
	 * @class
	 * @param {number} value the number we want to represent as a double.
	 * @return {Double}
	 */
	function Double(value) {
	  if(!(this instanceof Double)) return new Double(value);
	  
	  this._bsontype = 'Double';
	  this.value = value;
	}
	
	/**
	 * Access the number value.
	 *
	 * @method
	 * @return {number} returns the wrapped double number.
	 */
	Double.prototype.valueOf = function() {
	  return this.value;
	};
	
	/**
	 * @ignore
	 */
	Double.prototype.toJSON = function() {
	  return this.value;
	}
	
	module.exports = Double;
	module.exports.Double = Double;

/***/ },
/* 139 */
/***/ function(module, exports) {

	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//     http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// Copyright 2009 Google Inc. All Rights Reserved
	
	/**
	 * This type is for INTERNAL use in MongoDB only and should not be used in applications.
	 * The appropriate corresponding type is the JavaScript Date type.
	 * 
	 * Defines a Timestamp class for representing a 64-bit two's-complement
	 * integer value, which faithfully simulates the behavior of a Java "Timestamp". This
	 * implementation is derived from TimestampLib in GWT.
	 *
	 * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
	 * values as *signed* integers.  See the from* functions below for more
	 * convenient ways of constructing Timestamps.
	 *
	 * The internal representation of a Timestamp is the two given signed, 32-bit values.
	 * We use 32-bit pieces because these are the size of integers on which
	 * Javascript performs bit-operations.  For operations like addition and
	 * multiplication, we split each number into 16-bit pieces, which can easily be
	 * multiplied within Javascript's floating-point representation without overflow
	 * or change in sign.
	 *
	 * In the algorithms below, we frequently reduce the negative case to the
	 * positive case by negating the input(s) and then post-processing the result.
	 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
	 * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
	 * a positive number, it overflows back into a negative).  Not handling this
	 * case would often result in infinite recursion.
	 *
	 * @class
	 * @param {number} low  the low (signed) 32 bits of the Timestamp.
	 * @param {number} high the high (signed) 32 bits of the Timestamp.
	 */
	function Timestamp(low, high) {
	  if(!(this instanceof Timestamp)) return new Timestamp(low, high);
	  this._bsontype = 'Timestamp';
	  /**
	   * @type {number}
	   * @ignore
	   */
	  this.low_ = low | 0;  // force into 32 signed bits.
	
	  /**
	   * @type {number}
	   * @ignore
	   */
	  this.high_ = high | 0;  // force into 32 signed bits.
	};
	
	/**
	 * Return the int value.
	 *
	 * @return {number} the value, assuming it is a 32-bit integer.
	 */
	Timestamp.prototype.toInt = function() {
	  return this.low_;
	};
	
	/**
	 * Return the Number value.
	 *
	 * @method
	 * @return {number} the closest floating-point representation to this value.
	 */
	Timestamp.prototype.toNumber = function() {
	  return this.high_ * Timestamp.TWO_PWR_32_DBL_ +
	         this.getLowBitsUnsigned();
	};
	
	/**
	 * Return the JSON value.
	 *
	 * @method
	 * @return {string} the JSON representation.
	 */
	Timestamp.prototype.toJSON = function() {
	  return this.toString();
	}
	
	/**
	 * Return the String value.
	 *
	 * @method
	 * @param {number} [opt_radix] the radix in which the text should be written.
	 * @return {string} the textual representation of this value.
	 */
	Timestamp.prototype.toString = function(opt_radix) {
	  var radix = opt_radix || 10;
	  if (radix < 2 || 36 < radix) {
	    throw Error('radix out of range: ' + radix);
	  }
	
	  if (this.isZero()) {
	    return '0';
	  }
	
	  if (this.isNegative()) {
	    if (this.equals(Timestamp.MIN_VALUE)) {
	      // We need to change the Timestamp value before it can be negated, so we remove
	      // the bottom-most digit in this base and then recurse to do the rest.
	      var radixTimestamp = Timestamp.fromNumber(radix);
	      var div = this.div(radixTimestamp);
	      var rem = div.multiply(radixTimestamp).subtract(this);
	      return div.toString(radix) + rem.toInt().toString(radix);
	    } else {
	      return '-' + this.negate().toString(radix);
	    }
	  }
	
	  // Do several (6) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = Timestamp.fromNumber(Math.pow(radix, 6));
	
	  var rem = this;
	  var result = '';
	  while (true) {
	    var remDiv = rem.div(radixToPower);
	    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
	    var digits = intval.toString(radix);
	
	    rem = remDiv;
	    if (rem.isZero()) {
	      return digits + result;
	    } else {
	      while (digits.length < 6) {
	        digits = '0' + digits;
	      }
	      result = '' + digits + result;
	    }
	  }
	};
	
	/**
	 * Return the high 32-bits value.
	 *
	 * @method
	 * @return {number} the high 32-bits as a signed value.
	 */
	Timestamp.prototype.getHighBits = function() {
	  return this.high_;
	};
	
	/**
	 * Return the low 32-bits value.
	 *
	 * @method
	 * @return {number} the low 32-bits as a signed value.
	 */
	Timestamp.prototype.getLowBits = function() {
	  return this.low_;
	};
	
	/**
	 * Return the low unsigned 32-bits value.
	 *
	 * @method
	 * @return {number} the low 32-bits as an unsigned value.
	 */
	Timestamp.prototype.getLowBitsUnsigned = function() {
	  return (this.low_ >= 0) ?
	      this.low_ : Timestamp.TWO_PWR_32_DBL_ + this.low_;
	};
	
	/**
	 * Returns the number of bits needed to represent the absolute value of this Timestamp.
	 *
	 * @method
	 * @return {number} Returns the number of bits needed to represent the absolute value of this Timestamp.
	 */
	Timestamp.prototype.getNumBitsAbs = function() {
	  if (this.isNegative()) {
	    if (this.equals(Timestamp.MIN_VALUE)) {
	      return 64;
	    } else {
	      return this.negate().getNumBitsAbs();
	    }
	  } else {
	    var val = this.high_ != 0 ? this.high_ : this.low_;
	    for (var bit = 31; bit > 0; bit--) {
	      if ((val & (1 << bit)) != 0) {
	        break;
	      }
	    }
	    return this.high_ != 0 ? bit + 33 : bit + 1;
	  }
	};
	
	/**
	 * Return whether this value is zero.
	 *
	 * @method
	 * @return {boolean} whether this value is zero.
	 */
	Timestamp.prototype.isZero = function() {
	  return this.high_ == 0 && this.low_ == 0;
	};
	
	/**
	 * Return whether this value is negative.
	 *
	 * @method
	 * @return {boolean} whether this value is negative.
	 */
	Timestamp.prototype.isNegative = function() {
	  return this.high_ < 0;
	};
	
	/**
	 * Return whether this value is odd.
	 *
	 * @method
	 * @return {boolean} whether this value is odd.
	 */
	Timestamp.prototype.isOdd = function() {
	  return (this.low_ & 1) == 1;
	};
	
	/**
	 * Return whether this Timestamp equals the other
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp equals the other
	 */
	Timestamp.prototype.equals = function(other) {
	  return (this.high_ == other.high_) && (this.low_ == other.low_);
	};
	
	/**
	 * Return whether this Timestamp does not equal the other.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp does not equal the other.
	 */
	Timestamp.prototype.notEquals = function(other) {
	  return (this.high_ != other.high_) || (this.low_ != other.low_);
	};
	
	/**
	 * Return whether this Timestamp is less than the other.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp is less than the other.
	 */
	Timestamp.prototype.lessThan = function(other) {
	  return this.compare(other) < 0;
	};
	
	/**
	 * Return whether this Timestamp is less than or equal to the other.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp is less than or equal to the other.
	 */
	Timestamp.prototype.lessThanOrEqual = function(other) {
	  return this.compare(other) <= 0;
	};
	
	/**
	 * Return whether this Timestamp is greater than the other.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp is greater than the other.
	 */
	Timestamp.prototype.greaterThan = function(other) {
	  return this.compare(other) > 0;
	};
	
	/**
	 * Return whether this Timestamp is greater than or equal to the other.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp is greater than or equal to the other.
	 */
	Timestamp.prototype.greaterThanOrEqual = function(other) {
	  return this.compare(other) >= 0;
	};
	
	/**
	 * Compares this Timestamp with the given one.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} 0 if they are the same, 1 if the this is greater, and -1 if the given one is greater.
	 */
	Timestamp.prototype.compare = function(other) {
	  if (this.equals(other)) {
	    return 0;
	  }
	
	  var thisNeg = this.isNegative();
	  var otherNeg = other.isNegative();
	  if (thisNeg && !otherNeg) {
	    return -1;
	  }
	  if (!thisNeg && otherNeg) {
	    return 1;
	  }
	
	  // at this point, the signs are the same, so subtraction will not overflow
	  if (this.subtract(other).isNegative()) {
	    return -1;
	  } else {
	    return 1;
	  }
	};
	
	/**
	 * The negation of this value.
	 *
	 * @method
	 * @return {Timestamp} the negation of this value.
	 */
	Timestamp.prototype.negate = function() {
	  if (this.equals(Timestamp.MIN_VALUE)) {
	    return Timestamp.MIN_VALUE;
	  } else {
	    return this.not().add(Timestamp.ONE);
	  }
	};
	
	/**
	 * Returns the sum of this and the given Timestamp.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to add to this one.
	 * @return {Timestamp} the sum of this and the given Timestamp.
	 */
	Timestamp.prototype.add = function(other) {
	  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
	
	  var a48 = this.high_ >>> 16;
	  var a32 = this.high_ & 0xFFFF;
	  var a16 = this.low_ >>> 16;
	  var a00 = this.low_ & 0xFFFF;
	
	  var b48 = other.high_ >>> 16;
	  var b32 = other.high_ & 0xFFFF;
	  var b16 = other.low_ >>> 16;
	  var b00 = other.low_ & 0xFFFF;
	
	  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	  c00 += a00 + b00;
	  c16 += c00 >>> 16;
	  c00 &= 0xFFFF;
	  c16 += a16 + b16;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c32 += a32 + b32;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c48 += a48 + b48;
	  c48 &= 0xFFFF;
	  return Timestamp.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
	};
	
	/**
	 * Returns the difference of this and the given Timestamp.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to subtract from this.
	 * @return {Timestamp} the difference of this and the given Timestamp.
	 */
	Timestamp.prototype.subtract = function(other) {
	  return this.add(other.negate());
	};
	
	/**
	 * Returns the product of this and the given Timestamp.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to multiply with this.
	 * @return {Timestamp} the product of this and the other.
	 */
	Timestamp.prototype.multiply = function(other) {
	  if (this.isZero()) {
	    return Timestamp.ZERO;
	  } else if (other.isZero()) {
	    return Timestamp.ZERO;
	  }
	
	  if (this.equals(Timestamp.MIN_VALUE)) {
	    return other.isOdd() ? Timestamp.MIN_VALUE : Timestamp.ZERO;
	  } else if (other.equals(Timestamp.MIN_VALUE)) {
	    return this.isOdd() ? Timestamp.MIN_VALUE : Timestamp.ZERO;
	  }
	
	  if (this.isNegative()) {
	    if (other.isNegative()) {
	      return this.negate().multiply(other.negate());
	    } else {
	      return this.negate().multiply(other).negate();
	    }
	  } else if (other.isNegative()) {
	    return this.multiply(other.negate()).negate();
	  }
	
	  // If both Timestamps are small, use float multiplication
	  if (this.lessThan(Timestamp.TWO_PWR_24_) &&
	      other.lessThan(Timestamp.TWO_PWR_24_)) {
	    return Timestamp.fromNumber(this.toNumber() * other.toNumber());
	  }
	
	  // Divide each Timestamp into 4 chunks of 16 bits, and then add up 4x4 products.
	  // We can skip products that would overflow.
	
	  var a48 = this.high_ >>> 16;
	  var a32 = this.high_ & 0xFFFF;
	  var a16 = this.low_ >>> 16;
	  var a00 = this.low_ & 0xFFFF;
	
	  var b48 = other.high_ >>> 16;
	  var b32 = other.high_ & 0xFFFF;
	  var b16 = other.low_ >>> 16;
	  var b00 = other.low_ & 0xFFFF;
	
	  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	  c00 += a00 * b00;
	  c16 += c00 >>> 16;
	  c00 &= 0xFFFF;
	  c16 += a16 * b00;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c16 += a00 * b16;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c32 += a32 * b00;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c32 += a16 * b16;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c32 += a00 * b32;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
	  c48 &= 0xFFFF;
	  return Timestamp.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
	};
	
	/**
	 * Returns this Timestamp divided by the given one.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp by which to divide.
	 * @return {Timestamp} this Timestamp divided by the given one.
	 */
	Timestamp.prototype.div = function(other) {
	  if (other.isZero()) {
	    throw Error('division by zero');
	  } else if (this.isZero()) {
	    return Timestamp.ZERO;
	  }
	
	  if (this.equals(Timestamp.MIN_VALUE)) {
	    if (other.equals(Timestamp.ONE) ||
	        other.equals(Timestamp.NEG_ONE)) {
	      return Timestamp.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
	    } else if (other.equals(Timestamp.MIN_VALUE)) {
	      return Timestamp.ONE;
	    } else {
	      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
	      var halfThis = this.shiftRight(1);
	      var approx = halfThis.div(other).shiftLeft(1);
	      if (approx.equals(Timestamp.ZERO)) {
	        return other.isNegative() ? Timestamp.ONE : Timestamp.NEG_ONE;
	      } else {
	        var rem = this.subtract(other.multiply(approx));
	        var result = approx.add(rem.div(other));
	        return result;
	      }
	    }
	  } else if (other.equals(Timestamp.MIN_VALUE)) {
	    return Timestamp.ZERO;
	  }
	
	  if (this.isNegative()) {
	    if (other.isNegative()) {
	      return this.negate().div(other.negate());
	    } else {
	      return this.negate().div(other).negate();
	    }
	  } else if (other.isNegative()) {
	    return this.div(other.negate()).negate();
	  }
	
	  // Repeat the following until the remainder is less than other:  find a
	  // floating-point that approximates remainder / other *from below*, add this
	  // into the result, and subtract it from the remainder.  It is critical that
	  // the approximate value is less than or equal to the real value so that the
	  // remainder never becomes negative.
	  var res = Timestamp.ZERO;
	  var rem = this;
	  while (rem.greaterThanOrEqual(other)) {
	    // Approximate the result of division. This may be a little greater or
	    // smaller than the actual value.
	    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
	
	    // We will tweak the approximate result by changing it in the 48-th digit or
	    // the smallest non-fractional digit, whichever is larger.
	    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
	    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);
	
	    // Decrease the approximation until it is smaller than the remainder.  Note
	    // that if it is too large, the product overflows and is negative.
	    var approxRes = Timestamp.fromNumber(approx);
	    var approxRem = approxRes.multiply(other);
	    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
	      approx -= delta;
	      approxRes = Timestamp.fromNumber(approx);
	      approxRem = approxRes.multiply(other);
	    }
	
	    // We know the answer can't be zero... and actually, zero would cause
	    // infinite recursion since we would make no progress.
	    if (approxRes.isZero()) {
	      approxRes = Timestamp.ONE;
	    }
	
	    res = res.add(approxRes);
	    rem = rem.subtract(approxRem);
	  }
	  return res;
	};
	
	/**
	 * Returns this Timestamp modulo the given one.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp by which to mod.
	 * @return {Timestamp} this Timestamp modulo the given one.
	 */
	Timestamp.prototype.modulo = function(other) {
	  return this.subtract(this.div(other).multiply(other));
	};
	
	/**
	 * The bitwise-NOT of this value.
	 *
	 * @method
	 * @return {Timestamp} the bitwise-NOT of this value.
	 */
	Timestamp.prototype.not = function() {
	  return Timestamp.fromBits(~this.low_, ~this.high_);
	};
	
	/**
	 * Returns the bitwise-AND of this Timestamp and the given one.
	 *
	 * @method
	 * @param {Timestamp} other the Timestamp with which to AND.
	 * @return {Timestamp} the bitwise-AND of this and the other.
	 */
	Timestamp.prototype.and = function(other) {
	  return Timestamp.fromBits(this.low_ & other.low_, this.high_ & other.high_);
	};
	
	/**
	 * Returns the bitwise-OR of this Timestamp and the given one.
	 *
	 * @method
	 * @param {Timestamp} other the Timestamp with which to OR.
	 * @return {Timestamp} the bitwise-OR of this and the other.
	 */
	Timestamp.prototype.or = function(other) {
	  return Timestamp.fromBits(this.low_ | other.low_, this.high_ | other.high_);
	};
	
	/**
	 * Returns the bitwise-XOR of this Timestamp and the given one.
	 *
	 * @method
	 * @param {Timestamp} other the Timestamp with which to XOR.
	 * @return {Timestamp} the bitwise-XOR of this and the other.
	 */
	Timestamp.prototype.xor = function(other) {
	  return Timestamp.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
	};
	
	/**
	 * Returns this Timestamp with bits shifted to the left by the given amount.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Timestamp} this shifted to the left by the given amount.
	 */
	Timestamp.prototype.shiftLeft = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var low = this.low_;
	    if (numBits < 32) {
	      var high = this.high_;
	      return Timestamp.fromBits(
	                 low << numBits,
	                 (high << numBits) | (low >>> (32 - numBits)));
	    } else {
	      return Timestamp.fromBits(0, low << (numBits - 32));
	    }
	  }
	};
	
	/**
	 * Returns this Timestamp with bits shifted to the right by the given amount.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Timestamp} this shifted to the right by the given amount.
	 */
	Timestamp.prototype.shiftRight = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var high = this.high_;
	    if (numBits < 32) {
	      var low = this.low_;
	      return Timestamp.fromBits(
	                 (low >>> numBits) | (high << (32 - numBits)),
	                 high >> numBits);
	    } else {
	      return Timestamp.fromBits(
	                 high >> (numBits - 32),
	                 high >= 0 ? 0 : -1);
	    }
	  }
	};
	
	/**
	 * Returns this Timestamp with bits shifted to the right by the given amount, with the new top bits matching the current sign bit.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Timestamp} this shifted to the right by the given amount, with zeros placed into the new leading bits.
	 */
	Timestamp.prototype.shiftRightUnsigned = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var high = this.high_;
	    if (numBits < 32) {
	      var low = this.low_;
	      return Timestamp.fromBits(
	                 (low >>> numBits) | (high << (32 - numBits)),
	                 high >>> numBits);
	    } else if (numBits == 32) {
	      return Timestamp.fromBits(high, 0);
	    } else {
	      return Timestamp.fromBits(high >>> (numBits - 32), 0);
	    }
	  }
	};
	
	/**
	 * Returns a Timestamp representing the given (32-bit) integer value.
	 *
	 * @method
	 * @param {number} value the 32-bit integer in question.
	 * @return {Timestamp} the corresponding Timestamp value.
	 */
	Timestamp.fromInt = function(value) {
	  if (-128 <= value && value < 128) {
	    var cachedObj = Timestamp.INT_CACHE_[value];
	    if (cachedObj) {
	      return cachedObj;
	    }
	  }
	
	  var obj = new Timestamp(value | 0, value < 0 ? -1 : 0);
	  if (-128 <= value && value < 128) {
	    Timestamp.INT_CACHE_[value] = obj;
	  }
	  return obj;
	};
	
	/**
	 * Returns a Timestamp representing the given value, provided that it is a finite number. Otherwise, zero is returned.
	 *
	 * @method
	 * @param {number} value the number in question.
	 * @return {Timestamp} the corresponding Timestamp value.
	 */
	Timestamp.fromNumber = function(value) {
	  if (isNaN(value) || !isFinite(value)) {
	    return Timestamp.ZERO;
	  } else if (value <= -Timestamp.TWO_PWR_63_DBL_) {
	    return Timestamp.MIN_VALUE;
	  } else if (value + 1 >= Timestamp.TWO_PWR_63_DBL_) {
	    return Timestamp.MAX_VALUE;
	  } else if (value < 0) {
	    return Timestamp.fromNumber(-value).negate();
	  } else {
	    return new Timestamp(
	               (value % Timestamp.TWO_PWR_32_DBL_) | 0,
	               (value / Timestamp.TWO_PWR_32_DBL_) | 0);
	  }
	};
	
	/**
	 * Returns a Timestamp representing the 64-bit integer that comes by concatenating the given high and low bits. Each is assumed to use 32 bits.
	 *
	 * @method
	 * @param {number} lowBits the low 32-bits.
	 * @param {number} highBits the high 32-bits.
	 * @return {Timestamp} the corresponding Timestamp value.
	 */
	Timestamp.fromBits = function(lowBits, highBits) {
	  return new Timestamp(lowBits, highBits);
	};
	
	/**
	 * Returns a Timestamp representation of the given string, written using the given radix.
	 *
	 * @method
	 * @param {string} str the textual representation of the Timestamp.
	 * @param {number} opt_radix the radix in which the text is written.
	 * @return {Timestamp} the corresponding Timestamp value.
	 */
	Timestamp.fromString = function(str, opt_radix) {
	  if (str.length == 0) {
	    throw Error('number format error: empty string');
	  }
	
	  var radix = opt_radix || 10;
	  if (radix < 2 || 36 < radix) {
	    throw Error('radix out of range: ' + radix);
	  }
	
	  if (str.charAt(0) == '-') {
	    return Timestamp.fromString(str.substring(1), radix).negate();
	  } else if (str.indexOf('-') >= 0) {
	    throw Error('number format error: interior "-" character: ' + str);
	  }
	
	  // Do several (8) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = Timestamp.fromNumber(Math.pow(radix, 8));
	
	  var result = Timestamp.ZERO;
	  for (var i = 0; i < str.length; i += 8) {
	    var size = Math.min(8, str.length - i);
	    var value = parseInt(str.substring(i, i + size), radix);
	    if (size < 8) {
	      var power = Timestamp.fromNumber(Math.pow(radix, size));
	      result = result.multiply(power).add(Timestamp.fromNumber(value));
	    } else {
	      result = result.multiply(radixToPower);
	      result = result.add(Timestamp.fromNumber(value));
	    }
	  }
	  return result;
	};
	
	// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
	// from* methods on which they depend.
	
	
	/**
	 * A cache of the Timestamp representations of small integer values.
	 * @type {Object}
	 * @ignore
	 */
	Timestamp.INT_CACHE_ = {};
	
	// NOTE: the compiler should inline these constant values below and then remove
	// these variables, so there should be no runtime penalty for these.
	
	/**
	 * Number used repeated below in calculations.  This must appear before the
	 * first call to any from* function below.
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_16_DBL_ = 1 << 16;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_24_DBL_ = 1 << 24;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_32_DBL_ = Timestamp.TWO_PWR_16_DBL_ * Timestamp.TWO_PWR_16_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_31_DBL_ = Timestamp.TWO_PWR_32_DBL_ / 2;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_48_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_16_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_64_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_32_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_63_DBL_ = Timestamp.TWO_PWR_64_DBL_ / 2;
	
	/** @type {Timestamp} */
	Timestamp.ZERO = Timestamp.fromInt(0);
	
	/** @type {Timestamp} */
	Timestamp.ONE = Timestamp.fromInt(1);
	
	/** @type {Timestamp} */
	Timestamp.NEG_ONE = Timestamp.fromInt(-1);
	
	/** @type {Timestamp} */
	Timestamp.MAX_VALUE =
	    Timestamp.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);
	
	/** @type {Timestamp} */
	Timestamp.MIN_VALUE = Timestamp.fromBits(0, 0x80000000 | 0);
	
	/**
	 * @type {Timestamp}
	 * @ignore
	 */
	Timestamp.TWO_PWR_24_ = Timestamp.fromInt(1 << 24);
	
	/**
	 * Expose.
	 */
	module.exports = Timestamp;
	module.exports.Timestamp = Timestamp;

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Module dependencies.
	 * @ignore
	 */
	var BinaryParser = __webpack_require__(141).BinaryParser;
	
	/**
	 * Machine id.
	 *
	 * Create a random 3-byte value (i.e. unique for this
	 * process). Other drivers use a md5 of the machine id here, but
	 * that would mean an asyc call to gethostname, so we don't bother.
	 * @ignore
	 */
	var MACHINE_ID = parseInt(Math.random() * 0xFFFFFF, 10);
	
	// Regular expression that checks for hex value
	var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
	
	/**
	* Create a new ObjectID instance
	*
	* @class
	* @param {(string|number)} id Can be a 24 byte hex string, 12 byte binary string or a Number.
	* @property {number} generationTime The generation time of this ObjectId instance
	* @return {ObjectID} instance of ObjectID.
	*/
	var ObjectID = function ObjectID(id) {
	  if(!(this instanceof ObjectID)) return new ObjectID(id);
	  // Duck-typing to support ObjectId from different npm packages
	  if((id instanceof ObjectID) || (id && id.toHexString)) return id;
	
	  this._bsontype = 'ObjectID';
	  var __id = null;
	  var valid = ObjectID.isValid(id);
	
	  // Throw an error if it's not a valid setup
	  if(!valid && id != null){
	    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
	  } else if(valid && typeof id == 'string' && id.length == 24) {
	    return ObjectID.createFromHexString(id);
	  } else if(id == null || typeof id == 'number') {
	    // convert to 12 byte binary string
	    this.id = this.generate(id);
	  } else if(id != null && id.length === 12) {
	    // assume 12 byte string
	    this.id = id;
	  }
	
	  if(ObjectID.cacheHexString) this.__id = this.toHexString();
	};
	
	// Allow usage of ObjectId as well as ObjectID
	var ObjectId = ObjectID;
	
	// Precomputed hex table enables speedy hex string conversion
	var hexTable = [];
	for (var i = 0; i < 256; i++) {
	  hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);
	}
	
	/**
	* Return the ObjectID id as a 24 byte hex string representation
	*
	* @method
	* @return {string} return the 24 byte hex string representation.
	*/
	ObjectID.prototype.toHexString = function() {
	  if(ObjectID.cacheHexString && this.__id) return this.__id;
	
	  var hexString = '';
	
	  for (var i = 0; i < this.id.length; i++) {
	    hexString += hexTable[this.id.charCodeAt(i)];
	  }
	
	  if(ObjectID.cacheHexString) this.__id = hexString;
	  return hexString;
	};
	
	/**
	* Update the ObjectID index used in generating new ObjectID's on the driver
	*
	* @method
	* @return {number} returns next index value.
	* @ignore
	*/
	ObjectID.prototype.get_inc = function() {
	  return ObjectID.index = (ObjectID.index + 1) % 0xFFFFFF;
	};
	
	/**
	* Update the ObjectID index used in generating new ObjectID's on the driver
	*
	* @method
	* @return {number} returns next index value.
	* @ignore
	*/
	ObjectID.prototype.getInc = function() {
	  return this.get_inc();
	};
	
	/**
	* Generate a 12 byte id string used in ObjectID's
	*
	* @method
	* @param {number} [time] optional parameter allowing to pass in a second based timestamp.
	* @return {string} return the 12 byte id binary string.
	*/
	ObjectID.prototype.generate = function(time) {
	  if ('number' != typeof time) {
	    time = parseInt(Date.now()/1000,10);
	  }
	
	  var time4Bytes = BinaryParser.encodeInt(time, 32, true, true);
	  /* for time-based ObjectID the bytes following the time will be zeroed */
	  var machine3Bytes = BinaryParser.encodeInt(MACHINE_ID, 24, false);
	  var pid2Bytes = BinaryParser.fromShort((typeof process === 'undefined' ? Math.floor(Math.random() * 100000) : process.pid) % 0xFFFF);
	  var index3Bytes = BinaryParser.encodeInt(this.get_inc(), 24, false, true);
	
	  return time4Bytes + machine3Bytes + pid2Bytes + index3Bytes;
	};
	
	/**
	* Converts the id into a 24 byte hex string for printing
	*
	* @return {String} return the 24 byte hex string representation.
	* @ignore
	*/
	ObjectID.prototype.toString = function() {
	  return this.toHexString();
	};
	
	/**
	* Converts to a string representation of this Id.
	*
	* @return {String} return the 24 byte hex string representation.
	* @ignore
	*/
	ObjectID.prototype.inspect = ObjectID.prototype.toString;
	
	/**
	* Converts to its JSON representation.
	*
	* @return {String} return the 24 byte hex string representation.
	* @ignore
	*/
	ObjectID.prototype.toJSON = function() {
	  return this.toHexString();
	};
	
	/**
	* Compares the equality of this ObjectID with `otherID`.
	*
	* @method
	* @param {object} otherID ObjectID instance to compare against.
	* @return {boolean} the result of comparing two ObjectID's
	*/
	ObjectID.prototype.equals = function equals (otherID) {
	  var id;
	
	  if(otherID != null && (otherID instanceof ObjectID || otherID.toHexString)) {
	    id = otherID.id;
	  } else if(typeof otherID == 'string' && ObjectID.isValid(otherID)) {
	    id = ObjectID.createFromHexString(otherID).id;
	  } else {
	    return false;
	  }
	
	  return this.id === id;
	}
	
	/**
	* Returns the generation date (accurate up to the second) that this ID was generated.
	*
	* @method
	* @return {date} the generation date
	*/
	ObjectID.prototype.getTimestamp = function() {
	  var timestamp = new Date();
	  timestamp.setTime(Math.floor(BinaryParser.decodeInt(this.id.substring(0,4), 32, true, true)) * 1000);
	  return timestamp;
	}
	
	/**
	* @ignore
	*/
	ObjectID.index = parseInt(Math.random() * 0xFFFFFF, 10);
	
	/**
	* @ignore
	*/
	ObjectID.createPk = function createPk () {
	  return new ObjectID();
	};
	
	/**
	* Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.
	*
	* @method
	* @param {number} time an integer number representing a number of seconds.
	* @return {ObjectID} return the created ObjectID
	*/
	ObjectID.createFromTime = function createFromTime (time) {
	  var id = BinaryParser.encodeInt(time, 32, true, true) +
	           BinaryParser.encodeInt(0, 64, true, true);
	  return new ObjectID(id);
	};
	
	/**
	* Creates an ObjectID from a hex string representation of an ObjectID.
	*
	* @method
	* @param {string} hexString create a ObjectID from a passed in 24 byte hexstring.
	* @return {ObjectID} return the created ObjectID
	*/
	ObjectID.createFromHexString = function createFromHexString (hexString) {
	  // Throw an error if it's not a valid setup
	  if(typeof hexString === 'undefined' || hexString != null && hexString.length != 24)
	    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
	
	  var len = hexString.length;
	
	  if(len > 12*2) {
	    throw new Error('Id cannot be longer than 12 bytes');
	  }
	
	  var result = ''
	    , string
	    , number;
	
	  for (var index = 0; index < len; index += 2) {
	    string = hexString.substr(index, 2);
	    number = parseInt(string, 16);
	    result += BinaryParser.fromByte(number);
	  }
	
	  return new ObjectID(result, hexString);
	};
	
	/**
	* Checks if a value is a valid bson ObjectId
	*
	* @method
	* @return {boolean} return true if the value is a valid bson ObjectId, return false otherwise.
	*/
	ObjectID.isValid = function isValid(id) {
	  if(id == null) return false;
	
	  if(typeof id == 'number')
	    return true;
	  if(typeof id == 'string') {
	    return id.length == 12 || (id.length == 24 && checkForHexRegExp.test(id));
	  }
	  if(id instanceof ObjectID) {
	    return true;
	  }
	  // Duck-Typing detection of ObjectId like objects
	  if(id.toHexString) {
	    return id.id.length == 12 || (id.id.length == 24 && checkForHexRegExp.test(id.id));
	  }
	  return false;
	};
	
	/**
	* @ignore
	*/
	Object.defineProperty(ObjectID.prototype, "generationTime", {
	   enumerable: true
	 , get: function () {
	     return Math.floor(BinaryParser.decodeInt(this.id.substring(0,4), 32, true, true));
	   }
	 , set: function (value) {
	     var value = BinaryParser.encodeInt(value, 32, true, true);
	     this.id = value + this.id.substr(4);
	     // delete this.__id;
	     this.toHexString();
	   }
	});
	
	/**
	 * Expose.
	 */
	module.exports = ObjectID;
	module.exports.ObjectID = ObjectID;
	module.exports.ObjectId = ObjectID;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Binary Parser.
	 * Jonas Raoni Soares Silva
	 * http://jsfromhell.com/classes/binary-parser [v1.0]
	 */
	var chr = String.fromCharCode;
	
	var maxBits = [];
	for (var i = 0; i < 64; i++) {
		maxBits[i] = Math.pow(2, i);
	}
	
	function BinaryParser (bigEndian, allowExceptions) {
	  if(!(this instanceof BinaryParser)) return new BinaryParser(bigEndian, allowExceptions);
	  
		this.bigEndian = bigEndian;
		this.allowExceptions = allowExceptions;
	};
	
	BinaryParser.warn = function warn (msg) {
		if (this.allowExceptions) {
			throw new Error(msg);
	  }
	
		return 1;
	};
	
	BinaryParser.decodeFloat = function decodeFloat (data, precisionBits, exponentBits) {
		var b = new this.Buffer(this.bigEndian, data);
	
		b.checkBuffer(precisionBits + exponentBits + 1);
	
		var bias = maxBits[exponentBits - 1] - 1
	    , signal = b.readBits(precisionBits + exponentBits, 1)
	    , exponent = b.readBits(precisionBits, exponentBits)
	    , significand = 0
	    , divisor = 2
	    , curByte = b.buffer.length + (-precisionBits >> 3) - 1;
	
		do {
			for (var byteValue = b.buffer[ ++curByte ], startBit = precisionBits % 8 || 8, mask = 1 << startBit; mask >>= 1; ( byteValue & mask ) && ( significand += 1 / divisor ), divisor *= 2 );
		} while (precisionBits -= startBit);
	
		return exponent == ( bias << 1 ) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : ( 1 + signal * -2 ) * ( exponent || significand ? !exponent ? Math.pow( 2, -bias + 1 ) * significand : Math.pow( 2, exponent - bias ) * ( 1 + significand ) : 0 );
	};
	
	BinaryParser.decodeInt = function decodeInt (data, bits, signed, forceBigEndian) {
	  var b = new this.Buffer(this.bigEndian || forceBigEndian, data)
	      , x = b.readBits(0, bits)
	      , max = maxBits[bits]; //max = Math.pow( 2, bits );
	  
	  return signed && x >= max / 2
	      ? x - max
	      : x;
	};
	
	BinaryParser.encodeFloat = function encodeFloat (data, precisionBits, exponentBits) {
		var bias = maxBits[exponentBits - 1] - 1
	    , minExp = -bias + 1
	    , maxExp = bias
	    , minUnnormExp = minExp - precisionBits
	    , n = parseFloat(data)
	    , status = isNaN(n) || n == -Infinity || n == +Infinity ? n : 0
	    ,	exp = 0
	    , len = 2 * bias + 1 + precisionBits + 3
	    , bin = new Array(len)
	    , signal = (n = status !== 0 ? 0 : n) < 0
	    , intPart = Math.floor(n = Math.abs(n))
	    , floatPart = n - intPart
	    , lastBit
	    , rounded
	    , result
	    , i
	    , j;
	
		for (i = len; i; bin[--i] = 0);
	
		for (i = bias + 2; intPart && i; bin[--i] = intPart % 2, intPart = Math.floor(intPart / 2));
	
		for (i = bias + 1; floatPart > 0 && i; (bin[++i] = ((floatPart *= 2) >= 1) - 0 ) && --floatPart);
	
		for (i = -1; ++i < len && !bin[i];);
	
		if (bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i) >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1))) + 1]) {
			if (!(rounded = bin[lastBit])) {
				for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]);
			}
	
			for (j = lastBit + 1; rounded && --j >= 0; (bin[j] = !bin[j] - 0) && (rounded = 0));
		}
	
		for (i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i];);
	
		if ((exp = bias + 1 - i) >= minExp && exp <= maxExp) {
			++i;
	  } else if (exp < minExp) {
			exp != bias + 1 - len && exp < minUnnormExp && this.warn("encodeFloat::float underflow");
			i = bias + 1 - (exp = minExp - 1);
		}
	
		if (intPart || status !== 0) {
			this.warn(intPart ? "encodeFloat::float overflow" : "encodeFloat::" + status);
			exp = maxExp + 1;
			i = bias + 2;
	
			if (status == -Infinity) {
				signal = 1;
	    } else if (isNaN(status)) {
				bin[i] = 1;
	    }
		}
	
		for (n = Math.abs(exp + bias), j = exponentBits + 1, result = ""; --j; result = (n % 2) + result, n = n >>= 1);
	
		for (n = 0, j = 0, i = (result = (signal ? "1" : "0") + result + bin.slice(i, i + precisionBits).join("")).length, r = []; i; j = (j + 1) % 8) {
			n += (1 << j) * result.charAt(--i);
			if (j == 7) {
				r[r.length] = String.fromCharCode(n);
				n = 0;
			}
		}
	
		r[r.length] = n
	    ? String.fromCharCode(n)
	    : "";
	
		return (this.bigEndian ? r.reverse() : r).join("");
	};
	
	BinaryParser.encodeInt = function encodeInt (data, bits, signed, forceBigEndian) {
		var max = maxBits[bits];
	
	  if (data >= max || data < -(max / 2)) {
	    this.warn("encodeInt::overflow");
	    data = 0;
	  }
	
		if (data < 0) {
	    data += max;
	  }
	
		for (var r = []; data; r[r.length] = String.fromCharCode(data % 256), data = Math.floor(data / 256));
	
		for (bits = -(-bits >> 3) - r.length; bits--; r[r.length] = "\0");
	
	  return ((this.bigEndian || forceBigEndian) ? r.reverse() : r).join("");
	};
	
	BinaryParser.toSmall    = function( data ){ return this.decodeInt( data,  8, true  ); };
	BinaryParser.fromSmall  = function( data ){ return this.encodeInt( data,  8, true  ); };
	BinaryParser.toByte     = function( data ){ return this.decodeInt( data,  8, false ); };
	BinaryParser.fromByte   = function( data ){ return this.encodeInt( data,  8, false ); };
	BinaryParser.toShort    = function( data ){ return this.decodeInt( data, 16, true  ); };
	BinaryParser.fromShort  = function( data ){ return this.encodeInt( data, 16, true  ); };
	BinaryParser.toWord     = function( data ){ return this.decodeInt( data, 16, false ); };
	BinaryParser.fromWord   = function( data ){ return this.encodeInt( data, 16, false ); };
	BinaryParser.toInt      = function( data ){ return this.decodeInt( data, 32, true  ); };
	BinaryParser.fromInt    = function( data ){ return this.encodeInt( data, 32, true  ); };
	BinaryParser.toLong     = function( data ){ return this.decodeInt( data, 64, true  ); };
	BinaryParser.fromLong   = function( data ){ return this.encodeInt( data, 64, true  ); };
	BinaryParser.toDWord    = function( data ){ return this.decodeInt( data, 32, false ); };
	BinaryParser.fromDWord  = function( data ){ return this.encodeInt( data, 32, false ); };
	BinaryParser.toQWord    = function( data ){ return this.decodeInt( data, 64, true ); };
	BinaryParser.fromQWord  = function( data ){ return this.encodeInt( data, 64, true ); };
	BinaryParser.toFloat    = function( data ){ return this.decodeFloat( data, 23, 8   ); };
	BinaryParser.fromFloat  = function( data ){ return this.encodeFloat( data, 23, 8   ); };
	BinaryParser.toDouble   = function( data ){ return this.decodeFloat( data, 52, 11  ); };
	BinaryParser.fromDouble = function( data ){ return this.encodeFloat( data, 52, 11  ); };
	
	// Factor out the encode so it can be shared by add_header and push_int32
	BinaryParser.encode_int32 = function encode_int32 (number, asArray) {
	  var a, b, c, d, unsigned;
	  unsigned = (number < 0) ? (number + 0x100000000) : number;
	  a = Math.floor(unsigned / 0xffffff);
	  unsigned &= 0xffffff;
	  b = Math.floor(unsigned / 0xffff);
	  unsigned &= 0xffff;
	  c = Math.floor(unsigned / 0xff);
	  unsigned &= 0xff;
	  d = Math.floor(unsigned);
	  return asArray ? [chr(a), chr(b), chr(c), chr(d)] : chr(a) + chr(b) + chr(c) + chr(d);
	};
	
	BinaryParser.encode_int64 = function encode_int64 (number) {
	  var a, b, c, d, e, f, g, h, unsigned;
	  unsigned = (number < 0) ? (number + 0x10000000000000000) : number;
	  a = Math.floor(unsigned / 0xffffffffffffff);
	  unsigned &= 0xffffffffffffff;
	  b = Math.floor(unsigned / 0xffffffffffff);
	  unsigned &= 0xffffffffffff;
	  c = Math.floor(unsigned / 0xffffffffff);
	  unsigned &= 0xffffffffff;
	  d = Math.floor(unsigned / 0xffffffff);
	  unsigned &= 0xffffffff;
	  e = Math.floor(unsigned / 0xffffff);
	  unsigned &= 0xffffff;
	  f = Math.floor(unsigned / 0xffff);
	  unsigned &= 0xffff;
	  g = Math.floor(unsigned / 0xff);
	  unsigned &= 0xff;
	  h = Math.floor(unsigned);
	  return chr(a) + chr(b) + chr(c) + chr(d) + chr(e) + chr(f) + chr(g) + chr(h);
	};
	
	/**
	 * UTF8 methods
	 */
	
	// Take a raw binary string and return a utf8 string
	BinaryParser.decode_utf8 = function decode_utf8 (binaryStr) {
	  var len = binaryStr.length
	    , decoded = ''
	    , i = 0
	    , c = 0
	    , c1 = 0
	    , c2 = 0
	    , c3;
	
	  while (i < len) {
	    c = binaryStr.charCodeAt(i);
	    if (c < 128) {
	      decoded += String.fromCharCode(c);
	      i++;
	    } else if ((c > 191) && (c < 224)) {
		    c2 = binaryStr.charCodeAt(i+1);
	      decoded += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
	      i += 2;
	    } else {
		    c2 = binaryStr.charCodeAt(i+1);
		    c3 = binaryStr.charCodeAt(i+2);
	      decoded += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
	      i += 3;
	    }
	  }
	
	  return decoded;
	};
	
	// Encode a cstring
	BinaryParser.encode_cstring = function encode_cstring (s) {
	  return unescape(encodeURIComponent(s)) + BinaryParser.fromByte(0);
	};
	
	// Take a utf8 string and return a binary string
	BinaryParser.encode_utf8 = function encode_utf8 (s) {
	  var a = ""
	    , c;
	
	  for (var n = 0, len = s.length; n < len; n++) {
	    c = s.charCodeAt(n);
	
	    if (c < 128) {
		    a += String.fromCharCode(c);
	    } else if ((c > 127) && (c < 2048)) {
		    a += String.fromCharCode((c>>6) | 192) ;
		    a += String.fromCharCode((c&63) | 128);
	    } else {
	      a += String.fromCharCode((c>>12) | 224);
	      a += String.fromCharCode(((c>>6) & 63) | 128);
	      a += String.fromCharCode((c&63) | 128);
	    }
	  }
	
	  return a;
	};
	
	BinaryParser.hprint = function hprint (s) {
	  var number;
	
	  for (var i = 0, len = s.length; i < len; i++) {
	    if (s.charCodeAt(i) < 32) {
	      number = s.charCodeAt(i) <= 15
	        ? "0" + s.charCodeAt(i).toString(16)
	        : s.charCodeAt(i).toString(16);        
	      process.stdout.write(number + " ")
	    } else {
	      number = s.charCodeAt(i) <= 15
	        ? "0" + s.charCodeAt(i).toString(16)
	        : s.charCodeAt(i).toString(16);
	        process.stdout.write(number + " ")
	    }
	  }
	  
	  process.stdout.write("\n\n");
	};
	
	BinaryParser.ilprint = function hprint (s) {
	  var number;
	
	  for (var i = 0, len = s.length; i < len; i++) {
	    if (s.charCodeAt(i) < 32) {
	      number = s.charCodeAt(i) <= 15
	        ? "0" + s.charCodeAt(i).toString(10)
	        : s.charCodeAt(i).toString(10);
	
	      __webpack_require__(77).debug(number+' : ');
	    } else {
	      number = s.charCodeAt(i) <= 15
	        ? "0" + s.charCodeAt(i).toString(10)
	        : s.charCodeAt(i).toString(10);
	      __webpack_require__(77).debug(number+' : '+ s.charAt(i));
	    }
	  }
	};
	
	BinaryParser.hlprint = function hprint (s) {
	  var number;
	
	  for (var i = 0, len = s.length; i < len; i++) {
	    if (s.charCodeAt(i) < 32) {
	      number = s.charCodeAt(i) <= 15
	        ? "0" + s.charCodeAt(i).toString(16)
	        : s.charCodeAt(i).toString(16);
	      __webpack_require__(77).debug(number+' : ');
	    } else {
	      number = s.charCodeAt(i) <= 15
	        ? "0" + s.charCodeAt(i).toString(16)
	        : s.charCodeAt(i).toString(16);
	      __webpack_require__(77).debug(number+' : '+ s.charAt(i));
	    }
	  }
	};
	
	/**
	 * BinaryParser buffer constructor.
	 */
	function BinaryParserBuffer (bigEndian, buffer) {
	  this.bigEndian = bigEndian || 0;
	  this.buffer = [];
	  this.setBuffer(buffer);
	};
	
	BinaryParserBuffer.prototype.setBuffer = function setBuffer (data) {
	  var l, i, b;
	
		if (data) {
	    i = l = data.length;
	    b = this.buffer = new Array(l);
			for (; i; b[l - i] = data.charCodeAt(--i));
			this.bigEndian && b.reverse();
		}
	};
	
	BinaryParserBuffer.prototype.hasNeededBits = function hasNeededBits (neededBits) {
		return this.buffer.length >= -(-neededBits >> 3);
	};
	
	BinaryParserBuffer.prototype.checkBuffer = function checkBuffer (neededBits) {
		if (!this.hasNeededBits(neededBits)) {
			throw new Error("checkBuffer::missing bytes");
	  }
	};
	
	BinaryParserBuffer.prototype.readBits = function readBits (start, length) {
		//shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)
	
		function shl (a, b) {
			for (; b--; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1);
			return a;
		}
	
		if (start < 0 || length <= 0) {
			return 0;
	  }
	
		this.checkBuffer(start + length);
	
	  var offsetLeft
	    , offsetRight = start % 8
	    , curByte = this.buffer.length - ( start >> 3 ) - 1
	    , lastByte = this.buffer.length + ( -( start + length ) >> 3 )
	    , diff = curByte - lastByte
	    , sum = ((this.buffer[ curByte ] >> offsetRight) & ((1 << (diff ? 8 - offsetRight : length)) - 1)) + (diff && (offsetLeft = (start + length) % 8) ? (this.buffer[lastByte++] & ((1 << offsetLeft) - 1)) << (diff-- << 3) - offsetRight : 0);
	
		for(; diff; sum += shl(this.buffer[lastByte++], (diff-- << 3) - offsetRight));
	
		return sum;
	};
	
	/**
	 * Expose.
	 */
	BinaryParser.Buffer = BinaryParserBuffer;
	
	exports.BinaryParser = BinaryParser;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 142 */
/***/ function(module, exports) {

	/**
	 * A class representation of the BSON RegExp type.
	 *
	 * @class
	 * @return {BSONRegExp} A MinKey instance
	 */
	function BSONRegExp(pattern, options) {
	  if(!(this instanceof BSONRegExp)) return new BSONRegExp();
	  
	  // Execute
	  this._bsontype = 'BSONRegExp';
	  this.pattern = pattern;
	  this.options = options;
	
	  // Validate options
	  for(var i = 0; i < options.length; i++) {
	    if(!(this.options[i] == 'i' 
	      || this.options[i] == 'm'
	      || this.options[i] == 'x'
	      || this.options[i] == 'l'
	      || this.options[i] == 's'
	      || this.options[i] == 'u'
	    )) {
	      throw new Error('the regular expression options [' + this.options[i] + "] is not supported");
	    }
	  }
	}
	
	module.exports = BSONRegExp;
	module.exports.BSONRegExp = BSONRegExp;

/***/ },
/* 143 */
/***/ function(module, exports) {

	/**
	 * A class representation of the BSON Symbol type.
	 *
	 * @class
	 * @deprecated
	 * @param {string} value the string representing the symbol.
	 * @return {Symbol}
	 */
	function Symbol(value) {
	  if(!(this instanceof Symbol)) return new Symbol(value);
	  this._bsontype = 'Symbol';
	  this.value = value;
	}
	
	/**
	 * Access the wrapped string value.
	 *
	 * @method
	 * @return {String} returns the wrapped string.
	 */
	Symbol.prototype.valueOf = function() {
	  return this.value;
	};
	
	/**
	 * @ignore
	 */
	Symbol.prototype.toString = function() {
	  return this.value;
	}
	
	/**
	 * @ignore
	 */
	Symbol.prototype.inspect = function() {
	  return this.value;
	}
	
	/**
	 * @ignore
	 */
	Symbol.prototype.toJSON = function() {
	  return this.value;
	}
	
	module.exports = Symbol;
	module.exports.Symbol = Symbol;

/***/ },
/* 144 */
/***/ function(module, exports) {

	/**
	 * A class representation of the BSON Code type.
	 *
	 * @class
	 * @param {(string|function)} code a string or function.
	 * @param {Object} [scope] an optional scope for the function.
	 * @return {Code}
	 */
	var Code = function Code(code, scope) {
	  if(!(this instanceof Code)) return new Code(code, scope);
	  this._bsontype = 'Code';
	  this.code = code;
	  this.scope = scope == null ? {} : scope;
	};
	
	/**
	 * @ignore
	 */
	Code.prototype.toJSON = function() {
	  return {scope:this.scope, code:this.code};
	}
	
	module.exports = Code;
	module.exports.Code = Code;

/***/ },
/* 145 */
/***/ function(module, exports) {

	/**
	 * A class representation of the BSON MinKey type.
	 *
	 * @class
	 * @return {MinKey} A MinKey instance
	 */
	function MinKey() {
	  if(!(this instanceof MinKey)) return new MinKey();
	  
	  this._bsontype = 'MinKey';
	}
	
	module.exports = MinKey;
	module.exports.MinKey = MinKey;

/***/ },
/* 146 */
/***/ function(module, exports) {

	/**
	 * A class representation of the BSON MaxKey type.
	 *
	 * @class
	 * @return {MaxKey} A MaxKey instance
	 */
	function MaxKey() {
	  if(!(this instanceof MaxKey)) return new MaxKey();
	  
	  this._bsontype = 'MaxKey';  
	}
	
	module.exports = MaxKey;
	module.exports.MaxKey = MaxKey;

/***/ },
/* 147 */
/***/ function(module, exports) {

	/**
	 * A class representation of the BSON DBRef type.
	 *
	 * @class
	 * @param {string} namespace the collection name.
	 * @param {ObjectID} oid the reference ObjectID.
	 * @param {string} [db] optional db name, if omitted the reference is local to the current db.
	 * @return {DBRef}
	 */
	function DBRef(namespace, oid, db) {
	  if(!(this instanceof DBRef)) return new DBRef(namespace, oid, db);
	  
	  this._bsontype = 'DBRef';
	  this.namespace = namespace;
	  this.oid = oid;
	  this.db = db;
	};
	
	/**
	 * @ignore
	 * @api private
	 */
	DBRef.prototype.toJSON = function() {
	  return {
	    '$ref':this.namespace,
	    '$id':this.oid,
	    '$db':this.db == null ? '' : this.db
	  };
	}
	
	module.exports = DBRef;
	module.exports.DBRef = DBRef;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 * @ignore
	 */
	
	// Test if we're in Node via presence of "global" not absence of "window"
	// to support hybrid environments like Electron
	if(typeof global !== 'undefined') {
	  var Buffer = __webpack_require__(9).Buffer; // TODO just use global Buffer
	}
	
	/**
	 * A class representation of the BSON Binary type.
	 *
	 * Sub types
	 *  - **BSON.BSON_BINARY_SUBTYPE_DEFAULT**, default BSON type.
	 *  - **BSON.BSON_BINARY_SUBTYPE_FUNCTION**, BSON function type.
	 *  - **BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY**, BSON byte array type.
	 *  - **BSON.BSON_BINARY_SUBTYPE_UUID**, BSON uuid type.
	 *  - **BSON.BSON_BINARY_SUBTYPE_MD5**, BSON md5 type.
	 *  - **BSON.BSON_BINARY_SUBTYPE_USER_DEFINED**, BSON user defined type.
	 *
	 * @class
	 * @param {Buffer} buffer a buffer object containing the binary data.
	 * @param {Number} [subType] the option binary type.
	 * @return {Binary}
	 */
	function Binary(buffer, subType) {
	  if(!(this instanceof Binary)) return new Binary(buffer, subType);
	
	  this._bsontype = 'Binary';
	
	  if(buffer instanceof Number) {
	    this.sub_type = buffer;
	    this.position = 0;
	  } else {
	    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
	    this.position = 0;
	  }
	
	  if(buffer != null && !(buffer instanceof Number)) {
	    // Only accept Buffer, Uint8Array or Arrays
	    if(typeof buffer == 'string') {
	      // Different ways of writing the length of the string for the different types
	      if(typeof Buffer != 'undefined') {
	        this.buffer = new Buffer(buffer);
	      } else if(typeof Uint8Array != 'undefined' || (Object.prototype.toString.call(buffer) == '[object Array]')) {
	        this.buffer = writeStringToArray(buffer);
	      } else {
	        throw new Error("only String, Buffer, Uint8Array or Array accepted");
	      }
	    } else {
	      this.buffer = buffer;
	    }
	    this.position = buffer.length;
	  } else {
	    if(typeof Buffer != 'undefined') {
	      this.buffer =  new Buffer(Binary.BUFFER_SIZE);
	    } else if(typeof Uint8Array != 'undefined'){
	      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
	    } else {
	      this.buffer = new Array(Binary.BUFFER_SIZE);
	    }
	    // Set position to start of buffer
	    this.position = 0;
	  }
	};
	
	/**
	 * Updates this binary with byte_value.
	 *
	 * @method
	 * @param {string} byte_value a single byte we wish to write.
	 */
	Binary.prototype.put = function put(byte_value) {
	  // If it's a string and a has more than one character throw an error
	  if(byte_value['length'] != null && typeof byte_value != 'number' && byte_value.length != 1) throw new Error("only accepts single character String, Uint8Array or Array");
	  if(typeof byte_value != 'number' && byte_value < 0 || byte_value > 255) throw new Error("only accepts number in a valid unsigned byte range 0-255");
	
	  // Decode the byte value once
	  var decoded_byte = null;
	  if(typeof byte_value == 'string') {
	    decoded_byte = byte_value.charCodeAt(0);
	  } else if(byte_value['length'] != null) {
	    decoded_byte = byte_value[0];
	  } else {
	    decoded_byte = byte_value;
	  }
	
	  if(this.buffer.length > this.position) {
	    this.buffer[this.position++] = decoded_byte;
	  } else {
	    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {
	      // Create additional overflow buffer
	      var buffer = new Buffer(Binary.BUFFER_SIZE + this.buffer.length);
	      // Combine the two buffers together
	      this.buffer.copy(buffer, 0, 0, this.buffer.length);
	      this.buffer = buffer;
	      this.buffer[this.position++] = decoded_byte;
	    } else {
	      var buffer = null;
	      // Create a new buffer (typed or normal array)
	      if(Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {
	        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));
	      } else {
	        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);
	      }
	
	      // We need to copy all the content to the new array
	      for(var i = 0; i < this.buffer.length; i++) {
	        buffer[i] = this.buffer[i];
	      }
	
	      // Reassign the buffer
	      this.buffer = buffer;
	      // Write the byte
	      this.buffer[this.position++] = decoded_byte;
	    }
	  }
	};
	
	/**
	 * Writes a buffer or string to the binary.
	 *
	 * @method
	 * @param {(Buffer|string)} string a string or buffer to be written to the Binary BSON object.
	 * @param {number} offset specify the binary of where to write the content.
	 * @return {null}
	 */
	Binary.prototype.write = function write(string, offset) {
	  offset = typeof offset == 'number' ? offset : this.position;
	
	  // If the buffer is to small let's extend the buffer
	  if(this.buffer.length < offset + string.length) {
	    var buffer = null;
	    // If we are in node.js
	    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {
	      buffer = new Buffer(this.buffer.length + string.length);
	      this.buffer.copy(buffer, 0, 0, this.buffer.length);
	    } else if(Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {
	      // Create a new buffer
	      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length))
	      // Copy the content
	      for(var i = 0; i < this.position; i++) {
	        buffer[i] = this.buffer[i];
	      }
	    }
	
	    // Assign the new buffer
	    this.buffer = buffer;
	  }
	
	  if(typeof Buffer != 'undefined' && Buffer.isBuffer(string) && Buffer.isBuffer(this.buffer)) {
	    string.copy(this.buffer, offset, 0, string.length);
	    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;
	    // offset = string.length
	  } else if(typeof Buffer != 'undefined' && typeof string == 'string' && Buffer.isBuffer(this.buffer)) {
	    this.buffer.write(string, offset, 'binary');
	    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;
	    // offset = string.length;
	  } else if(Object.prototype.toString.call(string) == '[object Uint8Array]'
	    || Object.prototype.toString.call(string) == '[object Array]' && typeof string != 'string') {
	    for(var i = 0; i < string.length; i++) {
	      this.buffer[offset++] = string[i];
	    }
	
	    this.position = offset > this.position ? offset : this.position;
	  } else if(typeof string == 'string') {
	    for(var i = 0; i < string.length; i++) {
	      this.buffer[offset++] = string.charCodeAt(i);
	    }
	
	    this.position = offset > this.position ? offset : this.position;
	  }
	};
	
	/**
	 * Reads **length** bytes starting at **position**.
	 *
	 * @method
	 * @param {number} position read from the given position in the Binary.
	 * @param {number} length the number of bytes to read.
	 * @return {Buffer}
	 */
	Binary.prototype.read = function read(position, length) {
	  length = length && length > 0
	    ? length
	    : this.position;
	
	  // Let's return the data based on the type we have
	  if(this.buffer['slice']) {
	    return this.buffer.slice(position, position + length);
	  } else {
	    // Create a buffer to keep the result
	    var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
	    for(var i = 0; i < length; i++) {
	      buffer[i] = this.buffer[position++];
	    }
	  }
	  // Return the buffer
	  return buffer;
	};
	
	/**
	 * Returns the value of this binary as a string.
	 *
	 * @method
	 * @return {string}
	 */
	Binary.prototype.value = function value(asRaw) {
	  asRaw = asRaw == null ? false : asRaw;
	
	  // Optimize to serialize for the situation where the data == size of buffer
	  if(asRaw && typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer) && this.buffer.length == this.position)
	    return this.buffer;
	
	  // If it's a node.js buffer object
	  if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {
	    return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString('binary', 0, this.position);
	  } else {
	    if(asRaw) {
	      // we support the slice command use it
	      if(this.buffer['slice'] != null) {
	        return this.buffer.slice(0, this.position);
	      } else {
	        // Create a new buffer to copy content to
	        var newBuffer = Object.prototype.toString.call(this.buffer) == '[object Uint8Array]' ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);
	        // Copy content
	        for(var i = 0; i < this.position; i++) {
	          newBuffer[i] = this.buffer[i];
	        }
	        // Return the buffer
	        return newBuffer;
	      }
	    } else {
	      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
	    }
	  }
	};
	
	/**
	 * Length.
	 *
	 * @method
	 * @return {number} the length of the binary.
	 */
	Binary.prototype.length = function length() {
	  return this.position;
	};
	
	/**
	 * @ignore
	 */
	Binary.prototype.toJSON = function() {
	  return this.buffer != null ? this.buffer.toString('base64') : '';
	}
	
	/**
	 * @ignore
	 */
	Binary.prototype.toString = function(format) {
	  return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';
	}
	
	/**
	 * Binary default subtype
	 * @ignore
	 */
	var BSON_BINARY_SUBTYPE_DEFAULT = 0;
	
	/**
	 * @ignore
	 */
	var writeStringToArray = function(data) {
	  // Create a buffer
	  var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);
	  // Write the content to the buffer
	  for(var i = 0; i < data.length; i++) {
	    buffer[i] = data.charCodeAt(i);
	  }
	  // Write the string to the buffer
	  return buffer;
	}
	
	/**
	 * Convert Array ot Uint8Array to Binary String
	 *
	 * @ignore
	 */
	var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
	  var result = "";
	  for(var i = startIndex; i < endIndex; i++) {
	   result = result + String.fromCharCode(byteArray[i]);
	  }
	  return result;
	};
	
	Binary.BUFFER_SIZE = 256;
	
	/**
	 * Default BSON type
	 *
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_DEFAULT = 0;
	/**
	 * Function BSON type
	 *
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_FUNCTION = 1;
	/**
	 * Byte Array BSON type
	 *
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_BYTE_ARRAY = 2;
	/**
	 * OLD UUID BSON type
	 *
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_UUID_OLD = 3;
	/**
	 * UUID BSON type
	 *
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_UUID = 4;
	/**
	 * MD5 BSON type
	 *
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_MD5 = 5;
	/**
	 * User BSON type
	 *
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_USER_DEFINED = 128;
	
	/**
	 * Expose.
	 */
	module.exports = Binary;
	module.exports.Binary = Binary;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	"use strict"
	
	var readIEEE754 = __webpack_require__(135).readIEEE754,
		f = __webpack_require__(77).format,
		Long = __webpack_require__(137).Long,
	  Double = __webpack_require__(138).Double,
	  Timestamp = __webpack_require__(139).Timestamp,
	  ObjectID = __webpack_require__(140).ObjectID,
	  Symbol = __webpack_require__(143).Symbol,
	  Code = __webpack_require__(144).Code,
	  MinKey = __webpack_require__(145).MinKey,
	  MaxKey = __webpack_require__(146).MaxKey,
	  DBRef = __webpack_require__(147).DBRef,
	  BSONRegExp = __webpack_require__(142).BSONRegExp,
	  Binary = __webpack_require__(148).Binary;
	
	var deserialize = function(buffer, options, isArray) {
		options = options == null ? {} : options;
		var index = options && options.index ? options.index : 0;
		// Read the document size
	  var size = buffer[index] | buffer[index+1] << 8 | buffer[index+2] << 16 | buffer[index+3] << 24;
	
		// Ensure buffer is valid size
	  if(size < 5 || buffer.length < size) {
			throw new Error("corrupt bson message");
		}
	
		// Illegal end value
		if(buffer[index + size - 1] != 0) {
			throw new Error("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
		}
	
		// Start deserializtion
		return deserializeObject(buffer, index, options, isArray);
	}
	
	var deserializeObject = function(buffer, index, options, isArray) {
		var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];
	  var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];
	  var cacheFunctionsCrc32 = options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];
	  var promoteLongs = options['promoteLongs'] == null ? true : options['promoteLongs'];
		var fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];
		var raw = options['raw'] == null ? false : options['raw'];
	  // Return BSONRegExp objects instead of native regular expressions
	  var bsonRegExp = typeof options['bsonRegExp'] == 'boolean' ? options['bsonRegExp'] : false;
	  var promoteBuffers = options['promoteBuffers'] == null ? false : options['promoteBuffers'];
	
	  // Validate that we have at least 4 bytes of buffer
	  if(buffer.length < 5) throw new Error("corrupt bson message < 5 bytes long");
	
		// Read the document size
	  var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	
		// Ensure buffer is valid size
	  if(size < 5 || size > buffer.length) throw new Error("corrupt bson message");
	
	  // Create holding object
	  var object = isArray ? [] : {};
	
	  // While we have more left data left keep parsing
	  while(true) {
	    // Read the type
	    var elementType = buffer[index++];
	    // If we get a zero it's the last byte, exit
	    if(elementType == 0) break;
	
			// Get the start search index
			var i = index;
			// Locate the end of the c string
			while(buffer[i] !== 0x00 && i < buffer.length) {
				i++
			}
	
			// If are at the end of the buffer there is a problem with the document
			if(i >= buffer.length) throw new Error("Bad BSON Document: illegal CString")
			var name = buffer.toString('utf8', index, i);
	
			index = i + 1;
	
			if(elementType == BSON.BSON_DATA_STRING) {
	      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
				if(stringSize <= 0 || stringSize > (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error("bad string length in bson");
	      object[name] = buffer.toString('utf8', index, index + stringSize - 1);
	      index = index + stringSize;
			} else if(elementType == BSON.BSON_DATA_OID) {
	      var string = buffer.toString('binary', index, index + 12);
	      object[name] = new ObjectID(string);
	      index = index + 12;
			} else if(elementType == BSON.BSON_DATA_INT) {
	      object[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
			} else if(elementType == BSON.BSON_DATA_NUMBER) {
				object[name] = buffer.readDoubleLE(index);
	      index = index + 8;
			} else if(elementType == BSON.BSON_DATA_DATE) {
	      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	      object[name] = new Date(new Long(lowBits, highBits).toNumber());
			} else if(elementType == BSON.BSON_DATA_BOOLEAN) {
	      object[name] = buffer[index++] == 1;
			} else if(elementType == BSON.BSON_DATA_OBJECT) {
				var _index = index;
	      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
				if(objectSize <= 0 || objectSize > (buffer.length - index)) throw new Error("bad embedded document length in bson");
	
				// We have a raw value
				if(raw) {
		      object[name] = buffer.slice(index, index + objectSize);
				} else {
		      object[name] = deserializeObject(buffer, _index, options, false);
				}
	
	      index = index + objectSize;
			} else if(elementType == BSON.BSON_DATA_ARRAY) {
				var _index = index;
	      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
				var arrayOptions = options;
	
				// All elements of array to be returned as raw bson
				if(fieldsAsRaw && fieldsAsRaw[name]) {
					arrayOptions = {};
					for(var n in options) arrayOptions[n] = options[n];
					arrayOptions['raw'] = true;
				}
	
	      object[name] = deserializeObject(buffer, _index, arrayOptions, true);
	      index = index + objectSize;
			} else if(elementType == BSON.BSON_DATA_UNDEFINED || elementType == BSON.BSON_DATA_NULL) {
	      object[name] = null;
			} else if(elementType == BSON.BSON_DATA_LONG) {
	      // Unpack the low and high bits
	      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	      var long = new Long(lowBits, highBits);
	      // Promote the long if possible
	      if(promoteLongs) {
	        object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
	      } else {
	        object[name] = long;
	      }
			} else if(elementType == BSON.BSON_DATA_BINARY) {
	      var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	      var subType = buffer[index++];
	      // Decode as raw Buffer object if options specifies it
	      if(buffer['slice'] != null) {
	        // If we have subtype 2 skip the 4 bytes for the size
	        if(subType == Binary.SUBTYPE_BYTE_ARRAY) {
	          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	        }
	        if(promoteBuffers) {
	          object[name] = buffer.slice(index, index + binarySize);
	        } else {
	          object[name] = new Binary(buffer.slice(index, index + binarySize), subType);
	        }
	      } else {
	        var _buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);
	        // If we have subtype 2 skip the 4 bytes for the size
	        if(subType == Binary.SUBTYPE_BYTE_ARRAY) {
	          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	        }
	        // Copy the data
	        for(var i = 0; i < binarySize; i++) {
	          _buffer[i] = buffer[index + i];
	        }
	        if(promoteBuffers) {
	          object[name] = _buffer;
	        } else {
	          object[name] = new Binary(_buffer, subType);
	        }
	      }
	      // Update the index
	      index = index + binarySize;
			} else if(elementType == BSON.BSON_DATA_REGEXP && bsonRegExp == false) {
				// Get the start search index
				var i = index;
				// Locate the end of the c string
				while(buffer[i] !== 0x00 && i < buffer.length) {
					i++
				}
				// If are at the end of the buffer there is a problem with the document
				if(i >= buffer.length) throw new Error("Bad BSON Document: illegal CString")
				// Return the C string
				var source = buffer.toString('utf8', index, i);
	      // Create the regexp
				index = i + 1;
	
				// Get the start search index
				var i = index;
				// Locate the end of the c string
				while(buffer[i] !== 0x00 && i < buffer.length) {
					i++
				}
				// If are at the end of the buffer there is a problem with the document
				if(i >= buffer.length) throw new Error("Bad BSON Document: illegal CString")
				// Return the C string
				var regExpOptions = buffer.toString('utf8', index, i);
				index = i + 1;
	
	      // For each option add the corresponding one for javascript
	      var optionsArray = new Array(regExpOptions.length);
	
	      // Parse options
	      for(var i = 0; i < regExpOptions.length; i++) {
	        switch(regExpOptions[i]) {
	          case 'm':
	            optionsArray[i] = 'm';
	            break;
	          case 's':
	            optionsArray[i] = 'g';
	            break;
	          case 'i':
	            optionsArray[i] = 'i';
	            break;
	        }
	      }
	
	      object[name] = new RegExp(source, optionsArray.join(''));
	    } else if(elementType == BSON.BSON_DATA_REGEXP && bsonRegExp == true) {
				// Get the start search index
				var i = index;
				// Locate the end of the c string
				while(buffer[i] !== 0x00 && i < buffer.length) {
					i++
				}
				// If are at the end of the buffer there is a problem with the document
				if(i >= buffer.length) throw new Error("Bad BSON Document: illegal CString")
				// Return the C string
				var source = buffer.toString('utf8', index, i);
	      index = i + 1;
	
				// Get the start search index
				var i = index;
				// Locate the end of the c string
				while(buffer[i] !== 0x00 && i < buffer.length) {
					i++
				}
				// If are at the end of the buffer there is a problem with the document
				if(i >= buffer.length) throw new Error("Bad BSON Document: illegal CString")
				// Return the C string
				var regExpOptions = buffer.toString('utf8', index, i);
	      index = i + 1;
	
	      // Set the object
	      object[name] = new BSONRegExp(source, regExpOptions);
			} else if(elementType == BSON.BSON_DATA_SYMBOL) {
	      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
				if(stringSize <= 0 || stringSize > (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error("bad string length in bson");
	      object[name] = new Symbol(buffer.toString('utf8', index, index + stringSize - 1));
	      index = index + stringSize;
			} else if(elementType == BSON.BSON_DATA_TIMESTAMP) {
	      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	      object[name] = new Timestamp(lowBits, highBits);
			} else if(elementType == BSON.BSON_DATA_MIN_KEY) {
	      object[name] = new MinKey();
			} else if(elementType == BSON.BSON_DATA_MAX_KEY) {
	      object[name] = new MaxKey();
			} else if(elementType == BSON.BSON_DATA_CODE) {
	      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
				if(stringSize <= 0 || stringSize > (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error("bad string length in bson");
	      var functionString = buffer.toString('utf8', index, index + stringSize - 1);
	
	      // If we are evaluating the functions
	      if(evalFunctions) {
	        var value = null;
	        // If we have cache enabled let's look for the md5 of the function in the cache
	        if(cacheFunctions) {
	          var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
	          // Got to do this to avoid V8 deoptimizing the call due to finding eval
	          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
	        } else {
	          object[name] = isolateEval(functionString);
	        }
	      } else {
	        object[name]  = new Code(functionString, {});
	      }
	
	      // Update parse index position
	      index = index + stringSize;
			} else if(elementType == BSON.BSON_DATA_CODE_W_SCOPE) {
	      var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
				if(stringSize <= 0 || stringSize > (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error("bad string length in bson");
	      // Javascript function
	      var functionString = buffer.toString('utf8', index, index + stringSize - 1);
	      // Update parse index position
	      index = index + stringSize;
	      // Parse the element
				var _index = index;
	      // Decode the size of the object document
	      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
	      // Decode the scope object
	      var scopeObject = deserializeObject(buffer, _index, options, false);
	      // Adjust the index
	      index = index + objectSize;
	
	      // If we are evaluating the functions
	      if(evalFunctions) {
	        // Contains the value we are going to set
	        var value = null;
	        // If we have cache enabled let's look for the md5 of the function in the cache
	        if(cacheFunctions) {
	          var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
	          // Got to do this to avoid V8 deoptimizing the call due to finding eval
	          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
	        } else {
	          object[name] = isolateEval(functionString);
	        }
	
	        object[name].scope = scopeObject;
	      } else {
	        object[name]  = new Code(functionString, scopeObject);
	      }
	    }
	  }
	
	  // Check if we have a db ref object
	  if(object['$id'] != null) object = new DBRef(object['$ref'], object['$id'], object['$db']);
	  return object;
	}
	
	/**
	 * Ensure eval is isolated.
	 *
	 * @ignore
	 * @api private
	 */
	var isolateEvalWithHash = function(functionCache, hash, functionString, object) {
	  // Contains the value we are going to set
	  var value = null;
	
	  // Check for cache hit, eval if missing and return cached function
	  if(functionCache[hash] == null) {
	    eval("value = " + functionString);
	    functionCache[hash] = value;
	  }
	  // Set the object
	  return functionCache[hash].bind(object);
	}
	
	/**
	 * Ensure eval is isolated.
	 *
	 * @ignore
	 * @api private
	 */
	var isolateEval = function(functionString) {
	  // Contains the value we are going to set
	  var value = null;
	  // Eval the function
	  eval("value = " + functionString);
	  return value;
	}
	
	var BSON = {};
	
	/**
	 * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5
	 *
	 * @ignore
	 * @api private
	 */
	var functionCache = BSON.functionCache = {};
	
	/**
	 * Number BSON Type
	 *
	 * @classconstant BSON_DATA_NUMBER
	 **/
	BSON.BSON_DATA_NUMBER = 1;
	/**
	 * String BSON Type
	 *
	 * @classconstant BSON_DATA_STRING
	 **/
	BSON.BSON_DATA_STRING = 2;
	/**
	 * Object BSON Type
	 *
	 * @classconstant BSON_DATA_OBJECT
	 **/
	BSON.BSON_DATA_OBJECT = 3;
	/**
	 * Array BSON Type
	 *
	 * @classconstant BSON_DATA_ARRAY
	 **/
	BSON.BSON_DATA_ARRAY = 4;
	/**
	 * Binary BSON Type
	 *
	 * @classconstant BSON_DATA_BINARY
	 **/
	BSON.BSON_DATA_BINARY = 5;
	/**
	 * Binary BSON Type
	 *
	 * @classconstant BSON_DATA_UNDEFINED
	 **/
	BSON.BSON_DATA_UNDEFINED = 7;
	/**
	 * ObjectID BSON Type
	 *
	 * @classconstant BSON_DATA_OID
	 **/
	BSON.BSON_DATA_OID = 7;
	/**
	 * Boolean BSON Type
	 *
	 * @classconstant BSON_DATA_BOOLEAN
	 **/
	BSON.BSON_DATA_BOOLEAN = 8;
	/**
	 * Date BSON Type
	 *
	 * @classconstant BSON_DATA_DATE
	 **/
	BSON.BSON_DATA_DATE = 9;
	/**
	 * null BSON Type
	 *
	 * @classconstant BSON_DATA_NULL
	 **/
	BSON.BSON_DATA_NULL = 10;
	/**
	 * RegExp BSON Type
	 *
	 * @classconstant BSON_DATA_REGEXP
	 **/
	BSON.BSON_DATA_REGEXP = 11;
	/**
	 * Code BSON Type
	 *
	 * @classconstant BSON_DATA_CODE
	 **/
	BSON.BSON_DATA_CODE = 13;
	/**
	 * Symbol BSON Type
	 *
	 * @classconstant BSON_DATA_SYMBOL
	 **/
	BSON.BSON_DATA_SYMBOL = 14;
	/**
	 * Code with Scope BSON Type
	 *
	 * @classconstant BSON_DATA_CODE_W_SCOPE
	 **/
	BSON.BSON_DATA_CODE_W_SCOPE = 15;
	/**
	 * 32 bit Integer BSON Type
	 *
	 * @classconstant BSON_DATA_INT
	 **/
	BSON.BSON_DATA_INT = 16;
	/**
	 * Timestamp BSON Type
	 *
	 * @classconstant BSON_DATA_TIMESTAMP
	 **/
	BSON.BSON_DATA_TIMESTAMP = 17;
	/**
	 * Long BSON Type
	 *
	 * @classconstant BSON_DATA_LONG
	 **/
	BSON.BSON_DATA_LONG = 18;
	/**
	 * MinKey BSON Type
	 *
	 * @classconstant BSON_DATA_MIN_KEY
	 **/
	BSON.BSON_DATA_MIN_KEY = 0xff;
	/**
	 * MaxKey BSON Type
	 *
	 * @classconstant BSON_DATA_MAX_KEY
	 **/
	BSON.BSON_DATA_MAX_KEY = 0x7f;
	
	/**
	 * Binary Default Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_DEFAULT
	 **/
	BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
	/**
	 * Binary Function Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_FUNCTION
	 **/
	BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
	/**
	 * Binary Byte Array Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY
	 **/
	BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
	/**
	 * Binary UUID Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_UUID
	 **/
	BSON.BSON_BINARY_SUBTYPE_UUID = 3;
	/**
	 * Binary MD5 Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_MD5
	 **/
	BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
	/**
	 * Binary User Defined Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED
	 **/
	BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
	
	// BSON MAX VALUES
	BSON.BSON_INT32_MAX = 0x7FFFFFFF;
	BSON.BSON_INT32_MIN = -0x80000000;
	
	BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
	BSON.BSON_INT64_MIN = -Math.pow(2, 63);
	
	// JS MAX PRECISE VALUES
	BSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.
	BSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.
	
	// Internal long versions
	var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000);  // Any integer up to 2^53 can be precisely represented by a double.
	var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000);  // Any integer down to -2^53 can be precisely represented by a double.
	
	module.exports = deserialize


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict"
	
	var writeIEEE754 = __webpack_require__(135).writeIEEE754,
	  readIEEE754 = __webpack_require__(135).readIEEE754,
	  Long = __webpack_require__(137).Long,
	  Map = __webpack_require__(136),
	  Double = __webpack_require__(138).Double,
	  Timestamp = __webpack_require__(139).Timestamp,
	  ObjectID = __webpack_require__(140).ObjectID,
	  Symbol = __webpack_require__(143).Symbol,
	  Code = __webpack_require__(144).Code,
	  BSONRegExp = __webpack_require__(142).BSONRegExp,
	  MinKey = __webpack_require__(145).MinKey,
	  MaxKey = __webpack_require__(146).MaxKey,
	  DBRef = __webpack_require__(147).DBRef,
	  Binary = __webpack_require__(148).Binary;
	
	var regexp = /\x00/
	
	// To ensure that 0.4 of node works correctly
	var isDate = function isDate(d) {
	  return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';
	}
	
	var isRegExp = function isRegExp(d) {
	  return Object.prototype.toString.call(d) === '[object RegExp]';
	}
	
	var serializeString = function(buffer, key, value, index) {
	  // Encode String type
	  buffer[index++] = BSON.BSON_DATA_STRING;
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	  // Encode the name
	  index = index + numberOfWrittenBytes + 1;
	  buffer[index - 1] = 0;
	  // Write the string
	  var size = buffer.write(value, index + 4, 'utf8');
	  // Write the size of the string to buffer
	  buffer[index + 3] = (size + 1 >> 24) & 0xff;
	  buffer[index + 2] = (size + 1 >> 16) & 0xff;
	  buffer[index + 1] = (size + 1 >> 8) & 0xff;
	  buffer[index] = size + 1 & 0xff;
	  // Update index
	  index = index + 4 + size;
	  // Write zero
	  buffer[index++] = 0;
	  return index;
	}
	
	var serializeNumber = function(buffer, key, value, index) {
	  // We have an integer value
	  if(Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
	    // If the value fits in 32 bits encode as int, if it fits in a double
	    // encode it as a double, otherwise long
	    if(value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) {
	      // Set int type 32 bits or less
	      buffer[index++] = BSON.BSON_DATA_INT;
	      // Number of written bytes
	      var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	      // Encode the name
	      index = index + numberOfWrittenBytes;
	      buffer[index++] = 0;
	      // Write the int value
	      buffer[index++] = value & 0xff;
	      buffer[index++] = (value >> 8) & 0xff;
	      buffer[index++] = (value >> 16) & 0xff;
	      buffer[index++] = (value >> 24) & 0xff;
	    } else if(value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
	      // Encode as double
	      buffer[index++] = BSON.BSON_DATA_NUMBER;
	      // Number of written bytes
	      var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	      // Encode the name
	      index = index + numberOfWrittenBytes;
	      buffer[index++] = 0;
	      // Write float
	      writeIEEE754(buffer, value, index, 'little', 52, 8);
	      // Ajust index
	      index = index + 8;
	    } else {
	      // Set long type
	      buffer[index++] = BSON.BSON_DATA_LONG;
	      // Number of written bytes
	      var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	      // Encode the name
	      index = index + numberOfWrittenBytes;
	      buffer[index++] = 0;
	      var longVal = Long.fromNumber(value);
	      var lowBits = longVal.getLowBits();
	      var highBits = longVal.getHighBits();
	      // Encode low bits
	      buffer[index++] = lowBits & 0xff;
	      buffer[index++] = (lowBits >> 8) & 0xff;
	      buffer[index++] = (lowBits >> 16) & 0xff;
	      buffer[index++] = (lowBits >> 24) & 0xff;
	      // Encode high bits
	      buffer[index++] = highBits & 0xff;
	      buffer[index++] = (highBits >> 8) & 0xff;
	      buffer[index++] = (highBits >> 16) & 0xff;
	      buffer[index++] = (highBits >> 24) & 0xff;
	    }
	  } else {
	    // Encode as double
	    buffer[index++] = BSON.BSON_DATA_NUMBER;
	    // Number of written bytes
	    var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	    // Encode the name
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    // Write float
	    writeIEEE754(buffer, value, index, 'little', 52, 8);
	    // Ajust index
	    index = index + 8;
	  }
	
	  return index;
	}
	
	var serializeUndefined = function(buffer, key, value, index) {
	  // Set long type
	  buffer[index++] = BSON.BSON_DATA_NULL;
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  return index;
	}
	
	var serializeBoolean = function(buffer, key, value, index) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_BOOLEAN;
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Encode the boolean value
	  buffer[index++] = value ? 1 : 0;
	  return index;
	}
	
	var serializeDate = function(buffer, key, value, index) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_DATE;
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	
	  // Write the date
	  var dateInMilis = Long.fromNumber(value.getTime());
	  var lowBits = dateInMilis.getLowBits();
	  var highBits = dateInMilis.getHighBits();
	  // Encode low bits
	  buffer[index++] = lowBits & 0xff;
	  buffer[index++] = (lowBits >> 8) & 0xff;
	  buffer[index++] = (lowBits >> 16) & 0xff;
	  buffer[index++] = (lowBits >> 24) & 0xff;
	  // Encode high bits
	  buffer[index++] = highBits & 0xff;
	  buffer[index++] = (highBits >> 8) & 0xff;
	  buffer[index++] = (highBits >> 16) & 0xff;
	  buffer[index++] = (highBits >> 24) & 0xff;
	  return index;
	}
	
	var serializeRegExp = function(buffer, key, value, index) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_REGEXP;
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  if (value.source && value.source.match(regexp) != null) {
	    throw Error("value " + value.source + " must not contain null bytes");
	  }
	  // Adjust the index
	  index = index + buffer.write(value.source, index, 'utf8');
	  // Write zero
	  buffer[index++] = 0x00;
	  // Write the parameters
	  if(value.global) buffer[index++] = 0x73; // s
	  if(value.ignoreCase) buffer[index++] = 0x69; // i
	  if(value.multiline) buffer[index++] = 0x6d; // m
	  // Add ending zero
	  buffer[index++] = 0x00;
	  return index;
	}
	
	var serializeBSONRegExp = function(buffer, key, value, index) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_REGEXP;
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Adjust the index
	  index = index + buffer.write(value.pattern, index, 'utf8');
	  // Write zero
	  buffer[index++] = 0x00;
	  // Write the options
	  index = index + buffer.write(value.options, index, 'utf8');
	  // Add ending zero
	  buffer[index++] = 0x00;
	  return index;
	}
	
	var serializeMinMax = function(buffer, key, value, index) {
	  // Write the type of either min or max key
	  if(value === null) {
	    buffer[index++] = BSON.BSON_DATA_NULL;
	  } else if(value instanceof MinKey) {
	    buffer[index++] = BSON.BSON_DATA_MIN_KEY;
	  } else {
	    buffer[index++] = BSON.BSON_DATA_MAX_KEY;
	  }
	
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  return index;
	}
	
	var serializeObjectId = function(buffer, key, value, index) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_OID;
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	
	  // Write the objectId into the shared buffer
	  buffer.write(value.id, index, 'binary')
	
	  // Ajust index
	  return index + 12;
	}
	
	var serializeBuffer = function(buffer, key, value, index) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_BINARY;
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Get size of the buffer (current write point)
	  var size = value.length;
	  // Write the size of the string to buffer
	  buffer[index++] = size & 0xff;
	  buffer[index++] = (size >> 8) & 0xff;
	  buffer[index++] = (size >> 16) & 0xff;
	  buffer[index++] = (size >> 24) & 0xff;
	  // Write the default subtype
	  buffer[index++] = BSON.BSON_BINARY_SUBTYPE_DEFAULT;
	  // Copy the content form the binary field to the buffer
	  value.copy(buffer, index, 0, size);
	  // Adjust the index
	  index = index + size;
	  return index;
	}
	
	var serializeObject = function(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined) {
	  // Write the type
	  buffer[index++] = Array.isArray(value) ? BSON.BSON_DATA_ARRAY : BSON.BSON_DATA_OBJECT;
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  var endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined);
	  // Write size
	  var size = endIndex - index;
	  return endIndex;
	}
	
	var serializeLong = function(buffer, key, value, index) {
	  // Write the type
	  buffer[index++] = value._bsontype == 'Long' ? BSON.BSON_DATA_LONG : BSON.BSON_DATA_TIMESTAMP;
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Write the date
	  var lowBits = value.getLowBits();
	  var highBits = value.getHighBits();
	  // Encode low bits
	  buffer[index++] = lowBits & 0xff;
	  buffer[index++] = (lowBits >> 8) & 0xff;
	  buffer[index++] = (lowBits >> 16) & 0xff;
	  buffer[index++] = (lowBits >> 24) & 0xff;
	  // Encode high bits
	  buffer[index++] = highBits & 0xff;
	  buffer[index++] = (highBits >> 8) & 0xff;
	  buffer[index++] = (highBits >> 16) & 0xff;
	  buffer[index++] = (highBits >> 24) & 0xff;
	  return index;
	}
	
	var serializeDouble = function(buffer, key, value, index) {
	  // Encode as double
	  buffer[index++] = BSON.BSON_DATA_NUMBER;
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Write float
	  writeIEEE754(buffer, value, index, 'little', 52, 8);
	  // Ajust index
	  index = index + 8;
	  return index;
	}
	
	var serializeFunction = function(buffer, key, value, index, checkKeys, depth) {
	  buffer[index++] = BSON.BSON_DATA_CODE;
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Function string
	  var functionString = value.toString();
	  // Write the string
	  var size = buffer.write(functionString, index + 4, 'utf8') + 1;
	  // Write the size of the string to buffer
	  buffer[index] = size & 0xff;
	  buffer[index + 1] = (size >> 8) & 0xff;
	  buffer[index + 2] = (size >> 16) & 0xff;
	  buffer[index + 3] = (size >> 24) & 0xff;
	  // Update index
	  index = index + 4 + size - 1;
	  // Write zero
	  buffer[index++] = 0;
	  return index;
	}
	
	var serializeCode = function(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined) {
	  if(value.scope != null && Object.keys(value.scope).length > 0) {
	    // Write the type
	    buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;
	    // Number of written bytes
	    var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	    // Encode the name
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	
	    // Starting index
	    var startIndex = index;
	
	    // Serialize the function
	    // Get the function string
	    var functionString = typeof value.code == 'string' ? value.code : value.code.toString();
	    // Index adjustment
	    index = index + 4;
	    // Write string into buffer
	    var codeSize = buffer.write(functionString, index + 4, 'utf8') + 1;
	    // Write the size of the string to buffer
	    buffer[index] = codeSize & 0xff;
	    buffer[index + 1] = (codeSize >> 8) & 0xff;
	    buffer[index + 2] = (codeSize >> 16) & 0xff;
	    buffer[index + 3] = (codeSize >> 24) & 0xff;
	    // Write end 0
	    buffer[index + 4 + codeSize - 1] = 0;
	    // Write the
	    index = index + codeSize + 4;
	
	    //
	    // Serialize the scope value
	    var endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined)
	    index = endIndex - 1;
	
	    // Writ the total
	    var totalSize = endIndex - startIndex;
	
	    // Write the total size of the object
	    buffer[startIndex++] = totalSize & 0xff;
	    buffer[startIndex++] = (totalSize >> 8) & 0xff;
	    buffer[startIndex++] = (totalSize >> 16) & 0xff;
	    buffer[startIndex++] = (totalSize >> 24) & 0xff;
	    // Write trailing zero
	    buffer[index++] = 0;
	  } else {
	    buffer[index++] = BSON.BSON_DATA_CODE;
	    // Number of written bytes
	    var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	    // Encode the name
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    // Function string
	    var functionString = value.code.toString();
	    // Write the string
	    var size = buffer.write(functionString, index + 4, 'utf8') + 1;
	    // Write the size of the string to buffer
	    buffer[index] = size & 0xff;
	    buffer[index + 1] = (size >> 8) & 0xff;
	    buffer[index + 2] = (size >> 16) & 0xff;
	    buffer[index + 3] = (size >> 24) & 0xff;
	    // Update index
	    index = index + 4 + size - 1;
	    // Write zero
	    buffer[index++] = 0;
	  }
	
	  return index;
	}
	
	var serializeBinary = function(buffer, key, value, index) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_BINARY;
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Extract the buffer
	  var data = value.value(true);
	  // Calculate size
	  var size = value.position;
	  // Write the size of the string to buffer
	  buffer[index++] = size & 0xff;
	  buffer[index++] = (size >> 8) & 0xff;
	  buffer[index++] = (size >> 16) & 0xff;
	  buffer[index++] = (size >> 24) & 0xff;
	  // Write the subtype to the buffer
	  buffer[index++] = value.sub_type;
	
	  // If we have binary type 2 the 4 first bytes are the size
	  if(value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) {
	    buffer[index++] = size & 0xff;
	    buffer[index++] = (size >> 8) & 0xff;
	    buffer[index++] = (size >> 16) & 0xff;
	    buffer[index++] = (size >> 24) & 0xff;
	  }
	
	  // Write the data to the object
	  data.copy(buffer, index, 0, value.position);
	  // Adjust the index
	  index = index + value.position;
	  return index;
	}
	
	var serializeSymbol = function(buffer, key, value, index) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_SYMBOL;
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Write the string
	  var size = buffer.write(value.value, index + 4, 'utf8') + 1;
	  // Write the size of the string to buffer
	  buffer[index] = size & 0xff;
	  buffer[index + 1] = (size >> 8) & 0xff;
	  buffer[index + 2] = (size >> 16) & 0xff;
	  buffer[index + 3] = (size >> 24) & 0xff;
	  // Update index
	  index = index + 4 + size - 1;
	  // Write zero
	  buffer[index++] = 0x00;
	  return index;
	}
	
	var serializeDBRef = function(buffer, key, value, index, depth, serializeFunctions) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_OBJECT;
	  // Number of written bytes
	  var numberOfWrittenBytes = buffer.write(key, index, 'utf8');
	
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	
	  var startIndex = index;
	  var endIndex;
	
	  // Serialize object
	  if(null != value.db) {
	    endIndex = serializeInto(buffer, {
	        '$ref': value.namespace
	      , '$id' : value.oid
	      , '$db' : value.db
	    }, false, index, depth + 1, serializeFunctions);
	  } else {
	    endIndex = serializeInto(buffer, {
	        '$ref': value.namespace
	      , '$id' : value.oid
	    }, false, index, depth + 1, serializeFunctions);
	  }
	
	  // Calculate object size
	  var size = endIndex - startIndex;
	  // Write the size
	  buffer[startIndex++] = size & 0xff;
	  buffer[startIndex++] = (size >> 8) & 0xff;
	  buffer[startIndex++] = (size >> 16) & 0xff;
	  buffer[startIndex++] = (size >> 24) & 0xff;
	  // Set index
	  return endIndex;
	}
	
	var serializeInto = function serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined) {
	  startingIndex = startingIndex || 0;
	
	  // Start place to serialize into
	  var index = startingIndex + 4;
	  var self = this;
	
	  // Special case isArray
	  if(Array.isArray(object)) {
	    // Get object keys
	    for(var i = 0; i < object.length; i++) {
	      var key = "" + i;
	      var value = object[i];
	
	      // Is there an override value
	      if(value && value.toBSON) {
	        if(typeof value.toBSON != 'function') throw new Error("toBSON is not a function");
	        value = value.toBSON();
	      }
	
	      var type = typeof value;
	      if(type == 'string') {
	        index = serializeString(buffer, key, value, index);
	      } else if(type == 'number') {
	        index = serializeNumber(buffer, key, value, index);
	      } else if(type == 'boolean') {
	        index = serializeBoolean(buffer, key, value, index);
	      } else if(value instanceof Date || isDate(value)) {
	        index = serializeDate(buffer, key, value, index);
	      } else if(type == 'undefined' || value == null) {
	        index = serializeUndefined(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'ObjectID') {
	        index = serializeObjectId(buffer, key, value, index);
	      } else if(Buffer.isBuffer(value)) {
	        index = serializeBuffer(buffer, key, value, index);
	      } else if(value instanceof RegExp || isRegExp(value)) {
	        index = serializeRegExp(buffer, key, value, index);
	      } else if(type == 'object' && value['_bsontype'] == null) {
	        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
	      } else if(value['_bsontype'] == 'Long' || value['_bsontype'] == 'Timestamp') {
	        index = serializeLong(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Double') {
	        index = serializeDouble(buffer, key, value, index);
	      } else if(typeof value == 'function' && serializeFunctions) {
	        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
	      } else if(value['_bsontype'] == 'Code') {
	        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
	      } else if(value['_bsontype'] == 'Binary') {
	        index = serializeBinary(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Symbol') {
	        index = serializeSymbol(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'DBRef') {
	        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
	      } else if(value['_bsontype'] == 'BSONRegExp') {
	        index = serializeBSONRegExp(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
	        index = serializeMinMax(buffer, key, value, index);
	      }
	    }
	  } else if(object instanceof Map) {
	    var iterator = object.entries();
	    var done = false;
	
	    while(!done) {
	      // Unpack the next entry
	      var entry = iterator.next();
	      done = entry.done;
	      // Are we done, then skip and terminate
	      if(done) continue;
	
	      // Get the entry values
	      var key = entry.value[0];
	      var value = entry.value[1];
	
	      // Check the type of the value
	      var type = typeof value;
	
	      // Check the key and throw error if it's illegal
	      if(key != '$db' && key != '$ref' && key != '$id') {
	        if (key.match(regexp) != null) {
	          // The BSON spec doesn't allow keys with null bytes because keys are
	          // null-terminated.
	          throw Error("key " + key + " must not contain null bytes");
	        }
	
	        if (checkKeys) {
	          if('$' == key[0]) {
	            throw Error("key " + key + " must not start with '$'");
	          } else if (!!~key.indexOf('.')) {
	            throw Error("key " + key + " must not contain '.'");
	          }
	        }
	      }
	
	      // console.log("---------------------------------------------------")
	      // console.dir("key = " + key)
	      // console.dir("value = " + value)
	
	      if(type == 'string') {
	        index = serializeString(buffer, key, value, index);
	      } else if(type == 'number') {
	        index = serializeNumber(buffer, key, value, index);
	      } else if(type == 'boolean') {
	        index = serializeBoolean(buffer, key, value, index);
	      } else if(value instanceof Date || isDate(value)) {
	        index = serializeDate(buffer, key, value, index);
	      } else if(value === undefined && ignoreUndefined == true) {
	      } else if(value === null || value === undefined) {
	        index = serializeUndefined(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'ObjectID') {
	        index = serializeObjectId(buffer, key, value, index);
	      } else if(Buffer.isBuffer(value)) {
	        index = serializeBuffer(buffer, key, value, index);
	      } else if(value instanceof RegExp || isRegExp(value)) {
	        index = serializeRegExp(buffer, key, value, index);
	      } else if(type == 'object' && value['_bsontype'] == null) {
	        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
	      } else if(value['_bsontype'] == 'Long' || value['_bsontype'] == 'Timestamp') {
	        index = serializeLong(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Double') {
	        index = serializeDouble(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Code') {
	        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
	      } else if(typeof value == 'function' && serializeFunctions) {
	        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
	      } else if(value['_bsontype'] == 'Binary') {
	        index = serializeBinary(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Symbol') {
	        index = serializeSymbol(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'DBRef') {
	        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
	      } else if(value['_bsontype'] == 'BSONRegExp') {
	        index = serializeBSONRegExp(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
	        index = serializeMinMax(buffer, key, value, index);
	      }
	    }
	  } else {
	    // Did we provide a custom serialization method
	    if(object.toBSON) {
	      if(typeof object.toBSON != 'function') throw new Error("toBSON is not a function");
	      object = object.toBSON();
	      if(object != null && typeof object != 'object') throw new Error("toBSON function did not return an object");
	    }
	
	    // Iterate over all the keys
	    for(var key in object) {
	      var value = object[key];
	      // Is there an override value
	      if(value && value.toBSON) {
	        if(typeof value.toBSON != 'function') throw new Error("toBSON is not a function");
	        value = value.toBSON();
	      }
	
	      // Check the type of the value
	      var type = typeof value;
	
	      // Check the key and throw error if it's illegal
	      if(key != '$db' && key != '$ref' && key != '$id') {
	        if (key.match(regexp) != null) {
	          // The BSON spec doesn't allow keys with null bytes because keys are
	          // null-terminated.
	          throw Error("key " + key + " must not contain null bytes");
	        }
	
	        if (checkKeys) {
	          if('$' == key[0]) {
	            throw Error("key " + key + " must not start with '$'");
	          } else if (!!~key.indexOf('.')) {
	            throw Error("key " + key + " must not contain '.'");
	          }
	        }
	      }
	
	      if(type == 'string') {
	        index = serializeString(buffer, key, value, index);
	      } else if(type == 'number') {
	        index = serializeNumber(buffer, key, value, index);
	      } else if(type == 'boolean') {
	        index = serializeBoolean(buffer, key, value, index);
	      } else if(value instanceof Date || isDate(value)) {
	        index = serializeDate(buffer, key, value, index);
	      } else if(value === undefined && ignoreUndefined == true) {
	      } else if(value === null || value === undefined) {
	        index = serializeUndefined(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'ObjectID') {
	        index = serializeObjectId(buffer, key, value, index);
	      } else if(Buffer.isBuffer(value)) {
	        index = serializeBuffer(buffer, key, value, index);
	      } else if(value instanceof RegExp || isRegExp(value)) {
	        index = serializeRegExp(buffer, key, value, index);
	      } else if(type == 'object' && value['_bsontype'] == null) {
	        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
	      } else if(value['_bsontype'] == 'Long' || value['_bsontype'] == 'Timestamp') {
	        index = serializeLong(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Double') {
	        index = serializeDouble(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Code') {
	        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
	      } else if(typeof value == 'function' && serializeFunctions) {
	        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
	      } else if(value['_bsontype'] == 'Binary') {
	        index = serializeBinary(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Symbol') {
	        index = serializeSymbol(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'DBRef') {
	        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
	      } else if(value['_bsontype'] == 'BSONRegExp') {
	        index = serializeBSONRegExp(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
	        index = serializeMinMax(buffer, key, value, index);
	      }
	    }
	  }
	
	  // Final padding byte for object
	  buffer[index++] = 0x00;
	
	  // Final size
	  var size = index - startingIndex;
	  // Write the size of the object
	  buffer[startingIndex++] = size & 0xff;
	  buffer[startingIndex++] = (size >> 8) & 0xff;
	  buffer[startingIndex++] = (size >> 16) & 0xff;
	  buffer[startingIndex++] = (size >> 24) & 0xff;
	  return index;
	}
	
	var BSON = {};
	
	/**
	 * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5
	 *
	 * @ignore
	 * @api private
	 */
	var functionCache = BSON.functionCache = {};
	
	/**
	 * Number BSON Type
	 *
	 * @classconstant BSON_DATA_NUMBER
	 **/
	BSON.BSON_DATA_NUMBER = 1;
	/**
	 * String BSON Type
	 *
	 * @classconstant BSON_DATA_STRING
	 **/
	BSON.BSON_DATA_STRING = 2;
	/**
	 * Object BSON Type
	 *
	 * @classconstant BSON_DATA_OBJECT
	 **/
	BSON.BSON_DATA_OBJECT = 3;
	/**
	 * Array BSON Type
	 *
	 * @classconstant BSON_DATA_ARRAY
	 **/
	BSON.BSON_DATA_ARRAY = 4;
	/**
	 * Binary BSON Type
	 *
	 * @classconstant BSON_DATA_BINARY
	 **/
	BSON.BSON_DATA_BINARY = 5;
	/**
	 * ObjectID BSON Type
	 *
	 * @classconstant BSON_DATA_OID
	 **/
	BSON.BSON_DATA_OID = 7;
	/**
	 * Boolean BSON Type
	 *
	 * @classconstant BSON_DATA_BOOLEAN
	 **/
	BSON.BSON_DATA_BOOLEAN = 8;
	/**
	 * Date BSON Type
	 *
	 * @classconstant BSON_DATA_DATE
	 **/
	BSON.BSON_DATA_DATE = 9;
	/**
	 * null BSON Type
	 *
	 * @classconstant BSON_DATA_NULL
	 **/
	BSON.BSON_DATA_NULL = 10;
	/**
	 * RegExp BSON Type
	 *
	 * @classconstant BSON_DATA_REGEXP
	 **/
	BSON.BSON_DATA_REGEXP = 11;
	/**
	 * Code BSON Type
	 *
	 * @classconstant BSON_DATA_CODE
	 **/
	BSON.BSON_DATA_CODE = 13;
	/**
	 * Symbol BSON Type
	 *
	 * @classconstant BSON_DATA_SYMBOL
	 **/
	BSON.BSON_DATA_SYMBOL = 14;
	/**
	 * Code with Scope BSON Type
	 *
	 * @classconstant BSON_DATA_CODE_W_SCOPE
	 **/
	BSON.BSON_DATA_CODE_W_SCOPE = 15;
	/**
	 * 32 bit Integer BSON Type
	 *
	 * @classconstant BSON_DATA_INT
	 **/
	BSON.BSON_DATA_INT = 16;
	/**
	 * Timestamp BSON Type
	 *
	 * @classconstant BSON_DATA_TIMESTAMP
	 **/
	BSON.BSON_DATA_TIMESTAMP = 17;
	/**
	 * Long BSON Type
	 *
	 * @classconstant BSON_DATA_LONG
	 **/
	BSON.BSON_DATA_LONG = 18;
	/**
	 * MinKey BSON Type
	 *
	 * @classconstant BSON_DATA_MIN_KEY
	 **/
	BSON.BSON_DATA_MIN_KEY = 0xff;
	/**
	 * MaxKey BSON Type
	 *
	 * @classconstant BSON_DATA_MAX_KEY
	 **/
	BSON.BSON_DATA_MAX_KEY = 0x7f;
	
	/**
	 * Binary Default Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_DEFAULT
	 **/
	BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
	/**
	 * Binary Function Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_FUNCTION
	 **/
	BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
	/**
	 * Binary Byte Array Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY
	 **/
	BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
	/**
	 * Binary UUID Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_UUID
	 **/
	BSON.BSON_BINARY_SUBTYPE_UUID = 3;
	/**
	 * Binary MD5 Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_MD5
	 **/
	BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
	/**
	 * Binary User Defined Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED
	 **/
	BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
	
	// BSON MAX VALUES
	BSON.BSON_INT32_MAX = 0x7FFFFFFF;
	BSON.BSON_INT32_MIN = -0x80000000;
	
	BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
	BSON.BSON_INT64_MIN = -Math.pow(2, 63);
	
	// JS MAX PRECISE VALUES
	BSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.
	BSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.
	
	// Internal long versions
	var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000);  // Any integer up to 2^53 can be precisely represented by a double.
	var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000);  // Any integer down to -2^53 can be precisely represented by a double.
	
	module.exports = serializeInto;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict"
	
	var writeIEEE754 = __webpack_require__(135).writeIEEE754
		, readIEEE754 = __webpack_require__(135).readIEEE754
		, Long = __webpack_require__(137).Long
	  , Double = __webpack_require__(138).Double
	  , Timestamp = __webpack_require__(139).Timestamp
	  , ObjectID = __webpack_require__(140).ObjectID
	  , Symbol = __webpack_require__(143).Symbol
	  , BSONRegExp = __webpack_require__(142).BSONRegExp
	  , Code = __webpack_require__(144).Code
	  , MinKey = __webpack_require__(145).MinKey
	  , MaxKey = __webpack_require__(146).MaxKey
	  , DBRef = __webpack_require__(147).DBRef
	  , Binary = __webpack_require__(148).Binary;
	
	// To ensure that 0.4 of node works correctly
	var isDate = function isDate(d) {
	  return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';
	}
	
	var calculateObjectSize = function calculateObjectSize(object, serializeFunctions, ignoreUndefined) {
	  var totalLength = (4 + 1);
	
	  if(Array.isArray(object)) {
	    for(var i = 0; i < object.length; i++) {
	      totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined)
	    }
	  } else {
			// If we have toBSON defined, override the current object
			if(object.toBSON) {
				object = object.toBSON();
			}
	
			// Calculate size
	    for(var key in object) {
	      totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined)
	    }
	  }
	
	  return totalLength;
	}
	
	/**
	 * @ignore
	 * @api private
	 */
	function calculateElement(name, value, serializeFunctions, isArray, ignoreUndefined) {
		// If we have toBSON defined, override the current object
	  if(value && value.toBSON){
	    value = value.toBSON();
	  }
	
	  switch(typeof value) {
	    case 'string':
	      return 1 + Buffer.byteLength(name, 'utf8') + 1 + 4 + Buffer.byteLength(value, 'utf8') + 1;
	    case 'number':
	      if(Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
	        if(value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) { // 32 bit
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (4 + 1);
	        } else {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (8 + 1);
	        }
	      } else {  // 64 bit
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (8 + 1);
	      }
	    case 'undefined':
	      if(isArray || !ignoreUndefined) return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (1);
	      return 0;
	    case 'boolean':
	      return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (1 + 1);
	    case 'object':
	      if(value == null || value instanceof MinKey || value instanceof MaxKey || value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (1);
	      } else if(value instanceof ObjectID || value['_bsontype'] == 'ObjectID') {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (12 + 1);
	      } else if(value instanceof Date || isDate(value)) {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (8 + 1);
	      } else if(typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (1 + 4 + 1) + value.length;
	      } else if(value instanceof Long || value instanceof Double || value instanceof Timestamp
	          || value['_bsontype'] == 'Long' || value['_bsontype'] == 'Double' || value['_bsontype'] == 'Timestamp') {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (8 + 1);
	      } else if(value instanceof Code || value['_bsontype'] == 'Code') {
	        // Calculate size depending on the availability of a scope
	        if(value.scope != null && Object.keys(value.scope).length > 0) {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + 4 + 4 + Buffer.byteLength(value.code.toString(), 'utf8') + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
	        } else {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + 4 + Buffer.byteLength(value.code.toString(), 'utf8') + 1;
	        }
	      } else if(value instanceof Binary || value['_bsontype'] == 'Binary') {
	        // Check what kind of subtype we have
	        if(value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (value.position + 1 + 4 + 1 + 4);
	        } else {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (value.position + 1 + 4 + 1);
	        }
	      } else if(value instanceof Symbol || value['_bsontype'] == 'Symbol') {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + Buffer.byteLength(value.value, 'utf8') + 4 + 1 + 1;
	      } else if(value instanceof DBRef || value['_bsontype'] == 'DBRef') {
	        // Set up correct object for serialization
	        var ordered_values = {
	            '$ref': value.namespace
	          , '$id' : value.oid
	        };
	
	        // Add db reference if it exists
	        if(null != value.db) {
	          ordered_values['$db'] = value.db;
	        }
	
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + calculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
	      } else if(value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]') {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + Buffer.byteLength(value.source, 'utf8') + 1
	            + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1
	      } else if(value instanceof BSONRegExp || value['_bsontype'] == 'BSONRegExp') {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + Buffer.byteLength(value.pattern, 'utf8') + 1
	            + Buffer.byteLength(value.options, 'utf8') + 1
	      } else {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + calculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
	      }
	    case 'function':
	      // WTF for 0.4.X where typeof /someregexp/ === 'function'
	      if(value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]' || String.call(value) == '[object RegExp]') {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + Buffer.byteLength(value.source, 'utf8') + 1
	          + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1
	      } else {
	        if(serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + 4 + 4 + Buffer.byteLength(value.toString(), 'utf8') + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
	        } else if(serializeFunctions) {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + 4 + Buffer.byteLength(value.toString(), 'utf8') + 1;
	        }
	      }
	  }
	
	  return 0;
	}
	
	var BSON = {};
	
	/**
	 * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5
	 *
	 * @ignore
	 * @api private
	 */
	var functionCache = BSON.functionCache = {};
	
	/**
	 * Number BSON Type
	 *
	 * @classconstant BSON_DATA_NUMBER
	 **/
	BSON.BSON_DATA_NUMBER = 1;
	/**
	 * String BSON Type
	 *
	 * @classconstant BSON_DATA_STRING
	 **/
	BSON.BSON_DATA_STRING = 2;
	/**
	 * Object BSON Type
	 *
	 * @classconstant BSON_DATA_OBJECT
	 **/
	BSON.BSON_DATA_OBJECT = 3;
	/**
	 * Array BSON Type
	 *
	 * @classconstant BSON_DATA_ARRAY
	 **/
	BSON.BSON_DATA_ARRAY = 4;
	/**
	 * Binary BSON Type
	 *
	 * @classconstant BSON_DATA_BINARY
	 **/
	BSON.BSON_DATA_BINARY = 5;
	/**
	 * ObjectID BSON Type
	 *
	 * @classconstant BSON_DATA_OID
	 **/
	BSON.BSON_DATA_OID = 7;
	/**
	 * Boolean BSON Type
	 *
	 * @classconstant BSON_DATA_BOOLEAN
	 **/
	BSON.BSON_DATA_BOOLEAN = 8;
	/**
	 * Date BSON Type
	 *
	 * @classconstant BSON_DATA_DATE
	 **/
	BSON.BSON_DATA_DATE = 9;
	/**
	 * null BSON Type
	 *
	 * @classconstant BSON_DATA_NULL
	 **/
	BSON.BSON_DATA_NULL = 10;
	/**
	 * RegExp BSON Type
	 *
	 * @classconstant BSON_DATA_REGEXP
	 **/
	BSON.BSON_DATA_REGEXP = 11;
	/**
	 * Code BSON Type
	 *
	 * @classconstant BSON_DATA_CODE
	 **/
	BSON.BSON_DATA_CODE = 13;
	/**
	 * Symbol BSON Type
	 *
	 * @classconstant BSON_DATA_SYMBOL
	 **/
	BSON.BSON_DATA_SYMBOL = 14;
	/**
	 * Code with Scope BSON Type
	 *
	 * @classconstant BSON_DATA_CODE_W_SCOPE
	 **/
	BSON.BSON_DATA_CODE_W_SCOPE = 15;
	/**
	 * 32 bit Integer BSON Type
	 *
	 * @classconstant BSON_DATA_INT
	 **/
	BSON.BSON_DATA_INT = 16;
	/**
	 * Timestamp BSON Type
	 *
	 * @classconstant BSON_DATA_TIMESTAMP
	 **/
	BSON.BSON_DATA_TIMESTAMP = 17;
	/**
	 * Long BSON Type
	 *
	 * @classconstant BSON_DATA_LONG
	 **/
	BSON.BSON_DATA_LONG = 18;
	/**
	 * MinKey BSON Type
	 *
	 * @classconstant BSON_DATA_MIN_KEY
	 **/
	BSON.BSON_DATA_MIN_KEY = 0xff;
	/**
	 * MaxKey BSON Type
	 *
	 * @classconstant BSON_DATA_MAX_KEY
	 **/
	BSON.BSON_DATA_MAX_KEY = 0x7f;
	
	/**
	 * Binary Default Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_DEFAULT
	 **/
	BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
	/**
	 * Binary Function Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_FUNCTION
	 **/
	BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
	/**
	 * Binary Byte Array Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY
	 **/
	BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
	/**
	 * Binary UUID Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_UUID
	 **/
	BSON.BSON_BINARY_SUBTYPE_UUID = 3;
	/**
	 * Binary MD5 Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_MD5
	 **/
	BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
	/**
	 * Binary User Defined Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED
	 **/
	BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
	
	// BSON MAX VALUES
	BSON.BSON_INT32_MAX = 0x7FFFFFFF;
	BSON.BSON_INT32_MIN = -0x80000000;
	
	BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
	BSON.BSON_INT64_MIN = -Math.pow(2, 63);
	
	// JS MAX PRECISE VALUES
	BSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.
	BSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.
	
	// Internal long versions
	var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000);  // Any integer up to 2^53 can be precisely represented by a double.
	var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000);  // Any integer down to -2^53 can be precisely represented by a double.
	
	module.exports = calculateObjectSize;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module exports.
	 */
	
	exports.Binary = __webpack_require__(133);
	exports.ObjectId = __webpack_require__(153);
	exports.ReadPreference = __webpack_require__(132);


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) ObjectId
	 * @constructor NodeMongoDbObjectId
	 * @see ObjectId
	 */
	
	var ObjectId = __webpack_require__(134).ObjectID;
	
	/*!
	 * ignore
	 */
	
	module.exports = exports = ObjectId;


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var mongodb = __webpack_require__(155);
	var ReadPref = mongodb.ReadPreference;
	
	/*!
	 * Converts arguments to ReadPrefs the driver
	 * can understand.
	 *
	 * @param {String|Array} pref
	 * @param {Array} [tags]
	 */
	
	module.exports = function readPref(pref, tags) {
	  if (Array.isArray(pref)) {
	    tags = pref[1];
	    pref = pref[0];
	  }
	
	  if (pref instanceof ReadPref) {
	    return pref;
	  }
	
	  switch (pref) {
	    case 'p':
	      pref = 'primary';
	      break;
	    case 'pp':
	      pref = 'primaryPreferred';
	      break;
	    case 's':
	      pref = 'secondary';
	      break;
	    case 'sp':
	      pref = 'secondaryPreferred';
	      break;
	    case 'n':
	      pref = 'nearest';
	      break;
	  }
	
	  return new ReadPref(pref, tags);
	};


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	// Core module
	var core = __webpack_require__(156),
	  Instrumentation = __webpack_require__(192);
	
	// Set up the connect function
	var connect = __webpack_require__(214).connect;
	
	// Expose error class
	connect.MongoError = core.MongoError;
	
	// Actual driver classes exported
	connect.Admin = __webpack_require__(213);
	connect.MongoClient = __webpack_require__(214);
	connect.Db = __webpack_require__(212);
	connect.Collection = __webpack_require__(207);
	connect.Server = __webpack_require__(208);
	connect.ReplSet = __webpack_require__(210);
	connect.Mongos = __webpack_require__(211);
	connect.ReadPreference = __webpack_require__(195);
	connect.GridStore = __webpack_require__(205);
	connect.Chunk = __webpack_require__(206);
	connect.Logger = core.Logger;
	connect.Cursor = __webpack_require__(197);
	connect.GridFSBucket = __webpack_require__(216);
	
	// BSON types exported
	connect.Binary = core.BSON.Binary;
	connect.Code = core.BSON.Code;
	connect.Map = core.BSON.Map;
	connect.DBRef = core.BSON.DBRef;
	connect.Double = core.BSON.Double;
	connect.Long = core.BSON.Long;
	connect.MinKey = core.BSON.MinKey;
	connect.MaxKey = core.BSON.MaxKey;
	connect.ObjectID = core.BSON.ObjectID;
	connect.ObjectId = core.BSON.ObjectID;
	connect.Symbol = core.BSON.Symbol;
	connect.Timestamp = core.BSON.Timestamp;
	
	// Add connect method
	connect.connect = connect;
	
	// Set up the instrumentation method
	connect.instrument = function(options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  return new Instrumentation(core, options, callback);
	}
	
	// Set our exports to be the connect function
	module.exports = connect;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	    MongoError: __webpack_require__(157)
	  , Server: __webpack_require__(158)
	  , ReplSet: __webpack_require__(188)
	  , Mongos: __webpack_require__(191)
	  , Logger: __webpack_require__(163)
	  , Cursor: __webpack_require__(165)
	  , ReadPreference: __webpack_require__(164)
	  , BSON: __webpack_require__(134)
	  // Raw operations
	  , Query: __webpack_require__(162).Query
	  // Auth mechanisms
	  , MongoCR: __webpack_require__(173)
	  , X509: __webpack_require__(174)
	  , Plain: __webpack_require__(175)
	  , GSSAPI: __webpack_require__(176)
	  , ScramSHA1: __webpack_require__(187)
	}


/***/ },
/* 157 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Creates a new MongoError
	 * @class
	 * @augments Error
	 * @param {string} message The error message
	 * @return {MongoError} A MongoError instance
	 */
	function MongoError(message) {
	  this.name = 'MongoError';
	  this.message = message;
	  Error.captureStackTrace(this, MongoError);
	}
	
	/**
	 * Creates a new MongoError object
	 * @method
	 * @param {object} options The error options
	 * @return {MongoError} A MongoError instance
	 */
	MongoError.create = function(options) {
	  var err = null;
	
	  if(options instanceof Error) {
	    err = new MongoError(options.message);
	    err.stack = options.stack;
	  } else if(typeof options == 'string') {
	    err = new MongoError(options);
	  } else {
	    err = new MongoError(options.message || options.errmsg || options.$err || "n/a");
	    // Other options
	    for(var name in options) {
	      err[name] = options[name];
	    }
	  }
	
	  return err;
	}
	
	// Extend JavaScript error
	MongoError.prototype = new Error; 
	
	module.exports = MongoError;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var inherits = __webpack_require__(77).inherits
	  , f = __webpack_require__(77).format
	  , bindToCurrentDomain = __webpack_require__(159).bindToCurrentDomain
	  , EventEmitter = __webpack_require__(3).EventEmitter
	  , Pool = __webpack_require__(160)
	  , b = __webpack_require__(134)
	  , crypto = __webpack_require__(70)
	  , Query = __webpack_require__(162).Query
	  , MongoError = __webpack_require__(157)
	  , ReadPreference = __webpack_require__(164)
	  , BasicCursor = __webpack_require__(165)
	  , CommandResult = __webpack_require__(166)
	  , getSingleProperty = __webpack_require__(159).getSingleProperty
	  , getProperty = __webpack_require__(159).getProperty
	  , debugOptions = __webpack_require__(159).debugOptions
	  , BSON = __webpack_require__(134).native().BSON
	  , PreTwoSixWireProtocolSupport = __webpack_require__(167)
	  , TwoSixWireProtocolSupport = __webpack_require__(170)
	  , ThreeTwoWireProtocolSupport = __webpack_require__(171)
	  , Session = __webpack_require__(172)
	  , Logger = __webpack_require__(163)
	  , MongoCR = __webpack_require__(173)
	  , X509 = __webpack_require__(174)
	  , Plain = __webpack_require__(175)
	  , GSSAPI = __webpack_require__(176)
	  , SSPI = __webpack_require__(186)
	  , ScramSHA1 = __webpack_require__(187);
	
	/**
	 * @fileOverview The **Server** class is a class that represents a single server topology and is
	 * used to construct connections.
	 *
	 * @example
	 * var Server = require('mongodb-core').Server
	 *   , ReadPreference = require('mongodb-core').ReadPreference
	 *   , assert = require('assert');
	 *
	 * var server = new Server({host: 'localhost', port: 27017});
	 * // Wait for the connection event
	 * server.on('connect', function(server) {
	 *   server.destroy();
	 * });
	 *
	 * // Start connecting
	 * server.connect();
	 */
	
	// All bson types
	var bsonTypes = [b.Long, b.ObjectID, b.Binary, b.Code, b.DBRef, b.Symbol, b.Double, b.Timestamp, b.MaxKey, b.MinKey];
	// BSON parser
	var bsonInstance = null;
	// Server instance id
	var serverId = 0;
	// Callbacks instance id
	var callbackId = 0;
	
	// Single store for all callbacks
	var Callbacks = function() {
	  // EventEmitter.call(this);
	  var self = this;
	  // Callbacks
	  this.callbacks = {};
	  // Set the callbacks id
	  this.id = callbackId++;
	  // Set the type to server
	  this.type = 'server';
	}
	
	//
	// Clone the options
	var cloneOptions = function(options) {
	  var opts = {};
	  for(var name in options) {
	    opts[name] = options[name];
	  }
	  return opts;
	}
	
	//
	// Flush all callbacks
	Callbacks.prototype.flush = function(err) {
	  for(var id in this.callbacks) {
	    if(!isNaN(parseInt(id, 10))) {
	      var callback = this.callbacks[id];
	      delete this.callbacks[id];
	      callback(err, null);
	    }
	  }
	}
	
	//
	// Flush all callbacks
	Callbacks.prototype.flushConnection = function(err, connection) {
	  for(var id in this.callbacks) {
	    if(!isNaN(parseInt(id, 10))) {
	      var callback = this.callbacks[id];
	
	      // Validate if the operation ran on the connection
	      if(callback.connection && callback.connection.id === connection.id) {
	        delete this.callbacks[id];
	        callback(err, null);
	      } else if(!callback.connection && callback.monitoring) {
	        delete this.callbacks[id];
	        callback(err, null);
	      }
	    }
	  }
	}
	
	Callbacks.prototype.callback = function(id) {
	  return this.callbacks[id];
	}
	
	Callbacks.prototype.emit = function(id, err, value) {
	  var callback = this.callbacks[id];
	  delete this.callbacks[id];
	  callback(err, value);
	}
	
	Callbacks.prototype.raw = function(id) {
	  if(this.callbacks[id] == null) return false;
	  return this.callbacks[id].raw == true ? true : false
	}
	
	Callbacks.prototype.documentsReturnedIn = function(id) {
	  if(this.callbacks[id] == null) return false;
	  return typeof this.callbacks[id].documentsReturnedIn == 'string' ? this.callbacks[id].documentsReturnedIn : null;
	}
	
	Callbacks.prototype.unregister = function(id) {
	  delete this.callbacks[id];
	}
	
	Callbacks.prototype.register = function(id, callback) {
	  this.callbacks[id] = bindToCurrentDomain(callback);
	}
	
	var DISCONNECTED = 'disconnected';
	var CONNECTING = 'connecting';
	var CONNECTED = 'connected';
	var DESTROYED = 'destroyed';
	
	// Supports server
	var supportsServer = function(_s) {
	  return _s.ismaster && typeof _s.ismaster.minWireVersion == 'number';
	}
	
	//
	// createWireProtocolHandler
	var createWireProtocolHandler = function(result) {
	  // 3.2 wire protocol handler
	  if(result && result.maxWireVersion >= 4) {
	    return new ThreeTwoWireProtocolSupport(new TwoSixWireProtocolSupport());
	  }
	
	  // 2.6 wire protocol handler
	  if(result && result.maxWireVersion >= 2) {
	    return new TwoSixWireProtocolSupport();
	  }
	
	  // 2.4 or earlier wire protocol handler
	  return new PreTwoSixWireProtocolSupport();
	}
	
	var errorHandler = function(self, state) {
	  return function(err, connection) {
	    if(state.state == DISCONNECTED || state.state == DESTROYED) return;
	    // Flush the connection operations
	    if(self.s.callbacks) {
	      self.s.callbacks.flushConnection(new MongoError(f("server %s received an error %s", self.name, JSON.stringify(err))), connection);
	    }
	
	    // Emit error event
	    if(state.emitError && self.listeners('error').length > 0) {
	      self.emit('error', err, self);
	    }
	
	    // No more connections left, emit a close
	    if(state.pool.getAll().length == 0) {
	      // Set disconnected state
	      state.state = DISCONNECTED;
	      // Notify any strategies for read Preferences about closure
	      if(state.readPreferenceStrategies != null) notifyStrategies(self, self.s, 'error', [self]);
	      if(state.logger.isInfo()) state.logger.info(f('server %s errored out with %s', self.name, JSON.stringify(err)));
	      // Flush out all the callbacks
	      if(state.callbacks) {
	        state.callbacks.flushConnection(new MongoError(f("server %s received an error %s", self.name, JSON.stringify(err))), connection);
	      }
	      // Destroy all connections
	      self.destroy();
	      // Emit error event
	      if(state.emitError && self.listeners('error').length > 0) self.emit('error', err, self);
	      // If we specified the driver to reconnect perform it
	      if(state.reconnect) return setTimeout(function() {
	        reconnectServer(self, state)
	      }, state.reconnectInterval);
	      // No reconnect destroy instance
	      self.destroy();
	    }
	  }
	}
	
	//
	// reconnect error handler
	var reconnectErrorHandler = function(self, state) {
	  return function(err, connection) {
	    if(state.state == DESTROYED) return;
	
	    // Flush the connection operations
	    if(self.s.callbacks) {
	      self.s.callbacks.flushConnection(new MongoError(f("server %s received an error %s", self.name, JSON.stringify(err))), connection);
	    }
	
	    // Emit error event
	    if(state.emitError && self.listeners('error').length > 0) {
	      self.emit('error', err, self);
	    }
	
	    // No more connections left, emit a close
	    if(state.pool.getAll().length == 0) {
	      // No more retries
	      if(state.currentReconnectRetry == 0) {
	        // Set state to destroyed
	        self.state = DESTROYED;
	        // Destroy pool
	        self.destroy();
	
	        if(self.listeners('error').length > 0) {
	          self.emit('error', new MongoError(f('failed to connect to %s:%s after %s retries', state.options.host, state.options.port, state.reconnectTries)), self);
	        }
	      } else {
	        // Do we have an error listener emit the error
	        if(self.listeners('error').length > 0) {
	          self.emit('error', new MongoError(f('failed to connect to %s:%s, %s connection attempts left ', state.options.host, state.options.port, state.currentReconnectRetry)), self);
	        }
	
	        // Retry connection
	        setTimeout(function() {
	          reconnectServer(self, state);
	        }, state.reconnectInterval);
	      }
	    }
	  }
	}
	
	//
	// Reconnect server
	var reconnectServer = function(self, state) {
	  if(state.state == DESTROYED) return;
	  // Flush out any left over callbacks
	  if(self && state && state.callbacks) {
	    state.callbacks.flush(new MongoError(f("server %s received a broken socket pipe error", self.name)));
	  }
	
	  // If the current reconnect retries is 0 stop attempting to reconnect
	  if(state.currentReconnectRetry == 0) {
	    return self.destroy(true, true);
	  }
	
	  // Adjust the number of retries
	  state.currentReconnectRetry = state.currentReconnectRetry - 1;
	
	  // Set status to connecting
	  state.state = CONNECTING;
	
	  // If we have a pool destroy it
	  if(state.pool) state.pool.destroy();
	  // Create a new Pool
	  state.pool = new Pool(state.options);
	
	  //
	  // Attempt to connect
	  state.pool.once('connect', function() {
	    // Reset retries
	    state.currentReconnectRetry = state.reconnectTries;
	
	    // Remove any non used handlers
	    var events = ['error', 'close', 'timeout', 'parseError',
	      'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	      'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'];
	    events.forEach(function(e) {
	      state.pool.removeAllListeners(e);
	    });
	
	    // Set connected state
	    state.state = CONNECTED;
	
	    // Add proper handlers
	    state.pool.once('error', self.s.inTopology ? errorHandler(self, state) : reconnectErrorHandler(self, state));
	    state.pool.on('close', closeHandler(self, state));
	    state.pool.on('timeout', timeoutHandler(self, state));
	    state.pool.on('parseError', fatalErrorHandler(self, state));
	
	    // We need to ensure we have re-authenticated
	    var keys = Object.keys(state.authProviders);
	    if(keys.length == 0) return self.emit('reconnect', self);
	
	    // Get all connections
	    var connections = state.pool.getAll();
	    // Execute all providers
	    var count = keys.length;
	    // Iterate over keys
	    for(var i = 0; i < keys.length; i++) {
	      state.authProviders[keys[i]].reauthenticate(self, connections, function(err, r) {
	        count = count - 1;
	        // We are done, emit reconnect event
	        if(count == 0) {
	          if(!state.ismaster) {
	            return connectHandler(self, state)();
	          }
	
	          return self.emit('reconnect', self);
	        }
	      });
	    }
	  });
	
	  //
	  // Handle connection failure
	  state.pool.once('error', self.s.inTopology ? errorHandler(self, state) : reconnectErrorHandler(self, state));
	  state.pool.once('close', errorHandler(self, state));
	  state.pool.once('timeout', errorHandler(self, state));
	  state.pool.once('parseError', errorHandler(self, state));
	
	  // Connect pool
	  state.pool.connect();
	}
	
	//
	// Handlers
	var messageHandler = function(self, state) {
	  return function(response, connection) {
	    // Attempt to parse the message
	    try {
	      // Get the callback
	      var cb = state.callbacks.callback(response.responseTo);
	
	      // Parse options
	      var parseOptions = {
	        raw: state.callbacks.raw(response.responseTo),
	        promoteLongs: cb && typeof cb.promoteLongs == 'boolean' ? cb.promoteLongs : true,
	        documentsReturnedIn: state.callbacks.documentsReturnedIn(response.responseTo)
	      };
	
	      // Parse the message
	      response.parse(parseOptions);
	
	      // If no
	      if((cb && !cb.noRelease) || !cb) {
	        self.s.pool.connectionAvailable(connection);
	      }
	
	      // Log if debug enabled
	      if(state.logger.isDebug()) state.logger.debug(f('message [%s] received from %s', response.raw.toString('hex'), self.name));
	      // Execute the registered callback
	      state.callbacks.emit(response.responseTo, null, response);
	    } catch (err) {
	      state.callbacks.flushConnection(new MongoError(err), connection);
	      self.destroy();
	    }
	  }
	}
	
	var fatalErrorHandler = function(self, state) {
	  return function(err, connection) {
	    if(state.state == DISCONNECTED || state.state == DESTROYED) return;
	
	    // Flush the connection operations
	    if(self.s.callbacks) {
	      self.s.callbacks.flushConnection(new MongoError(f("server %s received an error %s", self.name, JSON.stringify(err))), connection);
	    }
	
	    // No more connections left, emit a close
	    if(state.pool.getAll().length == 0) {
	      // Set disconnected state
	      state.state = DISCONNECTED;
	      // Notify any strategies for read Preferences about closure
	      if(state.readPreferenceStrategies != null) notifyStrategies(self, self.s, 'error', [self]);
	      if(state.logger.isInfo()) state.logger.info(f('server %s errored out with %s', self.name, JSON.stringify(err)));
	      // Flush out all the callbacks
	      if(state.callbacks) {
	        state.callbacks.flushConnection(new MongoError(f("server %s received an error %s", self.name, JSON.stringify(err))), connection);
	      }
	      // Emit error event
	      if(self.listeners('error').length > 0) self.emit('error', err, self);
	      // If we specified the driver to reconnect perform it
	      if(state.reconnect) return setTimeout(function() {
	        reconnectServer(self, state)
	      }, state.reconnectInterval);
	      // No reconnect destroy instance
	      self.destroy();
	    }
	  }
	}
	
	var timeoutHandler = function(self, state) {
	  return function(err, connection) {
	    if(state.state == DISCONNECTED || state.state == DESTROYED) return;
	
	    // Flush the connection operations
	    if(self.s.callbacks) {
	      self.s.callbacks.flushConnection(new MongoError(f("server %s timed out", self.name)), connection);
	    }
	
	    // No more connections left, emit a close
	    if(state.pool.getAll().length == 0) {
	      // Set disconnected state
	      state.state = DISCONNECTED;
	      // Notify any strategies for read Preferences about closure
	      if(state.readPreferenceStrategies != null) notifyStrategies(self, self.s, 'timeout', [self]);
	      if(state.logger.isInfo()) state.logger.info(f('server %s timed out', self.name));
	      // Flush out all the callbacks
	      if(state.callbacks) {
	        state.callbacks.flushConnection(new MongoError(f("server %s timed out", self.name)), connection);
	      }
	      // Emit error event
	      self.emit('timeout', err, self);
	      // If we specified the driver to reconnect perform it
	      if(state.reconnect) return setTimeout(function() {
	        reconnectServer(self, state)
	      }, state.reconnectInterval);
	      // No reconnect destroy instance
	      self.destroy();
	    }
	  }
	}
	
	var closeHandler = function(self, state) {
	  return function(err, connection) {
	    if(state.state == DISCONNECTED || state.state == DESTROYED) return;
	
	    // Flush the connection operations
	    if(self.s.callbacks) {
	      self.s.callbacks.flushConnection(new MongoError(f("server %s timed out", self.name)), connection);
	    }
	
	    // No more connections left, emit a close
	    if(state.pool.getAll().length == 0) {
	      // Set state to disconnected
	      state.state = DISCONNECTED;
	      // Notify any strategies for read Preferences about closure
	      if(state.readPreferenceStrategies != null) notifyStrategies(self, self.s, 'close', [self]);
	      if(state.logger.isInfo()) state.logger.info(f('server %s closed', self.name));
	      // Flush out all the callbacks
	      if(state.callbacks) {
	        state.callbacks.flushConnection(new MongoError(f("server %s sockets closed", self.name)), connection);
	      }
	
	      // Emit opening server event
	      if(self.listeners('serverClosed').length > 0) self.emit('serverClosed', {
	        topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.s.id, address: self.name
	      });
	
	      // Emit toplogy opening event if not in topology
	      if(self.listeners('topologyClosed').length > 0 && !self.s.inTopology) {
	        self.emit('topologyClosed', { topologyId: self.s.id });
	      }
	
	      // Emit close event
	      self.emit('close', err, self);
	      // If we specified the driver to reconnect perform it
	      if(state.reconnect) return setTimeout(function() {
	        reconnectServer(self, state)
	      }, state.reconnectInterval);
	      // No reconnect destroy instance
	      self.destroy();
	    }
	  }
	}
	
	var connectHandler = function(self, state) {
	  // Apply all stored authentications
	  var applyAuthentications = function(ismaster, callback) {
	    // Do not authenticate if we have an arbiter
	    if(ismaster && ismaster.arbiterOnly) return callback(null, null);
	    // We need to ensure we have re-authenticated
	    var keys = Object.keys(state.authProviders);
	    if(keys.length == 0) return callback(null, null);
	
	    // Get all connections
	    var connections = state.pool.getAll();
	    // Execute all providers
	    var count = keys.length;
	    // Iterate over keys
	    for(var i = 0; i < keys.length; i++) {
	      state.authProviders[keys[i]].reauthenticate(self, connections, function(err, r) {
	        count = count - 1;
	        // We are done
	        if(count == 0) {
	          return callback(null, null);
	        }
	      });
	    }
	  }
	
	  return function() {
	    // Apply any applyAuthentications
	    // applyAuthentications(function() {
	    // Initiate monitoring
	    if(state.monitoring) {
	      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), state.haInterval);
	    }
	
	    // Get the actual latency of the ismaster
	    var start = new Date().getTime();
	    // Execute an ismaster
	    self.command('admin.$cmd', {ismaster:true}, function(err, r) {
	      if(err) {
	        state.state = DISCONNECTED;
	
	        // Emit opening closed event
	        if(self.listeners('serverClosed').length > 0) self.emit('serverClosed', {
	          topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.s.id, address: self.name
	        });
	
	        // Emit toplogy opening event if not in topology
	        if(!self.s.inTopology) {
	          self.emit('topologyOpening', { topologyId: self.s.id });
	        }
	
	        return self.emit('close', err, self);
	      }
	
	      // Apply authentication
	      applyAuthentications(r.result, function() {
	        // Emit server description changed if something listening
	        emitServerDescriptionChanged(self, {
	          address: self.name, arbiters: [], hosts: [], passives: [], type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)
	        });
	
	        // Emit topology description changed if something listening
	        emitTopologyDescriptionChanged(self, {
	          topologyType: 'Single', servers: [{address: self.name, arbiters: [], hosts: [], passives: [], type: 'Standalone'}]
	        });
	
	        // Set the latency for this instance
	        state.isMasterLatencyMS = new Date().getTime() - start;
	
	        // Set the current ismaster
	        if(!err) {
	          state.ismaster = r.result;
	        }
	
	        // Emit the ismaster
	        self.emit('ismaster', r.result, self);
	
	        // Determine the wire protocol handler
	        state.wireProtocolHandler = createWireProtocolHandler(state.ismaster);
	
	        // Set the wireProtocolHandler
	        state.options.wireProtocolHandler = state.wireProtocolHandler;
	
	        // Log the ismaster if available
	        if(state.logger.isInfo()) state.logger.info(f('server %s connected with ismaster [%s]', self.name, JSON.stringify(r.result)));
	
	        // Validate if we it's a server we can connect to
	        if(!supportsServer(state) && state.wireProtocolHandler == null) {
	          state.state = DISCONNECTED
	          return self.emit('error', new MongoError("non supported server version"), self);
	        }
	
	        // Set the details
	        if(state.ismaster && state.ismaster.me) {
	          state.serverDetails.name = state.ismaster.me;
	        }
	
	        // No read preference strategies just emit connect
	        if(state.readPreferenceStrategies == null) {
	          state.state = CONNECTED;
	          return self.emit('connect', self);
	        }
	
	        // Signal connect to all readPreferences
	        notifyStrategies(self, self.s, 'connect', [self], function(err, result) {
	          state.state = CONNECTED;
	          return self.emit('connect', self);
	        });
	      });
	    });
	    // });
	  }
	}
	
	var slaveOk = function(r) {
	  if(r) return r.slaveOk()
	  return false;
	}
	
	//
	// Execute readPreference Strategies
	var notifyStrategies = function(self, state, op, params, callback) {
	  if(typeof callback != 'function') {
	    // Notify query start to any read Preference strategies
	    for(var name in state.readPreferenceStrategies) {
	      if(state.readPreferenceStrategies[name][op]) {
	        var strat = state.readPreferenceStrategies[name];
	        strat[op].apply(strat, params);
	      }
	    }
	    // Finish up
	    return;
	  }
	
	  // Execute the async callbacks
	  var nPreferences = Object.keys(state.readPreferenceStrategies).length;
	  if(nPreferences == 0) return callback(null, null);
	  for(var name in state.readPreferenceStrategies) {
	    if(state.readPreferenceStrategies[name][op]) {
	      var strat = state.readPreferenceStrategies[name];
	      // Add a callback to params
	      var cParams = params.slice(0);
	      cParams.push(function(err, r) {
	        nPreferences = nPreferences - 1;
	        if(nPreferences == 0) {
	          callback(null, null);
	        }
	      })
	      // Execute the readPreference
	      strat[op].apply(strat, cParams);
	    }
	  }
	}
	
	var debugFields = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host'
	  , 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity'
	  , 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs'];
	
	/**
	 * Creates a new Server instance
	 * @class
	 * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection
	 * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times
	 * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries
	 * @param {boolean} [options.emitError=false] Server will emit errors events
	 * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors
	 * @param {string} options.host The server host
	 * @param {number} options.port The server port
	 * @param {number} [options.size=5] Server connection pool size
	 * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
	 * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.connectionTimeout=0] TCP Connection timeout setting
	 * @param {number} [options.socketTimeout=0] TCP Socket timeout setting
	 * @param {number} [options.monitoringSocketTimeout=30000] TCP Socket timeout setting for replicaset monitoring socket
	 * @param {boolean} [options.ssl=false] Use SSL for connection
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {Buffer} [options.ca] SSL Certificate store binary buffer
	 * @param {Buffer} [options.cert] SSL Certificate binary buffer
	 * @param {Buffer} [options.key] SSL Key file binary buffer
	 * @param {string} [options.passphrase] SSL Certificate pass phrase
	 * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates
	 * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
	 * @return {Server} A cursor instance
	 * @fires Server#connect
	 * @fires Server#close
	 * @fires Server#error
	 * @fires Server#timeout
	 * @fires Server#parseError
	 * @fires Server#reconnect
	 */
	var Server = function(options) {
	  var self = this;
	
	  // Add event listener
	  EventEmitter.call(this);
	
	  // BSON Parser, ensure we have a single instance
	  if(bsonInstance == null) {
	    bsonInstance = new BSON(bsonTypes);
	  }
	
	  // Reconnect retries
	  var reconnectTries = options.reconnectTries || 30;
	
	  // Keeps all the internal state of the server
	  this.s = {
	    // Options
	      options: options
	    // Contains all the callbacks
	    , callbacks: new Callbacks()
	    // Logger
	    , logger: Logger('Server', options)
	    // Server state
	    , state: DISCONNECTED
	    // Reconnect option
	    , reconnect: typeof options.reconnect == 'boolean' ? options.reconnect :  true
	    , reconnectTries: reconnectTries
	    , reconnectInterval: options.reconnectInterval || 1000
	    // Swallow or emit errors
	    , emitError: typeof options.emitError == 'boolean' ? options.emitError : false
	    // Current state
	    , currentReconnectRetry: reconnectTries
	    // Contains the ismaster
	    , ismaster: null
	    // Contains any alternate strategies for picking
	    , readPreferenceStrategies: options.readPreferenceStrategies
	    // Auth providers
	    , authProviders: options.authProviders || {}
	    // Server instance id
	    , id: serverId++
	    // Shared topology id if part of another one
	    , topologyId: options.topologyId || -1
	    // Grouping tag used for debugging purposes
	    , tag: options.tag
	    // Do we have a not connected handler
	    , disconnectHandler: options.disconnectHandler
	    // If we are monitoring this server we will create an exclusive reserved socket for that
	    , monitoring: typeof options.monitoring == 'boolean' ? options.monitoring : false
	    // High availability monitoring interval
	    , haInterval: options.haInterval || 10000
	    // wireProtocolHandler methods
	    , wireProtocolHandler: options.wireProtocolHandler || new PreTwoSixWireProtocolSupport()
	    // Factory overrides
	    , Cursor: options.cursorFactory || BasicCursor
	    // BSON Parser, ensure we have a single instance
	    , bsonInstance: bsonInstance
	    // Contains the inquireServerState timeout reference
	    , inquireServerStateTimeout: null
	    // Pick the right bson parser
	    , bson: options.bson ? options.bson : bsonInstance
	    // Internal connection pool
	    , pool: null
	    // Is master latency
	    , isMasterLatencyMS: 0
	    // Is the server in a topology
	    , inTopology: typeof options.inTopology == 'boolean' ? options.inTopology : false
	    // Server details
	    , serverDetails: {
	        host: options.host
	      , port: options.port
	      , name: options.port ? f("%s:%s", options.host, options.port) : options.host
	    }
	    // Current server description
	    , serverDescription: null
	    // Current topology description
	    , topologyDescription: null
	  }
	
	  // Create hash method
	  var hash = crypto.createHash('sha1');
	  hash.update(f('%s:%s', this.host, this.port));
	
	  // Create a hash name
	  this.hashedName = hash.digest('hex');
	
	  // Reference state
	  var s = this.s;
	
	  // Add bson parser to options
	  options.bson = s.bson;
	
	  // Set error properties
	  getProperty(this, 'name', 'name', s.serverDetails, {});
	  getProperty(this, 'bson', 'bson', s.options, {});
	  getProperty(this, 'wireProtocolHandler', 'wireProtocolHandler', s.options, {});
	  getSingleProperty(this, 'id', s.id);
	
	  // If we do not have an inherited authorization mechanism
	  if(!options.authProviders) {
	    this.addAuthProvider('mongocr', new MongoCR());
	    this.addAuthProvider('x509', new X509());
	    this.addAuthProvider('plain', new Plain());
	    this.addAuthProvider('gssapi', new GSSAPI());
	    this.addAuthProvider('sspi', new SSPI());
	    this.addAuthProvider('scram-sha-1', new ScramSHA1());
	  }
	}
	
	inherits(Server, EventEmitter);
	
	var getPreviousDescription = function(self) {
	  if(!self.s.serverDescription) {
	    self.s.serverDescription = {
	      address: self.name,
	      arbiters: [], hosts: [], passives: [], type: 'Unknown'
	    }
	  }
	
	  return self.s.serverDescription;
	}
	
	var emitServerDescriptionChanged = function(self, description) {
	  if(self.listeners('serverDescriptionChanged').length > 0) {
	    // Emit the server description changed events
	    self.emit('serverDescriptionChanged', {
	      topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.s.id, address: self.name,
	      previousDescription: getPreviousDescription(self),
	      newDescription: description
	    });
	
	    self.s.serverDescription = description;
	  }
	}
	
	var getPreviousTopologyDescription = function(self) {
	  if(!self.s.topologyDescription) {
	    self.s.topologyDescription = {
	      topologyType: 'Unknown',
	      servers: [{
	        address: self.name, arbiters: [], hosts: [], passives: [], type: 'Unknown'
	      }]
	    }
	  }
	
	  return self.s.topologyDescription;
	}
	
	var emitTopologyDescriptionChanged = function(self, description) {
	  if(self.listeners('topologyDescriptionChanged').length > 0) {
	    // Emit the server description changed events
	    self.emit('topologyDescriptionChanged', {
	      topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.s.id, address: self.name,
	      previousDescription: getPreviousTopologyDescription(self),
	      newDescription: description
	    });
	
	    self.s.serverDescription = description;
	  }
	}
	
	/**
	 * Emit event if it exists
	 * @method
	 */
	function emitSDAMEvent(self, event, description) {
	  if(self.listeners(event).length > 0) {
	    self.emit(event, description);
	  }
	}
	
	/**
	 * Get the server description
	 * @method
	 * @return {object}
	*/
	Server.prototype.getDescription = function() {
	  var ismaster = this.s.ismaster || {};
	  var description = {
	    type: getTopologyType(this),
	    address: this.name,
	  };
	
	  // Add fields if available
	  if(ismaster.hosts) description.hosts = ismaster.hosts;
	  if(ismaster.arbiters) description.arbiters = ismaster.arbiters;
	  if(ismaster.passives) description.passives = ismaster.passives;
	  if(ismaster.setName) description.setName = ismaster.setName;
	  return description;
	}
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} type Type of BSON parser to use (c++ or js)
	 */
	Server.prototype.setBSONParserType = function(type) {
	  var nBSON = null;
	
	  if(type == 'c++') {
	    nBSON = __webpack_require__(134).native().BSON;
	  } else if(type == 'js') {
	    nBSON = __webpack_require__(134).pure().BSON;
	  } else {
	    throw new MongoError(f("% parser not supported", type));
	  }
	
	  this.s.options.bson = new nBSON(bsonTypes);
	}
	
	/**
	 * Returns the last known ismaster document for this server
	 * @method
	 * @return {object}
	 */
	Server.prototype.lastIsMaster = function() {
	  return this.s.ismaster;
	}
	
	/**
	 * Returns the last known ismaster response latency
	 * @method
	 * @return {object}
	 */
	Server.prototype.isMasterLatencyMS = function() {
	  return this.s.isMasterLatencyMS;
	}
	
	/**
	 * Initiate server connect
	 * @method
	 */
	Server.prototype.connect = function(_options) {
	  var self = this;
	  // Set server specific settings
	  _options = _options || {}
	  // Set the promotion
	  if(typeof _options.promoteLongs == 'boolean')  {
	    self.s.options.promoteLongs = _options.promoteLongs;
	  }
	
	  // Destroy existing pool connections if connection called
	  // Multiple times
	  if(self.s.pool) {
	    self.s.pool.destroy();
	  }
	
	  // Set the state to connection
	  self.s.state = CONNECTING;
	
	  // Create a new connection pool
	  self.s.options.messageHandler = messageHandler(self, self.s);
	  self.s.pool = new Pool(self.s.options);
	
	  // Add all the event handlers
	  self.s.pool.on('timeout', timeoutHandler(self, self.s));
	  self.s.pool.on('close', closeHandler(self, self.s));
	  self.s.pool.once('error', self.s.inTopology ? errorHandler(self, self.s) : reconnectErrorHandler(self, self.s));
	  self.s.pool.once('connect', connectHandler(self, self.s));
	  self.s.pool.on('parseError', fatalErrorHandler(self, self.s));
	
	  // Emit toplogy opening event if not in topology
	  if(!self.s.inTopology) {
	    this.emit('topologyOpening', { topologyId: this.s.id });
	  }
	
	  // Emit opening server event
	  self.emit('serverOpening', {
	    topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.s.id, address: self.name
	  });
	
	  //
	  // Handle new connections
	  self.s.pool.on('connection', function(connection) {
	    // No auth handler used, return the connection
	    var keys = Object.keys(self.s.authProviders);
	    if(keys.length == 0) {
	      return self.s.pool.connectionAvailable(connection);
	    }
	
	    // Get all connections
	    var connections = [connection];
	    // Execute all providers
	    var count = keys.length;
	
	    // Iterate over all auth methods
	    for(var i = 0; i < keys.length; i++) {
	      // reauthenticate the connection
	      self.s.authProviders[keys[i]].reauthenticate(self, connections, function(err, r) {
	        count = count - 1;
	
	        // We are done, Make the connection available
	        if(count == 0) {
	          return self.s.pool.connectionAvailable(connection);
	        }
	      });
	    }
	  });
	
	  // Connect the pool
	  self.s.pool.connect();
	}
	
	var getTopologyType = function(self, ismaster) {
	  if(!ismaster) {
	    ismaster = self.s.ismaster;
	  }
	
	  if(!ismaster) return 'Unknown';
	  if(ismaster.ismaster && !ismaster.hosts) return 'Standalone';
	  if(ismaster.ismaster && ismaster.msg == 'isdbgrid') return 'Mongos';
	  if(ismaster.ismaster) return 'RSPrimary';
	  if(ismaster.secondary) return 'RSSecondary';
	  if(ismaster.arbiterOnly) return 'RSArbiter';
	  return 'Unknown';
	}
	
	var changedIsMaster = function(self, currentIsmaster, ismaster) {
	  var currentType = getTopologyType(self, currentIsmaster);
	  var newType = getTopologyType(self, ismaster);
	  if(newType != currentType) return true;
	  return false;
	}
	
	var inquireServerState = function(self) {
	  return function() {
	    if(self.s.state == DESTROYED) return;
	    // Record response time
	    var start = new Date().getTime();
	
	    // emitSDAMEvent
	    emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: self.name });
	
	    // Attempt to execute ismaster command
	    self.command('admin.$cmd', { ismaster:true },  { monitoring:true }, function(err, r) {
	      if(!err) {
	        // Legacy event sender
	        self.emit('ismaster', r, self);
	
	        // Calculate latencyMS
	        var latencyMS = new Date().getTime() - start;
	
	        // Server heart beat event
	        emitSDAMEvent(self, 'serverHeartbeatSucceeded', { durationMS: latencyMS, reply: r.result, connectionId: self.name });
	
	        // Did the server change
	        if(changedIsMaster(self, self.s.ismaster, r.result)) {
	          // Emit server description changed if something listening
	          emitServerDescriptionChanged(self, {
	            address: self.name, arbiters: [], hosts: [], passives: [], type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)
	          });
	        }
	
	        // Updat ismaster view
	        self.s.ismaster = r.result;
	
	        // Set server response time
	        self.s.isMasterLatencyMS = latencyMS;
	      } else {
	        emitSDAMEvent(self, 'serverHearbeatFailed', { durationMS: latencyMS, failure: err, connectionId: self.name });
	      }
	
	      // Perform another sweep
	      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);
	    });
	  };
	}
	
	/**
	 * Unref all connections belong to this server
	 * @method
	 */
	Server.prototype.unref = function() {
	  this.s.pool.unref();
	}
	
	/**
	 * Destroy the server connection
	 * @method
	 */
	Server.prototype.destroy = function(emitClose, emitDestroy) {
	  var self = this;
	  if(self.s.logger.isDebug()) self.s.logger.debug(f('destroy called on server %s', self.name));
	  // If we already destroyed ignore
	  if(self.s.state == DESTROYED) return;
	
	  // Do we have a inquireServerState running
	  if(this.s.inquireServerStateTimeout) {
	    clearTimeout(this.s.inquireServerStateTimeout);
	  }
	
	  // Emit close
	  if(emitClose && self.listeners('close').length > 0) {
	    self.emit('close', null, self);
	  }
	
	  // Emit opening server event
	  if(self.listeners('serverClosed').length > 0) self.emit('serverClosed', {
	    topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.s.id, address: self.name
	  });
	
	  // Emit toplogy opening event if not in topology
	  if(self.listeners('topologyClosed').length > 0 && !self.s.inTopology) {
	    self.emit('topologyClosed', { topologyId: self.s.id });
	  }
	
	  // Emit destroy event
	  if(emitDestroy) self.emit('destroy', self);
	  // Set state as destroyed
	  self.s.state = DESTROYED;
	  // Close the pool
	  if(self.s.pool) self.s.pool.destroy();
	  // Flush out all the callbacks
	  if(self.s.callbacks) self.s.callbacks.flush(new MongoError(f("server %s sockets closed", self.name)));
	}
	
	/**
	 * Figure out if the server is connected
	 * @method
	 * @return {boolean}
	 */
	Server.prototype.isConnected = function() {
	  var self = this;
	  if(self.s.pool) return self.s.pool.isConnected();
	  return false;
	}
	
	/**
	 * Figure out if the server instance was destroyed by calling destroy
	 * @method
	 * @return {boolean}
	 */
	Server.prototype.isDestroyed = function() {
	  return this.s.state == DESTROYED;
	}
	
	var executeSingleOperation = function(self, ns, cmd, queryOptions, options, onAll, callback) {
	  // Create a query instance
	  var query = new Query(self.s.bson, ns, cmd, queryOptions);
	  // Set slave OK
	  query.slaveOk = slaveOk(options.readPreference);
	
	  // Notify query start to any read Preference strategies
	  if(self.s.readPreferenceStrategies != null) {
	    notifyStrategies(self, self.s, 'startOperation', [self, query, new Date()]);
	  }
	
	  // Raw BSON response
	  var raw = typeof options.raw == 'boolean' ? options.raw : false;
	  // Do not promote longs
	  var promoteLongs = typeof options.promoteLongs == 'boolean' ? options.promoteLongs : true;
	  // Monitoring
	  var monitoring = typeof options.monitoring == 'boolean' ? options.monitoring : false;
	
	  // Execute multiple queries
	  if(onAll) {
	    var connections = self.s.pool.getAll();
	    var total = connections.length;
	    // We have an error
	    var error = null;
	    // Execute on all connections
	    for(var i = 0; i < connections.length; i++) {
	      // Command callback
	      var commandCallback = function(_connection) {
	        return function(err, result) {
	          if(err) error = err;
	          total = total - 1;
	
	          // Done
	          if(total == 0) {
	            // Notify end of command
	            notifyStrategies(self, self.s, 'endOperation', [self, error, result, new Date()]);
	            if(error) return callback(MongoError.create(error));
	
	            // Add the connection details
	            result.hashedName = _connection.hashedName;
	
	            // Execute callback, catch and rethrow if needed
	            try {
	              callback(null, new CommandResult(options.fullResult ? result : result.documents[0], connections));
	            } catch(err) {
	              process.nextTick(function() { throw err});
	            }
	          }
	        }
	      };
	
	      try {
	        query.incRequestId();
	        connections[i].write(query.toBin());
	      } catch(err) {
	        total = total - 1;
	        if(total == 0) return callback(MongoError.create(err));
	      }
	
	      // Return raw BSON docs
	      if(raw) {
	        commandCallback.raw = true;
	      }
	
	      // Add promote long
	      commandCallback.promoteLongs = promoteLongs;
	
	      // Add monitoring
	      commandCallback.monitoring = monitoring;
	
	      // Set the executed connection on the callback
	      commandCallback.connection = connections[i];
	
	      // Register the callback
	      self.s.callbacks.register(query.requestId, commandCallback(connections[i]));
	    }
	
	    return;
	  }
	
	  // Command callback
	  var commandCallback = function(err, result) {
	    // Notify end of command
	    notifyStrategies(self, self.s, 'endOperation', [self, err, result, new Date()]);
	    if(err) return callback(err);
	
	    if(result.documents[0]['$err']
	      || result.documents[0]['errmsg']
	      || result.documents[0]['err']
	      || result.documents[0]['code']) return callback(MongoError.create(result.documents[0]));
	
	      // Add the connection details
	      result.hashedName = result.connection.hashedName;
	
	      // Execute callback, catch and rethrow if needed
	      try {
	        callback(null, new CommandResult(options.fullResult ? result : result.documents[0], result.connection));
	      } catch(err) {
	        process.nextTick(function() { throw err});
	      }
	  };
	
	  try {
	    // Add monitoring
	    commandCallback.monitoring = monitoring;
	    // Write the query out to the passed in connection or use the pool
	    // Passed in connections are used for authentication mechanisms
	    if(options.connection) {
	      // Add the reference to the connection to the callback so
	      // we can flush only the affected operations
	      commandCallback.connection = options.connection;
	      commandCallback.noRelease = true;
	
	      // Write out the command
	      options.connection.write(query.toBin());
	    } else {
	      self.s.pool.write(query.toBin(), commandCallback, options);
	    }
	
	  } catch(err) {
	    return callback(MongoError.create(err));
	  }
	
	  // Return raw BSON docs
	  if(raw) commandCallback.raw = true;
	  // Promote long setting
	  commandCallback.promoteLongs = promoteLongs;
	
	  // Register the callback
	  self.s.callbacks.register(query.requestId, commandCallback);
	}
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {object} cmd The command hash
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.
	 * @param {opResultCallback} callback A callback function
	 */
	Server.prototype.command = function(ns, cmd, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  var self = this;
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Ensure we have no options
	  options = options || {};
	
	  // Do we have a read Preference it need to be of type ReadPreference
	  if(options.readPreference && !(options.readPreference instanceof ReadPreference)) {
	    throw new Error("readPreference must be an instance of ReadPreference");
	  }
	
	  // Debug log
	  if(self.s.logger.isDebug()) self.s.logger.debug(f('executing command [%s] against %s', JSON.stringify({
	    ns: ns, cmd: cmd, options: debugOptions(debugFields, options)
	  }), self.name));
	
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!self.isConnected() && self.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return self.s.disconnectHandler.add('command', ns, cmd, options, callback);
	  }
	
	  // If we have no connection error
	  if(!self.s.pool.isConnected()) {
	    return callback(new MongoError(f("no connection available to server %s", self.name)));
	  }
	
	  // Execute on all connections
	  var onAll = typeof options.onAll == 'boolean' ? options.onAll : false;
	
	  // Check keys
	  var checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys: false;
	
	  // Serialize function
	  var serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
	
	  // Ignore undefined values
	  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
	
	  // Raw BSON response
	  var raw = typeof options.raw == 'boolean' ? options.raw : false;
	
	  // Query options
	  var queryOptions = {
	    numberToSkip: 0, numberToReturn: -1, checkKeys: checkKeys
	  };
	
	  // Set up the serialize functions and ignore undefined
	  if(serializeFunctions) queryOptions.serializeFunctions = serializeFunctions;
	  if(ignoreUndefined) queryOptions.ignoreUndefined = ignoreUndefined;
	
	  // Single operation execution
	  executeSingleOperation(self, ns, cmd, queryOptions, options, onAll, callback);
	}
	
	/**
	 * Insert one or more documents
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of documents to insert
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Server.prototype.insert = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  var self = this;
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!self.isConnected() && self.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return self.s.disconnectHandler.add('insert', ns, ops, options, callback);
	  }
	
	  // Setup the docs as an array
	  ops = Array.isArray(ops) ? ops : [ops];
	  // Execute write
	  return self.s.wireProtocolHandler.insert(self, self.s.ismaster, ns, self.s.bson, self.s.pool, self.s.callbacks, ops, options, callback);
	}
	
	/**
	 * Perform one or more update operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of updates
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Server.prototype.update = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  var self = this;
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!self.isConnected() && self.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return self.s.disconnectHandler.add('update', ns, ops, options, callback);
	  }
	
	  // Setup the docs as an array
	  ops = Array.isArray(ops) ? ops : [ops];
	
	  // Execute write
	  return self.s.wireProtocolHandler.update(self, self.s.ismaster, ns, self.s.bson, self.s.pool, self.s.callbacks, ops, options, callback);
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of removes
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Server.prototype.remove = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  var self = this;
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!self.isConnected() && self.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return self.s.disconnectHandler.add('remove', ns, ops, options, callback);
	  }
	
	  // Setup the docs as an array
	  ops = Array.isArray(ops) ? ops : [ops];
	  // Execute write
	  return self.s.wireProtocolHandler.remove(self, self.s.ismaster, ns, self.s.bson, self.s.pool, self.s.callbacks, ops, options, callback);
	}
	
	/**
	 * Authenticate using a specified mechanism
	 * @method
	 * @param {string} mechanism The Auth mechanism we are invoking
	 * @param {string} db The db we are invoking the mechanism against
	 * @param {...object} param Parameters for the specific mechanism
	 * @param {authResultCallback} callback A callback function
	 */
	Server.prototype.auth = function(mechanism, db) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  var callback = args.pop();
	
	  // If we don't have the mechanism fail
	  if(self.s.authProviders[mechanism] == null && mechanism != 'default')
	    throw new MongoError(f("auth provider %s does not exist", mechanism));
	
	  // If we have the default mechanism we pick mechanism based on the wire
	  // protocol max version. If it's >= 3 then scram-sha1 otherwise mongodb-cr
	  if(mechanism == 'default' && self.s.ismaster && self.s.ismaster.maxWireVersion >= 3) {
	    mechanism = 'scram-sha-1';
	  } else if(mechanism == 'default') {
	    mechanism = 'mongocr';
	  }
	
	  // Get all available connections
	  var connections = self.s.pool.getAll();
	
	  // Actual arguments
	  var finalArguments = [self, connections, db].concat(args.slice(0)).concat([function(err, r) {
	    if(err) return callback(err);
	    if(!r) return callback(new MongoError('could not authenticate'));
	    callback(null, new Session({}, self));
	  }]);
	
	  // Let's invoke the auth mechanism
	  self.s.authProviders[mechanism].auth.apply(self.s.authProviders[mechanism], finalArguments);
	}
	
	//
	// Plugin methods
	//
	
	/**
	 * Add custom read preference strategy
	 * @method
	 * @param {string} name Name of the read preference strategy
	 * @param {object} strategy Strategy object instance
	 */
	Server.prototype.addReadPreferenceStrategy = function(name, strategy) {
	  var self = this;
	  if(self.s.readPreferenceStrategies == null) self.s.readPreferenceStrategies = {};
	  self.s.readPreferenceStrategies[name] = strategy;
	}
	
	/**
	 * Add custom authentication mechanism
	 * @method
	 * @param {string} name Name of the authentication mechanism
	 * @param {object} provider Authentication object instance
	 */
	Server.prototype.addAuthProvider = function(name, provider) {
	  var self = this;
	  self.s.authProviders[name] = provider;
	}
	
	/**
	 * Compare two server instances
	 * @method
	 * @param {Server} server Server to compare equality against
	 * @return {boolean}
	 */
	Server.prototype.equals = function(server) {
	  if(typeof server == 'string') return server == this.name;
	
	  if(server && server.name) {
	    return server.name == this.name;
	  }
	
	  return false;
	}
	
	/**
	 * All raw connections
	 * @method
	 * @return {Connection[]}
	 */
	Server.prototype.connections = function() {
	  return this.s.pool.getAll();
	}
	
	/**
	 * Get server
	 * @method
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @return {Server}
	 */
	Server.prototype.getServer = function(options) {
	  return this;
	}
	
	/**
	 * Get correct server for a given connection
	 * @method
	 * @param {Connection} [connection] A Connection showing a current server
	 * @return {Server}
	 */
	Server.prototype.getServerFrom = function(connection) {
	  return this;
	}
	
	/**
	 * Get connection
	 * @method
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @return {Connection}
	 */
	Server.prototype.getConnection = function(options) {
	  return this.s.pool.get();
	}
	
	/**
	 * Get callbacks object
	 * @method
	 * @return {Callbacks}
	 */
	Server.prototype.getCallbacks = function() {
	  return this.s.callbacks;
	}
	
	/**
	 * Name of BSON parser currently used
	 * @method
	 * @return {string}
	 */
	Server.prototype.parserType = function() {
	  var s = this.s;
	  if(s.options.bson.serialize.toString().indexOf('[native code]') != -1)
	    return 'c++';
	  return 'js';
	}
	
	// // Command
	// {
	//     find: ns
	//   , query: <object>
	//   , limit: <n>
	//   , fields: <object>
	//   , skip: <n>
	//   , hint: <string>
	//   , explain: <boolean>
	//   , snapshot: <boolean>
	//   , batchSize: <n>
	//   , returnKey: <boolean>
	//   , maxScan: <n>
	//   , min: <n>
	//   , max: <n>
	//   , showDiskLoc: <boolean>
	//   , comment: <string>
	//   , maxTimeMS: <n>
	//   , raw: <boolean>
	//   , readPreference: <ReadPreference>
	//   , tailable: <boolean>
	//   , oplogReplay: <boolean>
	//   , noCursorTimeout: <boolean>
	//   , awaitdata: <boolean>
	//   , exhaust: <boolean>
	//   , partial: <boolean>
	// }
	
	/**
	 * Get a new cursor
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {{object}|{Long}} cmd Can be either a command returning a cursor or a cursorId
	 * @param {object} [options.batchSize=0] Batchsize for the operation
	 * @param {array} [options.documents=[]] Initial documents list for cursor
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Server.prototype.cursor = function(ns, cmd, cursorOptions) {
	  var s = this.s;
	  cursorOptions = cursorOptions || {};
	  // Set up final cursor type
	  var FinalCursor = cursorOptions.cursorFactory || s.Cursor;
	  // Return the cursor
	  return new FinalCursor(s.bson, ns, cmd, cursorOptions, this, s.options);
	}
	
	/**
	 * A server connect event, used to verify that the connection is up and running
	 *
	 * @event Server#connect
	 * @type {Server}
	 */
	
	/**
	 * The server connection closed, all pool connections closed
	 *
	 * @event Server#close
	 * @type {Server}
	 */
	
	/**
	 * The server connection caused an error, all pool connections closed
	 *
	 * @event Server#error
	 * @type {Server}
	 */
	
	/**
	 * The server connection timed out, all pool connections closed
	 *
	 * @event Server#timeout
	 * @type {Server}
	 */
	
	/**
	 * The driver experienced an invalid message, all pool connections closed
	 *
	 * @event Server#parseError
	 * @type {Server}
	 */
	
	/**
	 * The server reestablished the connection
	 *
	 * @event Server#reconnect
	 * @type {Server}
	 */
	
	/**
	 * This is an insert result callback
	 *
	 * @callback opResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {CommandResult} command result
	 */
	
	/**
	 * This is an authentication result callback
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {Session} an authenticated session
	 */
	
	module.exports = Server;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	// Set property function
	var setProperty = function(obj, prop, flag, values) {
	  Object.defineProperty(obj, prop.name, {
	      enumerable:true,
	      set: function(value) {
	        if(typeof value != 'boolean') throw new Error(f("%s required a boolean", prop.name));
	        // Flip the bit to 1
	        if(value == true) values.flags |= flag;
	        // Flip the bit to 0 if it's set, otherwise ignore
	        if(value == false && (values.flags & flag) == flag) values.flags ^= flag;
	        prop.value = value;
	      }
	    , get: function() { return prop.value; }
	  });
	}
	
	// Set property function
	var getProperty = function(obj, propName, fieldName, values, func) {
	  Object.defineProperty(obj, propName, {
	    enumerable:true,
	    get: function() {
	      // Not parsed yet, parse it
	      if(values[fieldName] == null && obj.isParsed && !obj.isParsed()) {
	        obj.parse();
	      }
	
	      // Do we have a post processing function
	      if(typeof func == 'function') return func(values[fieldName]);
	      // Return raw value
	      return values[fieldName];
	    }
	  });
	}
	
	// Set simple property
	var getSingleProperty = function(obj, name, value) {
	  Object.defineProperty(obj, name, {
	    enumerable:true,
	    get: function() {
	      return value
	    }
	  });
	}
	
	// Shallow copy
	var copy = function(fObj, tObj) {
	  tObj = tObj || {};
	  for(var name in fObj) tObj[name] = fObj[name];
	  return tObj;
	}
	
	var debugOptions = function(debugFields, options) {
	  var finaloptions = {};
	  debugFields.forEach(function(n) {
	    finaloptions[n] = options[n];
	  });
	
	  return finaloptions;
	}
	
	/**
	 * @ignore
	 */
	var bindToCurrentDomain = function(callback) {
	  var domain = process.domain;
	  if(domain == null || callback == null) return callback;
	  var boundCallback = domain.bind(callback);
	
	  // Copy all fields over
	  for(var name in callback) {
	    boundCallback[name] = callback[name];
	  }
	
	  // Return the bound callback
	  return boundCallback;
	}
	
	exports.setProperty = setProperty;
	exports.getProperty = getProperty;
	exports.getSingleProperty = getSingleProperty;
	exports.copy = copy;
	exports.bindToCurrentDomain = bindToCurrentDomain;
	exports.debugOptions = debugOptions;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var inherits = __webpack_require__(77).inherits
	  , EventEmitter = __webpack_require__(3).EventEmitter
	  , Connection = __webpack_require__(161)
	  , Query = __webpack_require__(162).Query
	  , Logger = __webpack_require__(163)
	  , f = __webpack_require__(77).format;
	
	var DISCONNECTED = 'disconnected';
	var CONNECTING = 'connecting';
	var CONNECTED = 'connected';
	var DESTROYED = 'destroyed';
	
	var _id = 0;
	
	/**
	 * Creates a new Pool instance
	 * @class
	 * @param {string} options.host The server host
	 * @param {number} options.port The server port
	 * @param {number} [options.size=1] Max server connection pool size
	 * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
	 * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.connectionTimeout=0] TCP Connection timeout setting
	 * @param {number} [options.socketTimeout=0] TCP Socket timeout setting
	 * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed
	 * @param {boolean} [options.ssl=false] Use SSL for connection
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {Buffer} [options.ca] SSL Certificate store binary buffer
	 * @param {Buffer} [options.cert] SSL Certificate binary buffer
	 * @param {Buffer} [options.key] SSL Key file binary buffer
	 * @param {string} [options.passPhrase] SSL Certificate pass phrase
	 * @param {boolean} [options.rejectUnauthorized=false] Reject unauthorized server certificates
	 * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
	 * @fires Pool#connect
	 * @fires Pool#close
	 * @fires Pool#error
	 * @fires Pool#timeout
	 * @fires Pool#parseError
	 * @return {Pool} A cursor instance
	 */
	var Pool = function(options) {
	  var self = this;
	  // Add event listener
	  EventEmitter.call(this);
	  // Set empty if no options passed
	  this.options = options || {};
	  this.size = typeof options.size == 'number' && !isNaN(options.size) ? options.size : 5;
	  this.waitMS = typeof options.waitMS == 'number' && !isNaN(options.waitMS) ? options.waitMS : 1000;
	
	  // Save host and port
	  this.host = options.host;
	  this.port = options.port;
	
	  // Message handler
	  this.messageHandler = options.messageHandler;
	  // No bson parser passed in
	  if(!options.bson) throw new Error("must pass in valid bson parser");
	  // // Contains all connections
	  // this.connections = [];
	  // Contains all available connections
	  this.availableConnections = [];
	  this.inUseConnections = [];
	  this.newConnections = [];
	  this.connectingConnections = [];
	  // Current status of the pool
	  this.state = DISCONNECTED;
	  // Round robin index
	  this.index = 0;
	  this.dead = false;
	  // Logger instance
	  this.logger = Logger('Pool', options);
	  // Pool id
	  this.id = _id++;
	  // Grouping tag used for debugging purposes
	  this.tag = options.tag;
	  // Operation work queue
	  this.queue = [];
	  // Currently executing
	  this.executing = false;
	  // Unref pool
	  this.unreference = false;
	}
	
	inherits(Pool, EventEmitter);
	
	var removeConnection = function(self, connection) {
	  // Destroy connection
	  connection.destroy();
	
	  // Remove connection method
	  var remove = function(connections) {
	    for(var i = 0; i < connections.length; i++) {
	      if(connections[i] === connection) {
	        connections.splice(i, 1);
	        return true;
	      }
	    }
	  }
	
	  // Clean out the connection
	  if(remove(self.availableConnections)) return;
	  if(remove(self.inUseConnections)) return;
	  if(remove(self.newConnections)) return;
	  if(remove(self.connectingConnections)) return;
	}
	
	var errorHandler = function(self) {
	  return function(err, connection) {
	    if(self.logger.isDebug()) self.logger.debug(f('pool [%s] errored out [%s] with connection [%s]', this.dead, JSON.stringify(err), JSON.stringify(connection)));
	    // Destroy the connection
	    connection.destroy();
	    // Remove the connection
	    removeConnection(self, connection);
	    // Emit error
	    if(self.listeners('error').length > 0) {
	      self.emit('error', err, connection);
	    }
	  }
	}
	
	var timeoutHandler = function(self) {
	  return function(err, connection) {
	    if(self.logger.isDebug()) self.logger.debug(f('pool [%s] timed out [%s] with connection [%s]', this.dead, JSON.stringify(err), JSON.stringify(connection)));
	    // Destroy the connection
	    connection.destroy();
	    // Remove the connection
	    removeConnection(self, connection);
	    // Emit connection timeout to server instance
	    self.emit('timeout', err, connection);
	  }
	}
	
	var closeHandler = function(self) {
	  return function(err, connection) {
	    if(self.logger.isDebug()) self.logger.debug(f('pool [%s] closed [%s] with connection [%s]', this.dead, JSON.stringify(err), JSON.stringify(connection)));
	    // Destroy the connection
	    connection.destroy();
	    // Remove the connection
	    removeConnection(self, connection);
	    // Emit connection close to server instance
	    self.emit('close', err, connection);
	  }
	}
	
	var parseErrorHandler = function(self) {
	  return function(err, connection) {
	    if(self.logger.isDebug()) self.logger.debug(f('pool [%s] errored out [%s] with connection [%s]', this.dead, JSON.stringify(err), JSON.stringify(connection)));
	    // Destroy the connection
	    connection.destroy();
	    // Remove the connection
	    removeConnection(self, connection);
	    // Emit error to server instance
	    self.emit('parseError', err, connection);
	  }
	}
	
	/**
	 * Unref the pool
	 * @method
	 */
	Pool.prototype.unref = function() {
	  this.unreference = true;
	  this.getAll().forEach(function(c) {
	    c.unref();
	  });
	}
	
	/**
	 * Destroy pool
	 * @method
	 */
	Pool.prototype.destroy = function() {
	  this.state = DESTROYED;
	  // Set dead
	  this.dead = true;
	  // Get all the connections
	  var connections = this.getAll();
	  // Destroy all the connections
	  connections.forEach(function(c) {
	    // Destroy all event emitters
	    ["close", "message", "error", "timeout", "parseError", "connect"].forEach(function(e) {
	      c.removeAllListeners(e);
	    });
	
	    // Destroy the connection
	    c.destroy();
	  });
	
	  // Wipe out all connection arrays
	  this.availableConnections = [];
	  this.connectingConnections = [];
	  this.inUseConnections = [];
	  this.newConnections = [];
	}
	
	/**
	 * Connect pool
	 * @method
	 */
	Pool.prototype.connect = function(_options) {
	  var self = this;
	  // Set to connecting
	  this.state = CONNECTING
	  // No dead
	  this.dead = false;
	
	  // Set the message handler
	  self.options.messageHandler = self.messageHandler;
	  // Create a new connection
	  var connection = new Connection(self.options);
	
	  // Delete all the event handlers
	  ['close', 'error', 'timeout', 'parseError', 'connect'].forEach(function(x) {
	    connection.removeAllListeners(x);
	  })
	
	  // Add all handlers
	  connection.once('close', closeHandler(self));
	  connection.once('error', errorHandler(self));
	  connection.once('timeout', timeoutHandler(self));
	  connection.once('parseError', parseErrorHandler(self));
	  connection.on('connect', function(connection) {
	    if(self.state == 'DESTROYED') {
	      return connection.destroy();
	    }
	
	    // Add the connection to the list of available connections
	    self.availableConnections.push(connection);
	    // Emit connected event
	    self.emit("connect", self);
	  });
	
	  // Start connection
	  connection.connect(_options);
	}
	
	var _createConnection = function(self) {
	  self.options.messageHandler = self.messageHandler;
	  var connection = new Connection(self.options);
	
	  // Push the connection
	  self.connectingConnections.push(connection);
	
	  // Handle any errors
	  var tempErrorHandler = function(_connection) {
	    return function(err) {
	      _connection.destroy();
	    }
	  }
	
	  // All event handlers
	  var handlers = ["close", "message", "error", "timeout", "parseError", "connect"];
	
	  // Handle successful connection
	  var tempConnectHandler = function(_connection) {
	    return function() {
	      if(self.state == 'DESTROYED') {
	        // Remove the connection from the connectingConnections
	        var index = self.connectingConnections.indexOf(_connection);
	        if(index != -1) {
	          self.connectingConnections.splice(index, 1);
	        }
	
	        return _connection.destroy();
	      }
	
	      // Destroy all event emitters
	      handlers.forEach(function(e) {
	        _connection.removeAllListeners(e);
	      });
	
	      // Add the final handlers
	      _connection.once('close', closeHandler(self));
	      _connection.once('error', errorHandler(self));
	      _connection.once('timeout', timeoutHandler(self));
	      _connection.once('parseError', parseErrorHandler(self));
	
	      // Remove the connection from the connectingConnections
	      var index = self.connectingConnections.indexOf(_connection);
	      if(index != -1) {
	        self.connectingConnections.splice(index, 1);
	      }
	
	      // Add to queue of new connection
	      self.newConnections.push(_connection);
	      // Emit connection to server instance
	      // alowing it to apply any needed authentication
	      self.emit('connection', _connection);
	
	      // Execute any work waiting
	      _execute(self)();
	    }
	  }
	
	  // Add all handlers
	  connection.once('close', tempErrorHandler(connection));
	  connection.once('error', tempErrorHandler(connection));
	  connection.once('timeout', tempErrorHandler(connection));
	  connection.once('parseError', tempErrorHandler(connection));
	  connection.once('connect', tempConnectHandler(connection));
	
	  // Start connection
	  connection.connect();
	}
	
	var _execute = function(self) {
	  return function() {
	    if(self.state == 'DESTROYED') return;
	    // Already executing, skip
	    if(self.executing) return;
	    // Set pool as executing
	    self.executing = true;
	
	    // Total availble connections
	    var totalConnections = self.availableConnections.length
	      + self.connectingConnections.length
	      + self.inUseConnections.length
	      + self.newConnections.length;
	
	    // Have we not reached the max connection size yet
	    if(self.availableConnections.length == 0
	      && self.connectingConnections.length == 0
	      && totalConnections < self.size
	      && self.queue.length > 0) {
	      // Create a new connection
	      _createConnection(self);
	      // Attempt to execute again
	      self.executing = false;
	      return;
	    }
	
	    // Number of ops to do
	    var numberOfOps = self.availableConnections.length > self.queue.length
	      ? self.queue.length : self.availableConnections.length;
	
	    // As long as we have available connections
	    while(true) {
	      // No available connections available
	      if(self.availableConnections.length == 0) break;
	      if(self.queue.length == 0) break;
	
	      // Get a connection
	      var connection = self.availableConnections.pop();
	      if(connection.isConnected()) {
	        var workItem = self.queue.shift();
	
	        // Add connection to callback so we can flush out
	        // only ops for that connection on a socket closure
	        if(workItem.cb) {
	          workItem.cb.connection = connection;
	        }
	
	        // Get actual binary commands
	        var buffer = workItem.buffer;
	
	        // Add connection to workers in flight
	        self.inUseConnections.push(connection);
	
	        if(Array.isArray(buffer)) {
	          for(var i = 0; i < buffer.length; i++) {
	            connection.write(buffer[i]);
	          }
	        } else {
	          connection.write(buffer);
	        }
	
	        // Fire and forgot message
	        if(workItem.immediateRelease) {
	          self.availableConnections.push(connection);
	        }
	      }
	    }
	
	    self.executing = false;
	  }
	}
	
	/**
	 * Write a message to MongoDB
	 * @method
	 * @return {Connection}
	 */
	Pool.prototype.write = function(buffer, cb, options) {
	  // Do we have an operation
	  var operation = {buffer:buffer, cb: cb};
	  // Do we immediately release the connection back to available (fire and forget)
	  if(options && options.immediateRelease) {
	    operation.immediateRelease = true;
	  }
	
	  // Push the operation to the queue of operations in progress
	  this.queue.push(operation);
	  // Attempt to write all buffers out
	  _execute(this)();
	}
	
	/**
	 * Make a passed connection available
	 * @method
	 * @return {Connection}
	 */
	Pool.prototype.connectionAvailable = function(connection) {
	  // Get the connection from the newConnections
	  var index = this.newConnections.indexOf(connection);
	  if(index != -1) {
	    this.newConnections.splice(index, 1);
	  }
	
	  // If it's in the inUseConnections
	  index = this.inUseConnections.indexOf(connection);
	  if(index != -1) {
	    this.inUseConnections.splice(index, 1);
	  }
	
	  // Add the connection to available connections if it's not a monitoring threads
	  if(this.availableConnections.indexOf(connection) == -1) {
	    this.availableConnections.push(connection);
	  }
	
	  // Fire execute loop
	  _execute(this)();
	}
	
	/**
	 * Get a pool connection (round-robin)
	 * @method
	 * @return {Connection}
	 */
	Pool.prototype.get = function(options) {
	  options = options || {};
	
	  // Set the current index
	  this.index = this.index + 1;
	
	  // Get all connections
	  var connections = this.availableConnections.slice(0);
	
	  if(connections.length == 1) {
	    return connections[0];
	  } else {
	    this.index = this.index % connections.length;
	    return connections[this.index];
	  }
	}
	
	/**
	 * Get all pool connections
	 * @method
	 * @return {array}
	 */
	Pool.prototype.getAll = function() {
	  return this.availableConnections
	    .concat(this.inUseConnections)
	    .concat(this.connectingConnections)
	    .concat(this.newConnections);
	}
	
	/**
	 * Is the pool connected
	 * @method
	 * @return {boolean}
	 */
	Pool.prototype.isConnected = function() {
	  // Available connections
	  for(var i = 0; i < this.availableConnections.length; i++) {
	    if(this.availableConnections[i].isConnected()) return true;
	  }
	
	  // inUseConnections
	  for(var i = 0; i < this.inUseConnections.length; i++) {
	    if(this.inUseConnections[i].isConnected()) return true;
	  }
	
	  for(var i = 0; i < this.newConnections.length; i++) {
	    if(this.newConnections[i].isConnected()) return true;
	  }
	
	  return this.state == CONNECTED;
	}
	
	/**
	 * Was the pool destroyed
	 * @method
	 * @return {boolean}
	 */
	Pool.prototype.isDestroyed = function() {
	  return this.state == DESTROYED;
	}
	
	
	/**
	 * A server connect event, used to verify that the connection is up and running
	 *
	 * @event Pool#connect
	 * @type {Pool}
	 */
	
	/**
	 * The server connection closed, all pool connections closed
	 *
	 * @event Pool#close
	 * @type {Pool}
	 */
	
	/**
	 * The server connection caused an error, all pool connections closed
	 *
	 * @event Pool#error
	 * @type {Pool}
	 */
	
	/**
	 * The server connection timed out, all pool connections closed
	 *
	 * @event Pool#timeout
	 * @type {Pool}
	 */
	
	/**
	 * The driver experienced an invalid message, all pool connections closed
	 *
	 * @event Pool#parseError
	 * @type {Pool}
	 */
	
	module.exports = Pool;


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {"use strict";
	
	var inherits = __webpack_require__(77).inherits
	  , EventEmitter = __webpack_require__(3).EventEmitter
	  , net = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"net\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  , tls = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tls\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  , f = __webpack_require__(77).format
	  , crypto = __webpack_require__(70)
	  , getSingleProperty = __webpack_require__(159).getSingleProperty
	  , debugOptions = __webpack_require__(159).debugOptions
	  , Response = __webpack_require__(162).Response
	  , MongoError = __webpack_require__(157)
	  , Logger = __webpack_require__(163);
	
	var _id = 0;
	var debugFields = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay'
	  , 'connectionTimeout', 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'cert'
	  , 'rejectUnauthorized', 'promoteLongs', 'checkServerIdentity'];
	
	/**
	 * Creates a new Connection instance
	 * @class
	 * @param {string} options.host The server host
	 * @param {number} options.port The server port
	 * @param {number} [options.size=5] Server connection pool size
	 * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
	 * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.connectionTimeout=0] TCP Connection timeout setting
	 * @param {number} [options.socketTimeout=0] TCP Socket timeout setting
	 * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed
	 * @param {boolean} [options.ssl=false] Use SSL for connection
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {Buffer} [options.ca] SSL Certificate store binary buffer
	 * @param {Buffer} [options.cert] SSL Certificate binary buffer
	 * @param {Buffer} [options.key] SSL Key file binary buffer
	 * @param {string} [options.passphrase] SSL Certificate pass phrase
	 * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates
	 * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
	 * @fires Connection#connect
	 * @fires Connection#close
	 * @fires Connection#error
	 * @fires Connection#timeout
	 * @fires Connection#parseError
	 * @return {Connection} A cursor instance
	 */
	var Connection = function(options) {
	  // Add event listener
	  EventEmitter.call(this);
	  // Set empty if no options passed
	  this.options = options || {};
	  // Identification information
	  this.id = _id++;
	  // Logger instance
	  this.logger = Logger('Connection', options);
	  // No bson parser passed in
	  if(!options.bson) throw new Error("must pass in valid bson parser");
	  // Get bson parser
	  this.bson = options.bson;
	  // Grouping tag used for debugging purposes
	  this.tag = options.tag;
	  // Message handler
	  this.messageHandler = options.messageHandler;
	
	  // Max BSON message size
	  this.maxBsonMessageSize = options.maxBsonMessageSize || (1024 * 1024 * 16 * 4);
	  // Debug information
	  if(this.logger.isDebug()) this.logger.debug(f('creating connection %s with options [%s]', this.id, JSON.stringify(debugOptions(debugFields, options))));
	
	  // Default options
	  this.port = options.port || 27017;
	  this.host = options.host || 'localhost';
	  this.keepAlive = typeof options.keepAlive == 'boolean' ? options.keepAlive : true;
	  this.keepAliveInitialDelay = options.keepAliveInitialDelay || 0;
	  this.noDelay = typeof options.noDelay == 'boolean' ? options.noDelay : true;
	  this.connectionTimeout = options.connectionTimeout || 0;
	  this.socketTimeout = options.socketTimeout || 0;
	
	  // If connection was destroyed
	  this.destroyed = false;
	
	  // Check if we have a domain socket
	  this.domainSocket = this.host.indexOf('\/') != -1;
	
	  // Serialize commands using function
	  this.singleBufferSerializtion = typeof options.singleBufferSerializtion == 'boolean' ? options.singleBufferSerializtion : true;
	  this.serializationFunction = this.singleBufferSerializtion ? 'toBinUnified' : 'toBin';
	
	  // SSL options
	  this.ca = options.ca || null;
	  this.cert = options.cert || null;
	  this.key = options.key || null;
	  this.passphrase = options.passphrase || null;
	  this.ssl = typeof options.ssl == 'boolean' ? options.ssl : false;
	  this.rejectUnauthorized = typeof options.rejectUnauthorized == 'boolean' ? options.rejectUnauthorized : true;
	  this.checkServerIdentity = typeof options.checkServerIdentity == 'boolean'
	    || typeof options.checkServerIdentity == 'function' ? options.checkServerIdentity : true;
	
	  // If ssl not enabled
	  if(!this.ssl) this.rejectUnauthorized = false;
	
	  // Response options
	  this.responseOptions = {
	    promoteLongs: typeof options.promoteLongs == 'boolean' ?  options.promoteLongs : true
	  }
	
	  // Flushing
	  this.flushing = false;
	  this.queue = [];
	
	  // Internal state
	  this.connection = null;
	  this.writeStream = null;
	
	  // Create hash method
	  var hash = crypto.createHash('sha1');
	  hash.update(f('%s:%s', this.host, this.port));
	
	  // Create a hash name
	  this.hashedName = hash.digest('hex');
	}
	
	inherits(Connection, EventEmitter);
	
	Object.defineProperty(Connection.prototype, 'name', {
	  enumerable:true,
	  get: function() {
	    return this.port ? f("%s:%s", this.host, this.port) : this.host;
	  }
	});
	
	Object.defineProperty(Connection.prototype, 'socketTimeoutMS', {
	  enumerable:true,
	  set: function(value) {
	    if(typeof value != 'number') throw new Error("socketTimeoutMS requires a boolean");
	    // Set the socket timeout
	    this.socketTimeout = value;
	    // Set the socket timeout on the socket
	    this.connection.setTimeout(value);
	  },
	  get: function() { return this.socketTimeout; }
	});
	
	//
	// Connection handlers
	var errorHandler = function(self) {
	  return function(err) {
	    // Debug information
	    if(self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] errored out with [%s]', self.id, self.host, self.port, JSON.stringify(err)));
	    // Emit the error
	    if(self.listeners('error').length > 0) self.emit("error", MongoError.create(err), self);
	  }
	}
	
	var timeoutHandler = function(self) {
	  return function() {
	    // Debug information
	    if(self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] timed out', self.id, self.host, self.port));
	    // Emit timeout error
	    self.emit("timeout"
	      , MongoError.create(f("connection %s to %s:%s timed out", self.id, self.host, self.port))
	      , self);
	  }
	}
	
	var closeHandler = function(self) {
	  return function(hadError) {
	    // Debug information
	    if(self.logger.isDebug()) self.logger.debug(f('connection %s with for [%s:%s] closed', self.id, self.host, self.port));
	    // Emit close event
	    if(!hadError) {
	      self.emit("close"
	        , MongoError.create(f("connection %s to %s:%s closed", self.id, self.host, self.port))
	        , self);
	    }
	  }
	}
	
	var dataHandler = function(self) {
	  return function(data) {
	    // Parse until we are done with the data
	    while(data.length > 0) {
	      // If we still have bytes to read on the current message
	      if(self.bytesRead > 0 && self.sizeOfMessage > 0) {
	        // Calculate the amount of remaining bytes
	        var remainingBytesToRead = self.sizeOfMessage - self.bytesRead;
	        // Check if the current chunk contains the rest of the message
	        if(remainingBytesToRead > data.length) {
	          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)
	          data.copy(self.buffer, self.bytesRead);
	          // Adjust the number of bytes read so it point to the correct index in the buffer
	          self.bytesRead = self.bytesRead + data.length;
	
	          // Reset state of buffer
	          data = new Buffer(0);
	        } else {
	          // Copy the missing part of the data into our current buffer
	          data.copy(self.buffer, self.bytesRead, 0, remainingBytesToRead);
	          // Slice the overflow into a new buffer that we will then re-parse
	          data = data.slice(remainingBytesToRead);
	
	          // Emit current complete message
	          try {
	            var emitBuffer = self.buffer;
	            // Reset state of buffer
	            self.buffer = null;
	            self.sizeOfMessage = 0;
	            self.bytesRead = 0;
	            self.stubBuffer = null;
	            // Emit the buffer
	            self.messageHandler(new Response(self, self.bson, emitBuffer, self.responseOptions), self);
	          } catch(err) {
	            var errorObject = {err:"socketHandler", trace:err, bin:self.buffer, parseState:{
	              sizeOfMessage:self.sizeOfMessage,
	              bytesRead:self.bytesRead,
	              stubBuffer:self.stubBuffer}};
	            // We got a parse Error fire it off then keep going
	            self.emit("parseError", errorObject, self);
	          }
	        }
	      } else {
	        // Stub buffer is kept in case we don't get enough bytes to determine the
	        // size of the message (< 4 bytes)
	        if(self.stubBuffer != null && self.stubBuffer.length > 0) {
	          // If we have enough bytes to determine the message size let's do it
	          if(self.stubBuffer.length + data.length > 4) {
	            // Prepad the data
	            var newData = new Buffer(self.stubBuffer.length + data.length);
	            self.stubBuffer.copy(newData, 0);
	            data.copy(newData, self.stubBuffer.length);
	            // Reassign for parsing
	            data = newData;
	
	            // Reset state of buffer
	            self.buffer = null;
	            self.sizeOfMessage = 0;
	            self.bytesRead = 0;
	            self.stubBuffer = null;
	
	          } else {
	
	            // Add the the bytes to the stub buffer
	            var newStubBuffer = new Buffer(self.stubBuffer.length + data.length);
	            // Copy existing stub buffer
	            self.stubBuffer.copy(newStubBuffer, 0);
	            // Copy missing part of the data
	            data.copy(newStubBuffer, self.stubBuffer.length);
	            // Exit parsing loop
	            data = new Buffer(0);
	          }
	        } else {
	          if(data.length > 4) {
	            // Retrieve the message size
	            // var sizeOfMessage = data.readUInt32LE(0);
	            var sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;
	            // If we have a negative sizeOfMessage emit error and return
	            if(sizeOfMessage < 0 || sizeOfMessage > self.maxBsonMessageSize) {
	              var errorObject = {err:"socketHandler", trace:'', bin:self.buffer, parseState:{
	                sizeOfMessage: sizeOfMessage,
	                bytesRead: self.bytesRead,
	                stubBuffer: self.stubBuffer}};
	              // We got a parse Error fire it off then keep going
	              self.emit("parseError", errorObject, self);
	              return;
	            }
	
	            // Ensure that the size of message is larger than 0 and less than the max allowed
	            if(sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage > data.length) {
	              self.buffer = new Buffer(sizeOfMessage);
	              // Copy all the data into the buffer
	              data.copy(self.buffer, 0);
	              // Update bytes read
	              self.bytesRead = data.length;
	              // Update sizeOfMessage
	              self.sizeOfMessage = sizeOfMessage;
	              // Ensure stub buffer is null
	              self.stubBuffer = null;
	              // Exit parsing loop
	              data = new Buffer(0);
	
	            } else if(sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage == data.length) {
	              try {
	                var emitBuffer = data;
	                // Reset state of buffer
	                self.buffer = null;
	                self.sizeOfMessage = 0;
	                self.bytesRead = 0;
	                self.stubBuffer = null;
	                // Exit parsing loop
	                data = new Buffer(0);
	                // Emit the message
	                self.messageHandler(new Response(self, self.bson, emitBuffer, self.responseOptions), self);
	              } catch (err) {
	                var errorObject = {err:"socketHandler", trace:err, bin:self.buffer, parseState:{
	                  sizeOfMessage:self.sizeOfMessage,
	                  bytesRead:self.bytesRead,
	                  stubBuffer:self.stubBuffer}};
	                // We got a parse Error fire it off then keep going
	                self.emit("parseError", errorObject, self);
	              }
	            } else if(sizeOfMessage <= 4 || sizeOfMessage > self.maxBsonMessageSize) {
	              var errorObject = {err:"socketHandler", trace:null, bin:data, parseState:{
	                sizeOfMessage:sizeOfMessage,
	                bytesRead:0,
	                buffer:null,
	                stubBuffer:null}};
	              // We got a parse Error fire it off then keep going
	              self.emit("parseError", errorObject, self);
	
	              // Clear out the state of the parser
	              self.buffer = null;
	              self.sizeOfMessage = 0;
	              self.bytesRead = 0;
	              self.stubBuffer = null;
	              // Exit parsing loop
	              data = new Buffer(0);
	            } else {
	              var emitBuffer = data.slice(0, sizeOfMessage);
	              // Reset state of buffer
	              self.buffer = null;
	              self.sizeOfMessage = 0;
	              self.bytesRead = 0;
	              self.stubBuffer = null;
	              // Copy rest of message
	              data = data.slice(sizeOfMessage);
	              // Emit the message
	              self.messageHandler(new Response(self, self.bson, emitBuffer, self.responseOptions), self);
	            }
	          } else {
	            // Create a buffer that contains the space for the non-complete message
	            self.stubBuffer = new Buffer(data.length)
	            // Copy the data to the stub buffer
	            data.copy(self.stubBuffer, 0);
	            // Exit parsing loop
	            data = new Buffer(0);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Connect
	 * @method
	 */
	Connection.prototype.connect = function(_options) {
	  var self = this;
	  _options = _options || {};
	  // Check if we are overriding the promoteLongs
	  if(typeof _options.promoteLongs == 'boolean') {
	    self.responseOptions.promoteLongs = _options.promoteLongs;
	  }
	
	  // Create new connection instance
	  self.connection = self.domainSocket
	    ? net.createConnection(self.host)
	    : net.createConnection(self.port, self.host);
	
	  // Set the options for the connection
	  self.connection.setKeepAlive(self.keepAlive, self.keepAliveInitialDelay);
	  self.connection.setTimeout(self.connectionTimeout);
	  self.connection.setNoDelay(self.noDelay);
	
	  // If we have ssl enabled
	  if(self.ssl) {
	    var sslOptions = {
	        socket: self.connection
	      , rejectUnauthorized: self.rejectUnauthorized
	    }
	
	    if(self.ca) sslOptions.ca = self.ca;
	    if(self.cert) sslOptions.cert = self.cert;
	    if(self.key) sslOptions.key = self.key;
	    if(self.passphrase) sslOptions.passphrase = self.passphrase;
	
	    // Override checkServerIdentity behavior
	    if(self.checkServerIdentity == false) {
	      // Skip the identiy check by retuning undefined as per node documents
	      // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback
	      sslOptions.checkServerIdentity = function(servername, cert) {
	        return undefined;
	      }
	    } else if(typeof self.checkServerIdentity == 'function') {
	      sslOptions.checkServerIdentity = self.checkServerIdentity;
	    }
	
	    try {
	      self.connection = tls.connect(self.port, self.host, sslOptions, function() {
	        // Error on auth or skip
	        if(self.connection.authorizationError && self.rejectUnauthorized) {
	          return self.emit("error", self.connection.authorizationError, self, {ssl:true});
	        }
	
	        // Set socket timeout instead of connection timeout
	        self.connection.setTimeout(self.socketTimeout);
	        // We are done emit connect
	        self.emit('connect', self);
	      });
	    }
	    catch (error) {
	      // In the case of an invalid key, the Node tls module raises the error
	      // Error: error:0B080074:x509 certificate routines:X509_check_private_key
	      // but does not emit an error event like all other errors. We handle this
	      // and other potential inconsistencies here.
	      process.nextTick(function() {
	        return self.emit("error", MongoError.create(error), self, {ssl:true});
	      });
	    }
	    self.connection.setTimeout(self.connectionTimeout);
	  } else {
	    self.connection.on('connect', function() {
	      // Set socket timeout instead of connection timeout
	      self.connection.setTimeout(self.socketTimeout);
	      // Emit connect event
	      self.emit('connect', self);
	    });
	  }
	
	  // Add handlers for events
	  self.connection.once('error', errorHandler(self));
	  self.connection.once('timeout', timeoutHandler(self));
	  self.connection.once('close', closeHandler(self));
	  self.connection.on('data', dataHandler(self));
	}
	
	/**
	 * Unref this connection
	 * @method
	 * @return {boolean}
	 */
	Connection.prototype.unref = function() {
	  if (this.connection) this.connection.unref();
	  else {
	    var self = this;
	    this.once('connect', function() {
	      self.connection.unref();
	    });
	  }
	}
	
	/**
	 * Destroy connection
	 * @method
	 */
	Connection.prototype.destroy = function() {
	  if(this.connection) {
	    if (this.connection.unref) {
	      this.connection.unref();
	    }
	    this.connection.end();
	    this.connection.destroy();
	  }
	
	  this.destroyed = true;
	}
	
	/**
	 * Write to connection
	 * @method
	 * @param {Command} command Command to write out need to implement toBin and toBinUnified
	 */
	Connection.prototype.write = function(buffer) {
	  // Debug Log
	  if(this.logger.isDebug()) {
	    if(!Array.isArray(buffer)) {
	      this.logger.debug(f('writing buffer [%s] to %s:%s', buffer.toString('hex'), this.host, this.port));
	    } else {
	      for(var i = 0; i < buffer.length; i++)
	        this.logger.debug(f('writing buffer [%s] to %s:%s', buffer[i].toString('hex'), this.host, this.port));
	    }
	  }
	
	  // Write out the command
	  if(!Array.isArray(buffer)) return this.connection.write(buffer, 'binary');
	  // Iterate over all buffers and write them in order to the socket
	  for(var i = 0; i < buffer.length; i++) this.connection.write(buffer[i], 'binary');
	}
	
	/**
	 * Return id of connection as a string
	 * @method
	 * @return {string}
	 */
	Connection.prototype.toString = function() {
	  return "" + this.id;
	}
	
	/**
	 * Return json object of connection
	 * @method
	 * @return {object}
	 */
	Connection.prototype.toJSON = function() {
	  return {id: this.id, host: this.host, port: this.port};
	}
	
	/**
	 * Is the connection connected
	 * @method
	 * @return {boolean}
	 */
	Connection.prototype.isConnected = function() {
	  if(this.destroyed) return false;
	  return !this.connection.destroyed && this.connection.writable;
	}
	
	/**
	 * A server connect event, used to verify that the connection is up and running
	 *
	 * @event Connection#connect
	 * @type {Connection}
	 */
	
	/**
	 * The server connection closed, all pool connections closed
	 *
	 * @event Connection#close
	 * @type {Connection}
	 */
	
	/**
	 * The server connection caused an error, all pool connections closed
	 *
	 * @event Connection#error
	 * @type {Connection}
	 */
	
	/**
	 * The server connection timed out, all pool connections closed
	 *
	 * @event Connection#timeout
	 * @type {Connection}
	 */
	
	/**
	 * The driver experienced an invalid message, all pool connections closed
	 *
	 * @event Connection#parseError
	 * @type {Connection}
	 */
	
	module.exports = Connection;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer, __webpack_require__(6)))

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";
	
	var f = __webpack_require__(77).format
	  , Long = __webpack_require__(134).Long
	  , setProperty = __webpack_require__(159).setProperty
	  , getProperty = __webpack_require__(159).getProperty
	  , getSingleProperty = __webpack_require__(159).getSingleProperty;
	
	// Incrementing request id
	var _requestId = 0;
	
	// Wire command operation ids
	var OP_QUERY = 2004;
	var OP_GETMORE = 2005;
	var OP_KILL_CURSORS = 2007;
	
	// Query flags
	var OPTS_NONE = 0;
	var OPTS_TAILABLE_CURSOR = 2;
	var OPTS_SLAVE = 4;
	var OPTS_OPLOG_REPLAY = 8;
	var OPTS_NO_CURSOR_TIMEOUT = 16;
	var OPTS_AWAIT_DATA = 32;
	var OPTS_EXHAUST = 64;
	var OPTS_PARTIAL = 128;
	
	// Request Id Max Value in JS
	var JS_INT_MAX = 0x20000000000000;
	
	// Response flags
	var CURSOR_NOT_FOUND = 1;
	var QUERY_FAILURE = 2;
	var SHARD_CONFIG_STALE = 4;
	var AWAIT_CAPABLE = 8;
	
	/**************************************************************
	 * QUERY
	 **************************************************************/
	var Query = function(bson, ns, query, options) {
	  var self = this;
	  // Basic options needed to be passed in
	  if(ns == null) throw new Error("ns must be specified for query");
	  if(query == null) throw new Error("query must be specified for query");
	
	  // Validate that we are not passing 0x00 in the colletion name
	  if(!!~ns.indexOf("\x00")) {
	    throw new Error("namespace cannot contain a null character");
	  }
	
	  // Basic options
	  this.bson = bson;
	  this.ns = ns;
	  this.query = query;
	
	  // Ensure empty options
	  this.options = options || {};
	
	  // Additional options
	  this.numberToSkip = options.numberToSkip || 0;
	  this.numberToReturn = options.numberToReturn || 0;
	  this.returnFieldSelector = options.returnFieldSelector || null;
	  this.requestId = (_requestId++) % JS_INT_MAX;
	
	  // Serialization option
	  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
	  this.ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
	  this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
	  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : true;
	  this.batchSize = self.numberToReturn;
	
	  // Flags
	  this.tailable = false;
	  this.slaveOk = false;
	  this.oplogReplay = false;
	  this.noCursorTimeout = false;
	  this.awaitData = false;
	  this.exhaust = false;
	  this.partial = false;
	}
	
	//
	// Assign a new request Id
	Query.prototype.incRequestId = function() {
	  this.requestId = (_requestId++) % JS_INT_MAX;
	}
	
	//
	// Assign a new request Id
	Query.nextRequestId = function() {
	  return (_requestId + 1) % JS_INT_MAX;
	}
	
	//
	// Uses a single allocated buffer for the process, avoiding multiple memory allocations
	Query.prototype.toBin = function() {
	  var self = this;
	  var buffers = [];
	  var projection = null;
	
	  // Set up the flags
	  var flags = 0;
	  if(this.tailable) {
	    flags |= OPTS_TAILABLE_CURSOR;
	  }
	
	  if(this.slaveOk) {
	    flags |= OPTS_SLAVE;
	  }
	
	  if(this.oplogReplay) {
	    flags |= OPTS_OPLOG_REPLAY;
	  }
	
	  if(this.noCursorTimeout) {
	    flags |= OPTS_NO_CURSOR_TIMEOUT;
	  }
	
	  if(this.awaitData) {
	    flags |= OPTS_AWAIT_DATA;
	  }
	
	  if(this.exhaust) {
	    flags |= OPTS_EXHAUST;
	  }
	
	  if(this.partial) {
	    flags |= OPTS_PARTIAL;
	  }
	
	  // If batchSize is different to self.numberToReturn
	  if(self.batchSize != self.numberToReturn) self.numberToReturn = self.batchSize;
	
	  // Allocate write protocol header buffer
	  var header = new Buffer(
	    4 * 4 // Header
	    + 4   // Flags
	    + Buffer.byteLength(self.ns) + 1 // namespace
	    + 4 // numberToSkip
	    + 4 // numberToReturn
	  );
	
	  // Add header to buffers
	  buffers.push(header);
	
	  // Serialize the query
	  var query = self.bson.serialize(this.query
	    , this.checkKeys
	    , true
	    , this.serializeFunctions
	    , 0, this.ignoreUndefined);
	
	  // Add query document
	  buffers.push(query);
	
	  if(self.returnFieldSelector && Object.keys(self.returnFieldSelector).length > 0) {
	    // Serialize the projection document
	    projection = self.bson.serialize(this.returnFieldSelector, this.checkKeys, true, this.serializeFunctions, this.ignoreUndefined);
	    // Add projection document
	    buffers.push(projection);
	  }
	
	  // Total message size
	  var totalLength = header.length + query.length + (projection ? projection.length : 0);
	
	  // Set up the index
	  var index = 4;
	
	  // Write total document length
	  header[3] = (totalLength >> 24) & 0xff;
	  header[2] = (totalLength >> 16) & 0xff;
	  header[1] = (totalLength >> 8) & 0xff;
	  header[0] = (totalLength) & 0xff;
	
	  // Write header information requestId
	  header[index + 3] = (this.requestId >> 24) & 0xff;
	  header[index + 2] = (this.requestId >> 16) & 0xff;
	  header[index + 1] = (this.requestId >> 8) & 0xff;
	  header[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // Write header information responseTo
	  header[index + 3] = (0 >> 24) & 0xff;
	  header[index + 2] = (0 >> 16) & 0xff;
	  header[index + 1] = (0 >> 8) & 0xff;
	  header[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Write header information OP_QUERY
	  header[index + 3] = (OP_QUERY >> 24) & 0xff;
	  header[index + 2] = (OP_QUERY >> 16) & 0xff;
	  header[index + 1] = (OP_QUERY >> 8) & 0xff;
	  header[index] = (OP_QUERY) & 0xff;
	  index = index + 4;
	
	  // Write header information flags
	  header[index + 3] = (flags >> 24) & 0xff;
	  header[index + 2] = (flags >> 16) & 0xff;
	  header[index + 1] = (flags >> 8) & 0xff;
	  header[index] = (flags) & 0xff;
	  index = index + 4;
	
	  // Write collection name
	  index = index + header.write(this.ns, index, 'utf8') + 1;
	  header[index - 1] = 0;
	
	  // Write header information flags numberToSkip
	  header[index + 3] = (this.numberToSkip >> 24) & 0xff;
	  header[index + 2] = (this.numberToSkip >> 16) & 0xff;
	  header[index + 1] = (this.numberToSkip >> 8) & 0xff;
	  header[index] = (this.numberToSkip) & 0xff;
	  index = index + 4;
	
	  // Write header information flags numberToReturn
	  header[index + 3] = (this.numberToReturn >> 24) & 0xff;
	  header[index + 2] = (this.numberToReturn >> 16) & 0xff;
	  header[index + 1] = (this.numberToReturn >> 8) & 0xff;
	  header[index] = (this.numberToReturn) & 0xff;
	  index = index + 4;
	
	  // Return the buffers
	  return buffers;
	}
	
	Query.getRequestId = function() {
	  return (++_requestId) % JS_INT_MAX;
	}
	
	/**************************************************************
	 * GETMORE
	 **************************************************************/
	var GetMore = function(bson, ns, cursorId, opts) {
	  opts = opts || {};
	  this.numberToReturn = opts.numberToReturn || 0;
	  this.requestId = (_requestId++) % JS_INT_MAX;
	  this.bson = bson;
	  this.ns = ns;
	  this.cursorId = cursorId;
	}
	
	//
	// Uses a single allocated buffer for the process, avoiding multiple memory allocations
	GetMore.prototype.toBin = function() {
	  var length = 4 + Buffer.byteLength(this.ns) + 1 + 4 + 8 + (4 * 4);
	  // Create command buffer
	  var index = 0;
	  // Allocate buffer
	  var _buffer = new Buffer(length);
	
	  // Write header information
	  // index = write32bit(index, _buffer, length);
	  _buffer[index + 3] = (length >> 24) & 0xff;
	  _buffer[index + 2] = (length >> 16) & 0xff;
	  _buffer[index + 1] = (length >> 8) & 0xff;
	  _buffer[index] = (length) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, requestId);
	  _buffer[index + 3] = (this.requestId >> 24) & 0xff;
	  _buffer[index + 2] = (this.requestId >> 16) & 0xff;
	  _buffer[index + 1] = (this.requestId >> 8) & 0xff;
	  _buffer[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, 0);
	  _buffer[index + 3] = (0 >> 24) & 0xff;
	  _buffer[index + 2] = (0 >> 16) & 0xff;
	  _buffer[index + 1] = (0 >> 8) & 0xff;
	  _buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, OP_GETMORE);
	  _buffer[index + 3] = (OP_GETMORE >> 24) & 0xff;
	  _buffer[index + 2] = (OP_GETMORE >> 16) & 0xff;
	  _buffer[index + 1] = (OP_GETMORE >> 8) & 0xff;
	  _buffer[index] = (OP_GETMORE) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, 0);
	  _buffer[index + 3] = (0 >> 24) & 0xff;
	  _buffer[index + 2] = (0 >> 16) & 0xff;
	  _buffer[index + 1] = (0 >> 8) & 0xff;
	  _buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Write collection name
	  index = index + _buffer.write(this.ns, index, 'utf8') + 1;
	  _buffer[index - 1] = 0;
	
	  // Write batch size
	  // index = write32bit(index, _buffer, numberToReturn);
	  _buffer[index + 3] = (this.numberToReturn >> 24) & 0xff;
	  _buffer[index + 2] = (this.numberToReturn >> 16) & 0xff;
	  _buffer[index + 1] = (this.numberToReturn >> 8) & 0xff;
	  _buffer[index] = (this.numberToReturn) & 0xff;
	  index = index + 4;
	
	  // Write cursor id
	  // index = write32bit(index, _buffer, cursorId.getLowBits());
	  _buffer[index + 3] = (this.cursorId.getLowBits() >> 24) & 0xff;
	  _buffer[index + 2] = (this.cursorId.getLowBits() >> 16) & 0xff;
	  _buffer[index + 1] = (this.cursorId.getLowBits() >> 8) & 0xff;
	  _buffer[index] = (this.cursorId.getLowBits()) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, cursorId.getHighBits());
	  _buffer[index + 3] = (this.cursorId.getHighBits() >> 24) & 0xff;
	  _buffer[index + 2] = (this.cursorId.getHighBits() >> 16) & 0xff;
	  _buffer[index + 1] = (this.cursorId.getHighBits() >> 8) & 0xff;
	  _buffer[index] = (this.cursorId.getHighBits()) & 0xff;
	  index = index + 4;
	
	  // Return buffer
	  return _buffer;
	}
	
	/**************************************************************
	 * KILLCURSOR
	 **************************************************************/
	var KillCursor = function(bson, cursorIds) {
	  this.requestId = (_requestId++) % JS_INT_MAX;
	  this.cursorIds = cursorIds;
	}
	
	//
	// Uses a single allocated buffer for the process, avoiding multiple memory allocations
	KillCursor.prototype.toBin = function() {
	  var length = 4 + 4 + (4 * 4) + (this.cursorIds.length * 8);
	
	  // Create command buffer
	  var index = 0;
	  var _buffer = new Buffer(length);
	
	  // Write header information
	  // index = write32bit(index, _buffer, length);
	  _buffer[index + 3] = (length >> 24) & 0xff;
	  _buffer[index + 2] = (length >> 16) & 0xff;
	  _buffer[index + 1] = (length >> 8) & 0xff;
	  _buffer[index] = (length) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, requestId);
	  _buffer[index + 3] = (this.requestId >> 24) & 0xff;
	  _buffer[index + 2] = (this.requestId >> 16) & 0xff;
	  _buffer[index + 1] = (this.requestId >> 8) & 0xff;
	  _buffer[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, 0);
	  _buffer[index + 3] = (0 >> 24) & 0xff;
	  _buffer[index + 2] = (0 >> 16) & 0xff;
	  _buffer[index + 1] = (0 >> 8) & 0xff;
	  _buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, OP_KILL_CURSORS);
	  _buffer[index + 3] = (OP_KILL_CURSORS >> 24) & 0xff;
	  _buffer[index + 2] = (OP_KILL_CURSORS >> 16) & 0xff;
	  _buffer[index + 1] = (OP_KILL_CURSORS >> 8) & 0xff;
	  _buffer[index] = (OP_KILL_CURSORS) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, 0);
	  _buffer[index + 3] = (0 >> 24) & 0xff;
	  _buffer[index + 2] = (0 >> 16) & 0xff;
	  _buffer[index + 1] = (0 >> 8) & 0xff;
	  _buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Write batch size
	  // index = write32bit(index, _buffer, this.cursorIds.length);
	  _buffer[index + 3] = (this.cursorIds.length >> 24) & 0xff;
	  _buffer[index + 2] = (this.cursorIds.length >> 16) & 0xff;
	  _buffer[index + 1] = (this.cursorIds.length >> 8) & 0xff;
	  _buffer[index] = (this.cursorIds.length) & 0xff;
	  index = index + 4;
	
	  // Write all the cursor ids into the array
	  for(var i = 0; i < this.cursorIds.length; i++) {
	    // Write cursor id
	    // index = write32bit(index, _buffer, cursorIds[i].getLowBits());
	    _buffer[index + 3] = (this.cursorIds[i].getLowBits() >> 24) & 0xff;
	    _buffer[index + 2] = (this.cursorIds[i].getLowBits() >> 16) & 0xff;
	    _buffer[index + 1] = (this.cursorIds[i].getLowBits() >> 8) & 0xff;
	    _buffer[index] = (this.cursorIds[i].getLowBits()) & 0xff;
	    index = index + 4;
	
	    // index = write32bit(index, _buffer, cursorIds[i].getHighBits());
	    _buffer[index + 3] = (this.cursorIds[i].getHighBits() >> 24) & 0xff;
	    _buffer[index + 2] = (this.cursorIds[i].getHighBits() >> 16) & 0xff;
	    _buffer[index + 1] = (this.cursorIds[i].getHighBits() >> 8) & 0xff;
	    _buffer[index] = (this.cursorIds[i].getHighBits()) & 0xff;
	    index = index + 4;
	  }
	
	  // Return buffer
	  return _buffer;
	}
	
	var Response = function(connection, bson, data, opts) {
	  opts = opts || {promoteLongs: true};
	  this.parsed = false;
	  this.connection = connection;
	
	  //
	  // Parse Header
	  //
	  this.index = 0;
	  this.raw = data;
	  this.data = data;
	  this.bson = bson;
	  this.opts = opts;
	
	  // Read the message length
	  this.length = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	
	  // Fetch the request id for this reply
	  this.requestId = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	
	  // Fetch the id of the request that triggered the response
	  this.responseTo = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	
	  // Skip op-code field
	  this.index = this.index + 4;
	
	  // Unpack flags
	  this.responseFlags = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	
	  // Unpack the cursor
	  var lowBits = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	  var highBits = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	  // Create long object
	  this.cursorId = new Long(lowBits, highBits);
	
	  // Unpack the starting from
	  this.startingFrom = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	
	  // Unpack the number of objects returned
	  this.numberReturned = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	
	  // Preallocate document array
	  this.documents = new Array(this.numberReturned);
	
	  // Flag values
	  this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) != 0;
	  this.queryFailure = (this.responseFlags & QUERY_FAILURE) != 0;
	  this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) != 0;
	  this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) != 0;
	  this.promoteLongs = typeof opts.promoteLongs == 'boolean' ? opts.promoteLongs : true;
	}
	
	Response.prototype.isParsed = function() {
	  return this.parsed;
	}
	
	// Validation buffers
	var firstBatch = new Buffer('firstBatch', 'utf8');
	var nextBatch = new Buffer('nextBatch', 'utf8');
	var cursorId = new Buffer('id', 'utf8').toString('hex');
	
	var documentBuffers = {
	  firstBatch: firstBatch.toString('hex'),
	  nextBatch: nextBatch.toString('hex')
	};
	
	Response.prototype.parse = function(options) {
	  // Don't parse again if not needed
	  if(this.parsed) return;
	  options = options || {};
	
	  // Allow the return of raw documents instead of parsing
	  var raw = options.raw || false;
	  var documentsReturnedIn = options.documentsReturnedIn || null;
	
	  //
	  // Single document and documentsReturnedIn set
	  //
	  if(this.numberReturned == 1 && documentsReturnedIn != null && raw) {
	    // Calculate the bson size
	    var bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
	    // Slice out the buffer containing the command result document
	    var document = this.data.slice(this.index, this.index + bsonSize);
	    // Set up field we wish to keep as raw
	    var fieldsAsRaw = {}
	    fieldsAsRaw[documentsReturnedIn] = true;
	    // Set up the options
	    var _options = {promoteLongs: this.opts.promoteLongs, fieldsAsRaw: fieldsAsRaw};
	
	    // Do we have a promoteLongs value on the options
	    if(typeof options.promoteLongs == 'boolean') {
	      _options.promoteLongs = options.promoteLongs;
	    }
	
	    // Deserialize but keep the array of documents in non-parsed form
	    var doc = this.bson.deserialize(document, _options);
	
	    // Get the documents
	    this.documents = doc.cursor[documentsReturnedIn];
	    this.numberReturned = this.documents.length;
	    // Ensure we have a Long valie cursor id
	    this.cursorId = typeof doc.cursor.id == 'number'
	      ? Long.fromNumber(doc.cursor.id)
	      : doc.cursor.id;
	
	    // Adjust the index
	    this.index = this.index + bsonSize;
	
	    // Set as parsed
	    this.parsed = true
	    return;
	  }
	
	  //
	  // Parse Body
	  //
	  for(var i = 0; i < this.numberReturned; i++) {
	    var bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
	    // Parse options
	    var _options = {promoteLongs: this.opts.promoteLongs};
	
	    // Do we have a promoteLongs value on the options
	    if(typeof options.promoteLongs == 'boolean') {
	      _options.promoteLongs = options.promoteLongs;
	    }
	
	    // If we have raw results specified slice the return document
	    if(raw) {
	      this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
	    } else {
	      this.documents[i] = this.bson.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
	    }
	
	    // Adjust the index
	    this.index = this.index + bsonSize;
	  }
	
	  // Set parsed
	  this.parsed = true;
	}
	
	module.exports = {
	    Query: Query
	  , GetMore: GetMore
	  , Response: Response
	  , KillCursor: KillCursor
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var f = __webpack_require__(77).format
	  , MongoError = __webpack_require__(157);
	
	// Filters for classes
	var classFilters = {};
	var filteredClasses = {};
	var level = null;
	// Save the process id
	var pid = process.pid;
	// current logger
	var currentLogger = null;
	
	/**
	 * Creates a new Logger instance
	 * @class
	 * @param {string} className The Class name associated with the logging instance
	 * @param {object} [options=null] Optional settings.
	 * @param {Function} [options.logger=null] Custom logger function;
	 * @param {string} [options.loggerLevel=error] Override default global log level.
	 * @return {Logger} a Logger instance.
	 */
	var Logger = function(className, options) {
	  if(!(this instanceof Logger)) return new Logger(className, options);
	  options = options || {};
	
	  // Current reference
	  var self = this;
	  this.className = className;
	
	  // Current logger
	  if(currentLogger == null && options.logger) {
	    currentLogger = options.logger;
	  } else if(currentLogger == null) {
	    currentLogger = console.log;
	  }
	
	  // Set level of logging, default is error
	  if(level == null) {
	    level = options.loggerLevel || 'error';
	  }
	
	  // Add all class names
	  if(filteredClasses[this.className] == null) classFilters[this.className] =  true;
	}
	
	/**
	 * Log a message at the debug level
	 * @method
	 * @param {string} message The message to log
	 * @param {object} object additional meta data to log
	 * @return {null}
	 */
	Logger.prototype.debug = function(message, object) {
	  if(this.isDebug()
	    && ((Object.keys(filteredClasses).length > 0 && filteredClasses[this.className])
	      || (Object.keys(filteredClasses).length == 0 && classFilters[this.className]))) {
	    var dateTime = new Date().getTime();
	    var msg = f("[%s-%s:%s] %s %s", 'DEBUG', this.className, pid, dateTime, message);        
	    var state = {
	      type: 'debug', message: message, className: this.className, pid: pid, date: dateTime
	    };
	    if(object) state.meta = object;
	    currentLogger(msg, state);
	  }
	}
	
	/**
	 * Log a message at the info level
	 * @method
	 * @param {string} message The message to log
	 * @param {object} object additional meta data to log
	 * @return {null}
	 */
	Logger.prototype.info = function(message, object) {
	  if(this.isInfo()
	    && ((Object.keys(filteredClasses).length > 0 && filteredClasses[this.className])
	      || (Object.keys(filteredClasses).length == 0 && classFilters[this.className]))) {
	    var dateTime = new Date().getTime();
	    var msg = f("[%s-%s:%s] %s %s", 'INFO', this.className, pid, dateTime, message);
	    var state = {
	      type: 'info', message: message, className: this.className, pid: pid, date: dateTime
	    };
	    if(object) state.meta = object;
	    currentLogger(msg, state);
	  }
	},
	
	/**
	 * Log a message at the error level
	 * @method
	 * @param {string} message The message to log
	 * @param {object} object additional meta data to log
	 * @return {null}
	 */
	Logger.prototype.error = function(message, object) {
	  if(this.isError()
	    && ((Object.keys(filteredClasses).length > 0 && filteredClasses[this.className])
	      || (Object.keys(filteredClasses).length == 0 && classFilters[this.className]))) {
	    var dateTime = new Date().getTime();
	    var msg = f("[%s-%s:%s] %s %s", 'ERROR', this.className, pid, dateTime, message);
	    var state = {
	      type: 'error', message: message, className: this.className, pid: pid, date: dateTime
	    };
	    if(object) state.meta = object;
	    currentLogger(msg, state);
	  }
	},
	
	/**
	 * Is the logger set at info level
	 * @method
	 * @return {boolean}
	 */
	Logger.prototype.isInfo = function() {
	  return level == 'info' || level == 'debug';
	},
	
	/**
	 * Is the logger set at error level
	 * @method
	 * @return {boolean}
	 */
	Logger.prototype.isError = function() {
	  return level == 'error' || level == 'info' || level == 'debug';
	},
	
	/**
	 * Is the logger set at debug level
	 * @method
	 * @return {boolean}
	 */
	Logger.prototype.isDebug = function() {
	  return level == 'debug';
	}
	
	/**
	 * Resets the logger to default settings, error and no filtered classes
	 * @method
	 * @return {null}
	 */
	Logger.reset = function() {
	  level = 'error';
	  filteredClasses = {};
	}
	
	/**
	 * Get the current logger function
	 * @method
	 * @return {function}
	 */
	Logger.currentLogger = function() {
	  return currentLogger;
	}
	
	/**
	 * Set the current logger function
	 * @method
	 * @param {function} logger Logger function.
	 * @return {null}
	 */
	Logger.setCurrentLogger = function(logger) {
	  if(typeof logger != 'function') throw new MongoError("current logger must be a function");
	  currentLogger = logger;
	}
	
	/**
	 * Set what classes to log.
	 * @method
	 * @param {string} type The type of filter (currently only class)
	 * @param {string[]} values The filters to apply
	 * @return {null}
	 */
	Logger.filter = function(type, values) {
	  if(type == 'class' && Array.isArray(values)) {
	    filteredClasses = {};
	
	    values.forEach(function(x) {
	      filteredClasses[x] = true;
	    });
	  }
	}
	
	/**
	 * Set the current log level
	 * @method
	 * @param {string} level Set current log level (debug, info, error)
	 * @return {null}
	 */
	Logger.setLevel = function(_level) {
	  if(_level != 'info' && _level != 'error' && _level != 'debug') throw new Error(f("%s is an illegal logging level", _level));
	  level = _level;
	}
	
	module.exports = Logger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 164 */
/***/ function(module, exports) {

	"use strict";
	
	var needSlaveOk = ['primaryPreferred', 'secondary', 'secondaryPreferred', 'nearest'];
	
	/**
	 * @fileOverview The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is
	 * used to construct connections.
	 * 
	 * @example
	 * var ReplSet = require('mongodb-core').ReplSet
	 *   , ReadPreference = require('mongodb-core').ReadPreference
	 *   , assert = require('assert');
	 * 
	 * var server = new ReplSet([{host: 'localhost', port: 30000}], {setName: 'rs'});
	 * // Wait for the connection event
	 * server.on('connect', function(server) {
	 *   var cursor = server.cursor('db.test'
	 *     , {find: 'db.test', query: {}}
	 *     , {readPreference: new ReadPreference('secondary')});
	 *   cursor.next(function(err, doc) {
	 *     server.destroy();
	 *   });
	 * });
	 * 
	 * // Start connecting
	 * server.connect();
	 */
	
	/**
	 * Creates a new Pool instance
	 * @class
	 * @param {string} preference A string describing the preference (primary|primaryPreferred|secondary|secondaryPreferred|nearest)
	 * @param {object} tags The tags object
	 * @param {object} [options] Additional read preference options
	 * @property {string} preference The preference string (primary|primaryPreferred|secondary|secondaryPreferred|nearest)
	 * @property {object} tags The tags object
	 * @property {object} options Additional read preference options
	 * @return {ReadPreference}
	 */
	var ReadPreference = function(preference, tags, options) {
	  this.preference = preference;
	  this.tags = tags;
	  this.options = options;
	}
	
	/**
	 * This needs slaveOk bit set
	 * @method
	 * @return {boolean}
	 */
	ReadPreference.prototype.slaveOk = function() {
	  return needSlaveOk.indexOf(this.preference) != -1;
	}
	
	/**
	 * Are the two read preference equal
	 * @method
	 * @return {boolean}
	 */
	ReadPreference.prototype.equals = function(readPreference) {
	  return readPreference.preference == this.preference;
	}
	
	/**
	 * Return JSON representation
	 * @method
	 * @return {Object}
	 */
	ReadPreference.prototype.toJSON = function() {
	  var readPreference = {mode: this.preference};
	  if(Array.isArray(this.tags)) readPreference.tags = this.tags;
	  return readPreference;
	}
	
	/**
	 * Primary read preference
	 * @method
	 * @return {ReadPreference}
	 */
	ReadPreference.primary = new ReadPreference('primary');
	/**
	 * Primary Preferred read preference
	 * @method
	 * @return {ReadPreference}
	 */
	ReadPreference.primaryPreferred = new ReadPreference('primaryPreferred');
	/**
	 * Secondary read preference
	 * @method
	 * @return {ReadPreference}
	 */
	ReadPreference.secondary = new ReadPreference('secondary');
	/**
	 * Secondary Preferred read preference
	 * @method
	 * @return {ReadPreference}
	 */
	ReadPreference.secondaryPreferred = new ReadPreference('secondaryPreferred');
	/**
	 * Nearest read preference
	 * @method
	 * @return {ReadPreference}
	 */
	ReadPreference.nearest = new ReadPreference('nearest');
	
	module.exports = ReadPreference;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var Long = __webpack_require__(134).Long
	  , Logger = __webpack_require__(163)
	  , MongoError = __webpack_require__(157)
	  , f = __webpack_require__(77).format;
	
	/**
	 * This is a cursor results callback
	 *
	 * @callback resultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {object} document
	 */
	
	/**
	 * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB
	 * allowing for iteration over the results returned from the underlying query.
	 *
	 * **CURSORS Cannot directly be instantiated**
	 * @example
	 * var Server = require('mongodb-core').Server
	 *   , ReadPreference = require('mongodb-core').ReadPreference
	 *   , assert = require('assert');
	 *
	 * var server = new Server({host: 'localhost', port: 27017});
	 * // Wait for the connection event
	 * server.on('connect', function(server) {
	 *   assert.equal(null, err);
	 *
	 *   // Execute the write
	 *   var cursor = _server.cursor('integration_tests.inserts_example4', {
	 *       find: 'integration_tests.example4'
	 *     , query: {a:1}
	 *   }, {
	 *     readPreference: new ReadPreference('secondary');
	 *   });
	 *
	 *   // Get the first document
	 *   cursor.next(function(err, doc) {
	 *     assert.equal(null, err);
	 *     server.destroy();
	 *   });
	 * });
	 *
	 * // Start connecting
	 * server.connect();
	 */
	
	/**
	 * Creates a new Cursor, not to be used directly
	 * @class
	 * @param {object} bson An instance of the BSON parser
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {{object}|Long} cmd The selector (can be a command or a cursorId)
	 * @param {object} [options=null] Optional settings.
	 * @param {object} [options.batchSize=1000] Batchsize for the operation
	 * @param {array} [options.documents=[]] Initial documents list for cursor
	 * @param {object} [options.transforms=null] Transform methods for the cursor results
	 * @param {function} [options.transforms.query] Transform the value returned from the initial query
	 * @param {function} [options.transforms.doc] Transform each document returned from Cursor.prototype.next
	 * @param {object} topology The server topology instance.
	 * @param {object} topologyOptions The server topology options.
	 * @return {Cursor} A cursor instance
	 * @property {number} cursorBatchSize The current cursorBatchSize for the cursor
	 * @property {number} cursorLimit The current cursorLimit for the cursor
	 * @property {number} cursorSkip The current cursorSkip for the cursor
	 */
	var Cursor = function(bson, ns, cmd, options, topology, topologyOptions) {
	  options = options || {};
	  // Cursor reference
	  var self = this;
	  // Initial query
	  var query = null;
	
	  // Cursor pool
	  this.pool = null;
	  // Cursor server
	  this.server = null;
	
	  // Do we have a not connected handler
	  this.disconnectHandler = options.disconnectHandler;
	
	  // Set local values
	  this.bson = bson;
	  this.ns = ns;
	  this.cmd = cmd;
	  this.options = options;
	  this.topology = topology;
	
	  // All internal state
	  this.cursorState = {
	      cursorId: null
	    , cmd: cmd
	    , documents: options.documents || []
	    , cursorIndex: 0
	    , dead: false
	    , killed: false
	    , init: false
	    , notified: false
	    , limit: options.limit || cmd.limit || 0
	    , skip: options.skip || cmd.skip || 0
	    , batchSize: options.batchSize || cmd.batchSize || 1000
	    , currentLimit: 0
	    // Result field name if not a cursor (contains the array of results)
	    , transforms: options.transforms
	  }
	
	  // Add promoteLong to cursor state
	  if(typeof topologyOptions.promoteLongs == 'boolean') {
	    this.cursorState.promoteLongs = topologyOptions.promoteLongs;
	  }
	
	  // Callback controller
	  this.callbacks = null;
	
	  // Logger
	  this.logger = Logger('Cursor', options);
	
	  //
	  // Did we pass in a cursor id
	  if(typeof cmd == 'number') {
	    this.cursorState.cursorId = Long.fromNumber(cmd);
	    this.cursorState.lastCursorId = this.cursorState.cursorId;
	  } else if(cmd instanceof Long) {
	    this.cursorState.cursorId = cmd;
	    this.cursorState.lastCursorId = cmd;
	  }
	}
	
	Cursor.prototype.setCursorBatchSize = function(value) {
	  this.cursorState.batchSize = value;
	}
	
	Cursor.prototype.cursorBatchSize = function() {
	  return this.cursorState.batchSize;
	}
	
	Cursor.prototype.setCursorLimit = function(value) {
	  this.cursorState.limit = value;
	}
	
	Cursor.prototype.cursorLimit = function() {
	  return this.cursorState.limit;
	}
	
	Cursor.prototype.setCursorSkip = function(value) {
	  this.cursorState.skip = value;
	}
	
	Cursor.prototype.cursorSkip = function() {
	  return this.cursorState.skip;
	}
	
	//
	// Handle callback (including any exceptions thrown)
	var handleCallback = function(callback, err, result) {
	  try {
	    callback(err, result);
	  } catch(err) {
	    process.nextTick(function() {
	      throw err;
	    });
	  }
	}
	
	// Internal methods
	Cursor.prototype._find = function(callback) {
	  var self = this;
	
	  if(self.logger.isDebug()) {
	    self.logger.debug(f("issue initial query [%s] with flags [%s]"
	      , JSON.stringify(self.cmd)
	      , JSON.stringify(self.query)));
	  }
	
	  var queryCallback = function(err, result) {
	    if(err) return callback(err);
	
	    // Query failure bit set
	    if(result.queryFailure) {
	      return callback(MongoError.create(result.documents[0]), null);
	    }
	
	    // Store the connection for usage with getMore command
	    self.connection = result.connection;
	
	    // Check if we have a command cursor
	    if(Array.isArray(result.documents) && result.documents.length == 1
	      && (!self.cmd.find || (self.cmd.find && self.cmd.virtual == false))
	      && (result.documents[0].cursor != 'string'
	        || result.documents[0]['$err']
	        || result.documents[0]['errmsg']
	        || Array.isArray(result.documents[0].result))
	      ) {
	
	      // We have a an error document return the error
	      if(result.documents[0]['$err']
	        || result.documents[0]['errmsg']) {
	        return callback(MongoError.create(result.documents[0]), null);
	      }
	
	      // We have a cursor document
	      if(result.documents[0].cursor != null
	        && typeof result.documents[0].cursor != 'string') {
	          var id = result.documents[0].cursor.id;
	          // If we have a namespace change set the new namespace for getmores
	          if(result.documents[0].cursor.ns) {
	            self.ns = result.documents[0].cursor.ns;
	          }
	          // Promote id to long if needed
	          self.cursorState.cursorId = typeof id == 'number' ? Long.fromNumber(id) : id;
	          self.cursorState.lastCursorId = self.cursorState.cursorId;
	          // If we have a firstBatch set it
	          if(Array.isArray(result.documents[0].cursor.firstBatch)) {
	            self.cursorState.documents = result.documents[0].cursor.firstBatch;//.reverse();
	          }
	
	          // Return after processing command cursor
	          return callback(null, null);
	      }
	
	      if(Array.isArray(result.documents[0].result)) {
	        self.cursorState.documents = result.documents[0].result;
	        self.cursorState.cursorId = Long.ZERO;
	        return callback(null, null);
	      }
	    }
	
	    // Otherwise fall back to regular find path
	    self.cursorState.cursorId = result.cursorId;
	    self.cursorState.documents = result.documents;
	    self.cursorState.lastCursorId = result.cursorId;
	
	    // Transform the results with passed in transformation method if provided
	    if(self.cursorState.transforms && typeof self.cursorState.transforms.query == 'function') {
	      self.cursorState.documents = self.cursorState.transforms.query(result);
	    }
	
	    // Return callback
	    callback(null, null);
	  }
	
	  // If we have a raw query decorate the function
	  if(self.options.raw || self.cmd.raw) {
	    queryCallback.raw = self.options.raw || self.cmd.raw;
	  }
	
	  // Do we have documentsReturnedIn set on the query
	  if(typeof self.query.documentsReturnedIn == 'string') {
	    queryCallback.documentsReturnedIn = self.query.documentsReturnedIn;
	  }
	
	  // Add promote Long value if defined
	  if(typeof self.cursorState.promoteLongs == 'boolean') {
	    queryCallback.promoteLongs = self.cursorState.promoteLongs;
	  }
	
	  // Set up callback
	  self.callbacks.register(self.query.requestId, queryCallback);
	
	  // Write the initial command out
	  self.pool.write(self.query.toBin(), queryCallback);
	}
	
	Cursor.prototype._getmore = function(callback) {
	  if(this.logger.isDebug()) this.logger.debug(f("schedule getMore call for query [%s]", JSON.stringify(this.query)))
	  // Determine if it's a raw query
	  var raw = this.options.raw || this.cmd.raw;
	
	  // Set the current batchSize
	  var batchSize = this.cursorState.batchSize;
	  if(this.cursorState.limit > 0
	    && ((this.cursorState.currentLimit + batchSize) > this.cursorState.limit)) {
	    batchSize = this.cursorState.limit - this.cursorState.currentLimit;
	  }
	
	  // Default pool
	  var pool = this.pool;
	  // If we have a connection get the corresponding pool
	  if(this.connection && this.connection.isConnected()) {
	    // Get the server
	    var server = this.topology.getServerFrom(this.connection);
	    // Get the pool
	    if(server && server.s.pool) {
	      pool = server.s.pool;
	    }
	  }
	
	  // We have a wire protocol handler
	  this.server.wireProtocolHandler.getMore(this.bson, this.ns, this.cursorState, batchSize, raw, pool, this.callbacks, this.options, callback);
	}
	
	Cursor.prototype._killcursor = function(callback) {
	  // Set cursor to dead
	  this.cursorState.dead = true;
	  this.cursorState.killed = true;
	  // Remove documents
	  this.cursorState.documents = [];
	
	  // If no cursor id just return
	  if(this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init == false) {
	    if(callback) callback(null, null);
	    return;
	  }
	
	  // Default pool
	  var pool = this.pool;
	  // If we have a connection get the corresponding pool
	  if(this.connection && this.connection.isConnected()) {
	    // Get the server
	    var server = this.topology.getServerFrom(this.connection);
	    // Get the pool
	    if(server && server.s.pool) {
	      pool = server.s.pool;
	    }
	  }
	
	  // Execute command
	  this.server.wireProtocolHandler.killCursor(this.bson, this.ns, this.cursorState.cursorId, pool, this.callbacks, callback);
	}
	
	/**
	 * Clone the cursor
	 * @method
	 * @return {Cursor}
	 */
	Cursor.prototype.clone = function() {
	  return this.topology.cursor(this.ns, this.cmd, this.options);
	}
	
	/**
	 * Checks if the cursor is dead
	 * @method
	 * @return {boolean} A boolean signifying if the cursor is dead or not
	 */
	Cursor.prototype.isDead = function() {
	  return this.cursorState.dead == true;
	}
	
	/**
	 * Checks if the cursor was killed by the application
	 * @method
	 * @return {boolean} A boolean signifying if the cursor was killed by the application
	 */
	Cursor.prototype.isKilled = function() {
	  return this.cursorState.killed == true;
	}
	
	/**
	 * Checks if the cursor notified it's caller about it's death
	 * @method
	 * @return {boolean} A boolean signifying if the cursor notified the callback
	 */
	Cursor.prototype.isNotified = function() {
	  return this.cursorState.notified == true;
	}
	
	/**
	 * Returns current buffered documents length
	 * @method
	 * @return {number} The number of items in the buffered documents
	 */
	Cursor.prototype.bufferedCount = function() {
	  return this.cursorState.documents.length - this.cursorState.cursorIndex;
	}
	
	/**
	 * Returns current buffered documents
	 * @method
	 * @return {Array} An array of buffered documents
	 */
	Cursor.prototype.readBufferedDocuments = function(number) {
	  var unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;
	  var length = number < unreadDocumentsLength ? number : unreadDocumentsLength;
	  var elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length);
	
	  // Transform the doc with passed in transformation method if provided
	  if(this.cursorState.transforms && typeof this.cursorState.transforms.doc == 'function') {
	    // Transform all the elements
	    for(var i = 0; i < elements.length; i++) {
	      elements[i] = this.cursorState.transforms.doc(elements[i]);
	    }
	  }
	
	  // Ensure we do not return any more documents than the limit imposed
	  // Just return the number of elements up to the limit
	  if(this.cursorState.limit > 0 && (this.cursorState.currentLimit + elements.length) > this.cursorState.limit) {
	    elements = elements.slice(0, (this.cursorState.limit - this.cursorState.currentLimit));
	    this.kill();
	  }
	
	  // Adjust current limit
	  this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;
	  this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;
	
	  // Return elements
	  return elements;
	}
	
	/**
	 * Kill the cursor
	 * @method
	 * @param {resultCallback} callback A callback function
	 */
	Cursor.prototype.kill = function(callback) {
	  this._killcursor(callback);
	}
	
	/**
	 * Resets the cursor
	 * @method
	 * @return {null}
	 */
	Cursor.prototype.rewind = function() {
	  if(this.cursorState.init) {
	    if(!this.cursorState.dead) {
	      this.kill();
	    }
	
	    this.cursorState.currentLimit = 0;
	    this.cursorState.init = false;
	    this.cursorState.dead = false;
	    this.cursorState.killed = false;
	    this.cursorState.notified = false;
	    this.cursorState.documents = [];
	    this.cursorState.cursorId = null;
	    this.cursorState.cursorIndex = 0;
	  }
	}
	
	/**
	 * Validate if the pool is dead and return error
	 */
	var isConnectionDead = function(self, callback) {
	  if(self.pool
	    && !self.pool.isConnected()) {
	    self.cursorState.notified = true;
	    self.cursorState.killed = true;
	    self.cursorState.documents = [];
	    self.cursorState.cursorIndex = 0;
	    callback(MongoError.create(f('connection to host %s:%s was destroyed', self.pool.host, self.pool.port)))
	    return true;
	  }
	
	  return false;
	}
	
	/**
	 * Validate if the cursor is dead but was not explicitly killed by user
	 */
	var isCursorDeadButNotkilled = function(self, callback) {
	  // Cursor is dead but not marked killed, return null
	  if(self.cursorState.dead && !self.cursorState.killed) {
	    self.cursorState.notified = true;
	    self.cursorState.killed = true;
	    self.cursorState.documents = [];
	    self.cursorState.cursorIndex = 0;
	    handleCallback(callback, null, null);
	    return true;
	  }
	
	  return false;
	}
	
	/**
	 * Validate if the cursor is dead and was killed by user
	 */
	var isCursorDeadAndKilled = function(self, callback) {
	  if(self.cursorState.dead && self.cursorState.killed) {
	    handleCallback(callback, MongoError.create("cursor is dead"));
	    return true;
	  }
	
	  return false;
	}
	
	/**
	 * Validate if the cursor was killed by the user
	 */
	var isCursorKilled = function(self, callback) {
	  if(self.cursorState.killed) {
	    self.cursorState.notified = true;
	    self.cursorState.documents = [];
	    self.cursorState.cursorIndex = 0;
	    handleCallback(callback, null, null);
	    return true;
	  }
	
	  return false;
	}
	
	/**
	 * Mark cursor as being dead and notified
	 */
	var setCursorDeadAndNotified = function(self, callback) {
	  self.cursorState.dead = true;
	  self.cursorState.notified = true;
	  self.cursorState.documents = [];
	  self.cursorState.cursorIndex = 0;
	  handleCallback(callback, null, null);
	}
	
	/**
	 * Mark cursor as being notified
	 */
	var setCursorNotified = function(self, callback) {
	  self.cursorState.notified = true;
	  self.cursorState.documents = [];
	  self.cursorState.cursorIndex = 0;
	  handleCallback(callback, null, null);
	}
	
	var push = Array.prototype.push;
	
	var nextFunction = function(self, callback) {
	  // We have notified about it
	  if(self.cursorState.notified) {
	    return callback(new Error('cursor is exhausted'));
	  }
	
	  // Cursor is killed return null
	  if(isCursorKilled(self, callback)) return;
	
	  // Cursor is dead but not marked killed, return null
	  if(isCursorDeadButNotkilled(self, callback)) return;
	
	  // We have a dead and killed cursor, attempting to call next should error
	  if(isCursorDeadAndKilled(self, callback)) return;
	
	  // We have just started the cursor
	  if(!self.cursorState.init) {
	    // Topology is not connected, save the call in the provided store to be
	    // Executed at some point when the handler deems it's reconnected
	    if(!self.topology.isConnected(self.options) && self.disconnectHandler != null) {
	      return self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);
	    }
	
	    try {
	      // Get a server
	      self.server = self.topology.getServer(self.options);
	      // Get a reference to the pool
	      self.pool = self.server.s.pool;
	      // Get the callbacks
	      self.callbacks = self.server.getCallbacks();
	    } catch(err) {
	      // Handle the error and add object to next method call
	      if(self.disconnectHandler != null) {
	        return self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);
	      }
	
	      // Otherwise return the error
	      return callback(err);
	    }
	
	    // Set as init
	    self.cursorState.init = true;
	
	    try {
	      self.query = self.server.wireProtocolHandler.command(self.bson, self.ns, self.cmd, self.cursorState, self.topology, self.options);
	    } catch(err) {
	      return callback(err);
	    }
	  }
	
	  // If we don't have a cursorId execute the first query
	  if(self.cursorState.cursorId == null) {
	    // Check if pool is dead and return if not possible to
	    // execute the query against the db
	    if(isConnectionDead(self, callback)) return;
	
	    // Check if topology is destroyed
	    if(self.topology.isDestroyed()) return callback(new MongoError(f('connection destroyed, not possible to instantiate cursor')));
	
	    // query, cmd, options, cursorState, callback
	    self._find(function(err, r) {
	      if(err) return handleCallback(callback, err, null);
	
	      if(self.cursorState.documents.length == 0
	        && self.cursorState.cursorId && self.cursorState.cursorId.isZero()
	        && !self.cmd.tailable && !self.cmd.awaitData) {
	        return setCursorNotified(self, callback);
	      }
	
	      nextFunction(self, callback);
	    });
	  } else if(self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
	    // Ensure we kill the cursor on the server
	    self.kill();
	    // Set cursor in dead and notified state
	    return setCursorDeadAndNotified(self, callback);
	  } else if(self.cursorState.cursorIndex == self.cursorState.documents.length
	      && !Long.ZERO.equals(self.cursorState.cursorId)) {
	      // Ensure an empty cursor state
	      self.cursorState.documents = [];
	      self.cursorState.cursorIndex = 0;
	
	      // Check if topology is destroyed
	      if(self.topology.isDestroyed()) return callback(new MongoError(f('connection destroyed, not possible to instantiate cursor')));
	
	      // Check if connection is dead and return if not possible to
	      // execute a getmore on this connection
	      if(isConnectionDead(self, callback)) return;
	
	      // Execute the next get more
	      self._getmore(function(err, doc, connection) {
	        // General error
	        // if(err && err.code != 43) return handleCallback(callback, err);
	        if(err && err.code != 43) return handleCallback(callback, err);
	        // No cursor found error from mongos
	        if((err && err.code == 43) || (self.cursorState.documents.length == 0
	          && Long.ZERO.equals(self.cursorState.cursorId) && !self.cmd.tailable)) {
	            self.cursorState.dead = true;
	            // Finished iterating over the cursor
	            return setCursorDeadAndNotified(self, callback);
	          }
	
	        // Save the returned connection to ensure all getMore's fire over the same connection
	        self.connection = connection;
	
	        // Tailable cursor getMore result, notify owner about it
	        // No attempt is made here to retry, this is left to the user of the
	        // core module to handle to keep core simple
	        if(self.cursorState.documents.length == 0
	          && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {
	          // No more documents in the tailed cursor
	          return handleCallback(callback, MongoError.create({
	              message: "No more documents in tailed cursor"
	            , tailable: self.cmd.tailable
	            , awaitData: self.cmd.awaitData
	          }));
	        } else if(self.cursorState.documents.length == 0
	          && self.cmd.tailable && !Long.ZERO.equals(self.cursorState.cursorId)) {
	          return nextFunction(self, callback);
	        }
	
	        if(self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
	          return setCursorDeadAndNotified(self, callback);
	        }
	
	        nextFunction(self, callback);
	      });
	  } else if(self.cursorState.documents.length == self.cursorState.cursorIndex
	    && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {
	      return handleCallback(callback, MongoError.create({
	          message: "No more documents in tailed cursor"
	        , tailable: self.cmd.tailable
	        , awaitData: self.cmd.awaitData
	      }));
	  } else if(self.cursorState.documents.length == self.cursorState.cursorIndex
	      && Long.ZERO.equals(self.cursorState.cursorId)) {
	      setCursorDeadAndNotified(self, callback);
	  } else {
	    if(self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
	      // Ensure we kill the cursor on the server
	      self.kill();
	      // Set cursor in dead and notified state
	      return setCursorDeadAndNotified(self, callback);
	    }
	
	    // Increment the current cursor limit
	    self.cursorState.currentLimit += 1;
	
	    // Get the document
	    var doc = self.cursorState.documents[self.cursorState.cursorIndex++];
	
	    // Doc overflow
	    if(doc.$err) {
	      // Ensure we kill the cursor on the server
	      self.kill();
	      // Set cursor in dead and notified state
	      return setCursorDeadAndNotified(self, function() {
	        handleCallback(callback, new MongoError(doc.$err));
	      });
	    }
	
	    // Transform the doc with passed in transformation method if provided
	    if(self.cursorState.transforms && typeof self.cursorState.transforms.doc == 'function') {
	      doc = self.cursorState.transforms.doc(doc);
	    }
	
	    // Return the document
	    handleCallback(callback, null, doc);
	  }
	}
	
	/**
	 * Retrieve the next document from the cursor
	 * @method
	 * @param {resultCallback} callback A callback function
	 */
	Cursor.prototype.next = function(callback) {
	  nextFunction(this, callback);
	}
	
	module.exports = Cursor;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var setProperty = __webpack_require__(159).setProperty
	  , getProperty = __webpack_require__(159).getProperty
	  , getSingleProperty = __webpack_require__(159).getSingleProperty;
	
	/**
	 * Creates a new CommandResult instance
	 * @class
	 * @param {object} result CommandResult object
	 * @param {Connection} connection A connection instance associated with this result
	 * @return {CommandResult} A cursor instance
	 */
	var CommandResult = function(result, connection) {
	  this.result = result;
	  this.connection = connection;
	}
	
	/**
	 * Convert CommandResult to JSON
	 * @method
	 * @return {object}
	 */
	CommandResult.prototype.toJSON = function() {
	  return this.result;
	}
	
	/**
	 * Convert CommandResult to String representation
	 * @method
	 * @return {string}
	 */
	CommandResult.prototype.toString = function() {
	  return JSON.stringify(this.toJSON());
	}
	
	module.exports = CommandResult;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var Insert = __webpack_require__(168).Insert
	  , Update = __webpack_require__(168).Update
	  , Remove = __webpack_require__(168).Remove
	  , Query = __webpack_require__(162).Query
	  , copy = __webpack_require__(159).copy
	  , KillCursor = __webpack_require__(162).KillCursor
	  , GetMore = __webpack_require__(162).GetMore
	  , Query = __webpack_require__(162).Query
	  , ReadPreference = __webpack_require__(164)
	  , f = __webpack_require__(77).format
	  , CommandResult = __webpack_require__(166)
	  , MongoError = __webpack_require__(157)
	  , Long = __webpack_require__(134).Long
	  , getReadPreference = __webpack_require__(169).getReadPreference;
	
	// Write concern fields
	var writeConcernFields = ['w', 'wtimeout', 'j', 'fsync'];
	
	var WireProtocol = function() {}
	
	//
	// Needs to support legacy mass insert as well as ordered/unordered legacy
	// emulation
	//
	WireProtocol.prototype.insert = function(topology, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  options = options || {};
	  // Default is ordered execution
	  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
	  var legacy = typeof options.legacy == 'boolean' ? options.legacy : false;
	  ops = Array.isArray(ops) ? ops :[ops];
	
	  // If we have more than a 1000 ops fails
	  if(ops.length > 1000) return callback(new MongoError("exceeded maximum write batch size of 1000"));
	
	  // Write concern
	  var writeConcern = options.writeConcern || {w:1};
	
	  // We are unordered
	  if(!ordered || writeConcern.w == 0) {
	    return executeUnordered('insert', Insert, ismaster, ns, bson, pool, callbacks, ops, options, callback);
	  }
	
	  return executeOrdered('insert', Insert, ismaster, ns, bson, pool, callbacks, ops, options, callback);
	}
	
	WireProtocol.prototype.update = function(topology, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  options = options || {};
	  // Default is ordered execution
	  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
	  ops = Array.isArray(ops) ? ops :[ops];
	
	  // Write concern
	  var writeConcern = options.writeConcern || {w:1};
	
	  // We are unordered
	  if(!ordered || writeConcern.w == 0) {
	    return executeUnordered('update', Update, ismaster, ns, bson, pool, callbacks, ops, options, callback);
	  }
	
	  return executeOrdered('update', Update, ismaster, ns, bson, pool, callbacks, ops, options, callback);
	}
	
	WireProtocol.prototype.remove = function(topology, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  options = options || {};
	  // Default is ordered execution
	  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
	  ops = Array.isArray(ops) ? ops :[ops];
	
	  // Write concern
	  var writeConcern = options.writeConcern || {w:1};
	
	  // We are unordered
	  if(!ordered || writeConcern.w == 0) {
	    return executeUnordered('remove', Remove, ismaster, ns, bson, pool, callbacks, ops, options, callback);
	  }
	
	  return executeOrdered('remove', Remove, ismaster, ns, bson, pool, callbacks, ops, options, callback);
	}
	
	WireProtocol.prototype.killCursor = function(bson, ns, cursorId, pool, callbacks, callback) {
	  // Create a kill cursor command
	  var killCursor = new KillCursor(bson, [cursorId]);
	  // Execute the kill cursor command
	  if(pool && pool.isConnected()) pool.write(killCursor.toBin(), callback, {immediateRelease:true});
	  // Set cursor to 0
	  cursorId = Long.ZERO;
	  // Return to caller
	  if(callback) callback(null, null);
	}
	
	WireProtocol.prototype.getMore = function(bson, ns, cursorState, batchSize, raw, connection, callbacks, options, callback) {
	  // Create getMore command
	  var getMore = new GetMore(bson, ns, cursorState.cursorId, {numberToReturn: batchSize});
	
	  // Query callback
	  var queryCallback = function(err, r) {
	    if(err) return callback(err);
	
	    // If we have a timed out query or a cursor that was killed
	    if((r.responseFlags & (1 << 0)) != 0) {
	      return callback(new MongoError("cursor killed or timed out"), null);
	    }
	
	    // Ensure we have a Long valie cursor id
	    var cursorId = typeof r.cursorId == 'number'
	      ? Long.fromNumber(r.cursorId)
	      : r.cursorId;
	
	    // Set all the values
	    cursorState.documents = r.documents;
	    cursorState.cursorId = cursorId;
	
	    // Return
	    callback(null, null, r.connection);
	  }
	
	  // If we have a raw query decorate the function
	  if(raw) {
	    queryCallback.raw = raw;
	  }
	
	  // Check if we need to promote longs
	  if(typeof cursorState.promoteLongs == 'boolean') {
	    queryCallback.promoteLongs = cursorState.promoteLongs;
	  }
	
	  // Register a callback
	  callbacks.register(getMore.requestId, queryCallback);
	  // Write out the getMore command
	  connection.write(getMore.toBin(), queryCallback);
	}
	
	WireProtocol.prototype.command = function(bson, ns, cmd, cursorState, topology, options) {
	  // Establish type of command
	  if(cmd.find) {
	    return setupClassicFind(bson, ns, cmd, cursorState, topology, options)
	  } else if(cursorState.cursorId != null) {
	  } else if(cmd) {
	    return setupCommand(bson, ns, cmd, cursorState, topology, options);
	  } else {
	    throw new MongoError(f("command %s does not return a cursor", JSON.stringify(cmd)));
	  }
	}
	
	//
	// Execute a find command
	var setupClassicFind = function(bson, ns, cmd, cursorState, topology, options) {
	  // Ensure we have at least some options
	  options = options || {};
	  // Get the readPreference
	  var readPreference = getReadPreference(cmd, options);
	  // Set the optional batchSize
	  cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
	  var numberToReturn = 0;
	
	  // Unpack the limit and batchSize values
	  if(cursorState.limit == 0) {
	    numberToReturn = cursorState.batchSize;
	  } else if(cursorState.limit < 0 || cursorState.limit < cursorState.batchSize || (cursorState.limit > 0 && cursorState.batchSize == 0)) {
	    numberToReturn = cursorState.limit;
	  } else {
	    numberToReturn = cursorState.batchSize;
	  }
	
	  var numberToSkip = cursorState.skip || 0;
	  // Build actual find command
	  var findCmd = {};
	  // Using special modifier
	  var usesSpecialModifier = false;
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos' && readPreference) {
	    findCmd['$readPreference'] = readPreference.toJSON();
	    usesSpecialModifier = true;
	  }
	
	  // Add special modifiers to the query
	  if(cmd.sort) findCmd['orderby'] = cmd.sort, usesSpecialModifier = true;
	  if(cmd.hint) findCmd['$hint'] = cmd.hint, usesSpecialModifier = true;
	  if(cmd.snapshot) findCmd['$snapshot'] = cmd.snapshot, usesSpecialModifier = true;
	  if(cmd.returnKey) findCmd['$returnKey'] = cmd.returnKey, usesSpecialModifier = true;
	  if(cmd.maxScan) findCmd['$maxScan'] = cmd.maxScan, usesSpecialModifier = true;
	  if(cmd.min) findCmd['$min'] = cmd.min, usesSpecialModifier = true;
	  if(cmd.max) findCmd['$max'] = cmd.max, usesSpecialModifier = true;
	  if(cmd.showDiskLoc) findCmd['$showDiskLoc'] = cmd.showDiskLoc, usesSpecialModifier = true;
	  if(cmd.comment) findCmd['$comment'] = cmd.comment, usesSpecialModifier = true;
	  if(cmd.maxTimeMS) findCmd['$maxTimeMS'] = cmd.maxTimeMS, usesSpecialModifier = true;
	
	  if(cmd.explain) {
		// nToReturn must be 0 (match all) or negative (match N and close cursor)
		// nToReturn > 0 will give explain results equivalent to limit(0)
	    numberToReturn = -Math.abs(cmd.limit || 0);
	    usesSpecialModifier = true;
	    findCmd['$explain'] = true;
	  }
	
	  // If we have a special modifier
	  if(usesSpecialModifier) {
	    findCmd['$query'] = cmd.query;
	  } else {
	    findCmd = cmd.query;
	  }
	
	  // Throw on majority readConcern passed in
	  if(cmd.readConcern && cmd.readConcern.level != 'local') {
	    throw new MongoError(f('server find command does not support a readConcern level of %s', cmd.readConcern.level));
	  }
	
	  // Remove readConcern, ensure no failing commands
	  if(cmd.readConcern) {
	    cmd = copy(cmd);
	    delete cmd['readConcern'];
	  }
	
	  // Set up the serialize and ignoreUndefined fields
	  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
	    ? options.serializeFunctions : false;
	  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
	    ? options.ignoreUndefined : false;
	
	  // Build Query object
	  var query = new Query(bson, ns, findCmd, {
	      numberToSkip: numberToSkip, numberToReturn: numberToReturn
	    , checkKeys: false, returnFieldSelector: cmd.fields
	    , serializeFunctions: serializeFunctions, ignoreUndefined: ignoreUndefined
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Set up the option bits for wire protocol
	  if(typeof cmd.tailable == 'boolean') query.tailable = cmd.tailable;
	  if(typeof cmd.oplogReplay == 'boolean') query.oplogReplay = cmd.oplogReplay;
	  if(typeof cmd.noCursorTimeout == 'boolean') query.noCursorTimeout = cmd.noCursorTimeout;
	  if(typeof cmd.awaitData == 'boolean') query.awaitData = cmd.awaitData;
	  if(typeof cmd.partial == 'boolean') query.partial = cmd.partial;
	  // Return the query
	  return query;
	}
	
	//
	// Set up a command cursor
	var setupCommand = function(bson, ns, cmd, cursorState, topology, options) {
	  // Set empty options object
	  options = options || {}
	  // Get the readPreference
	  var readPreference = getReadPreference(cmd, options);
	  // Final query
	  var finalCmd = {};
	  for(var name in cmd) {
	    finalCmd[name] = cmd[name];
	  }
	
	  // Build command namespace
	  var parts = ns.split(/\./);
	
	  // Throw on majority readConcern passed in
	  if(cmd.readConcern && cmd.readConcern.level != 'local') {
	    throw new MongoError(f('server %s command does not support a readConcern level of %s', JSON.stringify(cmd), cmd.readConcern.level));
	  }
	
	  // Remove readConcern, ensure no failing commands
	  if(cmd.readConcern) delete cmd['readConcern'];
	
	  // Serialize functions
	  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
	    ? options.serializeFunctions : false;
	
	  // Set up the serialize and ignoreUndefined fields
	  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
	    ? options.ignoreUndefined : false;
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos'
	    && readPreference
	    && readPreference.preference != 'primary') {
	    finalCmd = {
	      '$query': finalCmd,
	      '$readPreference': readPreference.toJSON()
	    };
	  }
	
	  // Build Query object
	  var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, {
	      numberToSkip: 0, numberToReturn: -1
	    , checkKeys: false, serializeFunctions: serializeFunctions
	    , ignoreUndefined: ignoreUndefined
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Return the query
	  return query;
	}
	
	/**
	 * @ignore
	 */
	var bindToCurrentDomain = function(callback) {
	  var domain = process.domain;
	  if(domain == null || callback == null) {
	    return callback;
	  } else {
	    return domain.bind(callback);
	  }
	}
	
	var hasWriteConcern = function(writeConcern) {
	  if(writeConcern.w
	    || writeConcern.wtimeout
	    || writeConcern.j == true
	    || writeConcern.fsync == true
	    || Object.keys(writeConcern).length == 0) {
	    return true;
	  }
	  return false;
	}
	
	var cloneWriteConcern = function(writeConcern) {
	  var wc = {};
	  if(writeConcern.w != null) wc.w = writeConcern.w;
	  if(writeConcern.wtimeout != null) wc.wtimeout = writeConcern.wtimeout;
	  if(writeConcern.j != null) wc.j = writeConcern.j;
	  if(writeConcern.fsync != null) wc.fsync = writeConcern.fsync;
	  return wc;
	}
	
	//
	// Aggregate up all the results
	//
	var aggregateWriteOperationResults = function(opType, ops, results, connection) {
	  var finalResult = { ok: 1, n: 0 }
	
	  // Map all the results coming back
	  for(var i = 0; i < results.length; i++) {
	    var result = results[i];
	    var op = ops[i];
	
	    if((result.upserted || (result.updatedExisting == false)) && finalResult.upserted == null) {
	      finalResult.upserted = [];
	    }
	
	    // Push the upserted document to the list of upserted values
	    if(result.upserted) {
	      finalResult.upserted.push({index: i, _id: result.upserted});
	    }
	
	    // We have an upsert where we passed in a _id
	    if(result.updatedExisting == false && result.n == 1 && result.upserted == null) {
	      finalResult.upserted.push({index: i, _id: op.q._id});
	    }
	
	    // We have an insert command
	    if(result.ok == 1 && opType == 'insert' && result.err == null) {
	      finalResult.n = finalResult.n + 1;
	    }
	
	    // We have a command error
	    if(result != null && result.ok == 0 || result.err || result.errmsg) {
	      if(result.ok == 0) finalResult.ok = 0;
	      finalResult.code = result.code;
	      finalResult.errmsg = result.errmsg || result.err || result.errMsg;
	
	      // Check if we have a write error
	      if(result.code == 11000
	        || result.code == 11001
	        || result.code == 12582
	        || result.code == 16544
	        || result.code == 16538
	        || result.code == 16542
	        || result.code == 14
	        || result.code == 13511) {
	        if(finalResult.writeErrors == null) finalResult.writeErrors = [];
	        finalResult.writeErrors.push({
	            index: i
	          , code: result.code
	          , errmsg: result.errmsg || result.err || result.errMsg
	        });
	      } else {
	        finalResult.writeConcernError = {
	            code: result.code
	          , errmsg: result.errmsg || result.err || result.errMsg
	        }
	      }
	    } else if(typeof result.n == 'number') {
	      finalResult.n += result.n;
	    } else {
	      finalResult.n += 1;
	    }
	
	    // Result as expected
	    if(result != null && result.lastOp) finalResult.lastOp = result.lastOp;
	  }
	
	  // Return finalResult aggregated results
	  return new CommandResult(finalResult, connection);
	}
	
	//
	// Execute all inserts in an ordered manner
	//
	var executeOrdered = function(opType ,command, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  var _ops = ops.slice(0);
	  // Bind to current domain
	  callback = bindToCurrentDomain(callback);
	  // Collect all the getLastErrors
	  var getLastErrors = [];
	
	  // Execute an operation
	  var executeOp = function(list, _callback) {
	    // No more items in the list
	    if(list.length == 0) {
	      return process.nextTick(function() {
	        _callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, null));
	      });
	    }
	
	    // Get the first operation
	    var doc = list.shift();
	    // Create an insert command
	    var op = new command(Query.getRequestId(), ismaster, bson, ns, [doc], options);
	    // Write concern
	    var optionWriteConcern = options.writeConcern || {w:1};
	    // Final write concern
	    var writeConcern = cloneWriteConcern(optionWriteConcern);
	
	    // Get the db name
	    var db = ns.split('.').shift();
	
	    try {
	      // Add binary message to list of commands to execute
	      var commands = [op.toBin()];
	
	      // If write concern 0 don't fire getLastError
	      if(hasWriteConcern(writeConcern)) {
	        var getLastErrorCmd = {getlasterror: 1};
	        // Merge all the fields
	        for(var i = 0; i < writeConcernFields.length; i++) {
	          if(writeConcern[writeConcernFields[i]] != null) {
	            getLastErrorCmd[writeConcernFields[i]] = writeConcern[writeConcernFields[i]];
	          }
	        }
	
	        // Create a getLastError command
	        var getLastErrorOp = new Query(bson, f("%s.$cmd", db), getLastErrorCmd, {numberToReturn: -1});
	        // Add getLastError command to list of ops to execute
	        commands.push(getLastErrorOp.toBin());
	
	        // getLastError callback
	        var getLastErrorCallback = function(err, result) {
	          if(err) return callback(err);
	          // Get the document
	          var doc = result.documents[0];
	          // Save the getLastError document
	          getLastErrors.push(doc);
	
	          // If we have an error terminate
	          if(doc.ok == 0 || doc.err || doc.errmsg) {
	            return callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, result.connection));
	          }
	
	          // Execute the next op in the list
	          executeOp(list, callback);
	        }
	
	        // Register the callback
	        callbacks.register(getLastErrorOp.requestId, getLastErrorCallback);
	        // Write both commands out at the same time
	        pool.write(commands, getLastErrorCallback);
	      } else {
	        // Write both commands out at the same time
	        pool.write(commands, callback, {immediateRelease:true});
	      }
	    } catch(err) {
	      if(typeof err == 'string') err = new MongoError(err);
	      // We have a serialization error, rewrite as a write error to have same behavior as modern
	      // write commands
	      getLastErrors.push({ ok: 1, errmsg: err.message, code: 14 });
	      // Return due to an error
	      process.nextTick(function() {
	        callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, null));
	      });
	    }
	  }
	
	  // Execute the operations
	  executeOp(_ops, callback);
	}
	
	var executeUnordered = function(opType, command, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  // Bind to current domain
	  callback = bindToCurrentDomain(callback);
	  // Total operations to write
	  var totalOps = ops.length;
	  // Collect all the getLastErrors
	  var getLastErrors = [];
	  // Write concern
	  var optionWriteConcern = options.writeConcern || {w:1};
	  // Final write concern
	  var writeConcern = cloneWriteConcern(optionWriteConcern);
	  // Driver level error
	  var error;
	
	  // Execute all the operations
	  for(var i = 0; i < ops.length; i++) {
	    // Create an insert command
	    var op = new command(Query.getRequestId(), ismaster, bson, ns, [ops[i]], options);
	    // Get db name
	    var db = ns.split('.').shift();
	
	    try {
	      // Add binary message to list of commands to execute
	      var commands = [op.toBin()];
	
	      // If write concern 0 don't fire getLastError
	      if(hasWriteConcern(writeConcern)) {
	        var getLastErrorCmd = {getlasterror: 1};
	        // Merge all the fields
	        for(var j = 0; j < writeConcernFields.length; j++) {
	          if(writeConcern[writeConcernFields[j]] != null)
	            getLastErrorCmd[writeConcernFields[j]] = writeConcern[writeConcernFields[j]];
	        }
	
	        // Create a getLastError command
	        var getLastErrorOp = new Query(bson, f("%s.$cmd", db), getLastErrorCmd, {numberToReturn: -1});
	        // Add getLastError command to list of ops to execute
	        commands.push(getLastErrorOp.toBin());
	
	        // Give the result from getLastError the right index
	        var callbackOp = function(_index) {
	          return function(err, result) {
	            if(err) error = err;
	            // Update the number of operations executed
	            totalOps = totalOps - 1;
	            // Save the getLastError document
	            if(!err) getLastErrors[_index] = result.documents[0];
	            // Check if we are done
	            if(totalOps == 0) {
	              process.nextTick(function() {
	                if(error) return callback(error);
	                callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, result.connection));
	              });
	            }
	          }
	        }
	
	        // Register the callback
	        callbacks.register(getLastErrorOp.requestId, callbackOp(i));
	        // Write both commands out at the same time
	        pool.write(commands, callbackOp(i));
	      } else {
	        // Write both commands out at the same time
	        pool.write(commands, callback, {immediateRelease:true});
	      }
	    } catch(err) {
	      if(typeof err == 'string') err = new MongoError(err);
	      // Update the number of operations executed
	      totalOps = totalOps - 1;
	      // We have a serialization error, rewrite as a write error to have same behavior as modern
	      // write commands
	      getLastErrors[i] = { ok: 1, errmsg: err.message, code: 14 };
	      // Check if we are done
	      if(totalOps == 0) {
	        callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, null));
	      }
	    }
	  }
	
	  // Empty w:0 return
	  if(writeConcern
	    && writeConcern.w == 0 && callback) {
	    callback(null, null);
	  }
	}
	
	module.exports = WireProtocol;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";
	
	var MongoError = __webpack_require__(157);
	
	// Wire command operation ids
	var OP_UPDATE = 2001;
	var OP_INSERT = 2002;
	var OP_DELETE = 2006;
	
	var Insert = function(requestId, ismaster, bson, ns, documents, options) {
	  // Basic options needed to be passed in
	  if(ns == null) throw new MongoError("ns must be specified for query");
	  if(!Array.isArray(documents) || documents.length == 0) throw new MongoError("documents array must contain at least one document to insert");
	
	  // Validate that we are not passing 0x00 in the colletion name
	  if(!!~ns.indexOf("\x00")) {
	    throw new MongoError("namespace cannot contain a null character");
	  }
	
	  // Set internal
	  this.requestId = requestId;
	  this.bson = bson;
	  this.ns = ns;
	  this.documents = documents;
	  this.ismaster = ismaster;
	
	  // Ensure empty options
	  options = options || {};
	
	  // Unpack options
	  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
	  this.ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
	  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : true;
	  this.continueOnError = typeof options.continueOnError == 'boolean' ? options.continueOnError : false;
	  // Set flags
	  this.flags = this.continueOnError ? 1 : 0;
	}
	
	// To Binary
	Insert.prototype.toBin = function() {
	  // Contains all the buffers to be written
	  var buffers = [];
	
	  // Header buffer
	  var header = new Buffer(
	    4 * 4 // Header
	    + 4   // Flags
	    + Buffer.byteLength(this.ns) + 1 // namespace
	  );
	
	  // Add header to buffers
	  buffers.push(header);
	
	  // Total length of the message
	  var totalLength = header.length;
	
	  // Serialize all the documents
	  for(var i = 0; i < this.documents.length; i++) {
	    var buffer = this.bson.serialize(this.documents[i]
	      , this.checkKeys
	      , true
	      , this.serializeFunctions
	      , 0, this.ignoreUndefined);
	
	    // Document is larger than maxBsonObjectSize, terminate serialization
	    if(buffer.length > this.ismaster.maxBsonObjectSize) {
	      throw new MongoError("Document exceeds maximum allowed bson size of " + this.ismaster.maxBsonObjectSize + " bytes");
	    }
	
	    // Add to total length of wire protocol message
	    totalLength = totalLength + buffer.length;
	    // Add to buffer
	    buffers.push(buffer);
	  }
	
	  // Command is larger than maxMessageSizeBytes terminate serialization
	  if(totalLength > this.ismaster.maxMessageSizeBytes) {
	    throw new MongoError("Command exceeds maximum message size of " + this.ismaster.maxMessageSizeBytes + " bytes");
	  }
	
	  // Add all the metadata
	  var index = 0;
	
	  // Write header length
	  header[index + 3] = (totalLength >> 24) & 0xff;
	  header[index + 2] = (totalLength >> 16) & 0xff;
	  header[index + 1] = (totalLength >> 8) & 0xff;
	  header[index] = (totalLength) & 0xff;
	  index = index + 4;
	
	  // Write header requestId
	  header[index + 3] = (this.requestId >> 24) & 0xff;
	  header[index + 2] = (this.requestId >> 16) & 0xff;
	  header[index + 1] = (this.requestId >> 8) & 0xff;
	  header[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // No flags
	  header[index + 3] = (0 >> 24) & 0xff;
	  header[index + 2] = (0 >> 16) & 0xff;
	  header[index + 1] = (0 >> 8) & 0xff;
	  header[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Operation
	  header[index + 3] = (OP_INSERT >> 24) & 0xff;
	  header[index + 2] = (OP_INSERT >> 16) & 0xff;
	  header[index + 1] = (OP_INSERT >> 8) & 0xff;
	  header[index] = (OP_INSERT) & 0xff;
	  index = index + 4;
	
	  // Flags
	  header[index + 3] = (this.flags >> 24) & 0xff;
	  header[index + 2] = (this.flags >> 16) & 0xff;
	  header[index + 1] = (this.flags >> 8) & 0xff;
	  header[index] = (this.flags) & 0xff;
	  index = index + 4;
	
	  // Write collection name
	  index = index + header.write(this.ns, index, 'utf8') + 1;
	  header[index - 1] = 0;
	
	  // Return the buffers
	  return buffers;
	}
	
	var Update = function(requestId, ismaster, bson, ns, update, options) {
	  // Basic options needed to be passed in
	  if(ns == null) throw new MongoError("ns must be specified for query");
	
	  // Ensure empty options
	  options = options || {};
	
	  // Set internal
	  this.requestId = requestId;
	  this.bson = bson;
	  this.ns = ns;
	  this.ismaster = ismaster;
	
	  // Unpack options
	  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
	  this.ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
	  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : false;
	
	  // Unpack the update document
	  this.upsert = typeof update[0].upsert == 'boolean' ? update[0].upsert : false;
	  this.multi = typeof update[0].multi == 'boolean' ? update[0].multi : false;
	  this.q = update[0].q;
	  this.u = update[0].u;
	
	  // Create flag value
	  this.flags = this.upsert ? 1 : 0;
	  this.flags = this.multi ? this.flags | 2 : this.flags;
	}
	
	// To Binary
	Update.prototype.toBin = function() {
	  // Contains all the buffers to be written
	  var buffers = [];
	
	  // Header buffer
	  var header = new Buffer(
	    4 * 4 // Header
	    + 4   // ZERO
	    + Buffer.byteLength(this.ns) + 1 // namespace
	    + 4   // Flags
	  );
	
	  // Add header to buffers
	  buffers.push(header);
	
	  // Total length of the message
	  var totalLength = header.length;
	
	  // Serialize the selector
	  var selector = this.bson.serialize(this.q
	    , this.checkKeys
	    , true
	    , this.serializeFunctions
	    , 0, this.ignoreUndefined);
	  buffers.push(selector);
	  totalLength = totalLength + selector.length;
	
	  // Serialize the update
	  var update = this.bson.serialize(this.u
	    , this.checkKeys
	    , true
	    , this.serializeFunctions
	    , 0, this.ignoreUndefined);
	  buffers.push(update);
	  totalLength = totalLength + update.length;
	
	  // Index in header buffer
	  var index = 0;
	
	  // Write header length
	  header[index + 3] = (totalLength >> 24) & 0xff;
	  header[index + 2] = (totalLength >> 16) & 0xff;
	  header[index + 1] = (totalLength >> 8) & 0xff;
	  header[index] = (totalLength) & 0xff;
	  index = index + 4;
	
	  // Write header requestId
	  header[index + 3] = (this.requestId >> 24) & 0xff;
	  header[index + 2] = (this.requestId >> 16) & 0xff;
	  header[index + 1] = (this.requestId >> 8) & 0xff;
	  header[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // No flags
	  header[index + 3] = (0 >> 24) & 0xff;
	  header[index + 2] = (0 >> 16) & 0xff;
	  header[index + 1] = (0 >> 8) & 0xff;
	  header[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Operation
	  header[index + 3] = (OP_UPDATE >> 24) & 0xff;
	  header[index + 2] = (OP_UPDATE >> 16) & 0xff;
	  header[index + 1] = (OP_UPDATE >> 8) & 0xff;
	  header[index] = (OP_UPDATE) & 0xff;
	  index = index + 4;
	
	  // Write ZERO
	  header[index + 3] = (0 >> 24) & 0xff;
	  header[index + 2] = (0 >> 16) & 0xff;
	  header[index + 1] = (0 >> 8) & 0xff;
	  header[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Write collection name
	  index = index + header.write(this.ns, index, 'utf8') + 1;
	  header[index - 1] = 0;
	
	  // Flags
	  header[index + 3] = (this.flags >> 24) & 0xff;
	  header[index + 2] = (this.flags >> 16) & 0xff;
	  header[index + 1] = (this.flags >> 8) & 0xff;
	  header[index] = (this.flags) & 0xff;
	  index = index + 4;
	
	  // Return the buffers
	  return buffers;
	}
	
	var Remove = function(requestId, ismaster, bson, ns, remove, options) {
	  // Basic options needed to be passed in
	  if(ns == null) throw new MongoError("ns must be specified for query");
	
	  // Ensure empty options
	  options = options || {};
	
	  // Set internal
	  this.requestId = requestId;
	  this.bson = bson;
	  this.ns = ns;
	  this.ismaster = ismaster;
	
	  // Unpack options
	  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
	  this.ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
	  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : false;
	
	  // Unpack the update document
	  this.limit = typeof remove[0].limit == 'number' ? remove[0].limit : 1;
	  this.q = remove[0].q;
	
	  // Create flag value
	  this.flags = this.limit == 1 ? 1 : 0;
	}
	
	// To Binary
	Remove.prototype.toBin = function() {
	  // Contains all the buffers to be written
	  var buffers = [];
	
	  // Header buffer
	  var header = new Buffer(
	    4 * 4 // Header
	    + 4   // ZERO
	    + Buffer.byteLength(this.ns) + 1 // namespace
	    + 4   // Flags
	  );
	
	  // Add header to buffers
	  buffers.push(header);
	
	  // Total length of the message
	  var totalLength = header.length;
	
	  // Serialize the selector
	  var selector = this.bson.serialize(this.q
	    , this.checkKeys
	    , true
	    , this.serializeFunctions
	    , 0, this.ignoreUndefined);
	  buffers.push(selector);
	  totalLength = totalLength + selector.length;
	
	  // Index in header buffer
	  var index = 0;
	
	  // Write header length
	  header[index + 3] = (totalLength >> 24) & 0xff;
	  header[index + 2] = (totalLength >> 16) & 0xff;
	  header[index + 1] = (totalLength >> 8) & 0xff;
	  header[index] = (totalLength) & 0xff;
	  index = index + 4;
	
	  // Write header requestId
	  header[index + 3] = (this.requestId >> 24) & 0xff;
	  header[index + 2] = (this.requestId >> 16) & 0xff;
	  header[index + 1] = (this.requestId >> 8) & 0xff;
	  header[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // No flags
	  header[index + 3] = (0 >> 24) & 0xff;
	  header[index + 2] = (0 >> 16) & 0xff;
	  header[index + 1] = (0 >> 8) & 0xff;
	  header[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Operation
	  header[index + 3] = (OP_DELETE >> 24) & 0xff;
	  header[index + 2] = (OP_DELETE >> 16) & 0xff;
	  header[index + 1] = (OP_DELETE >> 8) & 0xff;
	  header[index] = (OP_DELETE) & 0xff;
	  index = index + 4;
	
	  // Write ZERO
	  header[index + 3] = (0 >> 24) & 0xff;
	  header[index + 2] = (0 >> 16) & 0xff;
	  header[index + 1] = (0 >> 8) & 0xff;
	  header[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Write collection name
	  index = index + header.write(this.ns, index, 'utf8') + 1;
	  header[index - 1] = 0;
	
	  // Write ZERO
	  header[index + 3] = (this.flags >> 24) & 0xff;
	  header[index + 2] = (this.flags >> 16) & 0xff;
	  header[index + 1] = (this.flags >> 8) & 0xff;
	  header[index] = (this.flags) & 0xff;
	  index = index + 4;
	
	  // Return the buffers
	  return buffers;
	}
	
	module.exports = {
	    Insert: Insert
	  , Update: Update
	  , Remove: Remove
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	var ReadPreference = __webpack_require__(164);
	
	var getReadPreference = function(cmd, options) {
	  // Default to command version of the readPreference
	  var readPreference = cmd.readPreference || new ReadPreference('primary');
	  // If we have an option readPreference override the command one
	  if(options.readPreference) {
	    readPreference = options.readPreference;
	  }
	
	  if(typeof readPreference == 'string') {
	    readPreference = new ReadPreference(readPreference);
	  }
	
	  if(!(readPreference instanceof ReadPreference)) {
	    throw new MongoError('readPreference must be a ReadPreference instance');
	  }
	
	  return readPreference;
	}
	
	module.exports = {
	  getReadPreference: getReadPreference
	}


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var Insert = __webpack_require__(168).Insert
	  , Update = __webpack_require__(168).Update
	  , Remove = __webpack_require__(168).Remove
	  , Query = __webpack_require__(162).Query
	  , copy = __webpack_require__(159).copy
	  , KillCursor = __webpack_require__(162).KillCursor
	  , GetMore = __webpack_require__(162).GetMore
	  , Query = __webpack_require__(162).Query
	  , ReadPreference = __webpack_require__(164)
	  , f = __webpack_require__(77).format
	  , CommandResult = __webpack_require__(166)
	  , MongoError = __webpack_require__(157)
	  , Long = __webpack_require__(134).Long
	  , getReadPreference = __webpack_require__(169).getReadPreference;
	
	var WireProtocol = function() {}
	
	//
	// Execute a write operation
	var executeWrite = function(topology, type, opsField, ns, ops, options, callback) {
	  if(ops.length == 0) throw new MongoError("insert must contain at least one document");
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  // Split the ns up to get db and collection
	  var p = ns.split(".");
	  var d = p.shift();
	  // Options
	  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
	  var writeConcern = options.writeConcern || {};
	  // return skeleton
	  var writeCommand = {};
	  writeCommand[type] = p.join('.');
	  writeCommand[opsField] = ops;
	  writeCommand.ordered = ordered;
	
	  // Did we specify a write concern
	  if(writeConcern && Object.keys(writeConcern).length > 0) {
	    writeCommand.writeConcern = writeConcern;
	  }
	
	  // Options object
	  var opts = {};
	  if(type == 'insert') opts.checkKeys = true;
	  // Ensure we support serialization of functions
	  if(options.serializeFunctions) opts.serializeFunctions = options.serializeFunctions;
	  if(options.ignoreUndefined) opts.ignoreUndefined = options.ignoreUndefined;
	  // Execute command
	  topology.command(f("%s.$cmd", d), writeCommand, opts, callback);
	}
	
	//
	// Needs to support legacy mass insert as well as ordered/unordered legacy
	// emulation
	//
	WireProtocol.prototype.insert = function(topology, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  executeWrite(topology, 'insert', 'documents', ns, ops, options, callback);
	}
	
	WireProtocol.prototype.update = function(topology, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  executeWrite(topology, 'update', 'updates', ns, ops, options, callback);
	}
	
	WireProtocol.prototype.remove = function(topology, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  executeWrite(topology, 'delete', 'deletes', ns, ops, options, callback);
	}
	
	WireProtocol.prototype.killCursor = function(bson, ns, cursorId, pool, callbacks, callback) {
	  // Create a kill cursor command
	  var killCursor = new KillCursor(bson, [cursorId]);
	  // Execute the kill cursor command
	  if(pool && pool.isConnected()) pool.write(killCursor.toBin(), callback, {immediateRelease:true});
	  // Set cursor to 0
	  cursorId = Long.ZERO;
	  // Return to caller
	  if(callback) callback(null, null);
	}
	
	WireProtocol.prototype.getMore = function(bson, ns, cursorState, batchSize, raw, connection, callbacks, options, callback) {
	  // Create getMore command
	  var getMore = new GetMore(bson, ns, cursorState.cursorId, {numberToReturn: batchSize});
	
	  // Query callback
	  var queryCallback = function(err, r) {
	    if(err) return callback(err);
	
	    // If we have a timed out query or a cursor that was killed
	    if((r.responseFlags & (1 << 0)) != 0) {
	      return callback(new MongoError("cursor killed or timed out"), null);
	    }
	
	    // Ensure we have a Long valie cursor id
	    var cursorId = typeof r.cursorId == 'number'
	      ? Long.fromNumber(r.cursorId)
	      : r.cursorId;
	
	    // Set all the values
	    cursorState.documents = r.documents;
	    cursorState.cursorId = cursorId;
	
	    // Return
	    callback(null, null, r.connection);
	  }
	
	  // If we have a raw query decorate the function
	  if(raw) {
	    queryCallback.raw = raw;
	  }
	
	  // Check if we need to promote longs
	  if(typeof cursorState.promoteLongs == 'boolean') {
	    queryCallback.promoteLongs = cursorState.promoteLongs;
	  }
	
	  // Register a callback
	  callbacks.register(getMore.requestId, queryCallback);
	  // Write out the getMore command
	  connection.write(getMore.toBin(), queryCallback);
	}
	
	WireProtocol.prototype.command = function(bson, ns, cmd, cursorState, topology, options) {
	  // Establish type of command
	  if(cmd.find) {
	    return setupClassicFind(bson, ns, cmd, cursorState, topology, options)
	  } else if(cursorState.cursorId != null) {
	  } else if(cmd) {
	    return setupCommand(bson, ns, cmd, cursorState, topology, options);
	  } else {
	    throw new MongoError(f("command %s does not return a cursor", JSON.stringify(cmd)));
	  }
	}
	
	//
	// Execute a find command
	var setupClassicFind = function(bson, ns, cmd, cursorState, topology, options) {
	  // Ensure we have at least some options
	  options = options || {};
	  // Get the readPreference
	  var readPreference = getReadPreference(cmd, options);
	  // Set the optional batchSize
	  cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
	  var numberToReturn = 0;
	
	  // Unpack the limit and batchSize values
	  if(cursorState.limit == 0) {
	    numberToReturn = cursorState.batchSize;
	  } else if(cursorState.limit < 0 || cursorState.limit < cursorState.batchSize || (cursorState.limit > 0 && cursorState.batchSize == 0)) {
	    numberToReturn = cursorState.limit;
	  } else {
	    numberToReturn = cursorState.batchSize;
	  }
	
	  var numberToSkip = cursorState.skip || 0;
	  // Build actual find command
	  var findCmd = {};
	  // Using special modifier
	  var usesSpecialModifier = false;
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos' && readPreference) {
	    findCmd['$readPreference'] = readPreference.toJSON();
	    usesSpecialModifier = true;
	  }
	
	  // Add special modifiers to the query
	  if(cmd.sort) findCmd['orderby'] = cmd.sort, usesSpecialModifier = true;
	  if(cmd.hint) findCmd['$hint'] = cmd.hint, usesSpecialModifier = true;
	  if(cmd.snapshot) findCmd['$snapshot'] = cmd.snapshot, usesSpecialModifier = true;
	  if(cmd.returnKey) findCmd['$returnKey'] = cmd.returnKey, usesSpecialModifier = true;
	  if(cmd.maxScan) findCmd['$maxScan'] = cmd.maxScan, usesSpecialModifier = true;
	  if(cmd.min) findCmd['$min'] = cmd.min, usesSpecialModifier = true;
	  if(cmd.max) findCmd['$max'] = cmd.max, usesSpecialModifier = true;
	  if(cmd.showDiskLoc) findCmd['$showDiskLoc'] = cmd.showDiskLoc, usesSpecialModifier = true;
	  if(cmd.comment) findCmd['$comment'] = cmd.comment, usesSpecialModifier = true;
	  if(cmd.maxTimeMS) findCmd['$maxTimeMS'] = cmd.maxTimeMS, usesSpecialModifier = true;
	
	  if(cmd.explain) {
		// nToReturn must be 0 (match all) or negative (match N and close cursor)
		// nToReturn > 0 will give explain results equivalent to limit(0)
	    numberToReturn = -Math.abs(cmd.limit || 0);
	    usesSpecialModifier = true;
	    findCmd['$explain'] = true;
	  }
	
	  // If we have a special modifier
	  if(usesSpecialModifier) {
	    findCmd['$query'] = cmd.query;
	  } else {
	    findCmd = cmd.query;
	  }
	
	  // Throw on majority readConcern passed in
	  if(cmd.readConcern && cmd.readConcern.level != 'local') {
	    throw new MongoError(f('server find command does not support a readConcern level of %s', cmd.readConcern.level));
	  }
	
	  // Remove readConcern, ensure no failing commands
	  if(cmd.readConcern) {
	    cmd = copy(cmd);
	    delete cmd['readConcern'];
	  }
	
	  // Serialize functions
	  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
	    ? options.serializeFunctions : false;
	  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
	    ? options.ignoreUndefined : false;
	
	  // Build Query object
	  var query = new Query(bson, ns, findCmd, {
	      numberToSkip: numberToSkip, numberToReturn: numberToReturn
	    , checkKeys: false, returnFieldSelector: cmd.fields
	    , serializeFunctions: serializeFunctions
	    , ignoreUndefined: ignoreUndefined
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Set up the option bits for wire protocol
	  if(typeof cmd.tailable == 'boolean') {
	    query.tailable = cmd.tailable;
	  }
	
	  if(typeof cmd.oplogReplay == 'boolean') {
	    query.oplogReplay = cmd.oplogReplay;
	  }
	
	  if(typeof cmd.noCursorTimeout == 'boolean') {
	    query.noCursorTimeout = cmd.noCursorTimeout;
	  }
	
	  if(typeof cmd.awaitData == 'boolean') {
	    query.awaitData = cmd.awaitData;
	  }
	
	  if(typeof cmd.partial == 'boolean') {
	    query.partial = cmd.partial;
	  }
	
	  // Return the query
	  return query;
	}
	
	//
	// Set up a command cursor
	var setupCommand = function(bson, ns, cmd, cursorState, topology, options) {
	  // Set empty options object
	  options = options || {}
	  // Get the readPreference
	  var readPreference = getReadPreference(cmd, options);
	
	  // Final query
	  var finalCmd = {};
	  for(var name in cmd) {
	    finalCmd[name] = cmd[name];
	  }
	
	  // Build command namespace
	  var parts = ns.split(/\./);
	
	  // Serialize functions
	  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
	    ? options.serializeFunctions : false;
	
	  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
	    ? options.ignoreUndefined : false;
	
	  // Throw on majority readConcern passed in
	  if(cmd.readConcern && cmd.readConcern.level != 'local') {
	    throw new MongoError(f('server %s command does not support a readConcern level of %s', JSON.stringify(cmd), cmd.readConcern.level));
	  }
	
	  // Remove readConcern, ensure no failing commands
	  if(cmd.readConcern) delete cmd['readConcern'];
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos'
	    && readPreference
	    && readPreference.preference != 'primary') {
	    finalCmd = {
	      '$query': finalCmd,
	      '$readPreference': readPreference.toJSON()
	    };
	  }
	
	  // Build Query object
	  var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, {
	      numberToSkip: 0, numberToReturn: -1
	    , checkKeys: false, serializeFunctions: serializeFunctions
	    , ignoreUndefined: ignoreUndefined
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Return the query
	  return query;
	}
	
	/**
	 * @ignore
	 */
	var bindToCurrentDomain = function(callback) {
	  var domain = process.domain;
	  if(domain == null || callback == null) {
	    return callback;
	  } else {
	    return domain.bind(callback);
	  }
	}
	
	module.exports = WireProtocol;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var Insert = __webpack_require__(168).Insert
	  , Update = __webpack_require__(168).Update
	  , Remove = __webpack_require__(168).Remove
	  , Query = __webpack_require__(162).Query
	  , copy = __webpack_require__(159).copy
	  , KillCursor = __webpack_require__(162).KillCursor
	  , GetMore = __webpack_require__(162).GetMore
	  , Query = __webpack_require__(162).Query
	  , ReadPreference = __webpack_require__(164)
	  , f = __webpack_require__(77).format
	  , CommandResult = __webpack_require__(166)
	  , MongoError = __webpack_require__(157)
	  , Long = __webpack_require__(134).Long
	  , getReadPreference = __webpack_require__(169).getReadPreference;
	
	var WireProtocol = function(legacyWireProtocol) {
	  this.legacyWireProtocol = legacyWireProtocol;
	}
	
	//
	// Execute a write operation
	var executeWrite = function(topology, type, opsField, ns, ops, options, callback) {
	  if(ops.length == 0) throw new MongoError("insert must contain at least one document");
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  // Split the ns up to get db and collection
	  var p = ns.split(".");
	  var d = p.shift();
	  // Options
	  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
	  var writeConcern = options.writeConcern;
	
	  // return skeleton
	  var writeCommand = {};
	  writeCommand[type] = p.join('.');
	  writeCommand[opsField] = ops;
	  writeCommand.ordered = ordered;
	
	  // Did we specify a write concern
	  if(writeConcern && Object.keys(writeConcern).length > 0) {
	    writeCommand.writeConcern = writeConcern;
	  }
	
	  // Do we have bypassDocumentValidation set, then enable it on the write command
	  if(typeof options.bypassDocumentValidation == 'boolean') {
	    writeCommand.bypassDocumentValidation = options.bypassDocumentValidation;
	  }
	
	  // Options object
	  var opts = {};
	  if(type == 'insert') opts.checkKeys = true;
	  // Ensure we support serialization of functions
	  if(options.serializeFunctions) opts.serializeFunctions = options.serializeFunctions;
	  if(options.ignoreUndefined) opts.ignoreUndefined = options.ignoreUndefined;
	  // Execute command
	  topology.command(f("%s.$cmd", d), writeCommand, opts, callback);
	}
	
	//
	// Needs to support legacy mass insert as well as ordered/unordered legacy
	// emulation
	//
	WireProtocol.prototype.insert = function(topology, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  executeWrite(topology, 'insert', 'documents', ns, ops, options, callback);
	}
	
	WireProtocol.prototype.update = function(topology, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  executeWrite(topology, 'update', 'updates', ns, ops, options, callback);
	}
	
	WireProtocol.prototype.remove = function(topology, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  executeWrite(topology, 'delete', 'deletes', ns, ops, options, callback);
	}
	
	WireProtocol.prototype.killCursor = function(bson, ns, cursorId, pool, callbacks, callback) {
	  // Build command namespace
	  var parts = ns.split(/\./);
	  // Command namespace
	  var commandns = f('%s.$cmd', parts.shift());
	  // Create getMore command
	  var killcursorCmd = {
	    killCursors: parts.join('.'),
	    cursors: [cursorId]
	  }
	
	  // Build Query object
	  var query = new Query(bson, commandns, killcursorCmd, {
	      numberToSkip: 0, numberToReturn: -1
	    , checkKeys: false, returnFieldSelector: null
	  });
	
	  // Set query flags
	  query.slaveOk = true;
	
	  // Execute the kill cursor command
	  if(pool && pool.isConnected()) {
	    pool.write(query.toBin(), callback);
	  }
	
	  // Kill cursor callback
	  var killCursorCallback = function(err, r) {
	    if(err) {
	      if(typeof callback != 'function') return;
	      return callback(err);
	    }
	
	    // If we have a timed out query or a cursor that was killed
	    if((r.responseFlags & (1 << 0)) != 0) {
	      if(typeof callback != 'function') return;
	      return callback(new MongoError("cursor killed or timed out"), null);
	    }
	
	    if(!Array.isArray(r.documents) || r.documents.length == 0) {
	      if(typeof callback != 'function') return;
	      return callback(new MongoError(f('invalid killCursors result returned for cursor id %s', cursorState.cursorId)));
	    }
	
	    // Return the result
	    if(typeof callback == 'function') {
	      callback(null, r.documents[0]);
	    }
	  }
	
	  // Register a callback
	  callbacks.register(query.requestId, killCursorCallback);
	}
	
	WireProtocol.prototype.getMore = function(bson, ns, cursorState, batchSize, raw, connection, callbacks, options, callback) {
	  options = options || {};
	  // Build command namespace
	  var parts = ns.split(/\./);
	  // Command namespace
	  var commandns = f('%s.$cmd', parts.shift());
	
	  // Check if we have an maxTimeMS set
	  var maxTimeMS = typeof cursorState.cmd.maxTimeMS == 'number' ? cursorState.cmd.maxTimeMS : 3000;
	
	  // Create getMore command
	  var getMoreCmd = {
	    getMore: cursorState.cursorId,
	    collection: parts.join('.'),
	    batchSize: Math.abs(batchSize)
	  }
	
	  if(cursorState.cmd.tailable
	    && typeof cursorState.cmd.maxAwaitTimeMS == 'number') {
	    getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;
	  }
	
	  // Build Query object
	  var query = new Query(bson, commandns, getMoreCmd, {
	      numberToSkip: 0, numberToReturn: -1
	    , checkKeys: false, returnFieldSelector: null
	  });
	
	  // Set query flags
	  query.slaveOk = true;
	
	  // Query callback
	  var queryCallback = function(err, r) {
	    if(err) return callback(err);
	
	    // If we have a timed out query or a cursor that was killed
	    if((r.responseFlags & (1 << 0)) != 0) {
	      return callback(new MongoError("cursor killed or timed out"), null);
	    }
	
	    // Raw, return all the extracted documents
	    if(raw) {
	      cursorState.documents = r.documents;
	      cursorState.cursorId = r.cursorId;
	      return callback(null, r.documents);
	    }
	
	    // We have an error detected
	    if(r.documents[0].ok == 0) {
	      return callback(MongoError.create(r.documents[0]));
	    }
	
	    // Ensure we have a Long valid cursor id
	    var cursorId = typeof r.documents[0].cursor.id == 'number'
	      ? Long.fromNumber(r.documents[0].cursor.id)
	      : r.documents[0].cursor.id;
	
	    // Set all the values
	    cursorState.documents = r.documents[0].cursor.nextBatch;
	    cursorState.cursorId = cursorId;
	
	    // Return the result
	    callback(null, r.documents[0], r.connection);
	  }
	
	  // If we have a raw query decorate the function
	  if(raw) {
	    queryCallback.raw = raw;
	  }
	
	  // Add the result field needed
	  queryCallback.documentsReturnedIn = 'nextBatch';
	
	  // Check if we need to promote longs
	  if(typeof cursorState.promoteLongs == 'boolean') {
	    queryCallback.promoteLongs = cursorState.promoteLongs;
	  }
	
	  // Register a callback
	  callbacks.register(query.requestId, queryCallback);
	  // Write out the getMore command
	  connection.write(query.toBin(), queryCallback);
	}
	
	WireProtocol.prototype.command = function(bson, ns, cmd, cursorState, topology, options) {
	  // Establish type of command
	  if(cmd.find) {
	    // Create the find command
	    var query = executeFindCommand(bson, ns, cmd, cursorState, topology, options)
	    // Mark the cmd as virtual
	    cmd.virtual = false;
	    // Signal the documents are in the firstBatch value
	    query.documentsReturnedIn = 'firstBatch';
	    // Return the query
	    return query;
	  } else if(cursorState.cursorId != null) {
	  } else if(cmd) {
	    return setupCommand(bson, ns, cmd, cursorState, topology, options);
	  } else {
	    throw new MongoError(f("command %s does not return a cursor", JSON.stringify(cmd)));
	  }
	}
	
	// // Command
	// {
	//     find: ns
	//   , query: <object>
	//   , limit: <n>
	//   , fields: <object>
	//   , skip: <n>
	//   , hint: <string>
	//   , explain: <boolean>
	//   , snapshot: <boolean>
	//   , batchSize: <n>
	//   , returnKey: <boolean>
	//   , maxScan: <n>
	//   , min: <n>
	//   , max: <n>
	//   , showDiskLoc: <boolean>
	//   , comment: <string>
	//   , maxTimeMS: <n>
	//   , raw: <boolean>
	//   , readPreference: <ReadPreference>
	//   , tailable: <boolean>
	//   , oplogReplay: <boolean>
	//   , noCursorTimeout: <boolean>
	//   , awaitdata: <boolean>
	//   , exhaust: <boolean>
	//   , partial: <boolean>
	// }
	
	// FIND/GETMORE SPEC
	// {
	//     find: <string>,
	//     filter: { ... },
	//     sort: { ... },
	//     projection: { ... },
	//     hint: { ... },
	//     skip: <int>,
	//     limit: <int>,
	//     batchSize: <int>,
	//     singleBatch: <bool>,
	//     comment: <string>,
	//     maxScan: <int>,
	//     maxTimeMS: <int>,
	//     max: { ... },
	//     min: { ... },
	//     returnKey: <bool>,
	//     showRecordId: <bool>,
	//     snapshot: <bool>,
	//     tailable: <bool>,
	//     oplogReplay: <bool>,
	//     noCursorTimeout: <bool>,
	//     awaitData: <bool>,
	//     partial: <bool>,
	//     $readPreference: { ... }
	// }
	
	//
	// Execute a find command
	var executeFindCommand = function(bson, ns, cmd, cursorState, topology, options) {
	  // Ensure we have at least some options
	  options = options || {};
	  // Get the readPreference
	  var readPreference = getReadPreference(cmd, options);
	  // Set the optional batchSize
	  cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
	
	  // Build command namespace
	  var parts = ns.split(/\./);
	  // Command namespace
	  var commandns = f('%s.$cmd', parts.shift());
	
	  // Build actual find command
	  var findCmd = {
	    find: parts.join('.')
	  };
	
	  // I we provided a filter
	  if(cmd.query) {
	    // Check if the user is passing in the $query parameter
	    if(cmd.query['$query']) {
	      findCmd.filter = cmd.query['$query'];
	    } else {
	      findCmd.filter = cmd.query;
	    }
	  }
	
	  // Sort value
	  var sortValue = cmd.sort;
	
	  // Handle issue of sort being an Array
	  if(Array.isArray(sortValue)) {
	    var sortObject = {};
	
	    if(sortValue.length > 0 && !Array.isArray(sortValue[0])) {
	      var sortDirection = sortValue[1];
	      // Translate the sort order text
	      if(sortDirection == 'asc') {
	        sortDirection = 1;
	      } else if(sortDirection == 'desc') {
	        sortDirection = -1;
	      }
	
	      // Set the sort order
	      sortObject[sortValue[0]] = sortDirection;
	    } else {
	      for(var i = 0; i < sortValue.length; i++) {
	        var sortDirection = sortValue[i][1];
	        // Translate the sort order text
	        if(sortDirection == 'asc') {
	          sortDirection = 1;
	        } else if(sortDirection == 'desc') {
	          sortDirection = -1;
	        }
	
	        // Set the sort order
	        sortObject[sortValue[i][0]] = sortDirection;
	      }
	    }
	
	    sortValue = sortObject;
	  };
	
	  // Add sort to command
	  if(cmd.sort) findCmd.sort = sortValue;
	  // Add a projection to the command
	  if(cmd.fields) findCmd.projection = cmd.fields;
	  // Add a hint to the command
	  if(cmd.hint) findCmd.hint = cmd.hint;
	  // Add a skip
	  if(cmd.skip) findCmd.skip = cmd.skip;
	  // Add a limit
	  if(cmd.limit) findCmd.limit = cmd.limit;
	  // Add a batchSize
	  if(typeof cmd.batchSize == 'number') findCmd.batchSize = Math.abs(cmd.batchSize);
	
	  // Check if we wish to have a singleBatch
	  if(cmd.limit < 0) {
	    findCmd.limit = Math.abs(cmd.limit);
	    findCmd.singleBatch = true;
	  }
	
	  // If we have comment set
	  if(cmd.comment) findCmd.comment = cmd.comment;
	
	  // If we have maxScan
	  if(cmd.maxScan) findCmd.maxScan = cmd.maxScan;
	
	  // If we have maxTimeMS set
	  if(cmd.maxTimeMS) findCmd.maxTimeMS = cmd.maxTimeMS;
	
	  // If we have min
	  if(cmd.min) findCmd.min = cmd.min;
	
	  // If we have max
	  if(cmd.max) findCmd.max = cmd.max;
	
	  // If we have returnKey set
	  if(cmd.returnKey) findCmd.returnKey = cmd.returnKey;
	
	  // If we have showDiskLoc set
	  if(cmd.showDiskLoc) findCmd.showRecordId = cmd.showDiskLoc;
	
	  // If we have snapshot set
	  if(cmd.snapshot) findCmd.snapshot = cmd.snapshot;
	
	  // If we have tailable set
	  if(cmd.tailable) findCmd.tailable = cmd.tailable;
	
	  // If we have oplogReplay set
	  if(cmd.oplogReplay) findCmd.oplogReplay = cmd.oplogReplay;
	
	  // If we have noCursorTimeout set
	  if(cmd.noCursorTimeout) findCmd.noCursorTimeout = cmd.noCursorTimeout;
	
	  // If we have awaitData set
	  if(cmd.awaitData) findCmd.awaitData = cmd.awaitData;
	  if(cmd.awaitdata) findCmd.awaitData = cmd.awaitdata;
	
	  // If we have partial set
	  if(cmd.partial) findCmd.partial = cmd.partial;
	
	  // If we have explain, we need to rewrite the find command
	  // to wrap it in the explain command
	  if(cmd.explain) {
	    findCmd = {
	      explain: findCmd
	    }
	  }
	
	  // Did we provide a readConcern
	  if(cmd.readConcern) findCmd.readConcern = cmd.readConcern;
	
	  // Set up the serialize and ignoreUndefined fields
	  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
	    ? options.serializeFunctions : false;
	  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
	    ? options.ignoreUndefined : false;
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos'
	    && readPreference
	    && readPreference.preference != 'primary') {
	    findCmd = {
	      '$query': findCmd,
	      '$readPreference': readPreference.toJSON()
	    };
	  }
	
	  // Build Query object
	  var query = new Query(bson, commandns, findCmd, {
	      numberToSkip: 0, numberToReturn: -1
	    , checkKeys: false, returnFieldSelector: null
	    , serializeFunctions: serializeFunctions, ignoreUndefined: ignoreUndefined
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Return the query
	  return query;
	}
	
	//
	// Set up a command cursor
	var setupCommand = function(bson, ns, cmd, cursorState, topology, options) {
	  // Set empty options object
	  options = options || {}
	  // Get the readPreference
	  var readPreference = getReadPreference(cmd, options);
	
	  // Final query
	  var finalCmd = {};
	  for(var name in cmd) {
	    finalCmd[name] = cmd[name];
	  }
	
	  // Build command namespace
	  var parts = ns.split(/\./);
	
	  // Serialize functions
	  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
	    ? options.serializeFunctions : false;
	
	  // Set up the serialize and ignoreUndefined fields
	  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
	    ? options.ignoreUndefined : false;
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos'
	    && readPreference
	    && readPreference.preference != 'primary') {
	    finalCmd = {
	      '$query': finalCmd,
	      '$readPreference': readPreference.toJSON()
	    };
	  }
	
	  // Build Query object
	  var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, {
	      numberToSkip: 0, numberToReturn: -1
	    , checkKeys: false, serializeFunctions: serializeFunctions
	    , ignoreUndefined: ignoreUndefined
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Return the query
	  return query;
	}
	
	/**
	 * @ignore
	 */
	var bindToCurrentDomain = function(callback) {
	  var domain = process.domain;
	  if(domain == null || callback == null) {
	    return callback;
	  } else {
	    return domain.bind(callback);
	  }
	}
	
	module.exports = WireProtocol;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var inherits = __webpack_require__(77).inherits
	  , f = __webpack_require__(77).format
	  , EventEmitter = __webpack_require__(3).EventEmitter;
	
	/**
	 * Creates a new Authentication Session
	 * @class
	 * @param {object} [options] Options for the session
	 * @param {{Server}|{ReplSet}|{Mongos}} topology The topology instance underpinning the session
	 */
	var Session = function(options, topology) {
	  this.options = options;
	  this.topology = topology;
	  
	  // Add event listener
	  EventEmitter.call(this);
	}
	
	inherits(Session, EventEmitter);
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {object} cmd The command hash
	 * @param {object} [options.readPreference] Specify read preference if command supports it
	 * @param {object} [options.connection] Specify connection object to execute command against
	 * @param {opResultCallback} callback A callback function
	 */
	Session.prototype.command = function(ns, cmd, options, callback) {
	  this.topology.command(ns, cmd, options, callback);
	}
	
	/**
	 * Insert one or more documents
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of documents to insert
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {opResultCallback} callback A callback function
	 */
	Session.prototype.insert = function(ns, ops, options, callback) {
	  this.topology.insert(ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more update operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of updates
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {opResultCallback} callback A callback function
	 */
	Session.prototype.update = function(ns, ops, options, callback) {
	  this.topology.update(ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of removes
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {opResultCallback} callback A callback function
	 */
	Session.prototype.remove = function(ns, ops, options, callback) {
	  this.topology.remove(ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {{object}|{Long}} cmd Can be either a command returning a cursor or a cursorId
	 * @param {object} [options.batchSize=0] Batchsize for the operation
	 * @param {array} [options.documents=[]] Initial documents list for cursor
	 * @param {boolean} [options.tailable=false] Tailable flag set
	 * @param {boolean} [options.oplogReply=false] oplogReply flag set
	 * @param {boolean} [options.awaitdata=false] awaitdata flag set
	 * @param {boolean} [options.exhaust=false] exhaust flag set
	 * @param {boolean} [options.partial=false] partial flag set
	 * @param {opResultCallback} callback A callback function
	 */
	Session.prototype.cursor = function(ns, cmd, options) {
	  return this.topology.cursor(ns, cmd, options);
	}  
	
	module.exports = Session;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var f = __webpack_require__(77).format
	  , crypto = __webpack_require__(70)
	  , MongoError = __webpack_require__(157);
	
	var AuthSession = function(db, username, password) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	/**
	 * Creates a new MongoCR authentication mechanism
	 * @class
	 * @return {MongoCR} A cursor instance
	 */
	var MongoCR = function() {
	  this.authStore = [];
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	MongoCR.prototype.auth = function(server, connections, db, username, password, callback) {
	  var self = this;
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var credentialsValid = false;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {
	    // Execute MongoCR
	    var executeMongoCR = function(connection) {
	      // Let's start the process
	      server.command(f("%s.$cmd", db)
	        , { getnonce: 1 }
	        , { connection: connection }, function(err, r) {
	          var nonce = null;
	          var key = null;
	
	          // Adjust the number of connections left
	          // Get nonce
	          if(err == null) {
	            nonce = r.result.nonce;
	            // Use node md5 generator
	            var md5 = crypto.createHash('md5');
	            // Generate keys used for authentication
	            md5.update(username + ":mongo:" + password, 'utf8');
	            var hash_password = md5.digest('hex');
	            // Final key
	            md5 = crypto.createHash('md5');
	            md5.update(nonce + username + hash_password, 'utf8');
	            key = md5.digest('hex');
	          }
	
	          // Execute command
	          server.command(f("%s.$cmd", db)
	            , { authenticate: 1, user: username, nonce: nonce, key:key}
	            , { connection: connection }, function(err, r) {
	              count = count - 1;
	
	              // If we have an error
	              if(err) {
	                errorObject = err;
	              } else if(r.result['$err']) {
	                errorObject = r.result;
	              } else if(r.result['errmsg']) {
	                errorObject = r.result;
	              } else {
	                credentialsValid = true;
	                numberOfValidConnections = numberOfValidConnections + 1;
	              }
	
	              // We have authenticated all connections
	              if(count == 0 && numberOfValidConnections > 0) {
	                // Store the auth details
	                addAuthSession(self.authStore, new AuthSession(db, username, password));
	                // Return correct authentication
	                callback(null, true);
	              } else if(count == 0) {
	                if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
	                callback(errorObject, false);
	              }
	          });
	      });
	    }
	
	    var _execute = function(_connection) {
	      process.nextTick(function() {
	        executeMongoCR(_connection);
	      });
	    }
	
	    _execute(connections.shift());
	  }
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	MongoCR.prototype.reauthenticate = function(server, connections, callback) {
	  var authStore = this.authStore.slice(0);
	  var err = null;
	  var count = authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < authStore.length; i++) {
	    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function(err, r) {
	      if(err) err = err;
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(err, null);
	      }
	    });
	  }
	}
	
	/**
	 * This is a result from a authentication strategy
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {boolean} result The result of the authentication process
	 */
	
	module.exports = MongoCR;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var f = __webpack_require__(77).format
	  , crypto = __webpack_require__(70)
	  , MongoError = __webpack_require__(157);
	
	var AuthSession = function(db, username, password) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	/**
	 * Creates a new X509 authentication mechanism
	 * @class
	 * @return {X509} A cursor instance
	 */
	var X509 = function() {
	  this.authStore = [];
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	X509.prototype.auth = function(server, connections, db, username, password, callback) {
	  var self = this;
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var credentialsValid = false;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {
	    // Execute MongoCR
	    var execute = function(connection) {
	      // Let's start the sasl process
	      var command = {
	          authenticate: 1
	        , mechanism: 'MONGODB-X509'
	        , user: username
	      };
	
	      // Let's start the process
	      server.command("$external.$cmd"
	        , command
	        , { connection: connection }, function(err, r) {
	        // Adjust count
	        count = count - 1;
	
	        // If we have an error
	        if(err) {
	          errorObject = err;
	        } else if(r.result['$err']) {
	          errorObject = r.result;
	        } else if(r.result['errmsg']) {
	          errorObject = r.result;
	        } else {
	          credentialsValid = true;
	          numberOfValidConnections = numberOfValidConnections + 1;
	        }
	
	        // We have authenticated all connections
	        if(count == 0 && numberOfValidConnections > 0) {
	          // Store the auth details
	          addAuthSession(self.authStore, new AuthSession(db, username, password));
	          // Return correct authentication
	          callback(null, true);
	        } else if(count == 0) {
	          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
	          callback(errorObject, false);
	        }
	      });
	    }
	
	    var _execute = function(_connection) {
	      process.nextTick(function() {
	        execute(_connection);
	      });
	    }
	
	    _execute(connections.shift());
	  }
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	X509.prototype.reauthenticate = function(server, connections, callback) {
	  var authStore = this.authStore.slice(0);
	  var err = null;
	  var count = authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < authStore.length; i++) {
	    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function(err, r) {
	      if(err) err = err;
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(err, null);
	      }
	    });
	  }
	}
	
	/**
	 * This is a result from a authentication strategy
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {boolean} result The result of the authentication process
	 */
	
	module.exports = X509;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var f = __webpack_require__(77).format
	  , crypto = __webpack_require__(70)
	  , Binary = __webpack_require__(134).Binary
	  , MongoError = __webpack_require__(157);
	
	var AuthSession = function(db, username, password) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	/**
	 * Creates a new Plain authentication mechanism
	 * @class
	 * @return {Plain} A cursor instance
	 */
	var Plain = function() {
	  this.authStore = [];
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	Plain.prototype.auth = function(server, connections, db, username, password, callback) {
	  var self = this;
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var credentialsValid = false;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {
	    // Execute MongoCR
	    var execute = function(connection) {
	      // Create payload
	      var payload = new Binary(f("\x00%s\x00%s", username, password));
	
	      // Let's start the sasl process
	      var command = {
	          saslStart: 1
	        , mechanism: 'PLAIN'
	        , payload: payload
	        , autoAuthorize: 1
	      };
	
	      // Let's start the process
	      server.command("$external.$cmd"
	        , command
	        , { connection: connection }, function(err, r) {
	        // Adjust count
	        count = count - 1;
	
	        // If we have an error
	        if(err) {
	          errorObject = err;
	        } else if(r.result['$err']) {
	          errorObject = r.result;
	        } else if(r.result['errmsg']) {
	          errorObject = r.result;
	        } else {
	          credentialsValid = true;
	          numberOfValidConnections = numberOfValidConnections + 1;
	        }
	
	        // We have authenticated all connections
	        if(count == 0 && numberOfValidConnections > 0) {
	          // Store the auth details
	          addAuthSession(self.authStore, new AuthSession(db, username, password));
	          // Return correct authentication
	          callback(null, true);
	        } else if(count == 0) {
	          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
	          callback(errorObject, false);
	        }
	      });
	    }
	
	    var _execute = function(_connection) {
	      process.nextTick(function() {
	        execute(_connection);
	      });
	    }
	
	    _execute(connections.shift());
	  }
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	Plain.prototype.reauthenticate = function(server, connections, callback) {
	  var authStore = this.authStore.slice(0);
	  var err = null;
	  var count = authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < authStore.length; i++) {
	    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function(err, r) {
	      if(err) err = err;
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(err, null);
	      }
	    });
	  }
	}
	
	/**
	 * This is a result from a authentication strategy
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {boolean} result The result of the authentication process
	 */
	
	module.exports = Plain;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var f = __webpack_require__(77).format
	  , crypto = __webpack_require__(70)
	  , require_optional = __webpack_require__(177)
	  , MongoError = __webpack_require__(157);
	
	var AuthSession = function(db, username, password, options) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	  this.options = options;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	// Kerberos class
	var Kerberos = null;
	var MongoAuthProcess = null;
	
	// Try to grab the Kerberos class
	try {
	  Kerberos = require_optional('kerberos').Kerberos;
	  // Authentication process for Mongo
	  MongoAuthProcess = require_optional('kerberos').processes.MongoAuthProcess
	} catch(err) {}
	
	/**
	 * Creates a new GSSAPI authentication mechanism
	 * @class
	 * @return {GSSAPI} A cursor instance
	 */
	var GSSAPI = function() {
	  this.authStore = [];
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	GSSAPI.prototype.auth = function(server, connections, db, username, password, options, callback) {
	  var self = this;
	  // We don't have the Kerberos library
	  if(Kerberos == null) return callback(new Error("Kerberos library is not installed"));
	  var gssapiServiceName = options['gssapiServiceName'] || 'mongodb';
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var credentialsValid = false;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {
	    // Execute MongoCR
	    var execute = function(connection) {
	      // Start Auth process for a connection
	      GSSAPIInitialize(db, username, password, db, gssapiServiceName, server, connection, options, function(err, r) {
	        // Adjust count
	        count = count - 1;
	
	        // If we have an error
	        if(err) {
	          errorObject = err;
	        } else if(r.result['$err']) {
	          errorObject = r.result;
	        } else if(r.result['errmsg']) {
	          errorObject = r.result;
	        } else {
	          credentialsValid = true;
	          numberOfValidConnections = numberOfValidConnections + 1;
	        }
	
	        // We have authenticated all connections
	        if(count == 0 && numberOfValidConnections > 0) {
	          // Store the auth details
	          addAuthSession(self.authStore, new AuthSession(db, username, password, options));
	          // Return correct authentication
	          callback(null, true);
	        } else if(count == 0) {
	          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
	          callback(errorObject, false);
	        }
	      });
	    }
	
	    var _execute = function(_connection) {
	      process.nextTick(function() {
	        execute(_connection);
	      });
	    }
	
	    _execute(connections.shift());
	  }
	}
	
	//
	// Initialize step
	var GSSAPIInitialize = function(db, username, password, authdb, gssapiServiceName, server, connection, options, callback) {
	  // Create authenticator
	  var mongo_auth_process = new MongoAuthProcess(connection.host, connection.port, gssapiServiceName, options);
	
	  // Perform initialization
	  mongo_auth_process.init(username, password, function(err, context) {
	    if(err) return callback(err, false);
	
	    // Perform the first step
	    mongo_auth_process.transition('', function(err, payload) {
	      if(err) return callback(err, false);
	
	      // Call the next db step
	      MongoDBGSSAPIFirstStep(mongo_auth_process, payload, db, username, password, authdb, server, connection, callback);
	    });
	  });
	}
	
	//
	// Perform first step against mongodb
	var MongoDBGSSAPIFirstStep = function(mongo_auth_process, payload, db, username, password, authdb, server, connection, callback) {
	  // Build the sasl start command
	  var command = {
	      saslStart: 1
	    , mechanism: 'GSSAPI'
	    , payload: payload
	    , autoAuthorize: 1
	  };
	
	  // Execute first sasl step
	  server.command("$external.$cmd"
	    , command
	    , { connection: connection }, function(err, r) {
	    if(err) return callback(err, false);
	    var doc = r.result;
	    // Execute mongodb transition
	    mongo_auth_process.transition(r.result.payload, function(err, payload) {
	      if(err) return callback(err, false);
	
	      // MongoDB API Second Step
	      MongoDBGSSAPISecondStep(mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback);
	    });
	  });
	}
	
	//
	// Perform first step against mongodb
	var MongoDBGSSAPISecondStep = function(mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback) {
	  // Build Authentication command to send to MongoDB
	  var command = {
	      saslContinue: 1
	    , conversationId: doc.conversationId
	    , payload: payload
	  };
	
	  // Execute the command
	  server.command("$external.$cmd"
	    , command
	    , { connection: connection }, function(err, r) {
	    if(err) return callback(err, false);
	    var doc = r.result;
	    // Call next transition for kerberos
	    mongo_auth_process.transition(doc.payload, function(err, payload) {
	      if(err) return callback(err, false);
	
	      // Call the last and third step
	      MongoDBGSSAPIThirdStep(mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback);
	    });
	  });
	}
	
	var MongoDBGSSAPIThirdStep = function(mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback) {
	  // Build final command
	  var command = {
	      saslContinue: 1
	    , conversationId: doc.conversationId
	    , payload: payload
	  };
	
	  // Execute the command
	  server.command("$external.$cmd"
	    , command
	    , { connection: connection }, function(err, r) {
	    if(err) return callback(err, false);
	    mongo_auth_process.transition(null, function(err, payload) {
	      if(err) return callback(err, null);
	      callback(null, r);
	    });
	  });
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	GSSAPI.prototype.reauthenticate = function(server, connections, callback) {
	  var authStore = this.authStore.slice(0);
	  var err = null;
	  var count = authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < authStore.length; i++) {
	    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, authStore[i].options, function(err, r) {
	      if(err) err = err;
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(err, null);
	      }
	    });
	  }
	}
	
	/**
	 * This is a result from a authentication strategy
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {boolean} result The result of the authentication process
	 */
	
	module.exports = GSSAPI;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname, module, process) {var path = __webpack_require__(45),
	  fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
	  f = __webpack_require__(77).format,
	  resolveFrom = __webpack_require__(178),
	  semver = __webpack_require__(179);
	
	var exists = fs.existsSync || path.existsSync;
	
	var find_package_json = function(location) {
	  var found = false;
	
	  while(!found) {
	    if (exists(location + '/package.json')) {
	      found = location;
	    } else if (location !== '/') {
	      location = path.dirname(location);
	    } else {
	      return false;
	    }
	  }
	
	  return location;
	}
	
	var require_optional = function(name, options) {
	  options = options || {};
	  options.strict = typeof options.strict == 'boolean' ? options.strict : true;
	
	  // Current location
	  var location = __dirname;
	  // Check if we have a parent
	  if(module.parent) {
	    location = module.parent.filename;
	  }
	
	  // Locate this module's package.json file
	  var location = find_package_json(location);
	  if(!location) {
	    throw new Error('package.json can not be located');
	  }
	
	  // Read the package.json file
	  var object = JSON.parse(fs.readFileSync(f('%s/package.json', location)));
	  // Is the name defined by interal file references
	  var parts = name.split(/\//);
	
	  // Optional dependencies exist
	  if(!object.peerOptionalDependencies) {
	    throw new Error(f('no optional dependency [%s] defined in peerOptionalDependencies in package.json', parts[0]));
	  } else if(object.peerOptionalDependencies && !object.peerOptionalDependencies[parts[0]]) {
	    throw new Error(f('no optional dependency [%s] defined in peerOptionalDependencies in package.json', parts[0]));
	  }
	
	  // Unpack the expected version
	  var expectedVersions = object.peerOptionalDependencies[parts[0]];
	  // The resolved package
	  var moduleEntry = undefined;
	  // Module file
	  var moduleEntryFile = name;
	
	  try {
	    // Validate if it's possible to read the module
	    moduleEntry = __webpack_require__(180)(moduleEntryFile);
	  } catch(err) {
	    // Attempt to resolve in top level package
	    try {
	      // Get the module entry file
	      moduleEntryFile = resolveFrom(process.cwd(), name);
	      if(moduleEntryFile == null) return undefined;
	      // Attempt to resolve the module
	      moduleEntry = __webpack_require__(180)(moduleEntryFile);
	    } catch(err) {
	      if(err.code === 'MODULE_NOT_FOUND') return undefined;
	    }
	  }
	
	  // Resolve the location of the module's package.json file
	  var location = find_package_json(/*require.resolve*/(__webpack_require__(180).resolve(moduleEntryFile)));
	  if(!location) {
	    throw new Error('package.json can not be located');
	  }
	
	  // Read the module file
	  var dependentOnModule = JSON.parse(fs.readFileSync(f('%s/package.json', location)));
	  // Get the version
	  var version = dependentOnModule.version;
	  // Validate if the found module satisfies the version id
	  if(semver.satisfies(version, expectedVersions) == false
	    && options.strict) {
	      var error = new Error(f('optional dependency [%s] found but version [%s] did not satisfy constraint [%s]', parts[0], version, expectedVersions));
	      error.code = 'OPTIONAL_MODULE_NOT_FOUND';
	      throw error;
	  }
	
	  // Satifies the module requirement
	  return moduleEntry;
	}
	
	require_optional.exists = function(name) {
	  try {
	    var m = require_optional(name);
	    if(m === undefined) return false;
	    return true;
	  } catch(err) {
	    return false;
	  }
	}
	
	module.exports = require_optional;
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/", __webpack_require__(34)(module), __webpack_require__(6)))

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var path = __webpack_require__(45);
	var Module = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"module\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	
	module.exports = function (fromDir, moduleId) {
		if (typeof fromDir !== 'string' || typeof moduleId !== 'string') {
			throw new TypeError('Expected `fromDir` and `moduleId` to be a string');
		}
	
		fromDir = path.resolve(fromDir);
	
		var fromFile = path.join(fromDir, 'noop.js');
	
		try {
			return Module._resolveFilename(moduleId, {
				id: fromFile,
				filename: fromFile,
				paths: Module._nodeModulePaths(fromDir)
			});
		} catch (err) {
			return null;
		}
	};


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = SemVer;
	
	// The debug function is excluded entirely from the minified version.
	/* nomin */ var debug;
	/* nomin */ if (typeof process === 'object' &&
	    /* nomin */ process.env &&
	    /* nomin */ process.env.NODE_DEBUG &&
	    /* nomin */ /\bsemver\b/i.test(process.env.NODE_DEBUG))
	  /* nomin */ debug = function() {
	    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);
	    /* nomin */ args.unshift('SEMVER');
	    /* nomin */ console.log.apply(console, args);
	    /* nomin */ };
	/* nomin */ else
	  /* nomin */ debug = function() {};
	
	// Note: this is the semver.org version of the spec that it implements
	// Not necessarily the package version of this code.
	exports.SEMVER_SPEC_VERSION = '2.0.0';
	
	var MAX_LENGTH = 256;
	var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
	
	// The actual regexps go on exports.re
	var re = exports.re = [];
	var src = exports.src = [];
	var R = 0;
	
	// The following Regular Expressions can be used for tokenizing,
	// validating, and parsing SemVer version strings.
	
	// ## Numeric Identifier
	// A single `0`, or a non-zero digit followed by zero or more digits.
	
	var NUMERICIDENTIFIER = R++;
	src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
	var NUMERICIDENTIFIERLOOSE = R++;
	src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';
	
	
	// ## Non-numeric Identifier
	// Zero or more digits, followed by a letter or hyphen, and then zero or
	// more letters, digits, or hyphens.
	
	var NONNUMERICIDENTIFIER = R++;
	src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
	
	
	// ## Main Version
	// Three dot-separated numeric identifiers.
	
	var MAINVERSION = R++;
	src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
	                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
	                   '(' + src[NUMERICIDENTIFIER] + ')';
	
	var MAINVERSIONLOOSE = R++;
	src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
	                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
	                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';
	
	// ## Pre-release Version Identifier
	// A numeric identifier, or a non-numeric identifier.
	
	var PRERELEASEIDENTIFIER = R++;
	src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
	                            '|' + src[NONNUMERICIDENTIFIER] + ')';
	
	var PRERELEASEIDENTIFIERLOOSE = R++;
	src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
	                                 '|' + src[NONNUMERICIDENTIFIER] + ')';
	
	
	// ## Pre-release Version
	// Hyphen, followed by one or more dot-separated pre-release version
	// identifiers.
	
	var PRERELEASE = R++;
	src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
	                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';
	
	var PRERELEASELOOSE = R++;
	src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
	                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';
	
	// ## Build Metadata Identifier
	// Any combination of digits, letters, or hyphens.
	
	var BUILDIDENTIFIER = R++;
	src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
	
	// ## Build Metadata
	// Plus sign, followed by one or more period-separated build metadata
	// identifiers.
	
	var BUILD = R++;
	src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
	             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';
	
	
	// ## Full Version String
	// A main version, followed optionally by a pre-release version and
	// build metadata.
	
	// Note that the only major, minor, patch, and pre-release sections of
	// the version string are capturing groups.  The build metadata is not a
	// capturing group, because it should not ever be used in version
	// comparison.
	
	var FULL = R++;
	var FULLPLAIN = 'v?' + src[MAINVERSION] +
	                src[PRERELEASE] + '?' +
	                src[BUILD] + '?';
	
	src[FULL] = '^' + FULLPLAIN + '$';
	
	// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
	// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
	// common in the npm registry.
	var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
	                 src[PRERELEASELOOSE] + '?' +
	                 src[BUILD] + '?';
	
	var LOOSE = R++;
	src[LOOSE] = '^' + LOOSEPLAIN + '$';
	
	var GTLT = R++;
	src[GTLT] = '((?:<|>)?=?)';
	
	// Something like "2.*" or "1.2.x".
	// Note that "x.x" is a valid xRange identifer, meaning "any version"
	// Only the first item is strictly required.
	var XRANGEIDENTIFIERLOOSE = R++;
	src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
	var XRANGEIDENTIFIER = R++;
	src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
	
	var XRANGEPLAIN = R++;
	src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
	                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
	                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
	                   '(?:' + src[PRERELEASE] + ')?' +
	                   src[BUILD] + '?' +
	                   ')?)?';
	
	var XRANGEPLAINLOOSE = R++;
	src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
	                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
	                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
	                        '(?:' + src[PRERELEASELOOSE] + ')?' +
	                        src[BUILD] + '?' +
	                        ')?)?';
	
	var XRANGE = R++;
	src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
	var XRANGELOOSE = R++;
	src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';
	
	// Tilde ranges.
	// Meaning is "reasonably at or greater than"
	var LONETILDE = R++;
	src[LONETILDE] = '(?:~>?)';
	
	var TILDETRIM = R++;
	src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
	re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
	var tildeTrimReplace = '$1~';
	
	var TILDE = R++;
	src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
	var TILDELOOSE = R++;
	src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';
	
	// Caret ranges.
	// Meaning is "at least and backwards compatible with"
	var LONECARET = R++;
	src[LONECARET] = '(?:\\^)';
	
	var CARETTRIM = R++;
	src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
	re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
	var caretTrimReplace = '$1^';
	
	var CARET = R++;
	src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
	var CARETLOOSE = R++;
	src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';
	
	// A simple gt/lt/eq thing, or just "" to indicate "any version"
	var COMPARATORLOOSE = R++;
	src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
	var COMPARATOR = R++;
	src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';
	
	
	// An expression to strip any whitespace between the gtlt and the thing
	// it modifies, so that `> 1.2.3` ==> `>1.2.3`
	var COMPARATORTRIM = R++;
	src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
	                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';
	
	// this one has to use the /g flag
	re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
	var comparatorTrimReplace = '$1$2$3';
	
	
	// Something like `1.2.3 - 1.2.4`
	// Note that these all use the loose form, because they'll be
	// checked against either the strict or loose comparator form
	// later.
	var HYPHENRANGE = R++;
	src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
	                   '\\s+-\\s+' +
	                   '(' + src[XRANGEPLAIN] + ')' +
	                   '\\s*$';
	
	var HYPHENRANGELOOSE = R++;
	src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
	                        '\\s+-\\s+' +
	                        '(' + src[XRANGEPLAINLOOSE] + ')' +
	                        '\\s*$';
	
	// Star ranges basically just allow anything at all.
	var STAR = R++;
	src[STAR] = '(<|>)?=?\\s*\\*';
	
	// Compile to actual regexp objects.
	// All are flag-free, unless they were created above with a flag.
	for (var i = 0; i < R; i++) {
	  debug(i, src[i]);
	  if (!re[i])
	    re[i] = new RegExp(src[i]);
	}
	
	exports.parse = parse;
	function parse(version, loose) {
	  if (version instanceof SemVer)
	    return version;
	
	  if (typeof version !== 'string')
	    return null;
	
	  if (version.length > MAX_LENGTH)
	    return null;
	
	  var r = loose ? re[LOOSE] : re[FULL];
	  if (!r.test(version))
	    return null;
	
	  try {
	    return new SemVer(version, loose);
	  } catch (er) {
	    return null;
	  }
	}
	
	exports.valid = valid;
	function valid(version, loose) {
	  var v = parse(version, loose);
	  return v ? v.version : null;
	}
	
	
	exports.clean = clean;
	function clean(version, loose) {
	  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
	  return s ? s.version : null;
	}
	
	exports.SemVer = SemVer;
	
	function SemVer(version, loose) {
	  if (version instanceof SemVer) {
	    if (version.loose === loose)
	      return version;
	    else
	      version = version.version;
	  } else if (typeof version !== 'string') {
	    throw new TypeError('Invalid Version: ' + version);
	  }
	
	  if (version.length > MAX_LENGTH)
	    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
	
	  if (!(this instanceof SemVer))
	    return new SemVer(version, loose);
	
	  debug('SemVer', version, loose);
	  this.loose = loose;
	  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);
	
	  if (!m)
	    throw new TypeError('Invalid Version: ' + version);
	
	  this.raw = version;
	
	  // these are actually numbers
	  this.major = +m[1];
	  this.minor = +m[2];
	  this.patch = +m[3];
	
	  if (this.major > MAX_SAFE_INTEGER || this.major < 0)
	    throw new TypeError('Invalid major version')
	
	  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
	    throw new TypeError('Invalid minor version')
	
	  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
	    throw new TypeError('Invalid patch version')
	
	  // numberify any prerelease numeric ids
	  if (!m[4])
	    this.prerelease = [];
	  else
	    this.prerelease = m[4].split('.').map(function(id) {
	      if (/^[0-9]+$/.test(id)) {
	        var num = +id;
	        if (num >= 0 && num < MAX_SAFE_INTEGER)
	          return num;
	      }
	      return id;
	    });
	
	  this.build = m[5] ? m[5].split('.') : [];
	  this.format();
	}
	
	SemVer.prototype.format = function() {
	  this.version = this.major + '.' + this.minor + '.' + this.patch;
	  if (this.prerelease.length)
	    this.version += '-' + this.prerelease.join('.');
	  return this.version;
	};
	
	SemVer.prototype.toString = function() {
	  return this.version;
	};
	
	SemVer.prototype.compare = function(other) {
	  debug('SemVer.compare', this.version, this.loose, other);
	  if (!(other instanceof SemVer))
	    other = new SemVer(other, this.loose);
	
	  return this.compareMain(other) || this.comparePre(other);
	};
	
	SemVer.prototype.compareMain = function(other) {
	  if (!(other instanceof SemVer))
	    other = new SemVer(other, this.loose);
	
	  return compareIdentifiers(this.major, other.major) ||
	         compareIdentifiers(this.minor, other.minor) ||
	         compareIdentifiers(this.patch, other.patch);
	};
	
	SemVer.prototype.comparePre = function(other) {
	  if (!(other instanceof SemVer))
	    other = new SemVer(other, this.loose);
	
	  // NOT having a prerelease is > having one
	  if (this.prerelease.length && !other.prerelease.length)
	    return -1;
	  else if (!this.prerelease.length && other.prerelease.length)
	    return 1;
	  else if (!this.prerelease.length && !other.prerelease.length)
	    return 0;
	
	  var i = 0;
	  do {
	    var a = this.prerelease[i];
	    var b = other.prerelease[i];
	    debug('prerelease compare', i, a, b);
	    if (a === undefined && b === undefined)
	      return 0;
	    else if (b === undefined)
	      return 1;
	    else if (a === undefined)
	      return -1;
	    else if (a === b)
	      continue;
	    else
	      return compareIdentifiers(a, b);
	  } while (++i);
	};
	
	// preminor will bump the version up to the next minor release, and immediately
	// down to pre-release. premajor and prepatch work the same way.
	SemVer.prototype.inc = function(release, identifier) {
	  switch (release) {
	    case 'premajor':
	      this.prerelease.length = 0;
	      this.patch = 0;
	      this.minor = 0;
	      this.major++;
	      this.inc('pre', identifier);
	      break;
	    case 'preminor':
	      this.prerelease.length = 0;
	      this.patch = 0;
	      this.minor++;
	      this.inc('pre', identifier);
	      break;
	    case 'prepatch':
	      // If this is already a prerelease, it will bump to the next version
	      // drop any prereleases that might already exist, since they are not
	      // relevant at this point.
	      this.prerelease.length = 0;
	      this.inc('patch', identifier);
	      this.inc('pre', identifier);
	      break;
	    // If the input is a non-prerelease version, this acts the same as
	    // prepatch.
	    case 'prerelease':
	      if (this.prerelease.length === 0)
	        this.inc('patch', identifier);
	      this.inc('pre', identifier);
	      break;
	
	    case 'major':
	      // If this is a pre-major version, bump up to the same major version.
	      // Otherwise increment major.
	      // 1.0.0-5 bumps to 1.0.0
	      // 1.1.0 bumps to 2.0.0
	      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
	        this.major++;
	      this.minor = 0;
	      this.patch = 0;
	      this.prerelease = [];
	      break;
	    case 'minor':
	      // If this is a pre-minor version, bump up to the same minor version.
	      // Otherwise increment minor.
	      // 1.2.0-5 bumps to 1.2.0
	      // 1.2.1 bumps to 1.3.0
	      if (this.patch !== 0 || this.prerelease.length === 0)
	        this.minor++;
	      this.patch = 0;
	      this.prerelease = [];
	      break;
	    case 'patch':
	      // If this is not a pre-release version, it will increment the patch.
	      // If it is a pre-release it will bump up to the same patch version.
	      // 1.2.0-5 patches to 1.2.0
	      // 1.2.0 patches to 1.2.1
	      if (this.prerelease.length === 0)
	        this.patch++;
	      this.prerelease = [];
	      break;
	    // This probably shouldn't be used publicly.
	    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
	    case 'pre':
	      if (this.prerelease.length === 0)
	        this.prerelease = [0];
	      else {
	        var i = this.prerelease.length;
	        while (--i >= 0) {
	          if (typeof this.prerelease[i] === 'number') {
	            this.prerelease[i]++;
	            i = -2;
	          }
	        }
	        if (i === -1) // didn't increment anything
	          this.prerelease.push(0);
	      }
	      if (identifier) {
	        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
	        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
	        if (this.prerelease[0] === identifier) {
	          if (isNaN(this.prerelease[1]))
	            this.prerelease = [identifier, 0];
	        } else
	          this.prerelease = [identifier, 0];
	      }
	      break;
	
	    default:
	      throw new Error('invalid increment argument: ' + release);
	  }
	  this.format();
	  this.raw = this.version;
	  return this;
	};
	
	exports.inc = inc;
	function inc(version, release, loose, identifier) {
	  if (typeof(loose) === 'string') {
	    identifier = loose;
	    loose = undefined;
	  }
	
	  try {
	    return new SemVer(version, loose).inc(release, identifier).version;
	  } catch (er) {
	    return null;
	  }
	}
	
	exports.diff = diff;
	function diff(version1, version2) {
	  if (eq(version1, version2)) {
	    return null;
	  } else {
	    var v1 = parse(version1);
	    var v2 = parse(version2);
	    if (v1.prerelease.length || v2.prerelease.length) {
	      for (var key in v1) {
	        if (key === 'major' || key === 'minor' || key === 'patch') {
	          if (v1[key] !== v2[key]) {
	            return 'pre'+key;
	          }
	        }
	      }
	      return 'prerelease';
	    }
	    for (var key in v1) {
	      if (key === 'major' || key === 'minor' || key === 'patch') {
	        if (v1[key] !== v2[key]) {
	          return key;
	        }
	      }
	    }
	  }
	}
	
	exports.compareIdentifiers = compareIdentifiers;
	
	var numeric = /^[0-9]+$/;
	function compareIdentifiers(a, b) {
	  var anum = numeric.test(a);
	  var bnum = numeric.test(b);
	
	  if (anum && bnum) {
	    a = +a;
	    b = +b;
	  }
	
	  return (anum && !bnum) ? -1 :
	         (bnum && !anum) ? 1 :
	         a < b ? -1 :
	         a > b ? 1 :
	         0;
	}
	
	exports.rcompareIdentifiers = rcompareIdentifiers;
	function rcompareIdentifiers(a, b) {
	  return compareIdentifiers(b, a);
	}
	
	exports.major = major;
	function major(a, loose) {
	  return new SemVer(a, loose).major;
	}
	
	exports.minor = minor;
	function minor(a, loose) {
	  return new SemVer(a, loose).minor;
	}
	
	exports.patch = patch;
	function patch(a, loose) {
	  return new SemVer(a, loose).patch;
	}
	
	exports.compare = compare;
	function compare(a, b, loose) {
	  return new SemVer(a, loose).compare(b);
	}
	
	exports.compareLoose = compareLoose;
	function compareLoose(a, b) {
	  return compare(a, b, true);
	}
	
	exports.rcompare = rcompare;
	function rcompare(a, b, loose) {
	  return compare(b, a, loose);
	}
	
	exports.sort = sort;
	function sort(list, loose) {
	  return list.sort(function(a, b) {
	    return exports.compare(a, b, loose);
	  });
	}
	
	exports.rsort = rsort;
	function rsort(list, loose) {
	  return list.sort(function(a, b) {
	    return exports.rcompare(a, b, loose);
	  });
	}
	
	exports.gt = gt;
	function gt(a, b, loose) {
	  return compare(a, b, loose) > 0;
	}
	
	exports.lt = lt;
	function lt(a, b, loose) {
	  return compare(a, b, loose) < 0;
	}
	
	exports.eq = eq;
	function eq(a, b, loose) {
	  return compare(a, b, loose) === 0;
	}
	
	exports.neq = neq;
	function neq(a, b, loose) {
	  return compare(a, b, loose) !== 0;
	}
	
	exports.gte = gte;
	function gte(a, b, loose) {
	  return compare(a, b, loose) >= 0;
	}
	
	exports.lte = lte;
	function lte(a, b, loose) {
	  return compare(a, b, loose) <= 0;
	}
	
	exports.cmp = cmp;
	function cmp(a, op, b, loose) {
	  var ret;
	  switch (op) {
	    case '===':
	      if (typeof a === 'object') a = a.version;
	      if (typeof b === 'object') b = b.version;
	      ret = a === b;
	      break;
	    case '!==':
	      if (typeof a === 'object') a = a.version;
	      if (typeof b === 'object') b = b.version;
	      ret = a !== b;
	      break;
	    case '': case '=': case '==': ret = eq(a, b, loose); break;
	    case '!=': ret = neq(a, b, loose); break;
	    case '>': ret = gt(a, b, loose); break;
	    case '>=': ret = gte(a, b, loose); break;
	    case '<': ret = lt(a, b, loose); break;
	    case '<=': ret = lte(a, b, loose); break;
	    default: throw new TypeError('Invalid operator: ' + op);
	  }
	  return ret;
	}
	
	exports.Comparator = Comparator;
	function Comparator(comp, loose) {
	  if (comp instanceof Comparator) {
	    if (comp.loose === loose)
	      return comp;
	    else
	      comp = comp.value;
	  }
	
	  if (!(this instanceof Comparator))
	    return new Comparator(comp, loose);
	
	  debug('comparator', comp, loose);
	  this.loose = loose;
	  this.parse(comp);
	
	  if (this.semver === ANY)
	    this.value = '';
	  else
	    this.value = this.operator + this.semver.version;
	
	  debug('comp', this);
	}
	
	var ANY = {};
	Comparator.prototype.parse = function(comp) {
	  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
	  var m = comp.match(r);
	
	  if (!m)
	    throw new TypeError('Invalid comparator: ' + comp);
	
	  this.operator = m[1];
	  if (this.operator === '=')
	    this.operator = '';
	
	  // if it literally is just '>' or '' then allow anything.
	  if (!m[2])
	    this.semver = ANY;
	  else
	    this.semver = new SemVer(m[2], this.loose);
	};
	
	Comparator.prototype.toString = function() {
	  return this.value;
	};
	
	Comparator.prototype.test = function(version) {
	  debug('Comparator.test', version, this.loose);
	
	  if (this.semver === ANY)
	    return true;
	
	  if (typeof version === 'string')
	    version = new SemVer(version, this.loose);
	
	  return cmp(version, this.operator, this.semver, this.loose);
	};
	
	
	exports.Range = Range;
	function Range(range, loose) {
	  if ((range instanceof Range) && range.loose === loose)
	    return range;
	
	  if (!(this instanceof Range))
	    return new Range(range, loose);
	
	  this.loose = loose;
	
	  // First, split based on boolean or ||
	  this.raw = range;
	  this.set = range.split(/\s*\|\|\s*/).map(function(range) {
	    return this.parseRange(range.trim());
	  }, this).filter(function(c) {
	    // throw out any that are not relevant for whatever reason
	    return c.length;
	  });
	
	  if (!this.set.length) {
	    throw new TypeError('Invalid SemVer Range: ' + range);
	  }
	
	  this.format();
	}
	
	Range.prototype.format = function() {
	  this.range = this.set.map(function(comps) {
	    return comps.join(' ').trim();
	  }).join('||').trim();
	  return this.range;
	};
	
	Range.prototype.toString = function() {
	  return this.range;
	};
	
	Range.prototype.parseRange = function(range) {
	  var loose = this.loose;
	  range = range.trim();
	  debug('range', range, loose);
	  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
	  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
	  range = range.replace(hr, hyphenReplace);
	  debug('hyphen replace', range);
	  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
	  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
	  debug('comparator trim', range, re[COMPARATORTRIM]);
	
	  // `~ 1.2.3` => `~1.2.3`
	  range = range.replace(re[TILDETRIM], tildeTrimReplace);
	
	  // `^ 1.2.3` => `^1.2.3`
	  range = range.replace(re[CARETTRIM], caretTrimReplace);
	
	  // normalize spaces
	  range = range.split(/\s+/).join(' ');
	
	  // At this point, the range is completely trimmed and
	  // ready to be split into comparators.
	
	  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
	  var set = range.split(' ').map(function(comp) {
	    return parseComparator(comp, loose);
	  }).join(' ').split(/\s+/);
	  if (this.loose) {
	    // in loose mode, throw out any that are not valid comparators
	    set = set.filter(function(comp) {
	      return !!comp.match(compRe);
	    });
	  }
	  set = set.map(function(comp) {
	    return new Comparator(comp, loose);
	  });
	
	  return set;
	};
	
	// Mostly just for testing and legacy API reasons
	exports.toComparators = toComparators;
	function toComparators(range, loose) {
	  return new Range(range, loose).set.map(function(comp) {
	    return comp.map(function(c) {
	      return c.value;
	    }).join(' ').trim().split(' ');
	  });
	}
	
	// comprised of xranges, tildes, stars, and gtlt's at this point.
	// already replaced the hyphen ranges
	// turn into a set of JUST comparators.
	function parseComparator(comp, loose) {
	  debug('comp', comp);
	  comp = replaceCarets(comp, loose);
	  debug('caret', comp);
	  comp = replaceTildes(comp, loose);
	  debug('tildes', comp);
	  comp = replaceXRanges(comp, loose);
	  debug('xrange', comp);
	  comp = replaceStars(comp, loose);
	  debug('stars', comp);
	  return comp;
	}
	
	function isX(id) {
	  return !id || id.toLowerCase() === 'x' || id === '*';
	}
	
	// ~, ~> --> * (any, kinda silly)
	// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
	// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
	// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
	// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
	// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
	function replaceTildes(comp, loose) {
	  return comp.trim().split(/\s+/).map(function(comp) {
	    return replaceTilde(comp, loose);
	  }).join(' ');
	}
	
	function replaceTilde(comp, loose) {
	  var r = loose ? re[TILDELOOSE] : re[TILDE];
	  return comp.replace(r, function(_, M, m, p, pr) {
	    debug('tilde', comp, _, M, m, p, pr);
	    var ret;
	
	    if (isX(M))
	      ret = '';
	    else if (isX(m))
	      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	    else if (isX(p))
	      // ~1.2 == >=1.2.0 <1.3.0
	      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	    else if (pr) {
	      debug('replaceTilde pr', pr);
	      if (pr.charAt(0) !== '-')
	        pr = '-' + pr;
	      ret = '>=' + M + '.' + m + '.' + p + pr +
	            ' <' + M + '.' + (+m + 1) + '.0';
	    } else
	      // ~1.2.3 == >=1.2.3 <1.3.0
	      ret = '>=' + M + '.' + m + '.' + p +
	            ' <' + M + '.' + (+m + 1) + '.0';
	
	    debug('tilde return', ret);
	    return ret;
	  });
	}
	
	// ^ --> * (any, kinda silly)
	// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
	// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
	// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
	// ^1.2.3 --> >=1.2.3 <2.0.0
	// ^1.2.0 --> >=1.2.0 <2.0.0
	function replaceCarets(comp, loose) {
	  return comp.trim().split(/\s+/).map(function(comp) {
	    return replaceCaret(comp, loose);
	  }).join(' ');
	}
	
	function replaceCaret(comp, loose) {
	  debug('caret', comp, loose);
	  var r = loose ? re[CARETLOOSE] : re[CARET];
	  return comp.replace(r, function(_, M, m, p, pr) {
	    debug('caret', comp, _, M, m, p, pr);
	    var ret;
	
	    if (isX(M))
	      ret = '';
	    else if (isX(m))
	      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	    else if (isX(p)) {
	      if (M === '0')
	        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	      else
	        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
	    } else if (pr) {
	      debug('replaceCaret pr', pr);
	      if (pr.charAt(0) !== '-')
	        pr = '-' + pr;
	      if (M === '0') {
	        if (m === '0')
	          ret = '>=' + M + '.' + m + '.' + p + pr +
	                ' <' + M + '.' + m + '.' + (+p + 1);
	        else
	          ret = '>=' + M + '.' + m + '.' + p + pr +
	                ' <' + M + '.' + (+m + 1) + '.0';
	      } else
	        ret = '>=' + M + '.' + m + '.' + p + pr +
	              ' <' + (+M + 1) + '.0.0';
	    } else {
	      debug('no pr');
	      if (M === '0') {
	        if (m === '0')
	          ret = '>=' + M + '.' + m + '.' + p +
	                ' <' + M + '.' + m + '.' + (+p + 1);
	        else
	          ret = '>=' + M + '.' + m + '.' + p +
	                ' <' + M + '.' + (+m + 1) + '.0';
	      } else
	        ret = '>=' + M + '.' + m + '.' + p +
	              ' <' + (+M + 1) + '.0.0';
	    }
	
	    debug('caret return', ret);
	    return ret;
	  });
	}
	
	function replaceXRanges(comp, loose) {
	  debug('replaceXRanges', comp, loose);
	  return comp.split(/\s+/).map(function(comp) {
	    return replaceXRange(comp, loose);
	  }).join(' ');
	}
	
	function replaceXRange(comp, loose) {
	  comp = comp.trim();
	  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
	  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
	    debug('xRange', comp, ret, gtlt, M, m, p, pr);
	    var xM = isX(M);
	    var xm = xM || isX(m);
	    var xp = xm || isX(p);
	    var anyX = xp;
	
	    if (gtlt === '=' && anyX)
	      gtlt = '';
	
	    if (xM) {
	      if (gtlt === '>' || gtlt === '<') {
	        // nothing is allowed
	        ret = '<0.0.0';
	      } else {
	        // nothing is forbidden
	        ret = '*';
	      }
	    } else if (gtlt && anyX) {
	      // replace X with 0
	      if (xm)
	        m = 0;
	      if (xp)
	        p = 0;
	
	      if (gtlt === '>') {
	        // >1 => >=2.0.0
	        // >1.2 => >=1.3.0
	        // >1.2.3 => >= 1.2.4
	        gtlt = '>=';
	        if (xm) {
	          M = +M + 1;
	          m = 0;
	          p = 0;
	        } else if (xp) {
	          m = +m + 1;
	          p = 0;
	        }
	      } else if (gtlt === '<=') {
	        // <=0.7.x is actually <0.8.0, since any 0.7.x should
	        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
	        gtlt = '<';
	        if (xm)
	          M = +M + 1;
	        else
	          m = +m + 1;
	      }
	
	      ret = gtlt + M + '.' + m + '.' + p;
	    } else if (xm) {
	      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	    } else if (xp) {
	      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	    }
	
	    debug('xRange return', ret);
	
	    return ret;
	  });
	}
	
	// Because * is AND-ed with everything else in the comparator,
	// and '' means "any version", just remove the *s entirely.
	function replaceStars(comp, loose) {
	  debug('replaceStars', comp, loose);
	  // Looseness is ignored here.  star is always as loose as it gets!
	  return comp.trim().replace(re[STAR], '');
	}
	
	// This function is passed to string.replace(re[HYPHENRANGE])
	// M, m, patch, prerelease, build
	// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
	// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
	// 1.2 - 3.4 => >=1.2.0 <3.5.0
	function hyphenReplace($0,
	                       from, fM, fm, fp, fpr, fb,
	                       to, tM, tm, tp, tpr, tb) {
	
	  if (isX(fM))
	    from = '';
	  else if (isX(fm))
	    from = '>=' + fM + '.0.0';
	  else if (isX(fp))
	    from = '>=' + fM + '.' + fm + '.0';
	  else
	    from = '>=' + from;
	
	  if (isX(tM))
	    to = '';
	  else if (isX(tm))
	    to = '<' + (+tM + 1) + '.0.0';
	  else if (isX(tp))
	    to = '<' + tM + '.' + (+tm + 1) + '.0';
	  else if (tpr)
	    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
	  else
	    to = '<=' + to;
	
	  return (from + ' ' + to).trim();
	}
	
	
	// if ANY of the sets match ALL of its comparators, then pass
	Range.prototype.test = function(version) {
	  if (!version)
	    return false;
	
	  if (typeof version === 'string')
	    version = new SemVer(version, this.loose);
	
	  for (var i = 0; i < this.set.length; i++) {
	    if (testSet(this.set[i], version))
	      return true;
	  }
	  return false;
	};
	
	function testSet(set, version) {
	  for (var i = 0; i < set.length; i++) {
	    if (!set[i].test(version))
	      return false;
	  }
	
	  if (version.prerelease.length) {
	    // Find the set of versions that are allowed to have prereleases
	    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
	    // That should allow `1.2.3-pr.2` to pass.
	    // However, `1.2.4-alpha.notready` should NOT be allowed,
	    // even though it's within the range set by the comparators.
	    for (var i = 0; i < set.length; i++) {
	      debug(set[i].semver);
	      if (set[i].semver === ANY)
	        continue;
	
	      if (set[i].semver.prerelease.length > 0) {
	        var allowed = set[i].semver;
	        if (allowed.major === version.major &&
	            allowed.minor === version.minor &&
	            allowed.patch === version.patch)
	          return true;
	      }
	    }
	
	    // Version has a -pre, but it's not one of the ones we like.
	    return false;
	  }
	
	  return true;
	}
	
	exports.satisfies = satisfies;
	function satisfies(version, range, loose) {
	  try {
	    range = new Range(range, loose);
	  } catch (er) {
	    return false;
	  }
	  return range.test(version);
	}
	
	exports.maxSatisfying = maxSatisfying;
	function maxSatisfying(versions, range, loose) {
	  return versions.filter(function(version) {
	    return satisfies(version, range, loose);
	  }).sort(function(a, b) {
	    return rcompare(a, b, loose);
	  })[0] || null;
	}
	
	exports.minSatisfying = minSatisfying;
	function minSatisfying(versions, range, loose) {
	  return versions.filter(function(version) {
	    return satisfies(version, range, loose);
	  }).sort(function(a, b) {
	    return compare(a, b, loose);
	  })[0] || null;
	}
	
	exports.validRange = validRange;
	function validRange(range, loose) {
	  try {
	    // Return '*' instead of '' so that truthiness works.
	    // This will throw if it's invalid anyway
	    return new Range(range, loose).range || '*';
	  } catch (er) {
	    return null;
	  }
	}
	
	// Determine if version is less than all the versions possible in the range
	exports.ltr = ltr;
	function ltr(version, range, loose) {
	  return outside(version, range, '<', loose);
	}
	
	// Determine if version is greater than all the versions possible in the range.
	exports.gtr = gtr;
	function gtr(version, range, loose) {
	  return outside(version, range, '>', loose);
	}
	
	exports.outside = outside;
	function outside(version, range, hilo, loose) {
	  version = new SemVer(version, loose);
	  range = new Range(range, loose);
	
	  var gtfn, ltefn, ltfn, comp, ecomp;
	  switch (hilo) {
	    case '>':
	      gtfn = gt;
	      ltefn = lte;
	      ltfn = lt;
	      comp = '>';
	      ecomp = '>=';
	      break;
	    case '<':
	      gtfn = lt;
	      ltefn = gte;
	      ltfn = gt;
	      comp = '<';
	      ecomp = '<=';
	      break;
	    default:
	      throw new TypeError('Must provide a hilo val of "<" or ">"');
	  }
	
	  // If it satisifes the range it is not outside
	  if (satisfies(version, range, loose)) {
	    return false;
	  }
	
	  // From now on, variable terms are as if we're in "gtr" mode.
	  // but note that everything is flipped for the "ltr" function.
	
	  for (var i = 0; i < range.set.length; ++i) {
	    var comparators = range.set[i];
	
	    var high = null;
	    var low = null;
	
	    comparators.forEach(function(comparator) {
	      if (comparator.semver === ANY) {
	        comparator = new Comparator('>=0.0.0')
	      }
	      high = high || comparator;
	      low = low || comparator;
	      if (gtfn(comparator.semver, high.semver, loose)) {
	        high = comparator;
	      } else if (ltfn(comparator.semver, low.semver, loose)) {
	        low = comparator;
	      }
	    });
	
	    // If the edge version comparator has a operator then our version
	    // isn't outside it
	    if (high.operator === comp || high.operator === ecomp) {
	      return false;
	    }
	
	    // If the lowest version comparator has an operator and our version
	    // is less than it then it isn't higher than the range
	    if ((!low.operator || low.operator === comp) &&
	        ltefn(version, low.semver)) {
	      return false;
	    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
	      return false;
	    }
	  }
	  return true;
	}
	
	exports.prerelease = prerelease;
	function prerelease(version, loose) {
	  var parsed = parse(version, loose);
	  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./index": 177,
		"./index.js": 177,
		"./test/require_optional_tests": 184,
		"./test/require_optional_tests.js": 184
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 180;


/***/ },
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(185),
	  require_optional = __webpack_require__(177);
	
	describe('Require Optional', function() {
	  describe('top level require', function() {
	    it('should correctly require co library', function() {
	      var promise = require_optional('es6-promise');
	      assert.ok(promise);
	    });
	
	    it('should fail to require es6-promise library', function() {
	      try {
	        require_optional('co');
	      } catch(e) {
	        assert.equal('OPTIONAL_MODULE_NOT_FOUND', e.code);
	        return;
	      }
	
	      assert.ok(false);
	    });
	
	    it('should ignore optional library not defined', function() {
	      assert.equal(undefined, require_optional('es6-promise2'));
	    });
	  });
	
	  describe('internal module file require', function() {
	    it('should correctly require co library', function() {
	      var Long = require_optional('bson/lib/bson/long.js');
	      assert.ok(Long);
	    });
	  });
	
	  describe('top level resolve', function() {
	    it('should correctly use exists method', function() {
	      assert.equal(false, require_optional.exists('co'));
	      assert.equal(true, require_optional.exists('es6-promise'));
	      assert.equal(true, require_optional.exists('bson/lib/bson/long.js'));
	      assert.equal(false, require_optional.exists('es6-promise2'));
	    });
	  });
	});


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:
	
	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }
	
	  var x = a.length;
	  var y = b.length;
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }
	
	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	function isBuffer(b) {
	  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	    return global.Buffer.isBuffer(b);
	  }
	  return !!(b != null && b._isBuffer);
	}
	
	// based on node assert, original notice:
	
	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var util = __webpack_require__(77);
	var hasOwn = Object.prototype.hasOwnProperty;
	var pSlice = Array.prototype.slice;
	var functionsHaveNames = (function () {
	  return function foo() {}.name === 'foo';
	}());
	function pToString (obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer(arrbuf)) {
	    return false;
	  }
	  if (typeof global.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.
	
	var assert = module.exports = ok;
	
	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })
	
	var regex = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!util.isFunction(func)) {
	    return;
	  }
	  if (functionsHaveNames) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex);
	  return match && match[1];
	}
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;
	
	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }
	
	      this.stack = out;
	    }
	  }
	};
	
	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);
	
	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames || !util.isFunction(something)) {
	    return util.inspect(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' +  name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(inspect(self.expected), 128);
	}
	
	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.
	
	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.
	
	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}
	
	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;
	
	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.
	
	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;
	
	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);
	
	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};
	
	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);
	
	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};
	
	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);
	
	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};
	
	assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	  }
	};
	
	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer(actual) && isBuffer(expected)) {
	    return compare(actual, expected) === 0;
	
	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;
	
	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;
	
	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer),
	                   new Uint8Array(expected.buffer)) === 0;
	
	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer(actual) !== isBuffer(expected)) {
	    return false;
	  } else {
	    memos = memos || {actual: [], expected: []};
	
	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }
	
	    memos.actual.push(actual);
	    memos.expected.push(expected);
	
	    return objEquiv(actual, expected, strict, memos);
	  }
	}
	
	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}
	
	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b))
	    return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments(a);
	  var bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}
	
	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);
	
	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};
	
	assert.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}
	
	
	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);
	
	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};
	
	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
	
	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};
	
	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }
	
	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }
	
	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }
	
	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }
	
	  return expected.call({}, actual) === true;
	}
	
	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}
	
	function _throws(shouldThrow, block, expected, message) {
	  var actual;
	
	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }
	
	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }
	
	  actual = _tryBlock(block);
	
	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');
	
	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }
	
	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && util.isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;
	
	  if ((isUnwantedException &&
	      userProvidedMessage &&
	      expectedException(actual, expected)) ||
	      isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }
	
	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}
	
	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);
	
	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	};
	
	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	};
	
	assert.ifError = function(err) { if (err) throw err; };
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var f = __webpack_require__(77).format
	  , crypto = __webpack_require__(70)
	  , require_optional = __webpack_require__(177)
	  , MongoError = __webpack_require__(157);
	
	var AuthSession = function(db, username, password, options) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	  this.options = options;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	// Kerberos class
	var Kerberos = null;
	var MongoAuthProcess = null;
	
	// Try to grab the Kerberos class
	try {
	  Kerberos = require_optional('kerberos').Kerberos
	  // Authentication process for Mongo
	  MongoAuthProcess = require_optional('kerberos').processes.MongoAuthProcess
	} catch(err) {}
	
	/**
	 * Creates a new SSPI authentication mechanism
	 * @class
	 * @return {SSPI} A cursor instance
	 */
	var SSPI = function() {
	  this.authStore = [];
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	SSPI.prototype.auth = function(server, connections, db, username, password, options, callback) {
	  var self = this;
	  // We don't have the Kerberos library
	  if(Kerberos == null) return callback(new Error("Kerberos library is not installed"));
	  var gssapiServiceName = options['gssapiServiceName'] || 'mongodb';
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var credentialsValid = false;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {
	    // Execute MongoCR
	    var execute = function(connection) {
	      // Start Auth process for a connection
	      SSIPAuthenticate(username, password, gssapiServiceName, server, connection, options, function(err, r) {
	        // Adjust count
	        count = count - 1;
	
	        // If we have an error
	        if(err) {
	          errorObject = err;
	        } else if(r && typeof r == 'object' && r.result['$err']) {
	          errorObject = r.result;
	        } else if(r && typeof r == 'object' && r.result['errmsg']) {
	          errorObject = r.result;
	        } else {
	          credentialsValid = true;
	          numberOfValidConnections = numberOfValidConnections + 1;
	        }
	
	        // We have authenticated all connections
	        if(count == 0 && numberOfValidConnections > 0) {
	          // Store the auth details
	          addAuthSession(self.authStore, new AuthSession(db, username, password, options));
	          // Return correct authentication
	          callback(null, true);
	        } else if(count == 0) {
	          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
	          callback(errorObject, false);
	        }
	      });
	    }
	
	    var _execute = function(_connection) {
	      process.nextTick(function() {
	        execute(_connection);
	      });
	    }
	
	    _execute(connections.shift());
	  }
	}
	
	var SSIPAuthenticate = function(username, password, gssapiServiceName, server, connection, options, callback) {
	  // Build Authentication command to send to MongoDB
	  var command = {
	      saslStart: 1
	    , mechanism: 'GSSAPI'
	    , payload: ''
	    , autoAuthorize: 1
	  };
	
	  // Create authenticator
	  var mongo_auth_process = new MongoAuthProcess(connection.host, connection.port, gssapiServiceName, options);
	
	  // Execute first sasl step
	  server.command("$external.$cmd"
	    , command
	    , { connection: connection }, function(err, r) {
	    if(err) return callback(err, false);
	    var doc = r.result;
	
	    mongo_auth_process.init(username, password, function(err) {
	      if(err) return callback(err);
	
	      mongo_auth_process.transition(doc.payload, function(err, payload) {
	        if(err) return callback(err);
	
	        // Perform the next step against mongod
	        var command = {
	            saslContinue: 1
	          , conversationId: doc.conversationId
	          , payload: payload
	        };
	
	        // Execute the command
	        server.command("$external.$cmd"
	          , command
	          , { connection: connection }, function(err, r) {
	          if(err) return callback(err, false);
	          var doc = r.result;
	
	          mongo_auth_process.transition(doc.payload, function(err, payload) {
	            if(err) return callback(err);
	
	            // Perform the next step against mongod
	            var command = {
	                saslContinue: 1
	              , conversationId: doc.conversationId
	              , payload: payload
	            };
	
	            // Execute the command
	            server.command("$external.$cmd"
	              , command
	              , { connection: connection }, function(err, r) {
	              if(err) return callback(err, false);
	              var doc = r.result;
	
	              mongo_auth_process.transition(doc.payload, function(err, payload) {
	                // Perform the next step against mongod
	                var command = {
	                    saslContinue: 1
	                  , conversationId: doc.conversationId
	                  , payload: payload
	                };
	
	                // Execute the command
	                server.command("$external.$cmd"
	                  , command
	                  , { connection: connection }, function(err, r) {
	                  if(err) return callback(err, false);
	                  var doc = r.result;
	
	                  if(doc.done) return callback(null, true);
	                  callback(new Error("Authentication failed"), false);
	                });
	              });
	            });
	          });
	        });
	      });
	    });
	  });
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	SSPI.prototype.reauthenticate = function(server, connections, callback) {
	  var authStore = this.authStore.slice(0);
	  var err = null;
	  var count = authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < authStore.length; i++) {
	    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, authStore[i].options, function(err, r) {
	      if(err) err = err;
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(err, null);
	      }
	    });
	  }
	}
	
	/**
	 * This is a result from a authentication strategy
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {boolean} result The result of the authentication process
	 */
	
	module.exports = SSPI;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {"use strict";
	
	var f = __webpack_require__(77).format
	  , crypto = __webpack_require__(70)
	  , Binary = __webpack_require__(134).Binary
	  , MongoError = __webpack_require__(157);
	
	var AuthSession = function(db, username, password) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	var id = 0;
	
	/**
	 * Creates a new ScramSHA1 authentication mechanism
	 * @class
	 * @return {ScramSHA1} A cursor instance
	 */
	var ScramSHA1 = function() {
	  this.authStore = [];
	  this.id = id++;
	}
	
	var parsePayload = function(payload) {
	  var dict = {};
	  var parts = payload.split(',');
	
	  for(var i = 0; i < parts.length; i++) {
	    var valueParts = parts[i].split('=');
	    dict[valueParts[0]] = valueParts[1];
	  }
	
	  return dict;
	}
	
	var passwordDigest = function(username, password) {
	  if(typeof username != 'string') throw new MongoError("username must be a string");
	  if(typeof password != 'string') throw new MongoError("password must be a string");
	  if(password.length == 0) throw new MongoError("password cannot be empty");
	  // Use node md5 generator
	  var md5 = crypto.createHash('md5');
	  // Generate keys used for authentication
	  md5.update(username + ":mongo:" + password, 'utf8');
	  return md5.digest('hex');
	}
	
	// XOR two buffers
	var xor = function(a, b) {
	  if (!Buffer.isBuffer(a)) a = new Buffer(a)
	  if (!Buffer.isBuffer(b)) b = new Buffer(b)
	  var res = []
	  if (a.length > b.length) {
	    for (var i = 0; i < b.length; i++) {
	      res.push(a[i] ^ b[i])
	    }
	  } else {
	    for (var i = 0; i < a.length; i++) {
	      res.push(a[i] ^ b[i])
	    }
	  }
	  return new Buffer(res);
	}
	
	// Create a final digest
	var hi = function(data, salt, iterations) {
	  // Create digest
	  var digest = function(msg) {
	    var hmac = crypto.createHmac('sha1', data);
	    hmac.update(msg);
	    return new Buffer(hmac.digest('base64'), 'base64');
	  }
	
	  // Create variables
	  salt = Buffer.concat([salt, new Buffer('\x00\x00\x00\x01')])
	  var ui = digest(salt);
	  var u1 = ui;
	
	  for(var i = 0; i < iterations - 1; i++) {
	    u1 = digest(u1);
	    ui = xor(ui, u1);
	  }
	
	  return ui;
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	ScramSHA1.prototype.auth = function(server, connections, db, username, password, callback) {
	  var self = this;
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var credentialsValid = false;
	  var errorObject = null;
	
	  // Execute MongoCR
	  var executeScram = function(connection) {
	    // Clean up the user
	    username = username.replace('=', "=3D").replace(',', '=2C');
	
	    // Create a random nonce
	    var nonce = crypto.randomBytes(24).toString('base64');
	    // var nonce = 'MsQUY9iw0T9fx2MUEz6LZPwGuhVvWAhc'
	    var firstBare = f("n=%s,r=%s", username, nonce);
	
	    // Build command structure
	    var cmd = {
	        saslStart: 1
	      , mechanism: 'SCRAM-SHA-1'
	      , payload: new Binary(f("n,,%s", firstBare))
	      , autoAuthorize: 1
	    }
	
	    // Handle the error
	    var handleError = function(err, r) {
	      if(err) {
	        numberOfValidConnections = numberOfValidConnections - 1;
	        errorObject = err; return false;
	      } else if(r.result['$err']) {
	        errorObject = r.result; return false;
	      } else if(r.result['errmsg']) {
	        errorObject = r.result; return false;
	      } else {
	        credentialsValid = true;
	        numberOfValidConnections = numberOfValidConnections + 1;
	      }
	
	      return true
	    }
	
	    // Finish up
	    var finish = function(_count, _numberOfValidConnections) {
	      if(_count == 0 && _numberOfValidConnections > 0) {
	        // Store the auth details
	        addAuthSession(self.authStore, new AuthSession(db, username, password));
	        // Return correct authentication
	        return callback(null, true);
	      } else if(_count == 0) {
	        if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using scram"));
	        return callback(errorObject, false);
	      }
	    }
	
	    var handleEnd = function(_err, _r) {
	      // Handle any error
	      handleError(_err, _r)
	      // Adjust the number of connections
	      count = count - 1;
	      // Execute the finish
	      finish(count, numberOfValidConnections);
	    }
	
	    // Execute start sasl command
	    server.command(f("%s.$cmd", db)
	      , cmd, { connection: connection }, function(err, r) {
	
	      // Do we have an error, handle it
	      if(handleError(err, r) == false) {
	        count = count - 1;
	
	        if(count == 0 && numberOfValidConnections > 0) {
	          // Store the auth details
	          addAuthSession(self.authStore, new AuthSession(db, username, password));
	          // Return correct authentication
	          return callback(null, true);
	        } else if(count == 0) {
	          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using scram"));
	          return callback(errorObject, false);
	        }
	
	        return;
	      }
	
	      // Get the dictionary
	      var dict = parsePayload(r.result.payload.value())
	
	      // Unpack dictionary
	      var iterations = parseInt(dict.i, 10);
	      var salt = dict.s;
	      var rnonce = dict.r;
	
	      // Set up start of proof
	      var withoutProof = f("c=biws,r=%s", rnonce);
	      var passwordDig = passwordDigest(username, password);
	      var saltedPassword = hi(passwordDig
	          , new Buffer(salt, 'base64')
	          , iterations);
	
	      // Create the client key
	      var hmac = crypto.createHmac('sha1', saltedPassword);
	      hmac.update(new Buffer("Client Key"));
	      var clientKey = new Buffer(hmac.digest('base64'), 'base64');
	
	      // Create the stored key
	      var hash = crypto.createHash('sha1');
	      hash.update(clientKey);
	      var storedKey = new Buffer(hash.digest('base64'), 'base64');
	
	      // Create the authentication message
	      var authMsg = [firstBare, r.result.payload.value().toString('base64'), withoutProof].join(',');
	
	      // Create client signature
	      var hmac = crypto.createHmac('sha1', storedKey);
	      hmac.update(new Buffer(authMsg));
	      var clientSig = new Buffer(hmac.digest('base64'), 'base64');
	
	      // Create client proof
	      var clientProof = f("p=%s", new Buffer(xor(clientKey, clientSig)).toString('base64'));
	
	      // Create client final
	      var clientFinal = [withoutProof, clientProof].join(',');
	
	      // Generate server key
	      var hmac = crypto.createHmac('sha1', saltedPassword);
	      hmac.update(new Buffer('Server Key'))
	      var serverKey = new Buffer(hmac.digest('base64'), 'base64');
	
	      // Generate server signature
	      var hmac = crypto.createHmac('sha1', serverKey);
	      hmac.update(new Buffer(authMsg))
	      var serverSig = new Buffer(hmac.digest('base64'), 'base64');
	
	      //
	      // Create continue message
	      var cmd = {
	          saslContinue: 1
	        , conversationId: r.result.conversationId
	        , payload: new Binary(new Buffer(clientFinal))
	      }
	
	      //
	      // Execute sasl continue
	      server.command(f("%s.$cmd", db)
	        , cmd, { connection: connection }, function(err, r) {
	          if(r && r.result.done == false) {
	            var cmd = {
	                saslContinue: 1
	              , conversationId: r.result.conversationId
	              , payload: new Buffer(0)
	            }
	
	            server.command(f("%s.$cmd", db)
	              , cmd, { connection: connection }, function(err, r) {
	                handleEnd(err, r);
	            });
	          } else {
	            handleEnd(err, r);
	          }
	      });
	    });
	  }
	
	  var _execute = function(_connection) {
	    process.nextTick(function() {
	      executeScram(_connection);
	    });
	  }
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {
	    _execute(connections.shift());
	  }
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	ScramSHA1.prototype.reauthenticate = function(server, connections, callback) {
	  var authStore = this.authStore.slice(0);
	  var count = authStore.length;
	  var err = null;
	  // No connections
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < authStore.length; i++) {
	    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function(err, r) {
	      if(err) err = err;
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(err, null);
	      }
	    });
	  }
	}
	
	
	module.exports = ScramSHA1;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer, __webpack_require__(6)))

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var inherits = __webpack_require__(77).inherits
	  , f = __webpack_require__(77).format
	  , b = __webpack_require__(134)
	  , bindToCurrentDomain = __webpack_require__(159).bindToCurrentDomain
	  , debugOptions = __webpack_require__(159).debugOptions
	  , EventEmitter = __webpack_require__(3).EventEmitter
	  , Server = __webpack_require__(158)
	  , ReadPreference = __webpack_require__(164)
	  , MongoError = __webpack_require__(157)
	  , Ping = __webpack_require__(189)
	  , Session = __webpack_require__(172)
	  , BasicCursor = __webpack_require__(165)
	  , BSON = __webpack_require__(134).native().BSON
	  , State = __webpack_require__(190)
	  , MongoCR = __webpack_require__(173)
	  , X509 = __webpack_require__(174)
	  , Plain = __webpack_require__(175)
	  , GSSAPI = __webpack_require__(176)
	  , SSPI = __webpack_require__(186)
	  , ScramSHA1 = __webpack_require__(187)
	  , Logger = __webpack_require__(163);
	
	/**
	 * @fileOverview The **ReplSet** class is a class that represents a Replicaset topology and is
	 * used to construct connecctions.
	 *
	 * @example
	 * var ReplSet = require('mongodb-core').ReplSet
	 *   , ReadPreference = require('mongodb-core').ReadPreference
	 *   , assert = require('assert');
	 *
	 * var server = new ReplSet([{host: 'localhost', port: 30000}], {setName: 'rs'});
	 * // Wait for the connection event
	 * server.on('connect', function(server) {
	 *   server.destroy();
	 * });
	 *
	 * // Start connecting
	 * server.connect();
	 */
	
	var DISCONNECTED = 'disconnected';
	var CONNECTING = 'connecting';
	var CONNECTED = 'connected';
	var DESTROYED = 'destroyed';
	
	//
	// ReplSet instance id
	var replSetId = 1;
	
	//
	// Clone the options
	var cloneOptions = function(options) {
	  var opts = {};
	  for(var name in options) {
	    opts[name] = options[name];
	  }
	  return opts;
	}
	
	// All bson types
	var bsonTypes = [b.Long, b.ObjectID, b.Binary, b.Code, b.DBRef, b.Symbol, b.Double, b.Timestamp, b.MaxKey, b.MinKey];
	// BSON parser
	var bsonInstance = null;
	
	/**
	 * Creates a new Replset instance
	 * @class
	 * @param {array} seedlist A list of seeds for the replicaset
	 * @param {boolean} options.setName The Replicaset set name
	 * @param {boolean} [options.secondaryOnlyConnectionAllowed=false] Allow connection to a secondary only replicaset
	 * @param {number} [options.haInterval=10000] The High availability period for replicaset inquiry
	 * @param {boolean} [options.emitError=false] Server will emit errors events
	 * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors
	 * @param {number} [options.size=5] Server connection pool size
	 * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
	 * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.connectionTimeout=10000] TCP Connection timeout setting
	 * @param {number} [options.socketTimeout=0] TCP Socket timeout setting
	 * @param {number} [options.monitoringSocketTimeout=30000] TCP Socket timeout setting for replicaset monitoring socket
	 * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed
	 * @param {boolean} [options.ssl=false] Use SSL for connection
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {Buffer} [options.ca] SSL Certificate store binary buffer
	 * @param {Buffer} [options.cert] SSL Certificate binary buffer
	 * @param {Buffer} [options.key] SSL Key file binary buffer
	 * @param {string} [options.passphrase] SSL Certificate pass phrase
	 * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates
	 * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
	 * @param {number} [options.pingInterval=5000] Ping interval to check the response time to the different servers
	 * @param {number} [options.acceptableLatency=250] Acceptable latency for selecting a server for reading (in milliseconds)
	 * @return {ReplSet} A cursor instance
	 * @fires ReplSet#connect
	 * @fires ReplSet#ha
	 * @fires ReplSet#joined
	 * @fires ReplSet#left
	 */
	var ReplSet = function(seedlist, options) {
	  var self = this;
	  options = options || {};
	  // Clone the options
	  options = cloneOptions(options);
	
	  // Validate seedlist
	  if(!Array.isArray(seedlist)) throw new MongoError("seedlist must be an array");
	  // Validate list
	  if(seedlist.length == 0) throw new MongoError("seedlist must contain at least one entry");
	  // Validate entries
	  seedlist.forEach(function(e) {
	    if(typeof e.host != 'string' || typeof e.port != 'number')
	      throw new MongoError("seedlist entry must contain a host and port");
	  });
	
	  // Add event listener
	  EventEmitter.call(this);
	
	  // Set the bson instance
	  bsonInstance = bsonInstance == null ? new BSON(bsonTypes) : bsonInstance;
	
	  // Internal state hash for the object
	  this.s = {
	      options: options
	    // Logger instance
	    , logger: Logger('ReplSet', options)
	    // Uniquely identify the replicaset instance
	    , id: replSetId++
	    // Index
	    , index: 0
	    // Ha Index
	    , haId: 0
	    // Current credentials used for auth
	    , credentials: []
	    // Factory overrides
	    , Cursor: options.cursorFactory || BasicCursor
	    // BSON Parser, ensure we have a single instance
	    , bsonInstance: bsonInstance
	    // Pick the right bson parser
	    , bson: options.bson ? options.bson : bsonInstance
	    // Special replicaset options
	    , secondaryOnlyConnectionAllowed: typeof options.secondaryOnlyConnectionAllowed == 'boolean'
	    ? options.secondaryOnlyConnectionAllowed : false
	    , haInterval: options.haInterval || 10000
	    // Current haInterval
	    , currentHaInterval: options.haInterval || 10000
	    // Are we running in debug mode
	    , debug: typeof options.debug == 'boolean' ? options.debug : false
	    // The replicaset name
	    , setName: options.setName
	    // Swallow or emit errors
	    , emitError: typeof options.emitError == 'boolean' ? options.emitError : false
	    // Grouping tag used for debugging purposes
	    , tag: options.tag
	    // Do we have a not connected handler
	    , disconnectHandler: options.disconnectHandler
	    // Contains any alternate strategies for picking
	    , readPreferenceStrategies: {}
	    // Auth providers
	    , authProviders: {}
	    // All the servers
	    , disconnectedServers: []
	    // Initial connection servers
	    , initialConnectionServers: []
	    // High availability process running
	    , highAvailabilityProcessRunning: false
	    // Full setup
	    , fullsetup: false
	    // All servers accounted for (used for testing)
	    , all: false
	    // Seedlist
	    , seedlist: seedlist
	    // Authentication in progress
	    , authInProgress: false
	    // Servers added while auth in progress
	    , authInProgressServers: []
	    // Minimum heartbeat frequency used if we detect a server close
	    , minHeartbeatFrequencyMS: 500
	    // stores high availability timer to allow efficient destroy
	    , haTimer : null
	  }
	
	  // Add bson parser to options
	  options.bson = this.s.bson;
	  // Set up the connection timeout for the options
	  options.connectionTimeout = options.connectionTimeout || 10000;
	
	  // Replicaset state
	  var replState = new State(this, {
	      id: this.s.id, setName: this.s.setName
	    // , connectingServers: this.s.connectingServers
	    , secondaryOnlyConnectionAllowed: this.s.secondaryOnlyConnectionAllowed
	  });
	
	  // Add Replicaset state to our internal state
	  this.s.replState = replState;
	
	  // Add the authentication mechanisms
	  this.addAuthProvider('mongocr', new MongoCR());
	  this.addAuthProvider('x509', new X509());
	  this.addAuthProvider('plain', new Plain());
	  this.addAuthProvider('gssapi', new GSSAPI());
	  this.addAuthProvider('sspi', new SSPI());
	  this.addAuthProvider('scram-sha-1', new ScramSHA1());
	
	  // BSON property (find a server and pass it along)
	  Object.defineProperty(this, 'bson', {
	    enumerable: true, get: function() {
	      var servers = self.s.replState.getAll();
	      return servers.length > 0 ? servers[0].bson : null;
	    }
	  });
	
	  Object.defineProperty(this, 'id', {
	    enumerable:true, get: function() { return self.s.id; }
	  });
	
	  Object.defineProperty(this, 'haInterval', {
	    enumerable:true, get: function() { return self.s.haInterval; }
	  });
	
	  Object.defineProperty(this, 'state', {
	    enumerable:true, get: function() { return self.s.replState; }
	  });
	
	  //
	  // Debug options
	  if(self.s.debug) {
	    // Add access to the read Preference Strategies
	    Object.defineProperty(this, 'readPreferenceStrategies', {
	      enumerable: true, get: function() { return self.s.readPreferenceStrategies; }
	    });
	  }
	
	  Object.defineProperty(this, 'type', {
	    enumerable:true, get: function() { return 'replset'; }
	  });
	
	  // Add the ping strategy for nearest
	  this.addReadPreferenceStrategy('nearest', new Ping(options));
	}
	
	inherits(ReplSet, EventEmitter);
	
	//
	// Plugin methods
	//
	
	/**
	 * Add custom read preference strategy
	 * @method
	 * @param {string} name Name of the read preference strategy
	 * @param {object} strategy Strategy object instance
	 */
	ReplSet.prototype.addReadPreferenceStrategy = function(name, func) {
	  this.s.readPreferenceStrategies[name] = func;
	}
	
	/**
	 * Add custom authentication mechanism
	 * @method
	 * @param {string} name Name of the authentication mechanism
	 * @param {object} provider Authentication object instance
	 */
	ReplSet.prototype.addAuthProvider = function(name, provider) {
	  if(this.s.authProviders == null) this.s.authProviders = {};
	  this.s.authProviders[name] = provider;
	}
	
	/**
	 * Name of BSON parser currently used
	 * @method
	 * @return {string}
	 */
	ReplSet.prototype.parserType = function() {
	  if(this.s.bson.serialize.toString().indexOf('[native code]') != -1)
	    return 'c++';
	  return 'js';
	}
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} type Type of BSON parser to use (c++ or js)
	 */
	ReplSet.prototype.setBSONParserType = function(type) {
	  var nBSON = null;
	
	  if(type == 'c++') {
	    nBSON = __webpack_require__(134).native().BSON;
	  } else if(type == 'js') {
	    nBSON = __webpack_require__(134).pure().BSON;
	  } else {
	    throw new MongoError(f("% parser not supported", type));
	  }
	
	  this.s.options.bson = new nBSON(bsonTypes);
	}
	
	/**
	 * Returns the last known ismaster document for this server
	 * @method
	 * @return {object}
	 */
	ReplSet.prototype.lastIsMaster = function() {
	  return this.s.replState.lastIsMaster();
	}
	
	/**
	 * Get connection
	 * @method
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @return {Connection}
	 */
	ReplSet.prototype.getConnection = function(options) {
	  // Ensure we have no options
	  options = options || {};
	  // Pick the right server based on readPreference
	  var server = pickServer(this, this.s, options.readPreference);
	  if(server == null) return null;
	  // Return connection
	  return server.getConnection();
	}
	
	/**
	 * All raw connections
	 * @method
	 * @return {Connection[]}
	 */
	ReplSet.prototype.connections = function() {
	  return this.s.replState.getAllConnections({includeArbiters:true});
	}
	
	/**
	 * Get server
	 * @method
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @return {Server}
	 */
	ReplSet.prototype.getServer = function(options) {
	  // Ensure we have no options
	  options = options || {};
	  // Pick the right server based on readPreference
	  return pickServer(this, this.s, options.readPreference);
	}
	
	/**
	 * Get correct server for a given connection
	 * @method
	 * @param {Connection} [connection] A Connection showing a current server
	 * @return {Server}
	 */
	ReplSet.prototype.getServerFrom = function(connection) {
	  var servers = this.s.replState.getAll();
	  // Go through all the server
	  for(var i = 0; i < servers.length; i++) {
	    if(servers[i].equals(connection.name)) return servers[i];
	  }
	
	  return null;
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {{object}|{Long}} cmd Can be either a command returning a cursor or a cursorId
	 * @param {object} [options.batchSize=0] Batchsize for the operation
	 * @param {array} [options.documents=[]] Initial documents list for cursor
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	ReplSet.prototype.cursor = function(ns, cmd, cursorOptions) {
	  cursorOptions = cursorOptions || {};
	  var FinalCursor = cursorOptions.cursorFactory || this.s.Cursor;
	  return new FinalCursor(this.s.bson, ns, cmd, cursorOptions, this, this.s.options);
	}
	
	//
	// Execute write operation
	var executeWriteOperation = function(self, op, ns, ops, options, callback) {
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  var server = null;
	  // Ensure we have no options
	  options = options || {};
	  // Get a primary
	  try {
	    server = pickServer(self, self.s, ReadPreference.primary);
	    if(self.s.debug) self.emit('pickedServer', ReadPreference.primary, server);
	  } catch(err) {
	    return callback(err);
	  }
	
	  // No server returned we had an error
	  if(server == null) return callback(new MongoError("no server found"));
	
	  // Handler
	  var handler = function(err, r) {
	    // We have a no master error, immediately refresh the view of the replicaset
	    if((notMasterError(r) || notMasterError(err)) && !self.s.highAvailabilityProcessRunning) {
	      // Set he current interval to minHeartbeatFrequencyMS
	      self.s.currentHaInterval = self.s.minHeartbeatFrequencyMS;
	      // Attempt to locate the current master immediately
	      replicasetInquirer(self, self.s, true)();
	    }
	    // Return the result
	    callback(err, r);
	  }
	
	  // Add operationId if existing
	  if(callback.operationId) handler.operationId = callback.operationId;
	  // Execute the command
	  server[op](ns, ops, options, handler);
	}
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {object} cmd The command hash
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {Connection} [options.connection] Specify connection object to execute command against
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	ReplSet.prototype.command = function(ns, cmd, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.replState.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  var server = null;
	  var self = this;
	  // Ensure we have no options
	  options = options || {};
	
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!this.isConnected(options) && this.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);
	  }
	
	  // We need to execute the command on all servers
	  if(options.onAll) {
	    var servers = this.s.replState.getAll();
	    var count = servers.length;
	    var cmdErr = null;
	
	    for(var i = 0; i < servers.length; i++) {
	      servers[i].command(ns, cmd, options, function(err, r) {
	        count = count - 1;
	        // Finished executing command
	        if(count == 0) {
	          // Was it a logout command clear any credentials
	          if(cmd.logout) clearCredentials(self.s, ns);
	          // We have a no master error, immediately refresh the view of the replicaset
	          if((notMasterError(r) || notMasterError(err)) && !self.s.highAvailabilityProcessRunning) {
	            replicasetInquirer(self, self.s, true)();
	          }
	
	          // Return the error
	          callback(err, r);
	        }
	      });
	    }
	
	    return;
	  }
	
	  // Pick the right server based on readPreference
	  try {
	    server = pickServer(self, self.s, options.writeConcern ? ReadPreference.primary : options.readPreference);
	    if(self.s.debug) self.emit('pickedServer', options.writeConcern ? ReadPreference.primary : options.readPreference, server);
	  } catch(err) {
	    return callback(err);
	  }
	
	  // No server returned we had an error
	  if(server == null) return callback(new MongoError("no server found"));
	  // Execute the command
	  server.command(ns, cmd, options, function(err, r) {
	    // Was it a logout command clear any credentials
	    if(cmd.logout) clearCredentials(self.s, ns);
	    // We have a no master error, immediately refresh the view of the replicaset
	    if((notMasterError(r) || notMasterError(err)) && !self.s.highAvailabilityProcessRunning) {
	      replicasetInquirer(self, self.s, true)();
	    }
	    // Return the error
	    callback(err, r);
	  });
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of removes
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	ReplSet.prototype.remove = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.replState.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!this.isConnected() && this.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return this.s.disconnectHandler.add('remove', ns, ops, options, callback);
	  }
	
	  executeWriteOperation(this, 'remove', ns, ops, options, callback);
	}
	
	/**
	 * Insert one or more documents
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of documents to insert
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	ReplSet.prototype.insert = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.replState.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!this.isConnected() && this.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return this.s.disconnectHandler.add('insert', ns, ops, options, callback);
	  }
	
	  executeWriteOperation(this, 'insert', ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more update operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of updates
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	ReplSet.prototype.update = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.replState.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!this.isConnected() && this.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return this.s.disconnectHandler.add('update', ns, ops, options, callback);
	  }
	
	  executeWriteOperation(this, 'update', ns, ops, options, callback);
	}
	
	/**
	 * Authenticate using a specified mechanism
	 * @method
	 * @param {string} mechanism The Auth mechanism we are invoking
	 * @param {string} db The db we are invoking the mechanism against
	 * @param {...object} param Parameters for the specific mechanism
	 * @param {authResultCallback} callback A callback function
	 */
	ReplSet.prototype.auth = function(mechanism, db) {
	  var allArgs = Array.prototype.slice.call(arguments, 0).slice(0);
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  var callback = args.pop();
	
	  // If we don't have the mechanism fail
	  if(this.s.authProviders[mechanism] == null && mechanism != 'default') {
	    throw new MongoError(f("auth provider %s does not exist", mechanism));
	  }
	
	  // Authenticate against all the servers
	  var servers = this.s.replState.getAll().slice(0);
	  var count = servers.length;
	  // Correct authentication
	  var authenticated = true;
	  var authErr = null;
	  // Set auth in progress
	  this.s.authInProgress = true;
	
	  // Authenticate against all servers
	  while(servers.length > 0) {
	    var server = servers.shift();
	
	    // Arguments without a callback
	    var argsWithoutCallback = [mechanism, db].concat(args.slice(0));
	    // Create arguments
	    var finalArguments = argsWithoutCallback.concat([function(err, r) {
	      count = count - 1;
	      if(err) authErr = err;
	      if(!r) authenticated = false;
	
	      // We are done
	      if(count == 0) {
	        // We have more servers that are not authenticated, let's authenticate
	        if(self.s.authInProgressServers.length > 0) {
	          self.s.authInProgressServers = [];
	          return self.auth.apply(self, [mechanism, db].concat(args).concat([callback]));
	        }
	
	        // Auth is done
	        self.s.authInProgress = false;
	        // Add successful credentials
	        if(authErr == null) addCredentials(self.s, db, argsWithoutCallback);
	        // Return the auth error
	        if(authErr) return callback(authErr, false);
	        // Successfully authenticated session
	        callback(null, new Session({}, self));
	      }
	    }]);
	
	    // Execute the auth
	    server.auth.apply(server, finalArguments);
	  }
	}
	
	ReplSet.prototype.state = function() {
	  return this.s.replState.state;
	}
	
	/**
	 * Ensure single socket connections to arbiters and hidden servers
	 * @method
	 */
	var handleIsmaster = function(self) {
	  return function(ismaster, _server) {
	    if(ismaster.arbiterOnly) {
	      _server.s.options.size = 1;
	    } else if(ismaster.hidden) {
	      _server.s.options.size = 1;
	    }
	  }
	}
	
	/**
	 * Emit event if it exists
	 * @method
	 */
	function emitSDAMEvent(self, event, description) {
	  if(self.listeners(event).length > 0) {
	    self.emit(event, description);
	  }
	}
	
	/**
	 * Initiate server connect
	 * @method
	 */
	ReplSet.prototype.connect = function(_options) {
	  var self = this;
	  // Start replicaset inquiry process
	  setHaTimer(self, self.s);
	  // Additional options
	  if(_options) for(var name in _options) this.s.options[name] = _options[name];
	
	  // Set the state as connecting
	  this.s.replState.state = CONNECTING;
	
	  // No fullsetup reached
	  this.s.fullsetup = false;
	
	  // Reset the replState
	  this.s.replState.resetDescription();
	
	  // For all entries in the seedlist build a server instance
	  this.s.seedlist.forEach(function(e) {
	    // Clone options
	    var opts = cloneOptions(self.s.options);
	    // Add host and port
	    opts.host = e.host;
	    opts.port = e.port;
	    opts.reconnect = false;
	    opts.readPreferenceStrategies = self.s.readPreferenceStrategies;
	    opts.emitError = true;
	    // Add a reserved connection for monitoring
	    opts.size = opts.size + 1;
	    opts.monitoring = true;
	    opts.topologyId = self.s.id;
	    // Server is in topology
	    opts.inTopology = true;
	    // Set up tags if any
	    if(self.s.tag) opts.tag = self.s.tag;
	    // Share the auth store
	    opts.authProviders = self.s.authProviders;
	    // Create a new Server
	    var server = new Server(opts);
	    // Handle the ismaster
	    server.on('ismaster', handleIsmaster(self));
	    // Add to list of disconnected servers
	    self.s.disconnectedServers.push(server);
	    // Add to list of inflight Connections
	    self.s.initialConnectionServers.push(server);
	  });
	
	  // Emit the topology opening event
	  emitSDAMEvent(this, 'topologyOpening', { topologyId: this.s.id });
	
	  // Attempt to connect to all the servers
	  while(this.s.disconnectedServers.length > 0) {
	    // Get the server
	    var server = self.s.disconnectedServers.shift();
	    // Ensure the server is properly disconnected
	    server.destroy();
	
	    // Set up the event handlers
	    server.once('error', errorHandlerTemp(self, self.s, 'error'));
	    server.once('close', errorHandlerTemp(self, self.s, 'close'));
	    server.once('timeout', errorHandlerTemp(self, self.s, 'timeout'));
	    server.once('connect', connectHandler(self, self.s));
	
	    // SDAM Monitoring events
	    server.on('serverOpening', function(e) { self.emit('serverOpening', e); });
	    server.on('serverDescriptionChanged', function(e) { self.emit('serverDescriptionChanged', e); });
	    server.on('serverHeartbeatStarted', function(e) { self.emit('serverHeartbeatStarted', e); });
	    server.on('serverHeartbeatSucceeded', function(e) { self.emit('serverHeartbeatSucceeded', e); });
	    server.on('serverHearbeatFailed', function(e) { self.emit('serverHearbeatFailed', e); });
	    server.on('serverClosed', function(e) { self.emit('serverClosed', e); });
	
	    // Ensure we schedule the opening of new socket
	    // on separate ticks of the event loop
	    var execute = function(_server) {
	      // Attempt to connect
	      process.nextTick(function() {
	        _server.connect();
	      });
	    }
	
	    execute(server);
	  }
	}
	
	/**
	 * Figure out if the server is connected
	 * @method
	 * @return {boolean}
	 */
	ReplSet.prototype.isConnected = function(options) {
	  options = options || {};
	  // If we specified a read preference check if we are connected to something
	  // than can satisfy this
	  if(options.readPreference
	    && options.readPreference.equals(ReadPreference.secondary)) {
	    return this.s.replState.isSecondaryConnected();
	  }
	
	  if(options.readPreference
	    && options.readPreference.equals(ReadPreference.primary)) {
	    return this.s.replState.isPrimaryConnected();
	  }
	
	  if(options.readPreference
	    && options.readPreference.equals(ReadPreference.primaryPreferred)) {
	    return this.s.replState.isSecondaryConnected() || this.s.replState.isPrimaryConnected();
	  }
	
	  if(options.readPreference
	    && options.readPreference.equals(ReadPreference.secondaryPreferred)) {
	    return this.s.replState.isSecondaryConnected() || this.s.replState.isPrimaryConnected();
	  }
	
	  if(this.s.secondaryOnlyConnectionAllowed
	    && this.s.replState.isSecondaryConnected()) {
	      return true;
	  }
	
	  return this.s.replState.isPrimaryConnected();
	}
	
	/**
	 * Figure out if the replicaset instance was destroyed by calling destroy
	 * @method
	 * @return {boolean}
	 */
	ReplSet.prototype.isDestroyed = function() {
	  return this.s.replState.state == DESTROYED;
	}
	
	/**
	 * Unref all connections belong to this server
	 * @method
	 */
	ReplSet.prototype.unref = function(emitClose) {
	  var self = this;
	  if(this.s.logger.isInfo()) this.s.logger.info(f('[%s] unreferenced', this.s.id));
	
	  // Emit close
	  if(emitClose && self.listeners('close').length > 0) self.emit('close', self);
	
	  // Unref sockets
	  this.s.replState.unref();
	
	  // Clear out any listeners
	  var events = ['timeout', 'error', 'close', 'joined', 'left',
	    'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	    'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'];
	  events.forEach(function(e) {
	    self.removeAllListeners(e);
	  });
	
	  clearTimeout(self.s.haTimer);
	}
	
	/**
	 * Destroy the server connection
	 * @method
	 */
	ReplSet.prototype.destroy = function(emitClose) {
	  var self = this;
	  if(this.s.logger.isInfo()) this.s.logger.info(f('[%s] destroyed', this.s.id));
	  this.s.replState.state = DESTROYED;
	
	  // Clear the ha timer
	  if(self.s.haTimer) clearTimeout(self.s.haTimer);
	
	  // Emit close
	  if(emitClose && self.listeners('close').length > 0) self.emit('close', self);
	
	  // Destroy state
	  this.s.replState.destroy();
	
	  // Emit toplogy closing event
	  emitSDAMEvent(this, 'topologyClosed', { topologyId: this.s.id });
	
	  // Clear out any listeners
	  var events = ['timeout', 'error', 'close', 'joined', 'left',
	    'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	    'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'];
	  events.forEach(function(e) {
	    self.removeAllListeners(e);
	  });
	
	  clearTimeout(self.s.haTimer);
	}
	
	/**
	 * A replset connect event, used to verify that the connection is up and running
	 *
	 * @event ReplSet#connect
	 * @type {ReplSet}
	 */
	
	/**
	 * The replset high availability event
	 *
	 * @event ReplSet#ha
	 * @type {function}
	 * @param {string} type The stage in the high availability event (start|end)
	 * @param {boolean} data.norepeat This is a repeating high availability process or a single execution only
	 * @param {number} data.id The id for this high availability request
	 * @param {object} data.state An object containing the information about the current replicaset
	 */
	
	/**
	 * A server member left the replicaset
	 *
	 * @event ReplSet#left
	 * @type {function}
	 * @param {string} type The type of member that left (primary|secondary|arbiter)
	 * @param {Server} server The server object that left
	 */
	
	/**
	 * A server member joined the replicaset
	 *
	 * @event ReplSet#joined
	 * @type {function}
	 * @param {string} type The type of member that joined (primary|secondary|arbiter)
	 * @param {Server} server The server object that joined
	 */
	
	//
	// Inquires about state changes
	//
	
	// Add the new credential for a db, removing the old
	// credential from the cache
	var addCredentials = function(s, db, argsWithoutCallback) {
	  // Remove any credentials for the db
	  clearCredentials(s, db + ".dummy");
	  // Add new credentials to list
	  s.credentials.push(argsWithoutCallback);
	}
	
	// Clear out credentials for a namespace
	var clearCredentials = function(s, ns) {
	  var db = ns.split('.')[0];
	  var filteredCredentials = [];
	
	  // Filter out all credentials for the db the user is logging out off
	  for(var i = 0; i < s.credentials.length; i++) {
	    if(s.credentials[i][1] != db) filteredCredentials.push(s.credentials[i]);
	  }
	
	  // Set new list of credentials
	  s.credentials = filteredCredentials;
	}
	
	//
	// Filter serves by tags
	var filterByTags = function(readPreference, servers) {
	  if(readPreference.tags == null) return servers;
	  var filteredServers = [];
	  var tagsArray = !Array.isArray(readPreference.tags) ? [tags] : tags;
	
	  // Iterate over the tags
	  for(var j = 0; j < tagsArray.length; j++) {
	    var tags = tagsArray[j];
	
	    // Iterate over all the servers
	    for(var i = 0; i < servers.length; i++) {
	      var serverTag = servers[i].lastIsMaster().tags || {};
	      // Did we find the a matching server
	      var found = true;
	      // Check if the server is valid
	      for(var name in tags) {
	        if(serverTag[name] != tags[name]) found = false;
	      }
	
	      // Add to candidate list
	      if(found) {
	        filteredServers.push(servers[i]);
	      }
	    }
	
	    // We found servers by the highest priority
	    if(found) break;
	  }
	
	  // Returned filtered servers
	  return filteredServers;
	}
	
	var eventHandler = {
	  fullsetup: function(self, state) {
	    // If no more initial servers and new scheduled servers to connect
	    if (!state.replState.primary) return;
	    if (state.replState.secondaries.length === 0) return;
	    if (state.fullsetup) return;
	
	    // Only emit if there is a listener
	    if(self.listeners('fullsetup').length > 0) {
	      state.fullsetup = true;
	      self.emit('fullsetup', self);
	    }
	  },
	  all: function(self, state) {
	    // If all servers are accounted for and we have not sent the all event
	    if (!state.replState.primary) return;
	    if (!self.lastIsMaster()) return;
	    if (!Array.isArray(self.lastIsMaster().hosts)) return;
	    if (state.all) return;
	
	    var length = 1 + state.replState.secondaries.length;
	    // If we have all secondaries + primary
	    if (length !== self.lastIsMaster().hosts.length) return;
	
	    // Only emit if there is a listener
	    if(self.listeners('all').length > 0) {
	      state.all = true;
	      self.emit('all', self);
	    }
	  }
	}
	
	var checkAndEmitEvent = function(self, state, event) {
	  var handler = eventHandler[event];
	  if (!handler) throw new MongoError(event + " event not implemented");
	
	  handler(self, state);
	}
	
	//
	// Pick a server based on readPreference
	var pickServer = function(self, s, readPreference) {
	  // If no read Preference set to primary by default
	  readPreference = readPreference || ReadPreference.primary;
	
	  // Do we have a custom readPreference strategy, use it
	  if(s.readPreferenceStrategies != null && s.readPreferenceStrategies[readPreference.preference] != null) {
	    if(s.readPreferenceStrategies[readPreference.preference] == null) throw new MongoError(f("cannot locate read preference handler for %s", readPreference.preference));
	    var server = s.readPreferenceStrategies[readPreference.preference].pickServer(s.replState, readPreference);
	    if(s.debug) self.emit('pickedServer', readPreference, server);
	    return server;
	  }
	
	  // Get all the secondaries
	  var secondaries = s.replState.getSecondaries();
	
	  // Check if we can satisfy and of the basic read Preferences
	  if(readPreference.equals(ReadPreference.secondary)
	    && secondaries.length == 0)
	      throw new MongoError("no secondary server available");
	
	  if(readPreference.equals(ReadPreference.secondaryPreferred)
	      && secondaries.length == 0
	      && s.replState.primary == null)
	    throw new MongoError("no secondary or primary server available");
	
	  if(readPreference.equals(ReadPreference.primary)
	    && s.replState.primary == null)
	      throw new MongoError("no primary server available");
	
	  // Secondary
	  if(readPreference.equals(ReadPreference.secondary)) {
	    s.index = (s.index + 1) % secondaries.length;
	    return secondaries[s.index];
	  }
	
	  // Secondary preferred
	  if(readPreference.equals(ReadPreference.secondaryPreferred)) {
	    if(secondaries.length > 0) {
	      // Apply tags if present
	      var servers = filterByTags(readPreference, secondaries);
	      // If have a matching server pick one otherwise fall through to primary
	      if(servers.length > 0) {
	        s.index = (s.index + 1) % servers.length;
	        return servers[s.index];
	      }
	    }
	
	    return s.replState.primary;
	  }
	
	  // Primary preferred
	  if(readPreference.equals(ReadPreference.primaryPreferred)) {
	    if(s.replState.primary) return s.replState.primary;
	
	    if(secondaries.length > 0) {
	      // Apply tags if present
	      var servers = filterByTags(readPreference, secondaries);
	      // If have a matching server pick one otherwise fall through to primary
	      if(servers.length > 0) {
	        s.index = (s.index + 1) % servers.length;
	        return servers[s.index];
	      }
	
	      // Throw error a we have not valid secondary or primary servers
	      throw new MongoError("no secondary or primary server available");
	    }
	  }
	
	  // Return the primary
	  return s.replState.primary;
	}
	
	var setHaTimer = function(self, state) {
	  if(state.highAvailabilityProcessRunning) return;
	  // all haTimers are set to to repeat, so we pass norepeat false
	  self.s.haTimer = setTimeout(replicasetInquirer(self, state, false), state.currentHaInterval);
	  return self.s.haTimer;
	}
	
	var haveAvailableServers = function(state) {
	  if(state.disconnectedServers.length == 0
	    && state.replState.secondaries.length == 0
	    && state.replState.arbiters.length == 0
	    && state.replState.primary == null) return false;
	    return true;
	}
	
	var merge = function(list, newList) {
	  var finalList = list.slice(0)
	
	  for(var i = 0; i < newList.length; i++) {
	    if(finalList.indexOf(newList[i]) == -1) finalList.push(newList[i]);
	  }
	
	  return finalList;
	}
	
	var replicasetInquirer = function(self, state, norepeat) {
	  return function() {
	    // Process already running don't rerun
	    if(state.highAvailabilityProcessRunning) {
	      return;
	    }
	
	    // State destroyed return
	    if(state.replState.state == DESTROYED) {
	      return
	    }
	
	    // Do we have a primary, ensure we only monitor by the haInterval
	    if(state.replState.isPrimaryConnected()) {
	      self.s.currentHaInterval = self.s.haInterval;
	    } else {
	      self.s.currentHaInterval = self.s.minHeartbeatFrequencyMS;
	    }
	
	    // Clean out any failed connection attempts
	    state.replState.clearConnectingServers();
	
	    // Cleanup state (removed disconnected servers)
	    state.replState.clean();
	
	    // Started processes
	    state.highAvailabilityProcessRunning = true;
	    // We have no connections we need to reseed the disconnected list
	    if(!haveAvailableServers(state)) {
	      // For all entries in the seedlist build a server instance
	      state.disconnectedServers = state.seedlist.map(function(e) {
	        // Clone options
	        var opts = cloneOptions(state.options);
	        // Add host and port
	        opts.host = e.host;
	        opts.port = e.port;
	        opts.reconnect = false;
	        opts.readPreferenceStrategies = state.readPreferenceStrategies;
	        opts.emitError = true;
	        // Add a reserved connection for monitoring
	        opts.size = opts.size + 1;
	        opts.monitoring = true;
	        opts.topologyId = self.s.id;
	        // Server is in topology
	        opts.inTopology = true;
	        // Set up tags if any
	        if(state.tag) opts.tag = state.tag;
	        // Share the auth store
	        opts.authProviders = state.authProviders;
	        // Create a new Server
	        var server = new Server(opts);
	        // Handle the ismaster
	        server.on('ismaster', handleIsmaster(self));
	        return server;
	      });
	    }
	
	    if(state.logger.isInfo()) state.logger.info(f('[%s] monitoring process running %s', state.id, JSON.stringify(state.replState)));
	
	    // Unique HA id to identify the current look running
	    var localHaId = state.haId++;
	
	    // Controls if we are doing a single inquiry or repeating
	    norepeat = typeof norepeat == 'boolean' ? norepeat : false;
	
	    // If we have a primary and a disconnect handler, execute
	    // buffered operations
	    if(state.replState.isPrimaryConnected() && state.replState.isSecondaryConnected() && state.disconnectHandler) {
	      state.disconnectHandler.execute();
	    }
	
	    // Emit replicasetInquirer
	    self.emit('ha', 'start', {norepeat: norepeat, id: localHaId, state: state.replState ? state.replState.toJSON() : {}});
	
	    // Let's process all the disconnected servers
	    while(state.disconnectedServers.length > 0) {
	      // Get the first disconnected server
	      var server = state.disconnectedServers.shift();
	      if(state.logger.isInfo()) state.logger.info(f('[%s] monitoring attempting to connect to %s', state.id, server.lastIsMaster() ? server.lastIsMaster().me : server.name));
	      // Set up the event handlers
	      server.once('error', errorHandlerTemp(self, state, 'error'));
	      server.once('close', errorHandlerTemp(self, state, 'close'));
	      server.once('timeout', errorHandlerTemp(self, state, 'timeout'));
	      server.once('connect', connectHandler(self, state));
	
	      // SDAM Monitoring events
	      server.on('serverOpening', function(e) { self.emit('serverOpening', e); });
	      server.on('serverDescriptionChanged', function(e) { self.emit('serverDescriptionChanged', e); });
	      server.on('serverHeartbeatStarted', function(e) { self.emit('serverHeartbeatStarted', e); });
	      server.on('serverHeartbeatSucceeded', function(e) { self.emit('serverHeartbeatSucceeded', e); });
	      server.on('serverHearbeatFailed', function(e) { self.emit('serverHearbeatFailed', e); });
	      server.on('serverClosed', function(e) { self.emit('serverClosed', e); });
	
	      // Ensure we schedule the opening of new socket
	      // on separate ticks of the event loop
	      var execute = function(_server) {
	        // Attempt to connect
	        process.nextTick(function() {
	          _server.connect();
	        });
	      }
	
	      execute(server);
	    }
	
	    // We need to query all servers
	    var servers = state.replState.getAll({includeArbiters:true});
	    var serversLeft = servers.length;
	
	    // If no servers and we are not destroyed keep pinging
	    if(servers.length == 0 && state.replState.state == CONNECTED) {
	      // Emit ha process end
	      self.emit('ha', 'end', {norepeat: norepeat, id: localHaId, state: state.replState ? state.replState.toJSON() : {}});
	      // Ended highAvailabilityProcessRunning
	      state.highAvailabilityProcessRunning = false;
	      // Restart ha process
	      if(!norepeat) {
	        setHaTimer(self, state);
	      }
	
	      return;
	    }
	
	    //
	    // ismaster for Master server
	    var primaryIsMaster = null;
	
	    //
	    // Inspect a specific servers ismaster
	    var inspectServer = function(server, callback) {
	      if(state.replState.state == DESTROYED) {
	        return;
	      }
	
	      if(server && !server.isConnected()) {
	        return callback();
	      }
	
	      // Did we get a server
	      if(server && server.isConnected()) {
	        // Execute ismaster
	        server.command('admin.$cmd', { ismaster:true }, {monitoring: true}, function(err, r) {
	          // If the state was destroyed
	          if(state.replState.state == DESTROYED) {
	            return callback();
	          }
	
	          // Count down the number of servers left
	          serversLeft = serversLeft - 1;
	
	          // If we have an error but still outstanding server request return
	          if(err && serversLeft > 0) {
	            return callback();
	          }
	
	          // We had an error and have no more servers to inspect, schedule a new check
	          if(err && serversLeft == 0) {
	            self.emit('ha', 'end', {norepeat: norepeat, id: localHaId, state: state.replState ? state.replState.toJSON() : {}});
	            // Ended highAvailabilityProcessRunning
	            state.highAvailabilityProcessRunning = false;
	            // Return the replicasetInquirer
	            return callback();
	          }
	
	          // Let all the read Preferences do things to the servers
	          var rPreferencesCount = Object.keys(state.readPreferenceStrategies).length;
	
	          // Handle the primary
	          var ismaster = r.result;
	          if(state.logger.isDebug()) state.logger.debug(f('[%s] monitoring process ismaster %s', state.id, JSON.stringify(ismaster)));
	
	          // Update server instance ismaster to ensure proper sync
	          // when producing SDAM monitoring events
	          server.s.ismaster = ismaster;
	
	          // Update the replicaset state
	          if(!state.replState.update(ismaster, server) && !state.replState.contains(server)) {
	            // Destroy the instance
	            server.destroy();
	            // Return
	            return callback();
	          }
	
	          //
	          // Process hosts list from ismaster under two conditions
	          // 1. Ismaster result is from primary
	          // 2. There is no primary and the ismaster result is from a non-primary
	          if(err == null
	            && (ismaster.ismaster || (!state.primary))
	            && Array.isArray(ismaster.hosts)) {
	            // Hosts to process
	            var hosts = ismaster.hosts;
	            // Add arbiters to list of hosts if we have any
	            if(Array.isArray(ismaster.arbiters)) {
	              hosts = hosts.concat(ismaster.arbiters.map(function(x) {
	                return {host: x, arbiter:true};
	              }));
	            }
	
	            if(Array.isArray(ismaster.passives)) hosts = hosts.concat(ismaster.passives);
	            // Process all the hsots
	            processHosts(self, state, hosts);
	          } else if(err == null && !Array.isArray(ismaster.hosts)) {
	            // Destroy the instance
	            server.destroy();
	            // Return
	            return callback();
	          }
	
	          // No read Preferences strategies
	          if(rPreferencesCount == 0) {
	            // Don't schedule a new inquiry
	            if(serversLeft > 0) {
	              return callback();
	            }
	
	            // Emit ha process end
	            self.emit('ha', 'end', {norepeat: norepeat, id: localHaId, state: state.replState ? state.replState.toJSON() : {}});
	            // Ended highAvailabilityProcessRunning
	            state.highAvailabilityProcessRunning = false;
	            return callback();
	          }
	
	          // No servers left to query, execute read preference strategies
	          if(serversLeft == 0) {
	            // Go over all the read preferences
	            for(var name in state.readPreferenceStrategies) {
	              state.readPreferenceStrategies[name].ha(self, state.replState, function() {
	                rPreferencesCount = rPreferencesCount - 1;
	
	                if(rPreferencesCount == 0) {
	                  // Add any new servers in primary ismaster
	                  if(err == null
	                    && ismaster.ismaster
	                    && Array.isArray(ismaster.hosts)) {
	                      processHosts(self, state, ismaster.hosts);
	                  }
	
	                  // Emit ha process end
	                  self.emit('ha', 'end', {norepeat: norepeat, id: localHaId, state: state.replState ? state.replState.toJSON() : {}});
	                  // Ended highAvailabilityProcessRunning
	                  state.highAvailabilityProcessRunning = false;
	                  return callback();
	                }
	              });
	            }
	          }
	
	          callback();
	        });
	      }
	    }
	
	    // Go over all the servers
	    if(servers.length == 0) {
	      // Set the high availability
	      state.highAvailabilityProcessRunning = false;
	      // Check if we need to emit a fullsetup event
	      checkAndEmitEvent(self, state, 'fullsetup');
	      // Check if we need to emit the all event
	      checkAndEmitEvent(self, state, 'all');
	      // Repeat the process
	      if(!norepeat) {
	        setHaTimer(self, state);
	      }
	    }
	
	    // Ge the number of servers left
	    var left = servers.length;
	    // Call ismaster on all servers
	    for(var i = 0; i < servers.length; i++) {
	      inspectServer(servers[i], function() {
	        left = left - 1;
	
	        if(left == 0) {
	          // Set the high availability
	          state.highAvailabilityProcessRunning = false;
	          // Check if we need to emit a fullsetup event
	          checkAndEmitEvent(self, state, 'fullsetup');
	          // Check if we need to emit the all event
	          checkAndEmitEvent(self, state, 'all');
	          // Repeat the process
	          if(!norepeat) {
	            setHaTimer(self, state);
	          }
	        }
	      });
	    }
	  }
	}
	
	// Error handler for initial connect
	var errorHandlerTemp = function(self, state, event) {
	  return function(err, server) {
	    // Destroy the server
	    server.destroy();
	    // Log the information
	    if(state.logger.isInfo()) state.logger.info(f('[%s] server %s disconnected', state.id, server.lastIsMaster() ? server.lastIsMaster().me : server.name));
	    // Filter out any connection servers
	    state.initialConnectionServers = state.initialConnectionServers.filter(function(_server) {
	      return server.name != _server.name;
	    });
	
	    // Remove from list of connected servers
	    state.replState.removeConnectingServer(server.name);
	
	    // Connection is destroyed, ignore
	    if(state.replState.state == DESTROYED) return;
	
	    // Remove any non used handlers
	    ['error', 'close', 'timeout', 'connect',
	      'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	      'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'].forEach(function(e) {
	      server.removeAllListeners(e);
	    })
	
	    // Push to list of disconnected servers
	    addToListIfNotExist(state.disconnectedServers, server);
	
	    // End connection operation if we have no legal replicaset state
	    if(state.initialConnectionServers == 0 && state.replState.state == CONNECTING) {
	       if((state.secondaryOnlyConnectionAllowed && !state.replState.isSecondaryConnected() && !state.replState.isPrimaryConnected())
	        || (!state.secondaryOnlyConnectionAllowed && !state.replState.isPrimaryConnected())) {
	          if(state.logger.isInfo()) state.logger.info(f('[%s] no valid seed servers in list', state.id));
	
	          if(self.listeners('error').length > 0) {
	            return self.emit('error', new MongoError('no valid seed servers in list'));
	          }
	       }
	    }
	
	    // If the number of disconnected servers is equal to
	    // the number of seed servers we cannot connect
	    if(state.disconnectedServers.length == state.seedlist.length && state.replState.state == CONNECTING) {
	      if(state.emitError && self.listeners('error').length > 0) {
	        if(state.logger.isInfo()) state.logger.info(f('[%s] no valid seed servers in list', state.id));
	
	        if(self.listeners('error').length > 0) {
	          self.emit('error', new MongoError('no valid seed servers in list'));
	        }
	      }
	    }
	  }
	}
	
	// Connect handler
	var connectHandler = function(self, state) {
	  return function(server) {
	    if(state.logger.isInfo()) state.logger.info(f('[%s] connected to %s', state.id, server.name));
	    // Destroyed connection
	    if(state.replState.state == DESTROYED) {
	      return server.destroy(false, false);
	    }
	
	    // Filter out any connection servers
	    state.initialConnectionServers = state.initialConnectionServers.filter(function(_server) {
	      return server.name != _server.name;
	    });
	
	    var ismaster = server.lastIsMaster();
	
	    // Process the new server
	    var processNewServer = function() {
	      // Discover any additional servers
	      var ismaster = server.lastIsMaster();
	
	      // Deal with events
	      var events = ['error', 'close', 'timeout', 'connect', 'message',
	        'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	        'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'];
	      // Remove any non used handlers
	      events.forEach(function(e) {
	        server.removeAllListeners(e);
	      })
	
	      // Clean up
	      // delete state.connectingServers[server.name];
	      state.replState.removeConnectingServer(server.name);
	
	      // Update the replicaset state, destroy if not added
	      if(!state.replState.update(ismaster, server) && !state.replState.contains(server)) {
	        // Destroy the server instance
	        server.destroy();
	        // No more candiate servers
	        if(state.state == CONNECTING && state.initialConnectionServers.length == 0
	          && state.replState.primary == null && state.replState.secondaries.length == 0) {
	            return self.emit('error', new MongoError("no replicaset members found in seedlist"));
	        }
	
	        return;
	      }
	
	      // Add the server handling code
	      if(server.isConnected()) {
	        server.on('error', errorHandler(self, state));
	        server.on('close', closeHandler(self, state));
	        server.on('timeout', timeoutHandler(self, state));
	
	        // SDAM Monitoring events
	        server.on('serverOpening', function(e) { self.emit('serverOpening', e); });
	        server.on('serverDescriptionChanged', function(e) { self.emit('serverDescriptionChanged', e); });
	        server.on('serverHeartbeatStarted', function(e) { self.emit('serverHeartbeatStarted', e); });
	        server.on('serverHeartbeatSucceeded', function(e) { self.emit('serverHeartbeatSucceeded', e); });
	        server.on('serverHearbeatFailed', function(e) { self.emit('serverHearbeatFailed', e); });
	        server.on('serverClosed', function(e) { self.emit('serverClosed', e); });
	      }
	
	      // Hosts to process
	      var hosts = ismaster.hosts;
	      // Add arbiters to list of hosts if we have any
	      if(Array.isArray(ismaster.arbiters)) {
	        hosts = hosts.concat(ismaster.arbiters.map(function(x) {
	          return {host: x, arbiter:true};
	        }));
	      }
	
	      if(Array.isArray(ismaster.passives)) hosts = hosts.concat(ismaster.passives);
	
	      // Add any new servers
	      processHosts(self, state, hosts);
	
	      // If have the server instance already destroy it
	      if(state.initialConnectionServers.length == 0 && state.replState.connectingServersCount() == 0
	        && !state.replState.isPrimaryConnected() && !state.secondaryOnlyConnectionAllowed && state.replState.state == CONNECTING) {
	        if(state.logger.isInfo()) state.logger.info(f('[%s] no primary found in replicaset', state.id));
	        self.emit('error', new MongoError("no primary found in replicaset"));
	        return self.destroy();
	      }
	
	      // Check if we need to emit a fullsetup event
	      checkAndEmitEvent(self, state, 'fullsetup');
	      // Check if we need to emit the all event
	      checkAndEmitEvent(self, state, 'all');
	    }
	
	    // Save up new members to be authenticated against
	    if(self.s.authInProgress) {
	      self.s.authInProgressServers.push(server);
	    }
	
	    // No credentials just process server
	    if(state.credentials.length == 0) return processNewServer();
	
	    // Apply all the credentials serially
	    var applyCredentials = function(server, index, credentials, callback) {
	      // Do not apply credentials if we have an arbiter
	      if(server.lastIsMaster() && server.lastIsMaster().arbiterOnly) return callback();
	      // Done applying the credentials return
	      if(index >= credentials.length || credentials.length == 0) return callback();
	      // Apply the credential
	      server.auth.apply(server, credentials[index].concat([function(err, r) {
	        if(err) return callback(err);
	        applyCredentials(server, index + 1, credentials, callback);
	      }]));
	    }
	
	    applyCredentials(server, 0, state.credentials, function(err) {
	      if(err) {
	        return server.destroy();
	      }
	
	      // Did not fail the authentication, process the instance
	      processNewServer();
	    });
	  }
	}
	
	//
	// Detect if we need to add new servers
	var processHosts = function(self, state, hosts) {
	  if(state.replState.state == DESTROYED) return;
	  if(Array.isArray(hosts)) {
	    // Check any hosts exposed by ismaster
	    for(var i = 0; i < hosts.length; i++) {
	      // Get the object
	      var host = hosts[i];
	      var options = {};
	
	      // Do we have an arbiter
	      if(typeof host == 'object') {
	        host = host.host;
	        options.arbiter = host.arbiter;
	      }
	
	      // If not found we need to create a new connection
	      if(!state.replState.contains(host)) {
	        if(!state.replState.isConnectingServer(host) && !inInitialConnectingServers(self, state, host)) {
	          if(state.logger.isInfo()) state.logger.info(f('[%s] scheduled server %s for connection', state.id, host));
	          // Make sure we know what is trying to connect
	          state.replState.addConnectingServer(host, host);
	          // Connect the server
	          connectToServer(self, state, host.split(':')[0], parseInt(host.split(':')[1], 10), options);
	        }
	      }
	    }
	  }
	}
	
	var inInitialConnectingServers = function(self, state, address) {
	  for(var i = 0; i < state.initialConnectionServers.length; i++) {
	    if(state.initialConnectionServers[i].name == address) return true;
	  }
	  return false;
	}
	
	// Connect to a new server
	var connectToServer = function(self, state, host, port, options) {
	  options = options || {};
	  var opts = cloneOptions(state.options);
	  opts.host = host;
	  opts.port = port;
	  opts.reconnect = false;
	  opts.readPreferenceStrategies = state.readPreferenceStrategies;
	  if(state.tag) opts.tag = state.tag;
	  // Share the auth store
	  opts.authProviders = state.authProviders;
	  opts.emitError = true;
	  // Server is in topology
	  opts.inTopology = true;
	  // Set the size to size + 1 and mark monitoring
	  opts.size = opts.size + 1;
	  opts.monitoring = true;
	  opts.topologyId = self.s.id;
	
	  // Do we have an arbiter set the poolSize to 1
	  if(options.arbiter) {
	    opts.size = 1;
	  }
	
	  // Do not create a new server instance
	  if(self.s.replState.state == DESTROYED) return;
	
	  // Create a new server instance
	  var server = new Server(opts);
	  // Handle the ismaster
	  server.on('ismaster', handleIsmaster(self));
	  // Set up the event handlers
	  server.once('error', errorHandlerTemp(self, state, 'error'));
	  server.once('close', errorHandlerTemp(self, state, 'close'));
	  server.once('timeout', errorHandlerTemp(self, state, 'timeout'));
	  server.once('connect', connectHandler(self, state));
	
	  // SDAM Monitoring events
	  server.on('serverOpening', function(e) { self.emit('serverOpening', e); });
	  server.on('serverDescriptionChanged', function(e) { self.emit('serverDescriptionChanged', e); });
	  server.on('serverHeartbeatStarted', function(e) { self.emit('serverHeartbeatStarted', e); });
	  server.on('serverHeartbeatSucceeded', function(e) { self.emit('serverHeartbeatSucceeded', e); });
	  server.on('serverHearbeatFailed', function(e) { self.emit('serverHearbeatFailed', e); });
	  server.on('serverClosed', function(e) { self.emit('serverClosed', e); });
	
	  // Ensure we schedule the opening of new socket
	  // on separate ticks of the event loop
	  var execute = function(_server) {
	    // Attempt to connect
	    process.nextTick(function() {
	      if(self.s.replState.state == DESTROYED) return;
	      _server.connect();
	    });
	  }
	
	  // Add server as connecting
	  state.replState.addConnectingServer(server.name, host);
	  // Attempt connection of server
	  execute(server);
	}
	
	//
	// Add server to the list if it does not exist
	var addToListIfNotExist = function(list, server) {
	  var found = false;
	  // If the server is a null value return false
	  if(server == null) return found;
	
	  // Remove any non used handlers
	  ['error', 'close', 'timeout', 'connect',
	    'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	    'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'].forEach(function(e) {
	    server.removeAllListeners(e);
	  })
	
	  // Check if the server already exists
	  for(var i = 0; i < list.length; i++) {
	    if(list[i].equals(server)) found = true;
	  }
	
	  if(!found) {
	    list.push(server);
	  }
	
	  return found;
	}
	
	var errorHandler = function(self, state) {
	  return function(err, server) {
	    // Destroy the server
	    server.destroy();
	    // Remove from list of connected servers
	    state.replState.removeConnectingServer(server.name);
	    // Check if destroyed the topology
	    if(state.replState.state == DESTROYED) return;
	    if(state.logger.isInfo()) state.logger.info(f('[%s] server %s errored out with %s', state.id, server.lastIsMaster() ? server.lastIsMaster().me : server.name, JSON.stringify(err)));
	    var found = addToListIfNotExist(state.disconnectedServers, server);
	    if(!found) self.emit('left', state.replState.remove(server), server);
	    if(found && state.emitError && self.listeners('error').length > 0) self.emit('error', err, server);
	  }
	}
	
	var timeoutHandler = function(self, state) {
	  return function(err, server) {
	    // Destroy the server
	    server.destroy();
	    // Remove from list of connected servers
	    state.replState.removeConnectingServer(server.name);
	    // Check if destroyed the topology
	    if(state.replState.state == DESTROYED) return;
	    if(state.logger.isInfo()) state.logger.info(f('[%s] server %s timed out', state.id, server.lastIsMaster() ? server.lastIsMaster().me : server.name));
	    var found = addToListIfNotExist(state.disconnectedServers, server);
	    if(!found) self.emit('left', state.replState.remove(server), server);
	  }
	}
	
	var closeHandler = function(self, state) {
	  return function(err, server) {
	    // Destroy the server
	    server.destroy();
	    // Remove from list of connected servers
	    state.replState.removeConnectingServer(server.name);
	    // Check if destroyed the topology
	    if(state.replState.state == DESTROYED) return;
	    if(state.logger.isInfo()) state.logger.info(f('[%s] server %s closed', state.id, server.lastIsMaster() ? server.lastIsMaster().me : server.name));
	    var found = addToListIfNotExist(state.disconnectedServers, server);
	    if(!found) {
	      self.emit('left', state.replState.remove(server), server);
	    }
	  }
	}
	
	//
	// Validate if a non-master or recovering error
	var notMasterError = function(r) {
	  // Get result of any
	  var result = r && r.result ? r.result : r;
	
	  // Explore if we have a not master error
	  if(result && (result.err == 'not master'
	    || result.errmsg == 'not master' || (result['$err'] && result['$err'].indexOf('not master or secondary') != -1)
	    || (result['$err'] && result['$err'].indexOf("not master and slaveOk=false") != -1)
	    || result.errmsg == 'node is recovering')) {
	    return true;
	  }
	
	  return false;
	}
	
	module.exports = ReplSet;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var Logger = __webpack_require__(163)
	  , EventEmitter = __webpack_require__(3).EventEmitter
	  , inherits = __webpack_require__(77).inherits
	  , f = __webpack_require__(77).format;
	
	/**
	 * Creates a new Ping read preference strategy instance
	 * @class
	 * @param {number} [options.pingInterval=5000] Ping interval to check the response time to the different servers
	 * @param {number} [options.acceptableLatency=250] Acceptable latency for selecting a server for reading (in milliseconds)
	 * @return {Ping} A cursor instance
	 */
	var Ping = function(options) {
	  // Add event listener
	  EventEmitter.call(this);
	
	  // Contains the ping state
	  this.s = {
	    // Contains all the ping data
	      pings: {}
	    // Set no options if none provided
	    , options: options || {}
	    // Logger
	    , logger: Logger('Ping', options)
	    // Ping interval
	    , pingInterval: options.pingInterval || 10000
	    , acceptableLatency: options.acceptableLatency || 15
	    // Debug options
	    , debug: typeof options.debug == 'boolean' ? options.debug : false
	    // Index
	    , index: 0
	    // Current ping time
	    , lastPing: null
	
	  }
	
	  // Log the options set
	  if(this.s.logger.isDebug()) this.s.logger.debug(f('ping strategy interval [%s], acceptableLatency [%s]', this.s.pingInterval, this.s.acceptableLatency));
	
	  // If we have enabled debug 
	  if(this.s.debug) {
	    // Add access to the read Preference Strategies
	    Object.defineProperty(this, 'data', {
	      enumerable: true, get: function() { return this.s.pings; }
	    });    
	  }
	}
	
	inherits(Ping, EventEmitter);
	
	/**
	 * @ignore
	 */
	var filterByTags = function(readPreference, servers) {
	  if(readPreference.tags == null) return servers;
	  var filteredServers = [];
	  var tags = readPreference.tags;
	
	  // Iterate over all the servers
	  for(var i = 0; i < servers.length; i++) {
	    var serverTag = servers[i].lastIsMaster().tags || {};
	    // Did we find the a matching server
	    var found = true;
	    // Check if the server is valid
	    for(var name in tags) {
	      if(serverTag[name] != tags[name]) found = false;
	    }
	
	    // Add to candidate list
	    if(found) filteredServers.push(servers[i]);
	  }
	
	  // Returned filtered servers
	  return filteredServers;
	}
	
	/**
	 * Pick a server
	 * @method
	 * @param {State} set The current replicaset state object 
	 * @param {ReadPreference} readPreference The current readPreference object
	 * @param {readPreferenceResultCallback} callback The callback to return the result from the function
	 * @return {object}
	 */
	Ping.prototype.pickServer = function(set, readPreference) {
	  var self = this;
	  // Only get primary and secondaries as seeds
	  var seeds = {};
	  var servers = [];
	  if(set.primary) {
	    servers.push(set.primary);
	  }
	
	  for(var i = 0; i < set.secondaries.length; i++) {
	    servers.push(set.secondaries[i]);
	  }
	
	  // Filter by tags
	  servers = filterByTags(readPreference, servers);
	
	  // Transform the list
	  var serverList = [];
	  // for(var name in seeds) {
	  for(var i = 0; i < servers.length; i++) {
	    serverList.push({name: servers[i].name, time: self.s.pings[servers[i].name] || 0});
	  }
	
	  // Sort by time
	  serverList.sort(function(a, b) {
	    return a.time > b.time;
	  });
	
	  // Locate lowest time (picked servers are lowest time + acceptable Latency margin)
	  var lowest = serverList.length > 0 ? serverList[0].time : 0;
	
	  // Filter by latency
	  serverList = serverList.filter(function(s) {
	    return s.time <= lowest + self.s.acceptableLatency;
	  });
	
	  // No servers, default to primary
	  if(serverList.length == 0 && set.primary) {
	    if(self.s.logger.isInfo()) self.s.logger.info(f('picked primary server [%s]', set.primary.name));
	    return set.primary;
	  } else if(serverList.length == 0) {
	    return null
	  }
	
	  // We picked first server
	  if(self.s.logger.isInfo()) self.s.logger.info(f('picked server [%s] with ping latency [%s]', serverList[0].name, serverList[0].time));
	
	  // Add to the index
	  self.s.index = self.s.index + 1;
	  // Select the index
	  self.s.index = self.s.index % serverList.length;
	  // Return the first server of the sorted and filtered list
	  return set.get(serverList[self.s.index].name);
	}
	
	/**
	 * Start of an operation
	 * @method
	 * @param {Server} server The server the operation is running against
	 * @param {object} query The operation running
	 * @param {Date} date The start time of the operation
	 * @return {object}
	 */
	Ping.prototype.startOperation = function(server, query, date) {
	}
	
	/**
	 * End of an operation
	 * @method
	 * @param {Server} server The server the operation is running against
	 * @param {error} err An error from the operation
	 * @param {object} result The result from the operation
	 * @param {Date} date The start time of the operation
	 * @return {object}
	 */
	Ping.prototype.endOperation = function(server, err, result, date) {
	}
	
	/**
	 * High availability process running
	 * @method
	 * @param {State} set The current replicaset state object 
	 * @param {resultCallback} callback The callback to return the result from the function
	 * @return {object}
	 */
	Ping.prototype.ha = function(topology, state, callback) {
	  var self = this;
	  var servers = state.getAll();
	  var count = servers.length;
	
	  // No servers return
	  if(servers.length == 0) return callback(null, null);
	
	  // Return if we have not yet reached the ping interval
	  if(self.s.lastPing != null) {
	    var diff = new Date().getTime() - self.s.lastPing.getTime();
	    if(diff < self.s.pingInterval) return callback(null, null);
	  }
	
	  // Execute operation
	  var operation = function(_server) {
	    var start = new Date();
	    // Execute ping against server
	    _server.command('system.$cmd', {ismaster:1}, function(err, r) {
	      count = count - 1;
	      var time = new Date().getTime() - start.getTime();
	      self.s.pings[_server.name] = time;
	      // Log info for debug
	      if(self.s.logger.isDebug()) self.s.logger.debug(f('ha latency for server [%s] is [%s] ms', _server.name, time));
	      // We are done with all the servers
	      if(count == 0) {
	        // Emit ping event
	        topology.emit('ping', err, r ? r.result : null);
	        // Update the last ping time
	        self.s.lastPing = new Date();
	        // Return
	        callback(null, null);
	      }
	    });
	  }
	
	  // Let's ping all servers
	  while(servers.length > 0) {
	    operation(servers.shift());
	  }
	}
	
	var removeServer = function(self, server) {
	  delete self.s.pings[server.name];
	}
	
	/**
	 * Server connection closed
	 * @method
	 * @param {Server} server The server that closed
	 */
	Ping.prototype.close = function(server) {
	  removeServer(this, server);
	}
	
	/**
	 * Server connection errored out
	 * @method
	 * @param {Server} server The server that errored out
	 */
	Ping.prototype.error = function(server) {
	  removeServer(this, server);
	}
	
	/**
	 * Server connection timeout
	 * @method
	 * @param {Server} server The server that timed out
	 */
	Ping.prototype.timeout = function(server) {
	  removeServer(this, server);
	}
	
	/**
	 * Server connection happened
	 * @method
	 * @param {Server} server The server that connected
	 * @param {resultCallback} callback The callback to return the result from the function
	 */
	Ping.prototype.connect = function(server, callback) {
	  var self = this;
	  // Get the command start date
	  var start = new Date();
	  // Execute ping against server
	  server.command('system.$cmd', {ismaster:1}, function(err, r) {
	    var time = new Date().getTime() - start.getTime();
	    self.s.pings[server.name] = time;
	    // Log info for debug
	    if(self.s.logger.isDebug()) self.s.logger.debug(f('connect latency for server [%s] is [%s] ms', server.name, time));
	    // Set last ping
	    self.s.lastPing = new Date();
	    // Done, return
	    callback(null, null);
	  });    
	}
	
	/**
	 * This is a result from a readPreference strategy
	 *
	 * @callback readPreferenceResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {Server} server The server picked by the strategy
	 */
	
	module.exports = Ping;

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";
	
	var Logger = __webpack_require__(163)
	  , f = __webpack_require__(77).format
	  , ObjectId = __webpack_require__(134).ObjectId
	  , MongoError = __webpack_require__(157);
	
	var DISCONNECTED = 'disconnected';
	var CONNECTING = 'connecting';
	var CONNECTED = 'connected';
	var DESTROYED = 'destroyed';
	
	/**
	 * Creates a new Replicaset State object
	 * @class
	 * @property {object} primary Primary property
	 * @property {array} secondaries List of secondaries
	 * @property {array} arbiters List of arbiters
	 * @return {State} A cursor instance
	 */
	var State = function(replSet, options) {
	  this.replSet = replSet;
	  this.options = options;
	  this.secondaries = [];
	  this.arbiters = [];
	  this.passives = [];
	  this.primary = null;
	  // Initial state is disconnected
	  this.state = DISCONNECTED;
	  // Current electionId
	  this.electionId = null;
	  // Get a logger instance
	  this.logger = Logger('ReplSet', options);
	  // Unpacked options
	  this.id = options.id;
	  this.setName = options.setName;
	  this.connectingServers = {};
	  this.secondaryOnlyConnectionAllowed = options.secondaryOnlyConnectionAllowed;
	  // Description of the Replicaset
	  this.replicasetDescription = null;
	}
	
	/**
	 * Is there a secondary connected
	 * @method
	 * @return {boolean}
	 */
	State.prototype.resetDescription = function() {
	  this.replicasetDescription = {
	    "topologyType": "Unknown",
	    "servers": []
	  }
	}
	
	function diff(previous, current) {
	  // Difference document
	  var diff = {
	    servers: []
	  }
	
	  // Got through all the servers
	  for(var i = 0; i < previous.servers.length; i++) {
	    var prevServer = previous.servers[i];
	
	    // Go through all current servers
	    for(var j = 0; j < current.servers.length; j++) {
	      var currServer = current.servers[j];
	
	      // Matching server
	      if(prevServer.address === currServer.address) {
	        // We had a change in state
	        if(prevServer.type != currServer.type) {
	          diff.servers.push({
	            address: prevServer.address,
	            from: prevServer.type,
	            to: currServer.type
	          });
	        }
	      }
	    }
	  }
	
	  // Return difference
	  return diff;
	}
	
	function emitTopologyDescriptionChanged(self) {
	  if(self.replSet.listeners('topologyDescriptionChanged').length > 0) {
	    var topology = 'Unknown';
	    var setName = self.setName;
	
	    if(self.isPrimaryConnected() && self.isSecondaryConnected()) {
	      topology = 'ReplicaSetWithPrimary';
	    } else if(!self.isPrimaryConnected() && self.isSecondaryConnected()) {
	      topology = 'ReplicaSetNoPrimary';
	    }
	
	    // Generate description
	    var description = {
	      topologyType: topology,
	      setName: setName,
	      servers: []
	    }
	
	    // Add the primary to the list
	    if(self.isPrimaryConnected()) {
	      var desc = self.primary.getDescription();
	      desc.type = 'RSPrimary';
	      description.servers.push(desc);
	    }
	
	    // Add all the secondaries
	    description.servers = description.servers.concat(self.secondaries.map(function(x) {
	      var description = x.getDescription();
	      description.type = 'RSSecondary';
	      return description;
	    }));
	
	    // Add all the arbiters
	    description.servers = description.servers.concat(self.arbiters.map(function(x) {
	      var description = x.getDescription();
	      return description;
	    }));
	
	    // Add all the passives
	    description.servers = description.servers.concat(self.passives.map(function(x) {
	      var description = x.getDescription();
	      description.type = 'RSSecondary';
	      return description;
	    }));
	
	    // Create the result
	    var result = {
	      topologyId: self.id,
	      previousDescription: self.replicasetDescription,
	      newDescription: description,
	      diff: diff(self.replicasetDescription, description)
	    };
	
	    // Emit the topologyDescription change
	    self.replSet.emit('topologyDescriptionChanged', result);
	
	    // Set the new description
	    self.replicasetDescription = description;
	  }
	}
	
	/**
	 * Is there a secondary connected
	 * @method
	 * @return {boolean}
	 */
	State.prototype.isSecondaryConnected = function() {
	  for(var i = 0; i < this.secondaries.length; i++) {
	    if(this.secondaries[i].isConnected()) return true;
	  }
	
	  return false;
	}
	
	/**
	 * Is there a primary connection
	 * @method
	 * @return {boolean}
	 */
	State.prototype.isPrimaryConnected = function() {
	  return this.primary != null && this.primary.isConnected();
	}
	
	/**
	 * Is the given address the primary
	 * @method
	 * @param {string} address Server address
	 * @return {boolean}
	 */
	State.prototype.isPrimary = function(address) {
	  if(this.primary == null) return false;
	  return this.primary && this.primary.equals(address);
	}
	
	/**
	 * Is the given address a secondary
	 * @method
	 * @param {string} address Server address
	 * @return {boolean}
	 */
	State.prototype.isSecondary = function(address) {
	  // Check if the server is a secondary at the moment
	  for(var i = 0; i < this.secondaries.length; i++) {
	    if(this.secondaries[i].equals(address)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Is the given address a secondary
	 * @method
	 * @param {string} address Server address
	 * @return {boolean}
	 */
	State.prototype.isPassive = function(address) {
	  // Check if the server is a secondary at the moment
	  for(var i = 0; i < this.passives.length; i++) {
	    if(this.passives[i].equals(address)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	State.prototype.clearConnectingServers = function() {
	  for(var name in this.connectingServers) {
	    if(typeof this.connectingServers[name].destroy == 'function') {
	      this.connectingServers[name].destroy();
	    }
	  }
	
	  this.connectingServers = {};
	}
	
	State.prototype.removeConnectingServer = function(address) {
	  if(this.connectingServers[address]) {
	    if(this.connectingServers[address].destroy) {
	      this.connectingServers[address].destroy();
	    }
	  }
	
	  delete this.connectingServers[address];
	}
	
	State.prototype.addConnectingServer = function(host, object) {
	  this.connectingServers[host] = object;
	}
	
	State.prototype.isConnectingServer = function(host) {
	  return this.connectingServers[host] != null;
	}
	
	State.prototype.connectingServersCount = function() {
	  return Object.keys(this.connectingServers).length;
	}
	
	/**
	 * Does the replicaset contain this server
	 * @method
	 * @param {string} address Server address
	 * @return {boolean}
	 */
	State.prototype.contains = function(address) {
	  if(this.primary && this.primary.equals(address)) return true;
	  for(var i = 0; i < this.secondaries.length; i++) {
	    if(this.secondaries[i].equals(address)) return true;
	  }
	
	  for(var i = 0; i < this.arbiters.length; i++) {
	    if(this.arbiters[i].equals(address)) return true;
	  }
	
	  for(var i = 0; i < this.passives.length; i++) {
	    if(this.passives[i].equals(address)) return true;
	  }
	
	  return false;
	}
	
	/**
	 * Return all the valid and non passive secondaries
	 * @method
	 * @return {Array[Server]}
	 */
	State.prototype.getSecondaries = function() {
	  // Filter out any non connected servers
	  this.secondaries = this.secondaries.filter(function(server) {
	    return server.isConnected();
	  });
	
	  // Filter out any hidden secondaries
	  return this.secondaries.filter(function(server) {
	    return server.lastIsMaster().hidden ? false : true;
	  });
	}
	
	/**
	 * Clean out all dead connections
	 * @method
	 */
	State.prototype.clean = function() {
	  var self = this;
	  var disconnectedServers = [];
	
	  if(this.primary != null && !this.primary.isConnected()) {
	    disconnectedServers.push(this.primary);
	    this.primary = null;
	  }
	
	  // Filter out disconnected servers
	  this.secondaries = this.secondaries.filter(function(s) {
	    if(!s.isConnected()) disconnectedServers.push(s);
	    return s.isConnected();
	  });
	
	  // Filter out disconnected servers
	  this.arbiters = this.arbiters.filter(function(s) {
	    if(!s.isConnected()) disconnectedServers.push(s);
	    return s.isConnected();
	  });
	
	  // Filter out disconnected servers
	  this.passives = this.passives.filter(function(s) {
	    if(!s.isConnected()) disconnectedServers.push(s);
	    return s.isConnected();
	  });
	
	  return disconnectedServers;
	}
	
	/**
	 * Unref state
	 * @method
	 */
	State.prototype.unref = function() {
	  if(this.primary) this.primary.unref();
	  this.secondaries.forEach(function(s) {
	    s.unref();
	  });
	  this.arbiters.forEach(function(s) {
	    s.unref();
	  });
	}
	
	// Remove listeners
	var events = ['timeout', 'error', 'close', 'joined', 'left',
	  'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	  'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'];
	
	var removeEvents = function(s) {
	  events.forEach(function(e) {
	    s.removeAllListeners(e);
	  });
	}
	
	/**
	 * Destroy state
	 * @method
	 */
	State.prototype.destroy = function() {
	  this.state = DESTROYED;
	
	  if(this.primary) {
	    this.primary.destroy();
	    removeEvents(this.primary);
	  }
	
	  this.secondaries.forEach(function(s) {
	    s.destroy();
	    removeEvents(s);
	  });
	
	  this.arbiters.forEach(function(s) {
	    s.destroy();
	    removeEvents(s);
	  });
	}
	
	/**
	 * Remove server from state
	 * @method
	 * @param {Server} Server to remove
	 * @return {string} Returns type of server removed (primary|secondary)
	 */
	State.prototype.remove = function(server) {
	  if(this.primary && this.primary.equals(server)) {
	    this.primary = null;
	  }
	
	  var length = this.arbiters.length;
	  // Filter out the server from the arbiters
	  this.arbiters = this.arbiters.filter(function(s) {
	    return !s.equals(server);
	  });
	  if(this.arbiters.length < length) return 'arbiter';
	
	  var length = this.passives.length;
	  // Filter out the server from the passives
	  this.passives = this.passives.filter(function(s) {
	    return !s.equals(server);
	  });
	
	  // We have removed a passive
	  if(this.passives.length < length)  {
	    // Ensure we removed it from the list of secondaries as well if it exists
	    this.secondaries = this.secondaries.filter(function(s) {
	      return !s.equals(server);
	    });
	  }
	
	  // Filter out the server from the secondaries
	  this.secondaries = this.secondaries.filter(function(s) {
	    return !s.equals(server);
	  });
	
	  // Get the isMaster
	  var isMaster = server.lastIsMaster();
	  // Return primary if the server was primary
	  if(isMaster.ismaster && isMaster.hosts) return 'primary';
	  if(isMaster.ismaster) return 'secondary';
	  if(isMaster.secondary) return 'secondary';
	  if(isMaster.passive) return 'passive';
	  return 'arbiter';
	}
	
	/**
	 * Get the server by name
	 * @method
	 * @param {string} address Server address
	 * @return {Server}
	 */
	State.prototype.get = function(server) {
	  var found = false;
	  // All servers to search
	  var servers = this.primary ? [this.primary] : [];
	  servers = servers.concat(this.secondaries);
	  // Locate the server
	  for(var i = 0; i < servers.length; i++) {
	    if(servers[i].equals(server)) {
	      return servers[i];
	    }
	  }
	}
	
	/**
	 * Get all the servers in the set
	 * @method
	 * @param {boolean} [options.includeArbiters] Include Arbiters in returned server list
	 * @return {array}
	 */
	State.prototype.getAll = function(options) {
	  options = options || {};
	  var servers = [];
	  if(this.primary) servers.push(this.primary);
	  servers = servers.concat(this.secondaries);
	
	  // Include the arbiters
	  if(options.includeArbiters) {
	    servers = servers.concat(this.arbiters);
	  }
	
	  return servers;
	}
	
	/**
	 * All raw connections
	 * @method
	 * @param {boolean} [options.includeArbiters] Include Arbiters in returned server list
	 * @return {array}
	 */
	State.prototype.getAllConnections = function(options) {
	  options = options || {};
	  var connections = [];
	  if(this.primary) connections = connections.concat(this.primary.connections());
	  this.secondaries.forEach(function(s) {
	    connections = connections.concat(s.connections());
	  })
	
	  // Include the arbiters
	  if(options.includeArbiters) {
	    this.arbiters.forEach(function(s) {
	      connections = connections.concat(s.connections());
	    })
	  }
	
	  return connections;
	}
	
	/**
	 * Return JSON object
	 * @method
	 * @return {object}
	 */
	State.prototype.toJSON = function() {
	  return {
	      primary: this.primary ? this.primary.lastIsMaster().me : null
	    , secondaries: this.secondaries.map(function(s) {
	      return s.lastIsMaster().me
	    })
	  }
	}
	
	/**
	 * Returns the last known ismaster document for this server
	 * @method
	 * @return {object}
	 */
	State.prototype.lastIsMaster = function() {
	  if(this.primary) return this.primary.lastIsMaster();
	  if(this.secondaries.length > 0) return this.secondaries[0].lastIsMaster();
	  return {};
	}
	
	/**
	 * Promote server to primary
	 * @method
	 * @param {Server} server Server we wish to promote
	 */
	State.prototype.promotePrimary = function(server) {
	  var currentServer = this.get(server);
	  // Server does not exist in the state, add it as new primary
	  if(currentServer == null) {
	    this.primary = server;
	    return;
	  }
	
	  // We found a server, make it primary and remove it from the secondaries
	  // Remove the server first
	  this.remove(currentServer);
	  // Set as primary
	  this.primary = currentServer;
	}
	
	var add = function(self, list, server) {
	  // Check if the server is contained in the list
	  for(var i = 0; i < list.length; i++) {
	    if(list[i].equals(server)) return false;
	  }
	
	  // Add serer to list
	  list.push(server);
	
	  // Return true
	  return true;
	}
	
	/**
	 * Add server to list of secondaries
	 * @method
	 * @param {Server} server Server we wish to add
	 */
	State.prototype.addSecondary = function(server) {
	  return add(this, this.secondaries, server);
	}
	
	/**
	 * Add server to list of arbiters
	 * @method
	 * @param {Server} server Server we wish to add
	 */
	State.prototype.addArbiter = function(server) {
	  return add(this, this.arbiters, server);
	}
	
	/**
	 * Add server to list of passives
	 * @method
	 * @param {Server} server Server we wish to add
	 */
	State.prototype.addPassive = function(server) {
	  return add(this, this.passives, server);
	}
	
	var compareObjectIds = function(id1, id2) {
	  var a = new Buffer(id1.toHexString(), 'hex');
	  var b = new Buffer(id2.toHexString(), 'hex');
	
	  if(a === b) {
	    return 0;
	  }
	
	  if(typeof Buffer.compare === 'function') {
	    return Buffer.compare(a, b);
	  }
	
	  var x = a.length;
	  var y = b.length;
	  var len = Math.min(x, y);
	
	  for (var i = 0; i < len; i++) {
	    if (a[i] !== b[i]) {
	      break;
	    }
	  }
	
	  if (i !== len) {
	    x = a[i];
	    y = b[i];
	  }
	
	  return x < y ? -1 : y < x ? 1 : 0;
	}
	
	/**
	 * Update the state given a specific ismaster result
	 * @method
	 * @param {object} ismaster IsMaster result
	 * @param {Server} server IsMaster Server source
	 */
	State.prototype.update = function(ismaster, server) {
	  var self = this;
	
	  // Perform a cleanup before performing the update
	  this.clean();
	
	  // Not in a known connection valid state
	  if((!ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) || !Array.isArray(ismaster.hosts)) {
	    // Remove the state
	    var result = self.remove(server);
	    if(self.state == CONNECTED)  {
	      if(self.logger.isInfo()) self.logger.info(f('[%s] removing %s from set', self.id, ismaster.me));
	      self.replSet.emit('left', result, server);
	    }
	
	    emitTopologyDescriptionChanged(this);
	    return false;
	  }
	
	  // Set the setName if it's not set from the first server
	  if(self.setName == null && ismaster.setName) {
	    if(self.logger.isInfo()) self.logger.info(f('[%s] setting setName to %s', self.id, ismaster.setName));
	    self.setName = ismaster.setName;
	  }
	
	  // Check if the replicaset name matches the provided one
	  if(ismaster.setName && self.setName != ismaster.setName) {
	    if(self.logger.isError()) self.logger.error(f('[%s] server in replset %s is not part of the specified setName %s', self.id, ismaster.setName, self.setName));
	    self.remove(server);
	    self.replSet.emit('error', new MongoError("provided setName for Replicaset Connection does not match setName found in server seedlist"));
	    emitTopologyDescriptionChanged(this);
	    return false;
	  }
	
	  // Log information
	  if(self.logger.isInfo()) self.logger.info(f('[%s] updating replicaset state %s', self.id, JSON.stringify(this)));
	
	  // It's a master set it
	  if(ismaster.ismaster && self.setName == ismaster.setName && !self.isPrimary(ismaster.me)) {
	    // Check if the electionId is not null
	    if(ismaster.electionId instanceof ObjectId && self.electionId instanceof ObjectId) {
	      if(compareObjectIds(self.electionId, ismaster.electionId) == -1) {
	        self.electionId = ismaster.electionId;
	      } else if(compareObjectIds(self.electionId, ismaster.electionId) == 0) {
	        self.electionId = ismaster.electionId;
	      } else {
	        return false;
	      }
	    }
	
	    // Initial electionId
	    if(ismaster.electionId instanceof ObjectId && self.electionId == null) {
	      self.electionId = ismaster.electionId;
	    }
	
	    // Promote to primary
	    self.promotePrimary(server);
	    // Log change of primary
	    if(self.logger.isInfo()) self.logger.info(f('[%s] promoting %s to primary', self.id, ismaster.me));
	    // Emit primary
	    self.replSet.emit('joined', 'primary', this.primary);
	
	    // Emit the description change
	    emitTopologyDescriptionChanged(this);
	
	    // We are connected
	    if(self.state == CONNECTING) {
	      self.state = CONNECTED;
	      self.replSet.emit('connect', self.replSet);
	    } else {
	      self.state = CONNECTED;
	      self.replSet.emit('reconnect', server);
	    }
	  } else if(!ismaster.ismaster && self.setName == ismaster.setName
	    && ismaster.arbiterOnly) {
	      if(self.addArbiter(server)) {
	        if(self.logger.isInfo()) self.logger.info(f('[%s] promoting %s to arbiter', self.id, ismaster.me));
	        self.replSet.emit('joined', 'arbiter', server);
	        emitTopologyDescriptionChanged(this);
	        return true;
	      };
	
	      return false;
	  } else if(!ismaster.ismaster && self.setName == ismaster.setName
	    && ismaster.secondary && ismaster.passive) {
	      if(self.addPassive(server) && self.addSecondary(server)) {
	        if(self.logger.isInfo()) self.logger.info(f('[%s] promoting %s to passive', self.id, ismaster.me));
	        self.replSet.emit('joined', 'passive', server);
	
	        // If we have secondaryOnlyConnectionAllowed and just a passive it's
	        // still a valid connection
	        if(self.secondaryOnlyConnectionAllowed && self.state == CONNECTING) {
	          self.state = CONNECTED;
	          self.replSet.emit('connect', self.replSet);
	        }
	
	        emitTopologyDescriptionChanged(this);
	        return true;
	      };
	
	      return false;
	  } else if(!ismaster.ismaster && self.setName == ismaster.setName
	    && ismaster.secondary) {
	      if(self.addSecondary(server)) {
	        if(self.logger.isInfo()) self.logger.info(f('[%s] promoting %s to secondary', self.id, ismaster.me));
	        self.replSet.emit('joined', 'secondary', server);
	
	        // Is this the primary right now
	        if(self.primary && self.primary.name == server.name) {
	          self.primary = null;
	        }
	
	        if(self.secondaryOnlyConnectionAllowed && self.state == CONNECTING) {
	          self.state = CONNECTED;
	          self.replSet.emit('connect', self.replSet);
	        }
	
	        emitTopologyDescriptionChanged(this);
	        return true;
	      };
	
	      return false;
	  }
	
	  // Return update applied
	  return true;
	}
	
	module.exports = State;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var inherits = __webpack_require__(77).inherits
	  , f = __webpack_require__(77).format
	  , b = __webpack_require__(134)
	  , bindToCurrentDomain = __webpack_require__(159).bindToCurrentDomain
	  , EventEmitter = __webpack_require__(3).EventEmitter
	  , BasicCursor = __webpack_require__(165)
	  , BSON = __webpack_require__(134).native().BSON
	  , BasicCursor = __webpack_require__(165)
	  , Server = __webpack_require__(158)
	  , MongoCR = __webpack_require__(173)
	  , X509 = __webpack_require__(174)
	  , Plain = __webpack_require__(175)
	  , GSSAPI = __webpack_require__(176)
	  , SSPI = __webpack_require__(186)
	  , ScramSHA1 = __webpack_require__(187)
	  , Logger = __webpack_require__(163)
	  , ReadPreference = __webpack_require__(164)
	  , Session = __webpack_require__(172)
	  , MongoError = __webpack_require__(157);
	
	/**
	 * @fileOverview The **Mongos** class is a class that represents a Mongos Proxy topology and is
	 * used to construct connections.
	 *
	 * @example
	 * var Mongos = require('mongodb-core').Mongos
	 *   , ReadPreference = require('mongodb-core').ReadPreference
	 *   , assert = require('assert');
	 *
	 * var server = new Mongos([{host: 'localhost', port: 30000}]);
	 * // Wait for the connection event
	 * server.on('connect', function(server) {
	 *   server.destroy();
	 * });
	 *
	 * // Start connecting
	 * server.connect();
	 */
	
	var DISCONNECTED = 'disconnected';
	var CONNECTING = 'connecting';
	var CONNECTED = 'connected';
	var DESTROYED = 'destroyed';
	
	// All bson types
	var bsonTypes = [b.Long, b.ObjectID, b.Binary, b.Code, b.DBRef, b.Symbol, b.Double, b.Timestamp, b.MaxKey, b.MinKey];
	// BSON parser
	var bsonInstance = null;
	
	// Instance id
	var mongosId = 0;
	
	//
	// Clone the options
	var cloneOptions = function(options) {
	  var opts = {};
	  for(var name in options) {
	    opts[name] = options[name];
	  }
	  return opts;
	}
	
	var State = function(readPreferenceStrategies, localThresholdMS) {
	  // Internal state
	  this.s = {
	      connectedServers: []
	    , disconnectedServers: []
	    , readPreferenceStrategies: readPreferenceStrategies
	    , lowerBoundLatency: Number.MAX_VALUE
	    , localThresholdMS: localThresholdMS
	    , index: 0
	    , topologyDescription: null
	  }
	}
	
	/**
	 * Emit event if it exists
	 * @method
	 */
	function emitSDAMEvent(self, event, description) {
	  if(self.listeners(event).length > 0) {
	    self.emit(event, description);
	  }
	}
	
	/**
	 * Is there a secondary connected
	 * @method
	 * @return {boolean}
	 */
	State.prototype.resetDescription = function() {
	  this.s.topologyDescription = {
	    "topologyType": "Sharded",
	    "servers": []
	  }
	}
	
	function emitTopologyDescriptionChanged(self, state) {
	  if(self.listeners('topologyDescriptionChanged').length > 0 && state) {
	    var state = state.s;
	    // Generate description
	    var description = {
	      topologyType: 'Sharded',
	      servers: []
	    }
	
	    // Add all the secondaries
	    description.servers = description.servers.concat(state.connectedServers.map(function(x) {
	      var description = x.getDescription();
	      description.type = 'Mongos';
	      return description;
	    }));
	
	    description.servers = description.servers.concat(state.disconnectedServers.map(function(x) {
	      var description = x.getDescription();
	      description.type = 'Unknown';
	      return description;
	    }));
	
	    // Create the result
	    var result = {
	      topologyId: self.id,
	      previousDescription: state.topologyDescription,
	      newDescription: description
	    };
	
	    // Emit the topologyDescription change
	    self.emit('topologyDescriptionChanged', result);
	
	    // Set the new description
	    state.topologyDescription = description;
	  }
	}
	
	//
	// A Mongos connected
	State.prototype.connected = function(server) {
	  // Locate in disconnected servers and remove
	  this.s.disconnectedServers = this.s.disconnectedServers.filter(function(s) {
	    return !s.equals(server);
	  });
	
	  var found = false;
	  // Check if the server exists
	  this.s.connectedServers.forEach(function(s) {
	    if(s.equals(server)) found = true;
	  });
	
	  // Add to disconnected list if it does not already exist
	  if(!found) this.s.connectedServers.push(server);
	
	  // Adjust lower bound
	  if(this.s.lowerBoundLatency > server.s.isMasterLatencyMS) {
	    this.s.lowerBoundLatency = server.s.isMasterLatencyMS;
	  }
	}
	
	//
	// A Mongos disconnected
	State.prototype.disconnected = function(server) {
	  // Locate in disconnected servers and remove
	  this.s.connectedServers = this.s.connectedServers.filter(function(s) {
	    return !s.equals(server);
	  });
	
	  var found = false;
	  // Check if the server exists
	  this.s.disconnectedServers.forEach(function(s) {
	    if(s.equals(server)) found = true;
	  });
	
	  // Add to disconnected list if it does not already exist
	  if(!found) this.s.disconnectedServers.push(server);
	}
	
	//
	// Return the list of disconnected servers
	State.prototype.disconnectedServers = function() {
	  return this.s.disconnectedServers.slice(0);
	}
	
	//
	// Get connectedServers
	State.prototype.connectedServers = function() {
	  return this.s.connectedServers.slice(0)
	}
	
	//
	// Get all servers
	State.prototype.getAll = function() {
	  return this.s.connectedServers.slice(0).concat(this.s.disconnectedServers);
	}
	
	//
	// Get all connections
	State.prototype.getAllConnections = function() {
	  var connections = [];
	
	  this.s.connectedServers.forEach(function(e) {
	    connections = connections.concat(e.connections());
	  });
	  return connections;
	}
	
	//
	// Unref the state
	State.prototype.unref = function() {
	  // Unref all the servers
	  for(var i = 0; i < this.s.connectedServers.length; i++) {
	    // Get each of the servers
	    var server = this.s.connectedServers[i];
	    // Remove any non used handlers
	    ['error', 'close', 'timeout', 'connect'].forEach(function(e) {
	      server.removeAllListeners(e);
	    })
	    // Unreference the server
	    server.unref();
	  }
	}
	
	//
	// Destroy the state
	State.prototype.destroy = function() {
	  // Destroy any connected servers
	  while(this.s.connectedServers.length > 0) {
	    var server = this.s.connectedServers.shift();
	
	    // Remove any non used handlers
	    ['error', 'close', 'timeout', 'connect'].forEach(function(e) {
	      server.removeAllListeners(e);
	    })
	
	    // Server destroy
	    server.destroy();
	    // Add to list of disconnected servers
	    this.s.disconnectedServers.push(server);
	  }
	}
	
	var pickProxies = function(self, options) {
	  options = options || {};
	  var readPreference = options.readPreference || ReadPreference.primary;
	
	  // All connected servers
	  var servers = self.s.connectedServers.slice(0);
	
	  // Do we have a custom readPreference strategy, use it
	  if(self.s.readPreferenceStrategies != null && self.s.readPreferenceStrategies[readPreference] != null) {
	    var server = self.s.readPreferenceStrategies[readPreference].pickServer(servers, readPreference);
	    // Return the server if one is found
	    return !server ? [] : [server];
	  }
	
	  // Filter out the possible servers
	  servers = self.s.connectedServers.filter(function(server) {
	    if((server.s.isMasterLatencyMS <= (self.s.lowerBoundLatency + self.s.localThresholdMS))
	      && server.isConnected()) {
	      return true;
	    }
	  });
	
	  // If no servers found return the lowest latency proxy
	  if(servers.length == 0 && self.s.connectedServers.length > 0) {
	    servers = self.s.connectedServers.sort(function(server1, server2) {
	      return server1.s.isMasterLatencyMS - server2.s.isMasterLatencyMS;
	    });
	
	    // Return the lowest latency server if none is found
	    return [servers[0]];
	  }
	
	  // Return all the servers found
	  return servers;
	}
	
	//
	// Are we connected
	State.prototype.isConnected = function(options) {
	  // Get all the servers
	  var servers = pickProxies(this, options);
	  // Return if the server is connected
	  return servers.length > 0 ? true : false;
	}
	
	//
	// Pick a server
	State.prototype.pickServer = function(readPreference) {
	  // Get all the servers
	  var servers = pickProxies(this, {readPreference:readPreference});
	  // No valid connections
	  if(servers.length == 0) throw new MongoError("no mongos proxy available");
	  // Update index
	  this.s.index = (this.s.index + 1) % servers.length;
	  // Pick first one
	  return servers[this.s.index];
	}
	
	/**
	 * Creates a new Mongos instance
	 * @class
	 * @param {array} seedlist A list of seeds for the replicaset
	 * @param {number} [options.reconnectTries=30] Reconnect retries for HA if no servers available
	 * @param {number} [options.haInterval=5000] The High availability period for replicaset inquiry
	 * @param {boolean} [options.emitError=false] Server will emit errors events
	 * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors
	 * @param {number} [options.size=5] Server connection pool size
	 * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
	 * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled
	 * @param {number} [options.localThresholdMS=15] Cutoff latency point in MS for MongoS proxy selection
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.connectionTimeout=1000] TCP Connection timeout setting
	 * @param {number} [options.socketTimeout=0] TCP Socket timeout setting
	 * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed
	 * @param {boolean} [options.ssl=false] Use SSL for connection
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {Buffer} [options.ca] SSL Certificate store binary buffer
	 * @param {Buffer} [options.cert] SSL Certificate binary buffer
	 * @param {Buffer} [options.key] SSL Key file binary buffer
	 * @param {string} [options.passphrase] SSL Certificate pass phrase
	 * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates
	 * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
	 * @return {Mongos} A cursor instance
	 * @fires Mongos#connect
	 * @fires Mongos#joined
	 * @fires Mongos#left
	 */
	var Mongos = function(seedlist, options) {
	  var self = this;
	  options = options || {};
	
	  // Add event listener
	  EventEmitter.call(this);
	
	  // Validate seedlist
	  if(!Array.isArray(seedlist)) throw new MongoError("seedlist must be an array");
	  // Validate list
	  if(seedlist.length == 0) throw new MongoError("seedlist must contain at least one entry");
	  // Validate entries
	  seedlist.forEach(function(e) {
	    if(typeof e.host != 'string' || typeof e.port != 'number')
	      throw new MongoError("seedlist entry must contain a host and port");
	  });
	
	  // BSON Parser, ensure we have a single instance
	  bsonInstance = bsonInstance == null ? new BSON(bsonTypes) : bsonInstance;
	  // Pick the right bson parser
	  var bson = options.bson ? options.bson : bsonInstance;
	  // Add bson parser to options
	  options.bson = bson;
	
	  // The Mongos state
	  this.s = {
	    // Seed list for sharding passed in
	      seedlist: seedlist
	    // Passed in options
	    , options: options
	    // Logger
	    , logger: Logger('Mongos', options)
	    // Reconnect tries
	    , reconnectTries: options.reconnectTries || 30
	    // Ha interval
	    , haInterval: options.haInterval || 5000
	    // localThresholdMS
	    , localThresholdMS: options.localThresholdMS || 15
	    // Have omitted fullsetup
	    , fullsetup: false
	    // Cursor factory
	    , Cursor: options.cursorFactory || BasicCursor
	    // Current credentials used for auth
	    , credentials: []
	    // BSON Parser
	    , bsonInstance: bsonInstance
	    , bson: bson
	    // Pings
	    , pings: {}
	    // Default state
	    , state: DISCONNECTED
	    // Swallow or emit errors
	    , emitError: typeof options.emitError == 'boolean' ? options.emitError : false
	    // Contains any alternate strategies for picking
	    , readPreferenceStrategies: {}
	    // Auth providers
	    , authProviders: {}
	    // Unique instance id
	    , id: mongosId++
	    // Authentication in progress
	    , authInProgress: false
	    // Servers added while auth in progress
	    , authInProgressServers: []
	    // Current retries left
	    , retriesLeft: options.reconnectTries || 30
	    // Do we have a not connected handler
	    , disconnectHandler: options.disconnectHandler
	  }
	
	  // Set up the connection timeout for the options
	  options.connectionTimeout = options.connectionTimeout || 1000;
	
	  // Create a new state for the mongos
	  this.s.mongosState = new State(this.s.readPreferenceStrategies, this.s.localThresholdMS);
	
	  // Add the authentication mechanisms
	  this.addAuthProvider('mongocr', new MongoCR());
	  this.addAuthProvider('x509', new X509());
	  this.addAuthProvider('plain', new Plain());
	  this.addAuthProvider('gssapi', new GSSAPI());
	  this.addAuthProvider('sspi', new SSPI());
	  this.addAuthProvider('scram-sha-1', new ScramSHA1());
	
	  // BSON property (find a server and pass it along)
	  Object.defineProperty(this, 'bson', {
	    enumerable: true, get: function() {
	      var servers = self.s.mongosState.getAll();
	      return servers.length > 0 ? servers[0].bson : null;
	    }
	  });
	
	  Object.defineProperty(this, 'id', {
	    enumerable:true, get: function() { return self.s.id; }
	  });
	
	  Object.defineProperty(this, 'type', {
	    enumerable:true, get: function() { return 'mongos'; }
	  });
	
	  Object.defineProperty(this, 'haInterval', {
	    enumerable:true, get: function() { return self.s.haInterval; }
	  });
	
	  Object.defineProperty(this, 'state', {
	    enumerable:true, get: function() { return self.s.mongosState; }
	  });
	}
	
	inherits(Mongos, EventEmitter);
	
	/**
	 * Name of BSON parser currently used
	 * @method
	 * @return {string}
	 */
	Mongos.prototype.parserType = function() {
	  if(this.s.bson.serialize.toString().indexOf('[native code]') != -1)
	    return 'c++';
	  return 'js';
	}
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} type Type of BSON parser to use (c++ or js)
	 */
	Mongos.prototype.setBSONParserType = function(type) {
	  var nBSON = null;
	
	  if(type == 'c++') {
	    nBSON = __webpack_require__(134).native().BSON;
	  } else if(type == 'js') {
	    nBSON = __webpack_require__(134).pure().BSON;
	  } else {
	    throw new MongoError(f("% parser not supported", type));
	  }
	
	  this.s.options.bson = new nBSON(bsonTypes);
	}
	
	/**
	 * Returns the last known ismaster document for this server
	 * @method
	 * @return {object}
	 */
	Mongos.prototype.lastIsMaster = function() {
	  var connectedServers = this.s.mongosState.connectedServers();
	  if(connectedServers.length > 0) return connectedServers[0].lastIsMaster();
	  return null;
	}
	
	/**
	 * Initiate server connect
	 * @method
	 */
	Mongos.prototype.connect = function(_options) {
	  var self = this;
	  // Start replicaset inquiry process
	  setTimeout(mongosInquirer(self, self.s), self.s.haInterval);
	  // Additional options
	  if(_options) for(var name in _options) self.s.options[name] = _options[name];
	  // For all entries in the seedlist build a server instance
	  self.s.seedlist.forEach(function(e) {
	    // Clone options
	    var opts = cloneOptions(self.s.options);
	    // Add host and port
	    opts.host = e.host;
	    opts.port = e.port;
	    opts.reconnect = false;
	    opts.readPreferenceStrategies = self.s.readPreferenceStrategies;
	    // Share the auth store
	    opts.authProviders = self.s.authProviders;
	    // Don't emit errors
	    opts.emitError = true;
	    // Set that server is in a topology
	    opts.inTopology = true;
	    opts.topologyId = self.s.id;
	    opts.monitoring = true;
	    // Create a new Server
	    self.s.mongosState.disconnected(new Server(opts));
	  });
	
	  // Reset the replState
	  this.s.mongosState.resetDescription();
	
	  // Emit the topology opening event
	  emitSDAMEvent(this, 'topologyOpening', { topologyId: this.s.id });
	
	  // Get the disconnected servers
	  var servers = self.s.mongosState.disconnectedServers();
	
	  // Set connecting state
	  this.s.state = CONNECTING;
	
	  // Attempt to connect to all the servers
	  while(servers.length > 0) {
	    // Get the server
	    var server = servers.shift();
	
	    // Remove any non used handlers
	    ['error', 'close', 'timeout', 'connect', 'message', 'parseError',
	      'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	      'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'].forEach(function(e) {
	      server.removeAllListeners(e);
	    });
	
	    // Set up the event handlers
	    server.once('error', errorHandlerTemp(self, self.s, server));
	    server.once('close', errorHandlerTemp(self, self.s, server));
	    server.once('timeout', errorHandlerTemp(self, self.s, server));
	    server.once('parseError', errorHandlerTemp(self, self.s, server));
	    server.once('connect', connectHandler(self, self.s, 'connect'));
	
	    // SDAM Monitoring events
	    server.on('serverOpening', function(e) { self.emit('serverOpening', e); });
	    server.on('serverDescriptionChanged', function(e) { self.emit('serverDescriptionChanged', e); });
	    server.on('serverHeartbeatStarted', function(e) { self.emit('serverHeartbeatStarted', e); });
	    server.on('serverHeartbeatSucceeded', function(e) { self.emit('serverHeartbeatSucceeded', e); });
	    server.on('serverHearbeatFailed', function(e) { self.emit('serverHearbeatFailed', e); });
	    server.on('serverClosed', function(e) { self.emit('serverClosed', e); });
	
	    if(self.s.logger.isInfo()) self.s.logger.info(f('connecting to server %s', server.name));
	
	    // Execute the connect
	    var execute = function(_server) {
	      process.nextTick(function() {
	        _server.connect();
	      });
	    }
	
	    // Connect
	    execute(server);
	  }
	}
	
	/**
	 * Unref all connections belong to this server
	 * @method
	 */
	Mongos.prototype.unref = function(emitClose) {
	  if(this.s.logger.isInfo()) this.s.logger.info(f('[%s] unreferenced', this.s.id));
	  // Emit close
	  if(emitClose && this.listeners('close').length > 0) this.emit('close', this);
	  // Unref sockets
	  this.s.mongosState.unref();
	}
	
	/**
	 * Destroy the server connection
	 * @method
	 */
	Mongos.prototype.destroy = function(emitClose) {
	  this.s.state = DESTROYED;
	  // Emit toplogy closing event
	  emitSDAMEvent(this, 'topologyClosed', { topologyId: this.s.id });
	  // Emit close
	  if(emitClose && self.listeners('close').length > 0) self.emit('close', self);
	  // Destroy the state
	  this.s.mongosState.destroy();
	}
	
	/**
	 * Figure out if the server is connected
	 * @method
	 * @return {boolean}
	 */
	Mongos.prototype.isConnected = function(options) {
	  return this.s.mongosState.isConnected(options);
	}
	
	/**
	 * Figure out if the server instance was destroyed by calling destroy
	 * @method
	 * @return {boolean}
	 */
	Mongos.prototype.isDestroyed = function() {
	  return this.s.state  == DESTROYED;
	}
	
	//
	// Operations
	//
	
	/**
	 * Insert one or more documents
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of documents to insert
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Mongos.prototype.insert = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!this.isConnected() && this.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return this.s.disconnectHandler.add('insert', ns, ops, options, callback);
	  }
	
	  executeWriteOperation(this.s, 'insert', ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more update operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of updates
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Mongos.prototype.update = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!this.isConnected() && this.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return this.s.disconnectHandler.add('update', ns, ops, options, callback);
	  }
	
	  executeWriteOperation(this.s, 'update', ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of removes
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Mongos.prototype.remove = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!this.isConnected() && this.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return this.s.disconnectHandler.add('remove', ns, ops, options, callback);
	  }
	
	  executeWriteOperation(this.s, 'remove', ns, ops, options, callback);
	}
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {object} cmd The command hash
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {Connection} [options.connection] Specify connection object to execute command against
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Mongos.prototype.command = function(ns, cmd, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  var self = this;
	
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!self.isConnected() && self.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return self.s.disconnectHandler.add('command', ns, cmd, options, callback);
	  }
	
	  var server = null;
	  // Ensure we have no options
	  options = options || {};
	
	  // We need to execute the command on all servers
	  if(options.onAll) {
	    var servers = self.s.mongosState.getAll();
	    var count = servers.length;
	    var cmdErr = null;
	
	    for(var i = 0; i < servers.length; i++) {
	      servers[i].command(ns, cmd, options, function(err, r) {
	        count = count - 1;
	        // Finished executing command
	        if(count == 0) {
	          // Was it a logout command clear any credentials
	          if(cmd.logout) clearCredentials(self.s, ns);
	          // Return the error
	          callback(err, r);
	        }
	      });
	    }
	
	    return;
	  }
	
	
	  try {
	    // Get a primary
	    server = self.s.mongosState.pickServer(options.writeConcern ? ReadPreference.primary : options.readPreference);
	  } catch(err) {
	    return callback(err);
	  }
	
	  // No server returned we had an error
	  if(server == null) return callback(new MongoError("no mongos found"));
	  server.command(ns, cmd, options, function(err, r) {
	    // Was it a logout command clear any credentials
	    if(cmd.logout) clearCredentials(self.s, ns);
	    callback(err, r);
	  });
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {{object}|{Long}} cmd Can be either a command returning a cursor or a cursorId
	 * @param {object} [options.batchSize=0] Batchsize for the operation
	 * @param {array} [options.documents=[]] Initial documents list for cursor
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Mongos.prototype.cursor = function(ns, cmd, cursorOptions) {
	  cursorOptions = cursorOptions || {};
	  var FinalCursor = cursorOptions.cursorFactory || this.s.Cursor;
	  return new FinalCursor(this.s.bson, ns, cmd, cursorOptions, this, this.s.options);
	}
	
	/**
	 * Authenticate using a specified mechanism
	 * @method
	 * @param {string} mechanism The Auth mechanism we are invoking
	 * @param {string} db The db we are invoking the mechanism against
	 * @param {...object} param Parameters for the specific mechanism
	 * @param {authResultCallback} callback A callback function
	 */
	Mongos.prototype.auth = function(mechanism, db) {
	  var allArgs = Array.prototype.slice.call(arguments, 0).slice(0);
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  var callback = args.pop();
	
	  // If we don't have the mechanism fail
	  if(this.s.authProviders[mechanism] == null && mechanism != 'default')
	    throw new MongoError(f("auth provider %s does not exist", mechanism));
	
	  // Authenticate against all the servers
	  var servers = this.s.mongosState.connectedServers().slice(0);
	  var count = servers.length;
	  // Correct authentication
	  var authenticated = true;
	  var authErr = null;
	  // Set auth in progress
	  this.s.authInProgress = true;
	
	  // Authenticate against all servers
	  while(servers.length > 0) {
	    var server = servers.shift();
	    // Arguments without a callback
	    var argsWithoutCallback = [mechanism, db].concat(args.slice(0));
	    // Create arguments
	    var finalArguments = argsWithoutCallback.concat([function(err, r) {
	      count = count - 1;
	      if(err) authErr = err;
	      if(!r) authenticated = false;
	
	      // We are done
	      if(count == 0) {
	        // We have more servers that are not authenticated, let's authenticate
	        if(self.s.authInProgressServers.length > 0) {
	          self.s.authInProgressServers = [];
	          return self.auth.apply(self, [mechanism, db].concat(args).concat([callback]));
	        }
	
	        // Auth is done
	        self.s.authInProgress = false;
	        // Add successful credentials
	        if(authErr == null) addCredentials(self.s, db, argsWithoutCallback);
	        // Return the auth error
	        if(authErr) return callback(authErr, false);
	        // Successfully authenticated session
	        callback(null, new Session({}, self));
	      }
	    }]);
	
	    // Execute the auth
	    server.auth.apply(server, finalArguments);
	  }
	}
	
	//
	// Plugin methods
	//
	
	/**
	 * Add custom read preference strategy
	 * @method
	 * @param {string} name Name of the read preference strategy
	 * @param {object} strategy Strategy object instance
	 */
	Mongos.prototype.addReadPreferenceStrategy = function(name, strategy) {
	  if(this.s.readPreferenceStrategies == null) this.s.readPreferenceStrategies = {};
	  this.s.readPreferenceStrategies[name] = strategy;
	}
	
	/**
	 * Add custom authentication mechanism
	 * @method
	 * @param {string} name Name of the authentication mechanism
	 * @param {object} provider Authentication object instance
	 */
	Mongos.prototype.addAuthProvider = function(name, provider) {
	  this.s.authProviders[name] = provider;
	}
	
	/**
	 * Get connection
	 * @method
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @return {Connection}
	 */
	Mongos.prototype.getConnection = function(options) {
	  // Ensure we have no options
	  options = options || {};
	  // Pick the right server based on readPreference
	  var server = this.s.mongosState.pickServer(options.readPreference);
	  if(server == null) return null;
	  // Return connection
	  return server.getConnection();
	}
	
	/**
	 * Get server
	 * @method
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @return {Server}
	 */
	Mongos.prototype.getServer = function(options) {
	  // Ensure we have no options
	  options = options || {};
	  // Pick the right server based on readPreference
	  return this.s.mongosState.pickServer(options.readPreference);
	}
	
	/**
	 * Get correct server for a given connection
	 * @method
	 * @param {Connection} [connection] A Connection showing a current server
	 * @return {Server}
	 */
	Mongos.prototype.getServerFrom = function(connection) {
	  var servers = this.s.mongosState.getAll();
	  // Go through all the server
	  for(var i = 0; i < servers.length; i++) {
	    if(servers[i].equals(connection.name)) return servers[i];
	  }
	
	  return null;
	}
	
	/**
	 * All raw connections
	 * @method
	 * @return {Connection[]}
	 */
	Mongos.prototype.connections = function() {
	  return this.s.mongosState.getAllConnections();
	}
	
	//
	// Inquires about state changes
	//
	var mongosInquirer = function(self, state) {
	  return function() {
	    if(state.state == DESTROYED) return
	    if(state.state == CONNECTED) state.retriesLeft = state.reconnectTries;
	
	    // If we have a disconnected site
	    if(state.state == DISCONNECTED && state.retriesLeft == 0) {
	      self.destroy();
	      return self.emit('error', new MongoError(f('failed to reconnect after %s', state.reconnectTries)));
	    } else if(state.state == DISCONNECTED) {
	      state.retriesLeft = state.retriesLeft - 1;
	    }
	
	    // If we have a primary and a disconnect handler, execute
	    // buffered operations
	    if(state.mongosState.isConnected() && state.disconnectHandler) {
	      state.disconnectHandler.execute();
	    }
	
	    // Log the information
	    if(state.logger.isDebug()) state.logger.debug(f('mongos ha proceess running'));
	
	    // Let's query any disconnected proxies
	    var disconnectedServers = state.mongosState.disconnectedServers();
	    if(disconnectedServers.length == 0) return setTimeout(mongosInquirer(self, state), state.haInterval);
	
	    // Count of connections waiting to be connected
	    var connectionCount = disconnectedServers.length;
	    if(state.logger.isDebug()) state.logger.debug(f('mongos ha proceess found %d disconnected proxies', connectionCount));
	
	    // Let's attempt to reconnect
	    while(disconnectedServers.length > 0) {
	      // Connect to proxy
	      var connectToProxy = function(_server) {
	        setTimeout(function() {
	          // Remove any non used handlers
	          ['error', 'close', 'timeout', 'connect', 'message', 'parseError',
	            'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	            'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'].forEach(function(e) {
	            _server.removeAllListeners(e);
	          });
	
	          // Set up the event handlers
	          _server.once('error', errorHandlerTemp(self, state, server));
	          _server.once('close', errorHandlerTemp(self, state, server));
	          _server.once('timeout', errorHandlerTemp(self, state, server));
	          _server.once('connect', connectHandler(self, state, 'ha'));
	
	          // SDAM Monitoring events
	          _server.on('serverOpening', function(e) { self.emit('serverOpening', e); });
	          _server.on('serverDescriptionChanged', function(e) { self.emit('serverDescriptionChanged', e); });
	          _server.on('serverHeartbeatStarted', function(e) { self.emit('serverHeartbeatStarted', e); });
	          _server.on('serverHeartbeatSucceeded', function(e) { self.emit('serverHeartbeatSucceeded', e); });
	          _server.on('serverHearbeatFailed', function(e) { self.emit('serverHearbeatFailed', e); });
	          _server.on('serverClosed', function(e) { self.emit('serverClosed', e); });
	
	          // Start connect
	          _server.connect();
	        }, 1);
	      }
	
	      var server = disconnectedServers.shift();
	      if(state.logger.isDebug()) state.logger.debug(f('attempting to connect to server %s', server.name));
	      connectToProxy(server);
	    }
	
	    // Let's keep monitoring but wait for possible timeout to happen
	    return setTimeout(mongosInquirer(self, state), state.options.connectionTimeout + state.haInterval);
	  }
	}
	
	//
	// Error handler for initial connect
	var errorHandlerTemp = function(self, state, server) {
	  return function(err, server) {
	    // Log the information
	    if(state.logger.isInfo()) state.logger.info(f('server %s disconnected with error %s',  server.name, JSON.stringify(err)));
	
	    // Signal disconnect of server
	    state.mongosState.disconnected(server);
	
	    // Remove any non used handlers
	    var events = ['error', 'close', 'timeout', 'connect'];
	    events.forEach(function(e) {
	      server.removeAllListeners(e);
	    })
	  }
	}
	
	//
	// Handlers
	var errorHandler = function(self, state) {
	  return function(err, server) {
	    if(state.logger.isInfo()) state.logger.info(f('server %s errored out with %s', server.name, JSON.stringify(err)));
	    state.mongosState.disconnected(server);
	    // No more servers left emit close
	    if(state.mongosState.connectedServers().length == 0) {
	      state.state = DISCONNECTED;
	    }
	
	    // Emit topology changed event
	    emitTopologyDescriptionChanged(self, state.mongosState);
	
	    // Signal server left
	    self.emit('left', 'mongos', server);
	    if(state.emitError) self.emit('error', err, server);
	  }
	}
	
	var timeoutHandler = function(self, state) {
	  return function(err, server) {
	    if(state.logger.isInfo()) state.logger.info(f('server %s timed out', server.name));
	    state.mongosState.disconnected(server);
	
	    // No more servers emit close event if no entries left
	    if(state.mongosState.connectedServers().length == 0) {
	      state.state = DISCONNECTED;
	    }
	
	    // Emit topology changed event
	    emitTopologyDescriptionChanged(self, state.mongosState);
	
	    // Signal server left
	    self.emit('left', 'mongos', server);
	  }
	}
	
	var closeHandler = function(self, state) {
	  return function(err, server) {
	    if(state.logger.isInfo()) state.logger.info(f('server %s closed', server.name));
	    state.mongosState.disconnected(server);
	
	    // No more servers left emit close
	    if(state.mongosState.connectedServers().length == 0) {
	      state.state = DISCONNECTED;
	    }
	
	    // Emit topology changed event
	    emitTopologyDescriptionChanged(self, state.mongosState);
	
	    // Signal server left
	    self.emit('left', 'mongos', server);
	  }
	}
	
	// Connect handler
	var connectHandler = function(self, state, e) {
	  return function(server) {
	    if(state.logger.isInfo()) state.logger.info(f('connected to %s', server.name));
	
	    // Remove any non used handlers
	    ['error', 'close', 'timeout', 'connect', 'message', 'parseError'].forEach(function(e) {
	      server.removeAllListeners(e);
	    });
	
	    // finish processing the server
	    var processNewServer = function(_server) {
	      // Add the server handling code
	      if(_server.isConnected()) {
	        _server.once('error', errorHandler(self, state));
	        _server.once('close', closeHandler(self, state));
	        _server.once('timeout', timeoutHandler(self, state));
	        _server.once('parseError', timeoutHandler(self, state));
	      }
	
	      // Emit joined event
	      self.emit('joined', 'mongos', _server);
	
	      // Add to list connected servers
	      state.mongosState.connected(_server);
	
	      // Do we have a reconnect event
	      if('ha' == e && state.mongosState.connectedServers().length == 1) {
	        self.emit('reconnect', _server);
	      }
	
	      // Full setup
	      if(state.mongosState.disconnectedServers().length == 0 &&
	        state.mongosState.connectedServers().length > 0 &&
	        !state.fullsetup) {
	        state.fullsetup = true;
	        self.emit('fullsetup', self);
	      }
	
	      // all connected
	      if(state.mongosState.disconnectedServers().length == 0 &&
	        state.mongosState.connectedServers().length == state.seedlist.length &&
	        !state.all) {
	        state.all = true;
	        self.emit('all', self);
	      }
	
	      // Emit topology changed event
	      emitTopologyDescriptionChanged(self, state.mongosState);
	
	      // Set connected
	      if(state.state == DISCONNECTED) {
	        state.state = CONNECTED;
	        self.emit('reconnect', self);
	      } else if(state.state == CONNECTING) {
	        state.state = CONNECTED;
	        self.emit('connect', self);
	      }
	    }
	
	    // Is there an authentication process ongoing
	    if(state.authInProgress) {
	      state.authInProgressServers.push(server);
	    }
	
	    // No credentials just process server
	    if(state.credentials.length == 0) return processNewServer(server);
	
	    // Do we have credentials, let's apply them all
	    var count = state.credentials.length;
	    // Apply the credentials
	    for(var i = 0; i < state.credentials.length; i++) {
	      server.auth.apply(server, state.credentials[i].concat([function(err, r) {
	        count = count - 1;
	        if(count == 0) processNewServer(server);
	      }]));
	    }
	  }
	}
	
	//
	// Add server to the list if it does not exist
	var addToListIfNotExist = function(list, server) {
	  var found = false;
	
	  // Remove any non used handlers
	  ['error', 'close', 'timeout', 'connect'].forEach(function(e) {
	    server.removeAllListeners(e);
	  })
	
	  // Check if the server already exists
	  for(var i = 0; i < list.length; i++) {
	    if(list[i].equals(server)) found = true;
	  }
	
	  if(!found) {
	    list.push(server);
	  }
	}
	
	// Add the new credential for a db, removing the old
	// credential from the cache
	var addCredentials = function(state, db, argsWithoutCallback) {
	  // Remove any credentials for the db
	  clearCredentials(state, db + ".dummy");
	  // Add new credentials to list
	  state.credentials.push(argsWithoutCallback);
	}
	
	// Clear out credentials for a namespace
	var clearCredentials = function(state, ns) {
	  var db = ns.split('.')[0];
	  var filteredCredentials = [];
	
	  // Filter out all credentials for the db the user is logging out off
	  for(var i = 0; i < state.credentials.length; i++) {
	    if(state.credentials[i][1] != db) filteredCredentials.push(state.credentials[i]);
	  }
	
	  // Set new list of credentials
	  state.credentials = filteredCredentials;
	}
	
	var processReadPreference = function(cmd, options) {
	  options = options || {}
	  // No read preference specified
	  if(options.readPreference == null) return cmd;
	}
	
	//
	// Execute write operation
	var executeWriteOperation = function(state, op, ns, ops, options, callback) {
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  var server = null;
	  // Ensure we have no options
	  options = options || {};
	  try {
	    // Get a primary
	    server = state.mongosState.pickServer();
	  } catch(err) {
	    return callback(err);
	  }
	
	  // No server returned we had an error
	  if(server == null) return callback(new MongoError("no mongos found"));
	  // Execute the command
	  server[op](ns, ops, options, callback);
	}
	
	/**
	 * A mongos connect event, used to verify that the connection is up and running
	 *
	 * @event Mongos#connect
	 * @type {Mongos}
	 */
	
	/**
	 * A server member left the mongos list
	 *
	 * @event Mongos#left
	 * @type {Mongos}
	 * @param {string} type The type of member that left (mongos)
	 * @param {Server} server The server object that left
	 */
	
	/**
	 * A server member joined the mongos list
	 *
	 * @event Mongos#joined
	 * @type {Mongos}
	 * @param {string} type The type of member that left (mongos)
	 * @param {Server} server The server object that joined
	 */
	
	module.exports = Mongos;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var EventEmitter = __webpack_require__(3).EventEmitter,
	  inherits = __webpack_require__(77).inherits;
	
	// Get prototypes
	var AggregationCursor = __webpack_require__(193),
	  CommandCursor = __webpack_require__(201),
	  OrderedBulkOperation = __webpack_require__(202).OrderedBulkOperation,
	  UnorderedBulkOperation = __webpack_require__(204).UnorderedBulkOperation,
	  GridStore = __webpack_require__(205),
	  Server = __webpack_require__(208),
	  ReplSet = __webpack_require__(210),
	  Mongos = __webpack_require__(211),
	  Cursor = __webpack_require__(197),
	  Collection = __webpack_require__(207),
	  Db = __webpack_require__(212),
	  Admin = __webpack_require__(213);
	
	var basicOperationIdGenerator = {
	  operationId: 1,
	
	  next: function() {
	    return this.operationId++;
	  }
	}
	
	var basicTimestampGenerator = {
	  current: function() {
	    return new Date().getTime();
	  },
	
	  duration: function(start, end) {
	    return end - start;
	  }
	}
	
	var senstiveCommands = ['authenticate', 'saslStart', 'saslContinue', 'getnonce',
	  'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb'];
	
	var Instrumentation = function(core, options, callback) {
	  options = options || {};
	
	  // Optional id generators
	  var operationIdGenerator = options.operationIdGenerator || basicOperationIdGenerator;
	  // Optional timestamp generator
	  var timestampGenerator = options.timestampGenerator || basicTimestampGenerator;
	  // Extend with event emitter functionality
	  EventEmitter.call(this);
	
	  // Contains all the instrumentation overloads
	  this.overloads = [];
	
	  // ---------------------------------------------------------
	  //
	  // Instrument prototype
	  //
	  // ---------------------------------------------------------
	
	  var instrumentPrototype = function(callback) {
	    var instrumentations = []
	
	    // Classes to support
	    var classes = [GridStore, OrderedBulkOperation, UnorderedBulkOperation,
	      CommandCursor, AggregationCursor, Cursor, Collection, Db];
	
	    // Add instrumentations to the available list
	    for(var i = 0; i < classes.length; i++) {
	      if(classes[i].define) {
	        instrumentations.push(classes[i].define.generate());
	      }
	    }
	
	    // Return the list of instrumentation points
	    callback(null, instrumentations);
	  }
	
	  // Did the user want to instrument the prototype
	  if(typeof callback == 'function') {
	    instrumentPrototype(callback);
	  }
	
	  // ---------------------------------------------------------
	  //
	  // Server
	  //
	  // ---------------------------------------------------------
	
	  // Reference
	  var self = this;
	  // Names of methods we need to wrap
	  var methods = ['command', 'insert', 'update', 'remove'];
	  // Prototype
	  var proto = core.Server.prototype;
	  // Core server method we are going to wrap
	  methods.forEach(function(x) {
	    var func = proto[x];
	
	    // Add to overloaded methods
	    self.overloads.push({proto: proto, name:x, func:func});
	
	    // The actual prototype
	    proto[x] = function() {
	      var requestId = core.Query.nextRequestId();
	      // Get the aruments
	      var args = Array.prototype.slice.call(arguments, 0);
	      var ns = args[0];
	      var commandObj = args[1];
	      var options = args[2] || {};
	      var keys = Object.keys(commandObj);
	      var commandName = keys[0];
	      var db = ns.split('.')[0];
	
	      // Do we have a legacy insert/update/remove command
	      if(x == 'insert' && !this.lastIsMaster().maxWireVersion) {
	        commandName = 'insert';
	        // Get the collection
	        var col = ns.split('.');
	        col.shift();
	        col = col.join('.');
	
	        // Re-write the command
	        commandObj = {
	          insert: col, documents: commandObj
	        }
	
	        if(options.writeConcern && Object.keys(options.writeConcern).length > 0)  {
	          commandObj.writeConcern = options.writeConcern;
	        }
	
	        commandObj.ordered = options.ordered != undefined ? options.ordered : true;
	      } else if(x == 'update' && !this.lastIsMaster().maxWireVersion) {
	        commandName = 'update';
	
	        // Get the collection
	        var col = ns.split('.');
	        col.shift();
	        col = col.join('.');
	
	        // Re-write the command
	        commandObj = {
	          update: col, updates: commandObj
	        }
	
	        if(options.writeConcern && Object.keys(options.writeConcern).length > 0) {
	          commandObj.writeConcern = options.writeConcern;
	        }
	
	        commandObj.ordered = options.ordered != undefined ? options.ordered : true;
	      } else if(x == 'remove' && !this.lastIsMaster().maxWireVersion) {
	        commandName = 'delete';
	
	        // Get the collection
	        var col = ns.split('.');
	        col.shift();
	        col = col.join('.');
	
	        // Re-write the command
	        commandObj = {
	          delete: col, deletes: commandObj
	        }
	
	        if(options.writeConcern && Object.keys(options.writeConcern).length > 0) {
	          commandObj.writeConcern = options.writeConcern;
	        }
	
	        commandObj.ordered = options.ordered != undefined ? options.ordered : true;
	      } else if(x == 'insert' || x == 'update' || x == 'remove' && this.lastIsMaster().maxWireVersion >= 2) {
	        // Skip the insert/update/remove commands as they are executed as actual write commands in 2.6 or higher
	        return func.apply(this, args);
	      }
	
	      // Get the callback
	      var callback = args.pop();
	      // Set current callback operation id from the current context or create
	      // a new one
	      var ourOpId = callback.operationId || operationIdGenerator.next();
	
	      // Get a connection reference for this server instance
	      var connection = this.s.pool.get()
	
	      // Emit the start event for the command
	      var command = {
	        // Returns the command.
	        command: commandObj,
	        // Returns the database name.
	        databaseName: db,
	        // Returns the command name.
	        commandName: commandName,
	        // Returns the driver generated request id.
	        requestId: requestId,
	        // Returns the driver generated operation id.
	        // This is used to link events together such as bulk write operations. OPTIONAL.
	        operationId: ourOpId,
	        // Returns the connection id for the command. For languages that do not have this,
	        // this MUST return the driver equivalent which MUST include the server address and port.
	        // The name of this field is flexible to match the object that is returned from the driver.
	        connectionId: connection
	      };
	
	      // Filter out any sensitive commands
	      if(senstiveCommands.indexOf(commandName.toLowerCase())) {
	        command.commandObj = {};
	        command.commandObj[commandName] = true;
	      }
	
	      // Emit the started event
	      self.emit('started', command)
	
	      // Start time
	      var startTime = timestampGenerator.current();
	
	      // Push our handler callback
	      args.push(function(err, r) {
	        var endTime = timestampGenerator.current();
	        var command = {
	          duration: timestampGenerator.duration(startTime, endTime),
	          commandName: commandName,
	          requestId: requestId,
	          operationId: ourOpId,
	          connectionId: connection
	        };
	
	        // If we have an error
	        if(err || (r && r.result && r.result.ok == 0)) {
	          command.failure = err || r.result.writeErrors || r.result;
	
	          // Filter out any sensitive commands
	          if(senstiveCommands.indexOf(commandName.toLowerCase())) {
	            command.failure = {};
	          }
	
	          self.emit('failed', command);
	        } else if(commandObj && commandObj.writeConcern
	          && commandObj.writeConcern.w == 0) {
	          // If we have write concern 0
	          command.reply = {ok:1};
	          self.emit('succeeded', command);
	        } else {
	          command.reply = r && r.result ? r.result : r;
	
	          // Filter out any sensitive commands
	          if(senstiveCommands.indexOf(commandName.toLowerCase()) != -1) {
	            command.reply = {};
	          }
	
	          self.emit('succeeded', command);
	        }
	
	        // Return to caller
	        callback(err, r);
	      });
	
	      // Apply the call
	      func.apply(this, args);
	    }
	  });
	
	  // ---------------------------------------------------------
	  //
	  // Bulk Operations
	  //
	  // ---------------------------------------------------------
	
	  // Inject ourselves into the Bulk methods
	  var methods = ['execute'];
	  var prototypes = [
	    __webpack_require__(202).Bulk.prototype,
	    __webpack_require__(204).Bulk.prototype
	  ]
	
	  prototypes.forEach(function(proto) {
	    // Core server method we are going to wrap
	    methods.forEach(function(x) {
	      var func = proto[x];
	
	      // Add to overloaded methods
	      self.overloads.push({proto: proto, name:x, func:func});
	
	      // The actual prototype
	      proto[x] = function() {
	        var bulk = this;
	        // Get the aruments
	        var args = Array.prototype.slice.call(arguments, 0);
	        // Set an operation Id on the bulk object
	        this.operationId = operationIdGenerator.next();
	
	        // Get the callback
	        var callback = args.pop();
	        // If we have a callback use this
	        if(typeof callback == 'function') {
	          args.push(function(err, r) {
	            // Return to caller
	            callback(err, r);
	          });
	
	          // Apply the call
	          func.apply(this, args);
	        } else {
	          return func.apply(this, args);
	        }
	      }
	    });
	  });
	
	  // ---------------------------------------------------------
	  //
	  // Cursor
	  //
	  // ---------------------------------------------------------
	
	  // Inject ourselves into the Cursor methods
	  var methods = ['_find', '_getmore', '_killcursor'];
	  var prototypes = [
	    __webpack_require__(197).prototype,
	    __webpack_require__(201).prototype,
	    __webpack_require__(193).prototype
	  ]
	
	  // Command name translation
	  var commandTranslation = {
	    '_find': 'find', '_getmore': 'getMore', '_killcursor': 'killCursors', '_explain': 'explain'
	  }
	
	  prototypes.forEach(function(proto) {
	
	    // Core server method we are going to wrap
	    methods.forEach(function(x) {
	      var func = proto[x];
	
	      // Add to overloaded methods
	      self.overloads.push({proto: proto, name:x, func:func});
	
	      // The actual prototype
	      proto[x] = function() {
	        var cursor = this;
	        var requestId = core.Query.nextRequestId();
	        var ourOpId = operationIdGenerator.next();
	        var parts = this.ns.split('.');
	        var db = parts[0];
	
	        // Get the collection
	        parts.shift();
	        var collection = parts.join('.');
	
	        // Set the command
	        var command = this.query;
	        var cmd = this.s.cmd;
	
	        // If we have a find method, set the operationId on the cursor
	        if(x == '_find') {
	          cursor.operationId = ourOpId;
	        }
	
	        // Do we have a find command rewrite it
	        if(x == '_getmore') {
	          command = {
	            getMore: this.cursorState.cursorId,
	            collection: collection,
	            batchSize: cmd.batchSize
	          }
	
	          if(cmd.maxTimeMS) command.maxTimeMS = cmd.maxTimeMS;
	        } else if(x == '_killcursors') {
	          command = {
	            killCursors: collection,
	            cursors: [this.cursorState.cursorId]
	          }
	        } else if(cmd.find) {
	          command = {
	            find: collection, filter: cmd.query
	          }
	
	          if(cmd.sort) command.sort = cmd.sort;
	          if(cmd.fields) command.projection = cmd.fields;
	          if(cmd.limit && cmd.limit < 0) {
	            command.limit = Math.abs(cmd.limit);
	            command.singleBatch = true;
	          } else if(cmd.limit) {
	            command.limit = Math.abs(cmd.limit);
	          }
	
	          // Options
	          if(cmd.skip) command.skip = cmd.skip;
	          if(cmd.hint) command.hint = cmd.hint;
	          if(cmd.batchSize) command.batchSize = cmd.batchSize;
	          if(typeof cmd.returnKey == 'boolean') command.returnKey = cmd.returnKey;
	          if(cmd.comment) command.comment = cmd.comment;
	          if(cmd.min) command.min = cmd.min;
	          if(cmd.max) command.max = cmd.max;
	          if(cmd.maxScan) command.maxScan = cmd.maxScan;
	          if(cmd.maxTimeMS) command.maxTimeMS = cmd.maxTimeMS;
	
	          // Flags
	          if(typeof cmd.awaitData == 'boolean') command.awaitData = cmd.awaitData;
	          if(typeof cmd.snapshot == 'boolean') command.snapshot = cmd.snapshot;
	          if(typeof cmd.tailable == 'boolean') command.tailable = cmd.tailable;
	          if(typeof cmd.oplogReplay == 'boolean') command.oplogReplay = cmd.oplogReplay;
	          if(typeof cmd.noCursorTimeout == 'boolean') command.noCursorTimeout = cmd.noCursorTimeout;
	          if(typeof cmd.partial == 'boolean') command.partial = cmd.partial;
	          if(typeof cmd.showDiskLoc == 'boolean') command.showRecordId = cmd.showDiskLoc;
	
	          // Read Concern
	          if(cmd.readConcern) command.readConcern = cmd.readConcern;
	
	          // Override method
	          if(cmd.explain) command.explain = cmd.explain;
	          if(cmd.exhaust) command.exhaust = cmd.exhaust;
	
	          // If we have a explain flag
	          if(cmd.explain) {
	            // Create fake explain command
	            command = {
	              explain: command,
	              verbosity: 'allPlansExecution'
	            }
	
	            // Set readConcern on the command if available
	            if(cmd.readConcern) command.readConcern = cmd.readConcern
	
	            // Set up the _explain name for the command
	            x = '_explain';
	          }
	        } else {
	          command = cmd;
	        }
	
	        // Set up the connection
	        var connectionId = null;
	
	        // Set local connection
	        if(this.connection) connectionId = this.connection;
	        if(!connectionId && this.server && this.server.getConnection) connectionId = this.server.getConnection();
	
	        // Get the command Name
	        var commandName = x == '_find' ? Object.keys(command)[0] : commandTranslation[x];
	
	        // Emit the start event for the command
	        var command = {
	          // Returns the command.
	          command: command,
	          // Returns the database name.
	          databaseName: db,
	          // Returns the command name.
	          commandName: commandName,
	          // Returns the driver generated request id.
	          requestId: requestId,
	          // Returns the driver generated operation id.
	          // This is used to link events together such as bulk write operations. OPTIONAL.
	          operationId: this.operationId,
	          // Returns the connection id for the command. For languages that do not have this,
	          // this MUST return the driver equivalent which MUST include the server address and port.
	          // The name of this field is flexible to match the object that is returned from the driver.
	          connectionId: connectionId
	        };
	
	        // Get the aruments
	        var args = Array.prototype.slice.call(arguments, 0);
	
	        // Get the callback
	        var callback = args.pop();
	
	        // We do not have a callback but a Promise
	        if(typeof callback == 'function' || command.commandName == 'killCursors') {
	          var startTime = timestampGenerator.current();
	          // Emit the started event
	          self.emit('started', command)
	
	          // Emit succeeded event with killcursor if we have a legacy protocol
	          if(command.commandName == 'killCursors'
	            && this.server.lastIsMaster()
	            && this.server.lastIsMaster().maxWireVersion < 4) {
	            // Emit the succeeded command
	            var command = {
	              duration: timestampGenerator.duration(startTime, timestampGenerator.current()),
	              commandName: commandName,
	              requestId: requestId,
	              operationId: cursor.operationId,
	              connectionId: cursor.server.getConnection(),
	              reply: [{ok:1}]
	            };
	
	            // Emit the command
	            return self.emit('succeeded', command)
	          }
	
	          // Add our callback handler
	          args.push(function(err, r) {
	            if(err) {
	              // Command
	              var command = {
	                duration: timestampGenerator.duration(startTime, timestampGenerator.current()),
	                commandName: commandName,
	                requestId: requestId,
	                operationId: ourOpId,
	                connectionId: cursor.server.getConnection(),
	                failure: err };
	
	              // Emit the command
	              self.emit('failed', command)
	            } else {
	              // Do we have a getMore
	              if(commandName.toLowerCase() == 'getmore' && r == null) {
	                r = {
	                  cursor: {
	                    id: cursor.cursorState.cursorId,
	                    ns: cursor.ns,
	                    nextBatch: cursor.cursorState.documents
	                  }, ok:1
	                }
	              } else if(commandName.toLowerCase() == 'find' && r == null) {
	                r = {
	                  cursor: {
	                    id: cursor.cursorState.cursorId,
	                    ns: cursor.ns,
	                    firstBatch: cursor.cursorState.documents
	                  }, ok:1
	                }
	              } else if(commandName.toLowerCase() == 'killcursors' && r == null) {
	                r = {
	                  cursorsUnknown:[cursor.cursorState.lastCursorId],
	                  ok:1
	                }
	              }
	
	              // cursor id is zero, we can issue success command
	              var command = {
	                duration: timestampGenerator.duration(startTime, timestampGenerator.current()),
	                commandName: commandName,
	                requestId: requestId,
	                operationId: cursor.operationId,
	                connectionId: cursor.server.getConnection(),
	                reply: r && r.result ? r.result : r
	              };
	
	              // Emit the command
	              self.emit('succeeded', command)
	            }
	
	            // Return
	            if(!callback) return;
	
	            // Return to caller
	            callback(err, r);
	          });
	
	          // Apply the call
	          func.apply(this, args);
	        } else {
	          // Assume promise, push back the missing value
	          args.push(callback);
	          // Get the promise
	          var promise = func.apply(this, args);
	          // Return a new promise
	          return new cursor.s.promiseLibrary(function(resolve, reject) {
	            var startTime = timestampGenerator.current();
	            // Emit the started event
	            self.emit('started', command)
	            // Execute the function
	            promise.then(function(r) {
	              // cursor id is zero, we can issue success command
	              var command = {
	                duration: timestampGenerator.duration(startTime, timestampGenerator.current()),
	                commandName: commandName,
	                requestId: requestId,
	                operationId: cursor.operationId,
	                connectionId: cursor.server.getConnection(),
	                reply: cursor.cursorState.documents
	              };
	
	              // Emit the command
	              self.emit('succeeded', command)
	            }).catch(function(err) {
	              // Command
	              var command = {
	                duration: timestampGenerator.duration(startTime, timestampGenerator.current()),
	                commandName: commandName,
	                requestId: requestId,
	                operationId: ourOpId,
	                connectionId: cursor.server.getConnection(),
	                failure: err };
	
	              // Emit the command
	              self.emit('failed', command)
	              // reject the promise
	              reject(err);
	            });
	          });
	        }
	      }
	    });
	  });
	}
	
	inherits(Instrumentation, EventEmitter);
	
	Instrumentation.prototype.uninstrument = function() {
	  for(var i = 0; i < this.overloads.length; i++) {
	    var obj = this.overloads[i];
	    obj.proto[obj.name] = obj.func;
	  }
	
	  // Remove all listeners
	  this.removeAllListeners('started');
	  this.removeAllListeners('succeeded');
	  this.removeAllListeners('failed');
	}
	
	module.exports = Instrumentation;


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var inherits = __webpack_require__(77).inherits
	  , f = __webpack_require__(77).format
	  , toError = __webpack_require__(194).toError
	  , getSingleProperty = __webpack_require__(194).getSingleProperty
	  , formattedOrderClause = __webpack_require__(194).formattedOrderClause
	  , handleCallback = __webpack_require__(194).handleCallback
	  , Logger = __webpack_require__(156).Logger
	  , EventEmitter = __webpack_require__(3).EventEmitter
	  , ReadPreference = __webpack_require__(195)
	  , MongoError = __webpack_require__(156).MongoError
	  , Readable = __webpack_require__(54).Readable || __webpack_require__(55).Readable
	  , Define = __webpack_require__(196)
	  , CoreCursor = __webpack_require__(197)
	  , Query = __webpack_require__(156).Query
	  , CoreReadPreference = __webpack_require__(156).ReadPreference;
	
	/**
	 * @fileOverview The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB
	 * allowing for iteration over the results returned from the underlying query. It supports
	 * one by one document iteration, conversion to an array or can be iterated as a Node 0.10.X
	 * or higher stream
	 *
	 * **AGGREGATIONCURSOR Cannot directly be instantiated**
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Create a collection we want to drop later
	 *   var col = db.collection('createIndexExample1');
	 *   // Insert a bunch of documents
	 *   col.insert([{a:1, b:1}
	 *     , {a:2, b:2}, {a:3, b:3}
	 *     , {a:4, b:4}], {w:1}, function(err, result) {
	 *     test.equal(null, err);
	 *     // Show that duplicate records got dropped
	 *     col.aggregation({}, {cursor: {}}).toArray(function(err, items) {
	 *       test.equal(null, err);
	 *       test.equal(4, items.length);
	 *       db.close();
	 *     });
	 *   });
	 * });
	 */
	
	/**
	 * Namespace provided by the browser.
	 * @external Readable
	 */
	
	/**
	 * Creates a new Aggregation Cursor instance (INTERNAL TYPE, do not instantiate directly)
	 * @class AggregationCursor
	 * @extends external:Readable
	 * @fires AggregationCursor#data
	 * @fires AggregationCursor#end
	 * @fires AggregationCursor#close
	 * @fires AggregationCursor#readable
	 * @return {AggregationCursor} an AggregationCursor instance.
	 */
	var AggregationCursor = function(bson, ns, cmd, options, topology, topologyOptions) {
	  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
	  var self = this;
	  var state = AggregationCursor.INIT;
	  var streamOptions = {};
	
	  // MaxTimeMS
	  var maxTimeMS = null;
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(198).Promise;
	  }
	
	  // Set up
	  Readable.call(this, {objectMode: true});
	
	  // Internal state
	  this.s = {
	    // MaxTimeMS
	      maxTimeMS: maxTimeMS
	    // State
	    , state: state
	    // Stream options
	    , streamOptions: streamOptions
	    // BSON
	    , bson: bson
	    // Namespae
	    , ns: ns
	    // Command
	    , cmd: cmd
	    // Options
	    , options: options
	    // Topology
	    , topology: topology
	    // Topology Options
	    , topologyOptions: topologyOptions
	    // Promise library
	    , promiseLibrary: promiseLibrary
	  }
	}
	
	/**
	 * AggregationCursor stream data event, fired for each document in the cursor.
	 *
	 * @event AggregationCursor#data
	 * @type {object}
	 */
	
	/**
	 * AggregationCursor stream end event
	 *
	 * @event AggregationCursor#end
	 * @type {null}
	 */
	
	/**
	 * AggregationCursor stream close event
	 *
	 * @event AggregationCursor#close
	 * @type {null}
	 */
	
	/**
	 * AggregationCursor stream readable event
	 *
	 * @event AggregationCursor#readable
	 * @type {null}
	 */
	
	// Inherit from Readable
	inherits(AggregationCursor, Readable);
	
	// Set the methods to inherit from prototype
	var methodsToInherit = ['_next', 'next', 'each', 'forEach', 'toArray'
	  , 'rewind', 'bufferedCount', 'readBufferedDocuments', 'close', 'isClosed', 'kill'
	  , '_find', '_getmore', '_killcursor', 'isDead', 'explain', 'isNotified'];
	
	// Extend the Cursor
	for(var name in CoreCursor.prototype) {
	  AggregationCursor.prototype[name] = CoreCursor.prototype[name];
	}
	
	var define = AggregationCursor.define = new Define('AggregationCursor', AggregationCursor, true);
	
	/**
	 * Set the batch size for the cursor.
	 * @method
	 * @param {number} value The batchSize for the cursor.
	 * @throws {MongoError}
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.batchSize = function(value) {
	  if(this.s.state == AggregationCursor.CLOSED || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true });
	  if(typeof value != 'number') throw MongoError.create({message: "batchSize requires an integer", drvier:true });
	  if(this.s.cmd.cursor) this.s.cmd.cursor.batchSize = value;
	  this.setCursorBatchSize(value);
	  return this;
	}
	
	define.classMethod('batchSize', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a geoNear stage to the aggregation pipeline
	 * @method
	 * @param {object} document The geoNear stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.geoNear = function(document) {
	  this.s.cmd.pipeline.push({$geoNear: document});
	  return this;
	}
	
	define.classMethod('geoNear', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a group stage to the aggregation pipeline
	 * @method
	 * @param {object} document The group stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.group = function(document) {
	  this.s.cmd.pipeline.push({$group: document});
	  return this;
	}
	
	define.classMethod('group', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a limit stage to the aggregation pipeline
	 * @method
	 * @param {number} value The state limit value.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.limit = function(value) {
	  this.s.cmd.pipeline.push({$limit: value});
	  return this;
	}
	
	define.classMethod('limit', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a match stage to the aggregation pipeline
	 * @method
	 * @param {object} document The match stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.match = function(document) {
	  this.s.cmd.pipeline.push({$match: document});
	  return this;
	}
	
	define.classMethod('match', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a maxTimeMS stage to the aggregation pipeline
	 * @method
	 * @param {number} value The state maxTimeMS value.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.maxTimeMS = function(value) {
	  if(this.s.topology.lastIsMaster().minWireVersion > 2) {
	    this.s.cmd.maxTimeMS = value;
	  }
	  return this;
	}
	
	define.classMethod('maxTimeMS', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a out stage to the aggregation pipeline
	 * @method
	 * @param {number} destination The destination name.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.out = function(destination) {
	  this.s.cmd.pipeline.push({$out: destination});
	  return this;
	}
	
	define.classMethod('out', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a project stage to the aggregation pipeline
	 * @method
	 * @param {object} document The project stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.project = function(document) {
	  this.s.cmd.pipeline.push({$project: document});
	  return this;
	}
	
	define.classMethod('project', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a lookup stage to the aggregation pipeline
	 * @method
	 * @param {object} document The lookup stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.lookup = function(document) {
	  this.s.cmd.pipeline.push({$lookup: document});
	  return this;
	}
	
	define.classMethod('lookup', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a redact stage to the aggregation pipeline
	 * @method
	 * @param {object} document The redact stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.redact = function(document) {
	  this.s.cmd.pipeline.push({$redact: document});
	  return this;
	}
	
	define.classMethod('redact', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a skip stage to the aggregation pipeline
	 * @method
	 * @param {number} value The state skip value.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.skip = function(value) {
	  this.s.cmd.pipeline.push({$skip: value});
	  return this;
	}
	
	define.classMethod('skip', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a sort stage to the aggregation pipeline
	 * @method
	 * @param {object} document The sort stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.sort = function(document) {
	  this.s.cmd.pipeline.push({$sort: document});
	  return this;
	}
	
	define.classMethod('sort', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a unwind stage to the aggregation pipeline
	 * @method
	 * @param {number} field The unwind field name.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.unwind = function(field) {
	  this.s.cmd.pipeline.push({$unwind: field});
	  return this;
	}
	
	define.classMethod('unwind', {callback: false, promise:false, returns: [AggregationCursor]});
	
	AggregationCursor.prototype.get = AggregationCursor.prototype.toArray;
	
	// Inherited methods
	define.classMethod('toArray', {callback: true, promise:true});
	define.classMethod('each', {callback: true, promise:false});
	define.classMethod('forEach', {callback: true, promise:false});
	define.classMethod('next', {callback: true, promise:true});
	define.classMethod('close', {callback: true, promise:true});
	define.classMethod('isClosed', {callback: false, promise:false, returns: [Boolean]});
	define.classMethod('rewind', {callback: false, promise:false});
	define.classMethod('bufferedCount', {callback: false, promise:false, returns: [Number]});
	define.classMethod('readBufferedDocuments', {callback: false, promise:false, returns: [Array]});
	
	/**
	 * Get the next available document from the cursor, returns null if no more documents are available.
	 * @function AggregationCursor.prototype.next
	 * @param {AggregationCursor~resultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * The callback format for results
	 * @callback AggregationCursor~toArrayResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object[]} documents All the documents the satisfy the cursor.
	 */
	
	/**
	 * Returns an array of documents. The caller is responsible for making sure that there
	 * is enough memory to store the results. Note that the array only contain partial
	 * results when this cursor had been previouly accessed. In that case,
	 * cursor.rewind() can be used to reset the cursor.
	 * @method AggregationCursor.prototype.toArray
	 * @param {AggregationCursor~toArrayResultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * The callback format for results
	 * @callback AggregationCursor~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {(object|null)} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Iterates over all the documents for this cursor. As with **{cursor.toArray}**,
	 * not all of the elements will be iterated if this cursor had been previouly accessed.
	 * In that case, **{cursor.rewind}** can be used to reset the cursor. However, unlike
	 * **{cursor.toArray}**, the cursor will only hold a maximum of batch size elements
	 * at any given time if batch size is specified. Otherwise, the caller is responsible
	 * for making sure that the entire result can fit the memory.
	 * @method AggregationCursor.prototype.each
	 * @param {AggregationCursor~resultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	/**
	 * Close the cursor, sending a AggregationCursor command and emitting close.
	 * @method AggregationCursor.prototype.close
	 * @param {AggregationCursor~resultCallback} [callback] The result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * Is the cursor closed
	 * @method AggregationCursor.prototype.isClosed
	 * @return {boolean}
	 */
	
	/**
	 * Execute the explain for the cursor
	 * @method AggregationCursor.prototype.explain
	 * @param {AggregationCursor~resultCallback} [callback] The result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * Clone the cursor
	 * @function AggregationCursor.prototype.clone
	 * @return {AggregationCursor}
	 */
	
	/**
	 * Resets the cursor
	 * @function AggregationCursor.prototype.rewind
	 * @return {AggregationCursor}
	 */
	
	/**
	 * The callback format for the forEach iterator method
	 * @callback AggregationCursor~iteratorCallback
	 * @param {Object} doc An emitted document for the iterator
	 */
	
	/**
	 * The callback error format for the forEach iterator method
	 * @callback AggregationCursor~endCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 */
	
	/*
	 * Iterates over all the documents for this cursor using the iterator, callback pattern.
	 * @method AggregationCursor.prototype.forEach
	 * @param {AggregationCursor~iteratorCallback} iterator The iteration callback.
	 * @param {AggregationCursor~endCallback} callback The end callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	AggregationCursor.INIT = 0;
	AggregationCursor.OPEN = 1;
	AggregationCursor.CLOSED = 2;
	
	module.exports = AggregationCursor;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var MongoError = __webpack_require__(156).MongoError,
	  f = __webpack_require__(77).format;
	
	var shallowClone = function(obj) {
	  var copy = {};
	  for(var name in obj) copy[name] = obj[name];
	  return copy;
	}
	
	// Set simple property
	var getSingleProperty = function(obj, name, value) {
	  Object.defineProperty(obj, name, {
	    enumerable:true,
	    get: function() {
	      return value
	    }
	  });
	}
	
	var formatSortValue = exports.formatSortValue = function(sortDirection) {
	  var value = ("" + sortDirection).toLowerCase();
	
	  switch (value) {
	    case 'ascending':
	    case 'asc':
	    case '1':
	      return 1;
	    case 'descending':
	    case 'desc':
	    case '-1':
	      return -1;
	    default:
	      throw new Error("Illegal sort clause, must be of the form "
	                    + "[['field1', '(ascending|descending)'], "
	                    + "['field2', '(ascending|descending)']]");
	  }
	};
	
	var formattedOrderClause = exports.formattedOrderClause = function(sortValue) {
	  var orderBy = {};
	  if(sortValue == null) return null;
	  if (Array.isArray(sortValue)) {
	    if(sortValue.length === 0) {
	      return null;
	    }
	
	    for(var i = 0; i < sortValue.length; i++) {
	      if(sortValue[i].constructor == String) {
	        orderBy[sortValue[i]] = 1;
	      } else {
	        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);
	      }
	    }
	  } else if(sortValue != null && typeof sortValue == 'object') {
	    orderBy = sortValue;
	  } else if (typeof sortValue == 'string') {
	    orderBy[sortValue] = 1;
	  } else {
	    throw new Error("Illegal sort clause, must be of the form " +
	      "[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
	  }
	
	  return orderBy;
	};
	
	var checkCollectionName = function checkCollectionName (collectionName) {
	  if('string' !== typeof collectionName) {
	    throw Error("collection name must be a String");
	  }
	
	  if(!collectionName || collectionName.indexOf('..') != -1) {
	    throw Error("collection names cannot be empty");
	  }
	
	  if(collectionName.indexOf('$') != -1 &&
	      collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
	    throw Error("collection names must not contain '$'");
	  }
	
	  if(collectionName.match(/^\.|\.$/) != null) {
	    throw Error("collection names must not start or end with '.'");
	  }
	
	  // Validate that we are not passing 0x00 in the colletion name
	  if(!!~collectionName.indexOf("\x00")) {
	    throw new Error("collection names cannot contain a null character");
	  }
	};
	
	var handleCallback = function(callback, err, value1, value2) {
	  try {
	    if(callback == null) return;
	    if(value2) return callback(err, value1, value2);
	    return callback(err, value1);
	  } catch(err) {
	    process.nextTick(function() { throw err; });
	    return false;
	  }
	
	  return true;
	}
	
	/**
	 * Wrap a Mongo error document in an Error instance
	 * @ignore
	 * @api private
	 */
	var toError = function(error) {
	  if (error instanceof Error) return error;
	
	  var msg = error.err || error.errmsg || error.errMessage || error;
	  var e = MongoError.create({message: msg, driver:true});
	
	  // Get all object keys
	  var keys = typeof error == 'object'
	    ? Object.keys(error)
	    : [];
	
	  for(var i = 0; i < keys.length; i++) {
	    try {
	      e[keys[i]] = error[keys[i]];
	    } catch(err) {
	      // continue
	    }
	  }
	
	  return e;
	}
	
	/**
	 * @ignore
	 */
	var normalizeHintField = function normalizeHintField(hint) {
	  var finalHint = null;
	
	  if(typeof hint == 'string') {
	    finalHint = hint;
	  } else if(Array.isArray(hint)) {
	    finalHint = {};
	
	    hint.forEach(function(param) {
	      finalHint[param] = 1;
	    });
	  } else if(hint != null && typeof hint == 'object') {
	    finalHint = {};
	    for (var name in hint) {
	      finalHint[name] = hint[name];
	    }
	  }
	
	  return finalHint;
	};
	
	/**
	 * Create index name based on field spec
	 *
	 * @ignore
	 * @api private
	 */
	var parseIndexOptions = function(fieldOrSpec) {
	  var fieldHash = {};
	  var indexes = [];
	  var keys;
	
	  // Get all the fields accordingly
	  if('string' == typeof fieldOrSpec) {
	    // 'type'
	    indexes.push(fieldOrSpec + '_' + 1);
	    fieldHash[fieldOrSpec] = 1;
	  } else if(Array.isArray(fieldOrSpec)) {
	    fieldOrSpec.forEach(function(f) {
	      if('string' == typeof f) {
	        // [{location:'2d'}, 'type']
	        indexes.push(f + '_' + 1);
	        fieldHash[f] = 1;
	      } else if(Array.isArray(f)) {
	        // [['location', '2d'],['type', 1]]
	        indexes.push(f[0] + '_' + (f[1] || 1));
	        fieldHash[f[0]] = f[1] || 1;
	      } else if(isObject(f)) {
	        // [{location:'2d'}, {type:1}]
	        keys = Object.keys(f);
	        keys.forEach(function(k) {
	          indexes.push(k + '_' + f[k]);
	          fieldHash[k] = f[k];
	        });
	      } else {
	        // undefined (ignore)
	      }
	    });
	  } else if(isObject(fieldOrSpec)) {
	    // {location:'2d', type:1}
	    keys = Object.keys(fieldOrSpec);
	    keys.forEach(function(key) {
	      indexes.push(key + '_' + fieldOrSpec[key]);
	      fieldHash[key] = fieldOrSpec[key];
	    });
	  }
	
	  return {
	    name: indexes.join("_"), keys: keys, fieldHash: fieldHash
	  }
	}
	
	var isObject = exports.isObject = function (arg) {
	  return '[object Object]' == toString.call(arg)
	}
	
	var debugOptions = function(debugFields, options) {
	  var finaloptions = {};
	  debugFields.forEach(function(n) {
	    finaloptions[n] = options[n];
	  });
	
	  return finaloptions;
	}
	
	var decorateCommand = function(command, options, exclude) {
	  for(var name in options) {
	    if(exclude[name] == null) command[name] = options[name];
	  }
	
	  return command;
	}
	
	exports.shallowClone = shallowClone;
	exports.getSingleProperty = getSingleProperty;
	exports.checkCollectionName = checkCollectionName;
	exports.toError = toError;
	exports.formattedOrderClause = formattedOrderClause;
	exports.parseIndexOptions = parseIndexOptions;
	exports.normalizeHintField = normalizeHintField;
	exports.handleCallback = handleCallback;
	exports.decorateCommand = decorateCommand;
	exports.isObject = isObject;
	exports.debugOptions = debugOptions;
	exports.MAX_JS_INT = 0x20000000000000;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 195 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileOverview The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is
	 * used to construct connections.
	 * 
	 * @example
	 * var Db = require('mongodb').Db,
	 *   ReplSet = require('mongodb').ReplSet,
	 *   Server = require('mongodb').Server,
	 *   ReadPreference = require('mongodb').ReadPreference,
	 *   test = require('assert');
	 * // Connect using ReplSet
	 * var server = new Server('localhost', 27017);
	 * var db = new Db('test', new ReplSet([server]));
	 * db.open(function(err, db) {
	 *   test.equal(null, err);
	 *   // Perform a read
	 *   var cursor = db.collection('t').find({});
	 *   cursor.setReadPreference(ReadPreference.PRIMARY);
	 *   cursor.toArray(function(err, docs) {
	 *     test.equal(null, err);
	 *     db.close();
	 *   });
	 * });
	 */
	
	/**
	 * Creates a new ReadPreference instance
	 * 
	 * Read Preferences
	 *  - **ReadPreference.PRIMARY**, Read from primary only. All operations produce an error (throw an exception where applicable) if primary is unavailable. Cannot be combined with tags (This is the default.).
	 *  - **ReadPreference.PRIMARY_PREFERRED**, Read from primary if available, otherwise a secondary.
	 *  - **ReadPreference.SECONDARY**, Read from secondary if available, otherwise error.
	 *  - **ReadPreference.SECONDARY_PREFERRED**, Read from a secondary if available, otherwise read from the primary.
	 *  - **ReadPreference.NEAREST**, All modes read from among the nearest candidates, but unlike other modes, NEAREST will include both the primary and all secondaries in the random selection.
	 *
	 * @class
	 * @param {string} mode The ReadPreference mode as listed above.
	 * @param {object} tags An object representing read preference tags.
	 * @property {string} mode The ReadPreference mode.
	 * @property {object} tags The ReadPreference tags.
	 * @return {ReadPreference} a ReadPreference instance.
	 */ 
	var ReadPreference = function(mode, tags) {
	  if(!(this instanceof ReadPreference))
	    return new ReadPreference(mode, tags);
	  this._type = 'ReadPreference';
	  this.mode = mode;
	  this.tags = tags;
	}
	
	/**
	 * Validate if a mode is legal
	 *
	 * @method
	 * @param {string} mode The string representing the read preference mode.
	 * @return {boolean}
	 */  
	ReadPreference.isValid = function(_mode) {
	  return (_mode == ReadPreference.PRIMARY || _mode == ReadPreference.PRIMARY_PREFERRED
	    || _mode == ReadPreference.SECONDARY || _mode == ReadPreference.SECONDARY_PREFERRED
	    || _mode == ReadPreference.NEAREST
	    || _mode == true || _mode == false || _mode == null);
	}
	
	/**
	 * Validate if a mode is legal
	 *
	 * @method
	 * @param {string} mode The string representing the read preference mode.
	 * @return {boolean}
	 */  
	ReadPreference.prototype.isValid = function(mode) {
	  var _mode = typeof mode == 'string' ? mode : this.mode;
	  return ReadPreference.isValid(_mode);
	}
	
	/**
	 * @ignore
	 */
	ReadPreference.prototype.toObject = function() {
	  var object = {mode:this.mode};
	
	  if(this.tags != null) {
	    object['tags'] = this.tags;
	  }
	
	  return object;
	}
	
	/**
	 * @ignore
	 */
	ReadPreference.PRIMARY = 'primary';
	ReadPreference.PRIMARY_PREFERRED = 'primaryPreferred';
	ReadPreference.SECONDARY = 'secondary';
	ReadPreference.SECONDARY_PREFERRED = 'secondaryPreferred';
	ReadPreference.NEAREST = 'nearest'
	
	/**
	 * @ignore
	 */
	module.exports = ReadPreference;

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var f = __webpack_require__(77).format;
	
	var Define = function(name, object, stream) {
	  this.name = name;
	  this.object = object;
	  this.stream = typeof stream == 'boolean' ? stream : false;
	  this.instrumentations = {};
	}
	
	Define.prototype.classMethod = function(name, options) {
	  var keys = Object.keys(options).sort();
	  var key = generateKey(keys, options);
	
	  // Add a list of instrumentations
	  if(this.instrumentations[key] == null) {
	    this.instrumentations[key] = {
	      methods: [], options: options
	    }
	  }
	
	  // Push to list of method for this instrumentation
	  this.instrumentations[key].methods.push(name);
	}
	
	var generateKey = function(keys, options) {
	  var parts = [];
	  for(var i = 0; i < keys.length; i++) {
	    parts.push(f('%s=%s', keys[i], options[keys[i]]));
	  }
	
	  return parts.join();
	}
	
	Define.prototype.staticMethod = function(name, options) {
	  options.static = true;
	  var keys = Object.keys(options).sort();
	  var key = generateKey(keys, options);
	
	  // Add a list of instrumentations
	  if(this.instrumentations[key] == null) {
	    this.instrumentations[key] = {
	      methods: [], options: options
	    }
	  }
	
	  // Push to list of method for this instrumentation
	  this.instrumentations[key].methods.push(name);
	}
	
	Define.prototype.generate = function(keys, options) {
	  // Generate the return object
	  var object = {
	    name: this.name, obj: this.object, stream: this.stream,
	    instrumentations: []
	  }
	
	  for(var name in this.instrumentations) {
	    object.instrumentations.push(this.instrumentations[name]);
	  }
	
	  return object;
	}
	
	module.exports = Define;

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var inherits = __webpack_require__(77).inherits
	  , f = __webpack_require__(77).format
	  , formattedOrderClause = __webpack_require__(194).formattedOrderClause
	  , handleCallback = __webpack_require__(194).handleCallback
	  , ReadPreference = __webpack_require__(195)
	  , MongoError = __webpack_require__(156).MongoError
	  , Readable = __webpack_require__(54).Readable || __webpack_require__(55).Readable
	  , Define = __webpack_require__(196)
	  , CoreCursor = __webpack_require__(156).Cursor
	  , Map = __webpack_require__(156).BSON.Map
	  , Query = __webpack_require__(156).Query
	  , CoreReadPreference = __webpack_require__(156).ReadPreference;
	
	/**
	 * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB
	 * allowing for iteration over the results returned from the underlying query. It supports
	 * one by one document iteration, conversion to an array or can be iterated as a Node 0.10.X
	 * or higher stream
	 *
	 * **CURSORS Cannot directly be instantiated**
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Create a collection we want to drop later
	 *   var col = db.collection('createIndexExample1');
	 *   // Insert a bunch of documents
	 *   col.insert([{a:1, b:1}
	 *     , {a:2, b:2}, {a:3, b:3}
	 *     , {a:4, b:4}], {w:1}, function(err, result) {
	 *     test.equal(null, err);
	 *
	 *     // Show that duplicate records got dropped
	 *     col.find({}).toArray(function(err, items) {
	 *       test.equal(null, err);
	 *       test.equal(4, items.length);
	 *       db.close();
	 *     });
	 *   });
	 * });
	 */
	
	/**
	 * Namespace provided by the mongodb-core and node.js
	 * @external CoreCursor
	 * @external Readable
	 */
	
	// Flags allowed for cursor
	var flags = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];
	var fields = ['numberOfRetries', 'tailableRetryInterval'];
	var push = Array.prototype.push;
	
	/**
	 * Creates a new Cursor instance (INTERNAL TYPE, do not instantiate directly)
	 * @class Cursor
	 * @extends external:CoreCursor
	 * @extends external:Readable
	 * @property {string} sortValue Cursor query sort setting.
	 * @property {boolean} timeout Is Cursor able to time out.
	 * @property {ReadPreference} readPreference Get cursor ReadPreference.
	 * @fires Cursor#data
	 * @fires Cursor#end
	 * @fires Cursor#close
	 * @fires Cursor#readable
	 * @return {Cursor} a Cursor instance.
	 * @example
	 * Cursor cursor options.
	 *
	 * collection.find({}).project({a:1})                             // Create a projection of field a
	 * collection.find({}).skip(1).limit(10)                          // Skip 1 and limit 10
	 * collection.find({}).batchSize(5)                               // Set batchSize on cursor to 5
	 * collection.find({}).filter({a:1})                              // Set query on the cursor
	 * collection.find({}).comment('add a comment')                   // Add a comment to the query, allowing to correlate queries
	 * collection.find({}).addCursorFlag('tailable', true)            // Set cursor as tailable
	 * collection.find({}).addCursorFlag('oplogReplay', true)         // Set cursor as oplogReplay
	 * collection.find({}).addCursorFlag('noCursorTimeout', true)     // Set cursor as noCursorTimeout
	 * collection.find({}).addCursorFlag('awaitData', true)           // Set cursor as awaitData
	 * collection.find({}).addCursorFlag('partial', true)             // Set cursor as partial
	 * collection.find({}).addQueryModifier('$orderby', {a:1})        // Set $orderby {a:1}
	 * collection.find({}).max(10)                                    // Set the cursor maxScan
	 * collection.find({}).maxScan(10)                                // Set the cursor maxScan
	 * collection.find({}).maxTimeMS(1000)                            // Set the cursor maxTimeMS
	 * collection.find({}).min(100)                                   // Set the cursor min
	 * collection.find({}).returnKey(10)                              // Set the cursor returnKey
	 * collection.find({}).setReadPreference(ReadPreference.PRIMARY)  // Set the cursor readPreference
	 * collection.find({}).showRecordId(true)                         // Set the cursor showRecordId
	 * collection.find({}).snapshot(true)                             // Set the cursor snapshot
	 * collection.find({}).sort([['a', 1]])                           // Sets the sort order of the cursor query
	 * collection.find({}).hint('a_1')                                // Set the cursor hint
	 *
	 * All options are chainable, so one can do the following.
	 *
	 * collection.find({}).maxTimeMS(1000).maxScan(100).skip(1).toArray(..)
	 */
	var Cursor = function(bson, ns, cmd, options, topology, topologyOptions) {
	  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
	  var self = this;
	  var state = Cursor.INIT;
	  var streamOptions = {};
	
	  // Tailable cursor options
	  var numberOfRetries = options.numberOfRetries || 5;
	  var tailableRetryInterval = options.tailableRetryInterval || 500;
	  var currentNumberOfRetries = numberOfRetries;
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(198).Promise;
	  }
	
	  // Set up
	  Readable.call(this, {objectMode: true});
	
	  // Internal cursor state
	  this.s = {
	    // Tailable cursor options
	      numberOfRetries: numberOfRetries
	    , tailableRetryInterval: tailableRetryInterval
	    , currentNumberOfRetries: currentNumberOfRetries
	    // State
	    , state: state
	    // Stream options
	    , streamOptions: streamOptions
	    // BSON
	    , bson: bson
	    // Namespace
	    , ns: ns
	    // Command
	    , cmd: cmd
	    // Options
	    , options: options
	    // Topology
	    , topology: topology
	    // Topology options
	    , topologyOptions: topologyOptions
	    // Promise library
	    , promiseLibrary: promiseLibrary
	    // Current doc
	    , currentDoc: null
	  }
	
	  // Translate correctly
	  if(self.s.options.noCursorTimeout == true) {
	    self.addCursorFlag('noCursorTimeout', true);
	  }
	
	  // Set the sort value
	  this.sortValue = self.s.cmd.sort;
	}
	
	/**
	 * Cursor stream data event, fired for each document in the cursor.
	 *
	 * @event Cursor#data
	 * @type {object}
	 */
	
	/**
	 * Cursor stream end event
	 *
	 * @event Cursor#end
	 * @type {null}
	 */
	
	/**
	 * Cursor stream close event
	 *
	 * @event Cursor#close
	 * @type {null}
	 */
	
	/**
	 * Cursor stream readable event
	 *
	 * @event Cursor#readable
	 * @type {null}
	 */
	
	// Inherit from Readable
	inherits(Cursor, Readable);
	
	// Map core cursor _next method so we can apply mapping
	CoreCursor.prototype._next = CoreCursor.prototype.next;
	
	for(var name in CoreCursor.prototype) {
	  Cursor.prototype[name] = CoreCursor.prototype[name];
	}
	
	var define = Cursor.define = new Define('Cursor', Cursor, true);
	
	/**
	 * Check if there is any document still available in the cursor
	 * @method
	 * @param {Cursor~resultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	Cursor.prototype.hasNext = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') {
	    if(self.s.currentDoc){
	      return callback(null, true);
	    } else {
	      return nextObject(self, function(err, doc) {
	        if(!doc) return callback(null, false);
	        self.s.currentDoc = doc;
	        callback(null, true);
	      });
	    }
	  }
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    if(self.s.currentDoc){
	      resolve(true);
	    } else {
	      nextObject(self, function(err, doc) {
	        if(self.s.state == Cursor.CLOSED || self.isDead()) return resolve(false);
	        if(err) return reject(err);
	        if(!doc) return resolve(false);
	        self.s.currentDoc = doc;
	        resolve(true);
	      });
	    }
	  });
	}
	
	define.classMethod('hasNext', {callback: true, promise:true});
	
	/**
	 * Get the next available document from the cursor, returns null if no more documents are available.
	 * @method
	 * @param {Cursor~resultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	Cursor.prototype.next = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') {
	    // Return the currentDoc if someone called hasNext first
	    if(self.s.currentDoc) {
	      var doc = self.s.currentDoc;
	      self.s.currentDoc = null;
	      return callback(null, doc);
	    }
	
	    // Return the next object
	    return nextObject(self, callback)
	  };
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    // Return the currentDoc if someone called hasNext first
	    if(self.s.currentDoc) {
	      var doc = self.s.currentDoc;
	      self.s.currentDoc = null;
	      return resolve(doc);
	    }
	
	    nextObject(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('next', {callback: true, promise:true});
	
	/**
	 * Set the cursor query
	 * @method
	 * @param {object} filter The filter object used for the cursor.
	 * @return {Cursor}
	 */
	Cursor.prototype.filter = function(filter) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.query = filter;
	  return this;
	}
	
	define.classMethod('filter', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the cursor maxScan
	 * @method
	 * @param {object} maxScan Constrains the query to only scan the specified number of documents when fulfilling the query
	 * @return {Cursor}
	 */
	Cursor.prototype.maxScan = function(maxScan) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.maxScan = maxScan;
	  return this;
	}
	
	define.classMethod('maxScan', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the cursor hint
	 * @method
	 * @param {object} hint If specified, then the query system will only consider plans using the hinted index.
	 * @return {Cursor}
	 */
	Cursor.prototype.hint = function(hint) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.hint = hint;
	  return this;
	}
	
	define.classMethod('hint', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the cursor min
	 * @method
	 * @param {object} min Specify a $min value to specify the inclusive lower bound for a specific index in order to constrain the results of find(). The $min specifies the lower bound for all keys of a specific index in order.
	 * @return {Cursor}
	 */
	Cursor.prototype.min = function(min) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.min = min;
	  return this;
	}
	
	define.classMethod('min', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the cursor max
	 * @method
	 * @param {object} max Specify a $max value to specify the exclusive upper bound for a specific index in order to constrain the results of find(). The $max specifies the upper bound for all keys of a specific index in order.
	 * @return {Cursor}
	 */
	Cursor.prototype.max = function(max) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.max = max;
	  return this;
	}
	
	define.classMethod('max', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the cursor returnKey
	 * @method
	 * @param {object} returnKey Only return the index field or fields for the results of the query. If $returnKey is set to true and the query does not use an index to perform the read operation, the returned documents will not contain any fields. Use one of the following forms:
	 * @return {Cursor}
	 */
	Cursor.prototype.returnKey = function(value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.returnKey = value;
	  return this;
	}
	
	define.classMethod('returnKey', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the cursor showRecordId
	 * @method
	 * @param {object} showRecordId The $showDiskLoc option has now been deprecated and replaced with the showRecordId field. $showDiskLoc will still be accepted for OP_QUERY stye find.
	 * @return {Cursor}
	 */
	Cursor.prototype.showRecordId = function(value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.showDiskLoc = value;
	  return this;
	}
	
	define.classMethod('showRecordId', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the cursor snapshot
	 * @method
	 * @param {object} snapshot The $snapshot operator prevents the cursor from returning a document more than once because an intervening write operation results in a move of the document.
	 * @return {Cursor}
	 */
	Cursor.prototype.snapshot = function(value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.snapshot = value;
	  return this;
	}
	
	define.classMethod('snapshot', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set a node.js specific cursor option
	 * @method
	 * @param {string} field The cursor option to set ['numberOfRetries', 'tailableRetryInterval'].
	 * @param {object} value The field value.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.setCursorOption = function(field, value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(fields.indexOf(field) == -1) throw MongoError.create({message: f("option %s not a supported option %s", field, fields), driver:true });
	  this.s[field] = value;
	  if(field == 'numberOfRetries')
	    this.s.currentNumberOfRetries = value;
	  return this;
	}
	
	define.classMethod('setCursorOption', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Add a cursor flag to the cursor
	 * @method
	 * @param {string} flag The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial'].
	 * @param {boolean} value The flag boolean value.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.addCursorFlag = function(flag, value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(flags.indexOf(flag) == -1) throw MongoError.create({message: f("flag %s not a supported flag %s", flag, flags), driver:true });
	  if(typeof value != 'boolean') throw MongoError.create({message: f("flag %s must be a boolean value", flag), driver:true});
	  this.s.cmd[flag] = value;
	  return this;
	}
	
	define.classMethod('addCursorFlag', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Add a query modifier to the cursor query
	 * @method
	 * @param {string} name The query modifier (must start with $, such as $orderby etc)
	 * @param {boolean} value The flag boolean value.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.addQueryModifier = function(name, value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(name[0] != '$') throw MongoError.create({message: f("%s is not a valid query modifier"), driver:true});
	  // Strip of the $
	  var field = name.substr(1);
	  // Set on the command
	  this.s.cmd[field] = value;
	  // Deal with the special case for sort
	  if(field == 'orderby') this.s.cmd.sort = this.s.cmd[field];
	  return this;
	}
	
	define.classMethod('addQueryModifier', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Add a comment to the cursor query allowing for tracking the comment in the log.
	 * @method
	 * @param {string} value The comment attached to this query.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.comment = function(value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.comment = value;
	  return this;
	}
	
	define.classMethod('comment', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set a maxAwaitTimeMS on a tailing cursor query to allow to customize the timeout value for the option awaitData (Only supported on MongoDB 3.2 or higher, ignored otherwise)
	 * @method
	 * @param {number} value Number of milliseconds to wait before aborting the tailed query.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.maxAwaitTimeMS = function(value) {
	  if(typeof value != 'number') throw MongoError.create({message: "maxAwaitTimeMS must be a number", driver:true});
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.maxAwaitTimeMS = value;
	  return this;
	}
	
	define.classMethod('maxAwaitTimeMS', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
	 * @method
	 * @param {number} value Number of milliseconds to wait before aborting the query.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.maxTimeMS = function(value) {
	  if(typeof value != 'number') throw MongoError.create({message: "maxTimeMS must be a number", driver:true});
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.maxTimeMS = value;
	  return this;
	}
	
	define.classMethod('maxTimeMS', {callback: false, promise:false, returns: [Cursor]});
	
	Cursor.prototype.maxTimeMs = Cursor.prototype.maxTimeMS;
	
	define.classMethod('maxTimeMs', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Sets a field projection for the query.
	 * @method
	 * @param {object} value The field projection object.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.project = function(value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.fields = value;
	  return this;
	}
	
	define.classMethod('project', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Sets the sort order of the cursor query.
	 * @method
	 * @param {(string|array|object)} keyOrList The key or keys set for the sort.
	 * @param {number} [direction] The direction of the sorting (1 or -1).
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.sort = function(keyOrList, direction) {
	  if(this.s.options.tailable) throw MongoError.create({message: "Tailable cursor doesn't support sorting", driver:true});
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  var order = keyOrList;
	
	  // We have an array of arrays, we need to preserve the order of the sort
	  // so we will us a Map
	  if(Array.isArray(order) && Array.isArray(order[0])) {
	    order = new Map(order.map(function(x) {
	      var value = [x[0], null];
	      if(x[1] == 'asc') {
	        value[1] = 1;
	      } else if(x[1] == 'desc') {
	        value[1] = -1;
	      } else if(x[1] == 1 || x[1] == -1) {
	        value[1] = x[1];
	      } else {
	        throw new MongoError("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
	      }
	
	      return value;
	    }));
	  }
	
	  if(direction != null) {
	    order = [[keyOrList, direction]];
	  }
	
	  this.s.cmd.sort = order;
	  this.sortValue = order;
	  return this;
	}
	
	define.classMethod('sort', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the batch size for the cursor.
	 * @method
	 * @param {number} value The batchSize for the cursor.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.batchSize = function(value) {
	  if(this.s.options.tailable) throw MongoError.create({message: "Tailable cursor doesn't support batchSize", driver:true});
	  if(this.s.state == Cursor.CLOSED || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(typeof value != 'number') throw MongoError.create({message: "batchSize requires an integer", driver:true});
	  this.s.cmd.batchSize = value;
	  this.setCursorBatchSize(value);
	  return this;
	}
	
	define.classMethod('batchSize', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the limit for the cursor.
	 * @method
	 * @param {number} value The limit for the cursor query.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.limit = function(value) {
	  if(this.s.options.tailable) throw MongoError.create({message: "Tailable cursor doesn't support limit", driver:true});
	  if(this.s.state == Cursor.OPEN || this.s.state == Cursor.CLOSED || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(typeof value != 'number') throw MongoError.create({message: "limit requires an integer", driver:true});
	  this.s.cmd.limit = value;
	  // this.cursorLimit = value;
	  this.setCursorLimit(value);
	  return this;
	}
	
	define.classMethod('limit', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the skip for the cursor.
	 * @method
	 * @param {number} value The skip for the cursor query.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.skip = function(value) {
	  if(this.s.options.tailable) throw MongoError.create({message: "Tailable cursor doesn't support skip", driver:true});
	  if(this.s.state == Cursor.OPEN || this.s.state == Cursor.CLOSED || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(typeof value != 'number') throw MongoError.create({message: "skip requires an integer", driver:true});
	  this.s.cmd.skip = value;
	  this.setCursorSkip(value);
	  return this;
	}
	
	define.classMethod('skip', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * The callback format for results
	 * @callback Cursor~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {(object|null|boolean)} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Clone the cursor
	 * @function external:CoreCursor#clone
	 * @return {Cursor}
	 */
	
	/**
	 * Resets the cursor
	 * @function external:CoreCursor#rewind
	 * @return {null}
	 */
	
	/**
	 * Get the next available document from the cursor, returns null if no more documents are available.
	 * @method
	 * @param {Cursor~resultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @deprecated
	 * @return {Promise} returns Promise if no callback passed
	 */
	Cursor.prototype.nextObject = Cursor.prototype.next;
	
	var nextObject = function(self, callback) {
	  if(self.s.state == Cursor.CLOSED || self.isDead && self.isDead()) return handleCallback(callback, MongoError.create({message: "Cursor is closed", driver:true}));
	  if(self.s.state == Cursor.INIT && self.s.cmd.sort) {
	    try {
	      self.s.cmd.sort = formattedOrderClause(self.s.cmd.sort);
	    } catch(err) {
	      return handleCallback(callback, err);
	    }
	  }
	
	  // Get the next object
	  self._next(function(err, doc) {
	    self.s.state = Cursor.OPEN;
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, null, doc);
	  });
	}
	
	define.classMethod('nextObject', {callback: true, promise:true});
	
	// Trampoline emptying the number of retrieved items
	// without incurring a nextTick operation
	var loop = function(self, callback) {
	  // No more items we are done
	  if(self.bufferedCount() == 0) return;
	  // Get the next document
	  self._next(callback);
	  // Loop
	  return loop;
	}
	
	Cursor.prototype.next = Cursor.prototype.nextObject;
	
	define.classMethod('next', {callback: true, promise:true});
	
	/**
	 * Iterates over all the documents for this cursor. As with **{cursor.toArray}**,
	 * not all of the elements will be iterated if this cursor had been previouly accessed.
	 * In that case, **{cursor.rewind}** can be used to reset the cursor. However, unlike
	 * **{cursor.toArray}**, the cursor will only hold a maximum of batch size elements
	 * at any given time if batch size is specified. Otherwise, the caller is responsible
	 * for making sure that the entire result can fit the memory.
	 * @method
	 * @deprecated
	 * @param {Cursor~resultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	Cursor.prototype.each = function(callback) {
	  // Rewind cursor state
	  this.rewind();
	  // Set current cursor to INIT
	  this.s.state = Cursor.INIT;
	  // Run the query
	  _each(this, callback);
	};
	
	define.classMethod('each', {callback: true, promise:false});
	
	// Run the each loop
	var _each = function(self, callback) {
	  if(!callback) throw MongoError.create({message: 'callback is mandatory', driver:true});
	  if(self.isNotified()) return;
	  if(self.s.state == Cursor.CLOSED || self.isDead()) {
	    return handleCallback(callback, MongoError.create({message: "Cursor is closed", driver:true}));
	  }
	
	  if(self.s.state == Cursor.INIT) self.s.state = Cursor.OPEN;
	
	  // Define function to avoid global scope escape
	  var fn = null;
	  // Trampoline all the entries
	  if(self.bufferedCount() > 0) {
	    while(fn = loop(self, callback)) fn(self, callback);
	    _each(self, callback);
	  } else {
	    self.next(function(err, item) {
	      if(err) return handleCallback(callback, err);
	      if(item == null) {
	        self.s.state = Cursor.CLOSED;
	        return handleCallback(callback, null, null);
	      }
	
	      if(handleCallback(callback, null, item) == false) return;
	      _each(self, callback);
	    })
	  }
	}
	
	/**
	 * The callback format for the forEach iterator method
	 * @callback Cursor~iteratorCallback
	 * @param {Object} doc An emitted document for the iterator
	 */
	
	/**
	 * The callback error format for the forEach iterator method
	 * @callback Cursor~endCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 */
	
	/**
	 * Iterates over all the documents for this cursor using the iterator, callback pattern.
	 * @method
	 * @param {Cursor~iteratorCallback} iterator The iteration callback.
	 * @param {Cursor~endCallback} callback The end callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	Cursor.prototype.forEach = function(iterator, callback) {
	  this.each(function(err, doc){
	    if(err) { callback(err); return false; }
	    if(doc != null) { iterator(doc); return true; }
	    if(doc == null && callback) {
	      var internalCallback = callback;
	      callback = null;
	      internalCallback(null);
	      return false;
	    }
	  });
	}
	
	define.classMethod('forEach', {callback: true, promise:false});
	
	/**
	 * Set the ReadPreference for the cursor.
	 * @method
	 * @param {(string|ReadPreference)} readPreference The new read preference for the cursor.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.setReadPreference = function(r) {
	  if(this.s.state != Cursor.INIT) throw MongoError.create({message: 'cannot change cursor readPreference after cursor has been accessed', driver:true});
	  if(r instanceof ReadPreference) {
	    this.s.options.readPreference = new CoreReadPreference(r.mode, r.tags);
	  } else if(typeof r == 'string'){
	    this.s.options.readPreference = new CoreReadPreference(r);
	  } else if(r instanceof CoreReadPreference) {
	    this.s.options.readPreference = r;
	  }
	
	  return this;
	}
	
	define.classMethod('setReadPreference', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * The callback format for results
	 * @callback Cursor~toArrayResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object[]} documents All the documents the satisfy the cursor.
	 */
	
	/**
	 * Returns an array of documents. The caller is responsible for making sure that there
	 * is enough memory to store the results. Note that the array only contain partial
	 * results when this cursor had been previouly accessed. In that case,
	 * cursor.rewind() can be used to reset the cursor.
	 * @method
	 * @param {Cursor~toArrayResultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	Cursor.prototype.toArray = function(callback) {
	  var self = this;
	  if(self.s.options.tailable) throw MongoError.create({message: 'Tailable cursor cannot be converted to array', driver:true});
	
	  // Execute using callback
	  if(typeof callback == 'function') return toArray(self, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    toArray(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var toArray = function(self, callback) {
	  var items = [];
	
	  // Reset cursor
	  self.rewind();
	  self.s.state = Cursor.INIT;
	
	  // Fetch all the documents
	  var fetchDocs = function() {
	    self._next(function(err, doc) {
	      if(err) return handleCallback(callback, err);
	      if(doc == null) {
	        self.s.state = Cursor.CLOSED;
	        return handleCallback(callback, null, items);
	      }
	
	      // Add doc to items
	      items.push(doc)
	
	      // Get all buffered objects
	      if(self.bufferedCount() > 0) {
	        var docs = self.readBufferedDocuments(self.bufferedCount())
	
	        // Transform the doc if transform method added
	        if(self.s.transforms && typeof self.s.transforms.doc == 'function') {
	          docs = docs.map(self.s.transforms.doc);
	        }
	
	        push.apply(items, docs);
	      }
	
	      // Attempt a fetch
	      fetchDocs();
	    })
	  }
	
	  fetchDocs();
	}
	
	define.classMethod('toArray', {callback: true, promise:true});
	
	/**
	 * The callback format for results
	 * @callback Cursor~countResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {number} count The count of documents.
	 */
	
	/**
	 * Get the count of documents for this cursor
	 * @method
	 * @param {boolean} applySkipLimit Should the count command apply limit and skip settings on the cursor or in the passed in options.
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.skip=null] The number of documents to skip.
	 * @param {number} [options.limit=null] The maximum amounts to count before aborting.
	 * @param {number} [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
	 * @param {string} [options.hint=null] An index name hint for the query.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Cursor~countResultCallback} [callback] The result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	Cursor.prototype.count = function(applySkipLimit, opts, callback) {
	  var self = this;
	  if(self.s.cmd.query == null) throw MongoError.create({message: "count can only be used with find command", driver:true});
	  if(typeof opts == 'function') callback = opts, opts = {};
	  opts = opts || {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return count(self, applySkipLimit, opts, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    count(self, applySkipLimit, opts, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var count = function(self, applySkipLimit, opts, callback) {
	  if(typeof applySkipLimit == 'function') {
	    callback = applySkipLimit;
	    applySkipLimit = true;
	  }
	
	  if(applySkipLimit) {
	    if(typeof self.cursorSkip() == 'number') opts.skip = self.cursorSkip();
	    if(typeof self.cursorLimit() == 'number') opts.limit = self.cursorLimit();
	  }
	
	  // Command
	  var delimiter = self.s.ns.indexOf('.');
	
	  var command = {
	    'count': self.s.ns.substr(delimiter+1), 'query': self.s.cmd.query
	  }
	
	  if(typeof opts.maxTimeMS == 'number') {
	    command.maxTimeMS = opts.maxTimeMS;
	  } else if(self.s.cmd && typeof self.s.cmd.maxTimeMS == 'number') {
	    command.maxTimeMS = self.s.cmd.maxTimeMS;
	  }
	
	  // Merge in any options
	  if(opts.skip) command.skip = opts.skip;
	  if(opts.limit) command.limit = opts.limit;
	  if(self.s.options.hint) command.hint = self.s.options.hint;
	
	  // Execute the command
	  self.topology.command(f("%s.$cmd", self.s.ns.substr(0, delimiter))
	    , command, function(err, result) {
	      callback(err, result ? result.result.n : null)
	    });
	}
	
	define.classMethod('count', {callback: true, promise:true});
	
	/**
	 * Close the cursor, sending a KillCursor command and emitting close.
	 * @method
	 * @param {Cursor~resultCallback} [callback] The result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	Cursor.prototype.close = function(callback) {
	  this.s.state = Cursor.CLOSED;
	  // Kill the cursor
	  this.kill();
	  // Emit the close event for the cursor
	  this.emit('close');
	  // Callback if provided
	  if(typeof callback == 'function') return handleCallback(callback, null, this);
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    resolve();
	  });
	}
	
	define.classMethod('close', {callback: true, promise:true});
	
	/**
	 * Map all documents using the provided function
	 * @method
	 * @param {function} [transform] The mapping transformation method.
	 * @return {null}
	 */
	Cursor.prototype.map = function(transform) {
	  this.cursorState.transforms = { doc: transform };
	  return this;
	}
	
	define.classMethod('map', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Is the cursor closed
	 * @method
	 * @return {boolean}
	 */
	Cursor.prototype.isClosed = function() {
	  return this.isDead();
	}
	
	define.classMethod('isClosed', {callback: false, promise:false, returns: [Boolean]});
	
	Cursor.prototype.destroy = function(err) {
	  if(err) this.emit('error', err);
	  this.pause();
	  this.close();
	}
	
	define.classMethod('destroy', {callback: false, promise:false});
	
	/**
	 * Return a modified Readable stream including a possible transform method.
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {function} [options.transform=null] A transformation method applied to each document emitted by the stream.
	 * @return {Cursor}
	 */
	Cursor.prototype.stream = function(options) {
	  this.s.streamOptions = options || {};
	  return this;
	}
	
	define.classMethod('stream', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Execute the explain for the cursor
	 * @method
	 * @param {Cursor~resultCallback} [callback] The result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	Cursor.prototype.explain = function(callback) {
	  var self = this;
	  this.s.cmd.explain = true;
	
	  // Do we have a readConcern
	  if(this.s.cmd.readConcern) {
	    delete this.s.cmd['readConcern'];
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return this._next(callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self._next(function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('explain', {callback: true, promise:true});
	
	Cursor.prototype._read = function(n) {
	  var self = this;
	  if(self.s.state == Cursor.CLOSED || self.isDead()) {
	    return self.push(null);
	  }
	
	  // Get the next item
	  self.nextObject(function(err, result) {
	    if(err) {
	      if(self.listeners('error') && self.listeners('error').length > 0) {
	        self.emit('error', err);
	      }
	      if(!self.isDead()) self.close();
	
	      // Emit end event
	      self.emit('end');
	      return self.emit('finish');
	    }
	
	    // If we provided a transformation method
	    if(typeof self.s.streamOptions.transform == 'function' && result != null) {
	      return self.push(self.s.streamOptions.transform(result));
	    }
	
	    // If we provided a map function
	    if(self.cursorState.transforms && typeof self.cursorState.transforms.doc == 'function' && result != null) {
	      return self.push(self.cursorState.transforms.doc(result));
	    }
	
	    // Return the result
	    self.push(result);
	  });
	}
	
	Object.defineProperty(Cursor.prototype, 'readPreference', {
	  enumerable:true,
	  get: function() {
	    if (!this || !this.s) {
	      return null;
	    }
	
	    return this.s.options.readPreference;
	  }
	});
	
	Object.defineProperty(Cursor.prototype, 'namespace', {
	  enumerable: true,
	  get: function() {
	    if (!this || !this.s) {
	      return null;
	    }
	
	    // TODO: refactor this logic into core
	    var ns = this.s.ns || '';
	    var firstDot = ns.indexOf('.');
	    if (firstDot < 0) {
	      return {
	        database: this.s.ns,
	        collection: ''
	      };
	    }
	    return {
	      database: ns.substr(0, firstDot),
	      collection: ns.substr(firstDot + 1)
	    };
	  }
	});
	
	/**
	 * The read() method pulls some data out of the internal buffer and returns it. If there is no data available, then it will return null.
	 * @function external:Readable#read
	 * @param {number} size Optional argument to specify how much data to read.
	 * @return {(String | Buffer | null)}
	 */
	
	/**
	 * Call this function to cause the stream to return strings of the specified encoding instead of Buffer objects.
	 * @function external:Readable#setEncoding
	 * @param {string} encoding The encoding to use.
	 * @return {null}
	 */
	
	/**
	 * This method will cause the readable stream to resume emitting data events.
	 * @function external:Readable#resume
	 * @return {null}
	 */
	
	/**
	 * This method will cause a stream in flowing-mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.
	 * @function external:Readable#pause
	 * @return {null}
	 */
	
	/**
	 * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.
	 * @function external:Readable#pipe
	 * @param {Writable} destination The destination for writing data
	 * @param {object} [options] Pipe options
	 * @return {null}
	 */
	
	/**
	 * This method will remove the hooks set up for a previous pipe() call.
	 * @function external:Readable#unpipe
	 * @param {Writable} [destination] The destination for writing data
	 * @return {null}
	 */
	
	/**
	 * This is useful in certain cases where a stream is being consumed by a parser, which needs to "un-consume" some data that it has optimistically pulled out of the source, so that the stream can be passed on to some other party.
	 * @function external:Readable#unshift
	 * @param {(Buffer|string)} chunk Chunk of data to unshift onto the read queue.
	 * @return {null}
	 */
	
	/**
	 * Versions of Node prior to v0.10 had streams that did not implement the entire Streams API as it is today. (See "Compatibility" below for more information.)
	 * @function external:Readable#wrap
	 * @param {Stream} stream An "old style" readable stream.
	 * @return {null}
	 */
	
	Cursor.INIT = 0;
	Cursor.OPEN = 1;
	Cursor.CLOSED = 2;
	Cursor.GET_MORE = 3;
	
	module.exports = Cursor;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   3.0.2
	 */
	
	(function() {
	    "use strict";
	    function lib$es6$promise$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }
	
	    function lib$es6$promise$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }
	
	    function lib$es6$promise$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }
	
	    var lib$es6$promise$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$es6$promise$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$es6$promise$utils$$_isArray = Array.isArray;
	    }
	
	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	    var lib$es6$promise$asap$$len = 0;
	    var lib$es6$promise$asap$$toString = {}.toString;
	    var lib$es6$promise$asap$$vertxNext;
	    var lib$es6$promise$asap$$customSchedulerFn;
	
	    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	      lib$es6$promise$asap$$len += 2;
	      if (lib$es6$promise$asap$$len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        if (lib$es6$promise$asap$$customSchedulerFn) {
	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
	        } else {
	          lib$es6$promise$asap$$scheduleFlush();
	        }
	      }
	    }
	
	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
	    }
	
	    function lib$es6$promise$asap$$setAsap(asapFn) {
	      lib$es6$promise$asap$$asap = asapFn;
	    }
	
	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	    // test for web worker but not in IE10
	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';
	
	    // node
	    function lib$es6$promise$asap$$useNextTick() {
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // see https://github.com/cujojs/when/issues/410 for details
	      return function() {
	        process.nextTick(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    // vertx
	    function lib$es6$promise$asap$$useVertxTimer() {
	      return function() {
	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    function lib$es6$promise$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });
	
	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }
	
	    // web worker
	    function lib$es6$promise$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$es6$promise$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }
	
	    function lib$es6$promise$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$es6$promise$asap$$flush, 1);
	      };
	    }
	
	    var lib$es6$promise$asap$$queue = new Array(1000);
	    function lib$es6$promise$asap$$flush() {
	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
	        var callback = lib$es6$promise$asap$$queue[i];
	        var arg = lib$es6$promise$asap$$queue[i+1];
	
	        callback(arg);
	
	        lib$es6$promise$asap$$queue[i] = undefined;
	        lib$es6$promise$asap$$queue[i+1] = undefined;
	      }
	
	      lib$es6$promise$asap$$len = 0;
	    }
	
	    function lib$es6$promise$asap$$attemptVertx() {
	      try {
	        var r = require;
	        var vertx = __webpack_require__(199);
	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$es6$promise$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$es6$promise$asap$$useSetTimeout();
	      }
	    }
	
	    var lib$es6$promise$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$es6$promise$asap$$isNode) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	    } else if (lib$es6$promise$asap$$isWorker) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	    } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
	    } else {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	    }
	
	    function lib$es6$promise$$internal$$noop() {}
	
	    var lib$es6$promise$$internal$$PENDING   = void 0;
	    var lib$es6$promise$$internal$$FULFILLED = 1;
	    var lib$es6$promise$$internal$$REJECTED  = 2;
	
	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$selfFulfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }
	
	    function lib$es6$promise$$internal$$cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }
	
	    function lib$es6$promise$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	        return lib$es6$promise$$internal$$GET_THEN_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	       lib$es6$promise$asap$$asap(function(promise) {
	        var sealed = false;
	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$es6$promise$$internal$$resolve(promise, value);
	          } else {
	            lib$es6$promise$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;
	
	          lib$es6$promise$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	        if (!sealed && error) {
	          sealed = true;
	          lib$es6$promise$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }
	
	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
	      if (maybeThenable.constructor === promise.constructor) {
	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        var then = lib$es6$promise$$internal$$getThen(maybeThenable);
	
	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$es6$promise$utils$$isFunction(then)) {
	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }
	
	    function lib$es6$promise$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }
	
	      lib$es6$promise$$internal$$publish(promise);
	    }
	
	    function lib$es6$promise$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	
	      promise._result = value;
	      promise._state = lib$es6$promise$$internal$$FULFILLED;
	
	      if (promise._subscribers.length !== 0) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
	      }
	    }
	
	    function lib$es6$promise$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	      promise._state = lib$es6$promise$$internal$$REJECTED;
	      promise._result = reason;
	
	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
	    }
	
	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;
	
	      parent._onerror = null;
	
	      subscribers[length] = child;
	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;
	
	      if (length === 0 && parent._state) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;
	
	      if (subscribers.length === 0) { return; }
	
	      var child, callback, detail = promise._result;
	
	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];
	
	        if (child) {
	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }
	
	      promise._subscribers.length = 0;
	    }
	
	    function lib$es6$promise$$internal$$ErrorObject() {
	      this.error = null;
	    }
	
	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	          value, error, succeeded, failed;
	
	      if (hasCallback) {
	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);
	
	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }
	
	        if (promise === value) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	          return;
	        }
	
	      } else {
	        value = detail;
	        succeeded = true;
	      }
	
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value){
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$es6$promise$$internal$$reject(promise, e);
	      }
	    }
	
	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	      var enumerator = this;
	
	      enumerator._instanceConstructor = Constructor;
	      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);
	
	      if (enumerator._validateInput(input)) {
	        enumerator._input     = input;
	        enumerator.length     = input.length;
	        enumerator._remaining = input.length;
	
	        enumerator._init();
	
	        if (enumerator.length === 0) {
	          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
	        } else {
	          enumerator.length = enumerator.length || 0;
	          enumerator._enumerate();
	          if (enumerator._remaining === 0) {
	            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
	          }
	        }
	      } else {
	        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
	      }
	    }
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
	      return lib$es6$promise$utils$$isArray(input);
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
	      return new Error('Array Methods must be provided an Array');
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
	      this._result = new Array(this.length);
	    };
	
	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
	      var enumerator = this;
	
	      var length  = enumerator.length;
	      var promise = enumerator.promise;
	      var input   = enumerator._input;
	
	      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        enumerator._eachEntry(input[i], i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      var enumerator = this;
	      var c = enumerator._instanceConstructor;
	
	      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
	        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
	          entry._onerror = null;
	          enumerator._settledAt(entry._state, i, entry._result);
	        } else {
	          enumerator._willSettleAt(c.resolve(entry), i);
	        }
	      } else {
	        enumerator._remaining--;
	        enumerator._result[i] = entry;
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var enumerator = this;
	      var promise = enumerator.promise;
	
	      if (promise._state === lib$es6$promise$$internal$$PENDING) {
	        enumerator._remaining--;
	
	        if (state === lib$es6$promise$$internal$$REJECTED) {
	          lib$es6$promise$$internal$$reject(promise, value);
	        } else {
	          enumerator._result[i] = value;
	        }
	      }
	
	      if (enumerator._remaining === 0) {
	        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;
	
	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$es6$promise$promise$all$$all(entries) {
	      return new lib$es6$promise$enumerator$$default(this, entries).promise;
	    }
	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	    function lib$es6$promise$promise$race$$race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	
	      if (!lib$es6$promise$utils$$isArray(entries)) {
	        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
	        return promise;
	      }
	
	      var length = entries.length;
	
	      function onFulfillment(value) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      }
	
	      function onRejection(reason) {
	        lib$es6$promise$$internal$$reject(promise, reason);
	      }
	
	      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
	      }
	
	      return promise;
	    }
	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	    function lib$es6$promise$promise$resolve$$resolve(object) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }
	
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	    function lib$es6$promise$promise$reject$$reject(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
	
	    var lib$es6$promise$promise$$counter = 0;
	
	    function lib$es6$promise$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }
	
	    function lib$es6$promise$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }
	
	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promise's eventual value or the reason
	      why the promise cannot be fulfilled.
	
	      Terminology
	      -----------
	
	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.
	
	      A promise can be in one of three states: pending, fulfilled, or rejected.
	
	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.
	
	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.
	
	
	      Basic Usage:
	      ------------
	
	      ```js
	      var promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);
	
	        // on failure
	        reject(reason);
	      });
	
	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Advanced Usage:
	      ---------------
	
	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.
	
	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          var xhr = new XMLHttpRequest();
	
	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();
	
	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }
	
	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Unlike callbacks, promises are great composable primitives.
	
	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON
	
	        return values;
	      });
	      ```
	
	      @class Promise
	      @param {function} resolver
	      Useful for tooling.
	      @constructor
	    */
	    function lib$es6$promise$promise$$Promise(resolver) {
	      this._id = lib$es6$promise$promise$$counter++;
	      this._state = undefined;
	      this._result = undefined;
	      this._subscribers = [];
	
	      if (lib$es6$promise$$internal$$noop !== resolver) {
	        if (!lib$es6$promise$utils$$isFunction(resolver)) {
	          lib$es6$promise$promise$$needsResolver();
	        }
	
	        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
	          lib$es6$promise$promise$$needsNew();
	        }
	
	        lib$es6$promise$$internal$$initializePromise(this, resolver);
	      }
	    }
	
	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
	    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
	
	    lib$es6$promise$promise$$Promise.prototype = {
	      constructor: lib$es6$promise$promise$$Promise,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	
	      Chaining
	      --------
	
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	
	      Assimilation
	      ------------
	
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	
	      If the assimliated promise rejects, then the downstream promise will also reject.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	
	      Simple Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var result;
	
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	
	      Advanced Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var author, books;
	
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	
	      function foundBooks(books) {
	
	      }
	
	      function failure(reason) {
	
	      }
	
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: function(onFulfillment, onRejection) {
	        var parent = this;
	        var state = parent._state;
	
	        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
	          return this;
	        }
	
	        var child = new this.constructor(lib$es6$promise$$internal$$noop);
	        var result = parent._result;
	
	        if (state) {
	          var callback = arguments[state - 1];
	          lib$es6$promise$asap$$asap(function(){
	            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
	          });
	        } else {
	          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	        }
	
	        return child;
	      },
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection) {
	        return this.then(null, onRejection);
	      }
	    };
	    function lib$es6$promise$polyfill$$polyfill() {
	      var local;
	
	      if (typeof global !== 'undefined') {
	          local = global;
	      } else if (typeof self !== 'undefined') {
	          local = self;
	      } else {
	          try {
	              local = Function('return this')();
	          } catch (e) {
	              throw new Error('polyfill failed because global object is unavailable in this environment');
	          }
	      }
	
	      var P = local.Promise;
	
	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	        return;
	      }
	
	      local.Promise = lib$es6$promise$promise$$default;
	    }
	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
	
	    var lib$es6$promise$umd$$ES6Promise = {
	      'Promise': lib$es6$promise$promise$$default,
	      'polyfill': lib$es6$promise$polyfill$$default
	    };
	
	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(200)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$es6$promise$umd$$ES6Promise;
	    } else if (typeof this !== 'undefined') {
	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	    }
	
	    lib$es6$promise$polyfill$$default();
	}).call(this);
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), (function() { return this; }()), __webpack_require__(34)(module)))

/***/ },
/* 199 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 200 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var inherits = __webpack_require__(77).inherits
	  , f = __webpack_require__(77).format
	  , toError = __webpack_require__(194).toError
	  , getSingleProperty = __webpack_require__(194).getSingleProperty
	  , formattedOrderClause = __webpack_require__(194).formattedOrderClause
	  , handleCallback = __webpack_require__(194).handleCallback
	  , Logger = __webpack_require__(156).Logger
	  , EventEmitter = __webpack_require__(3).EventEmitter
	  , ReadPreference = __webpack_require__(195)
	  , MongoError = __webpack_require__(156).MongoError
	  , Readable = __webpack_require__(54).Readable || __webpack_require__(55).Readable
	  , Define = __webpack_require__(196)
	  , CoreCursor = __webpack_require__(197)
	  , Query = __webpack_require__(156).Query
	  , CoreReadPreference = __webpack_require__(156).ReadPreference;
	
	/**
	 * @fileOverview The **CommandCursor** class is an internal class that embodies a
	 * generalized cursor based on a MongoDB command allowing for iteration over the
	 * results returned. It supports one by one document iteration, conversion to an
	 * array or can be iterated as a Node 0.10.X or higher stream
	 *
	 * **CommandCursor Cannot directly be instantiated**
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Create a collection we want to drop later
	 *   var col = db.collection('listCollectionsExample1');
	 *   // Insert a bunch of documents
	 *   col.insert([{a:1, b:1}
	 *     , {a:2, b:2}, {a:3, b:3}
	 *     , {a:4, b:4}], {w:1}, function(err, result) {
	 *     test.equal(null, err);
	 *
	 *     // List the database collections available
	 *     db.listCollections().toArray(function(err, items) {
	 *       test.equal(null, err);
	 *       db.close();
	 *     });
	 *   });
	 * });
	 */
	
	/**
	 * Namespace provided by the browser.
	 * @external Readable
	 */
	
	/**
	 * Creates a new Command Cursor instance (INTERNAL TYPE, do not instantiate directly)
	 * @class CommandCursor
	 * @extends external:Readable
	 * @fires CommandCursor#data
	 * @fires CommandCursor#end
	 * @fires CommandCursor#close
	 * @fires CommandCursor#readable
	 * @return {CommandCursor} an CommandCursor instance.
	 */
	var CommandCursor = function(bson, ns, cmd, options, topology, topologyOptions) {
	  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
	  var self = this;
	  var state = CommandCursor.INIT;
	  var streamOptions = {};
	
	  // MaxTimeMS
	  var maxTimeMS = null;
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(198).Promise;
	  }
	
	  // Set up
	  Readable.call(this, {objectMode: true});
	
	  // Internal state
	  this.s = {
	    // MaxTimeMS
	      maxTimeMS: maxTimeMS
	    // State
	    , state: state
	    // Stream options
	    , streamOptions: streamOptions
	    // BSON
	    , bson: bson
	    // Namespae
	    , ns: ns
	    // Command
	    , cmd: cmd
	    // Options
	    , options: options
	    // Topology
	    , topology: topology
	    // Topology Options
	    , topologyOptions: topologyOptions
	    // Promise library
	    , promiseLibrary: promiseLibrary
	  }
	}
	
	/**
	 * CommandCursor stream data event, fired for each document in the cursor.
	 *
	 * @event CommandCursor#data
	 * @type {object}
	 */
	
	/**
	 * CommandCursor stream end event
	 *
	 * @event CommandCursor#end
	 * @type {null}
	 */
	
	/**
	 * CommandCursor stream close event
	 *
	 * @event CommandCursor#close
	 * @type {null}
	 */
	
	/**
	 * CommandCursor stream readable event
	 *
	 * @event CommandCursor#readable
	 * @type {null}
	 */
	
	// Inherit from Readable
	inherits(CommandCursor, Readable);
	
	// Set the methods to inherit from prototype
	var methodsToInherit = ['_next', 'next', 'each', 'forEach', 'toArray'
	  , 'rewind', 'bufferedCount', 'readBufferedDocuments', 'close', 'isClosed', 'kill'
	  , '_find', '_getmore', '_killcursor', 'isDead', 'explain', 'isNotified', 'isKilled'];
	
	// Only inherit the types we need
	for(var i = 0; i < methodsToInherit.length; i++) {
	  CommandCursor.prototype[methodsToInherit[i]] = CoreCursor.prototype[methodsToInherit[i]];
	}
	
	var define = CommandCursor.define = new Define('CommandCursor', CommandCursor, true);
	
	/**
	 * Set the ReadPreference for the cursor.
	 * @method
	 * @param {(string|ReadPreference)} readPreference The new read preference for the cursor.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	CommandCursor.prototype.setReadPreference = function(r) {
	  if(this.s.state == CommandCursor.CLOSED || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(this.s.state != CommandCursor.INIT) throw MongoError.create({message: 'cannot change cursor readPreference after cursor has been accessed', driver:true});
	
	  if(r instanceof ReadPreference) {
	    this.s.options.readPreference = new CoreReadPreference(r.mode, r.tags);
	  } else if(typeof r == 'string') {
	    this.s.options.readPreference = new CoreReadPreference(r);
	  } else if(r instanceof CoreReadPreference) {
	    this.s.options.readPreference = r;
	  }
	
	  return this;
	}
	
	define.classMethod('setReadPreference', {callback: false, promise:false, returns: [CommandCursor]});
	
	/**
	 * Set the batch size for the cursor.
	 * @method
	 * @param {number} value The batchSize for the cursor.
	 * @throws {MongoError}
	 * @return {CommandCursor}
	 */
	CommandCursor.prototype.batchSize = function(value) {
	  if(this.s.state == CommandCursor.CLOSED || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(typeof value != 'number') throw MongoError.create({message: "batchSize requires an integer", driver:true});
	  if(this.s.cmd.cursor) this.s.cmd.cursor.batchSize = value;
	  this.setCursorBatchSize(value);
	  return this;
	}
	
	define.classMethod('batchSize', {callback: false, promise:false, returns: [CommandCursor]});
	
	/**
	 * Add a maxTimeMS stage to the aggregation pipeline
	 * @method
	 * @param {number} value The state maxTimeMS value.
	 * @return {CommandCursor}
	 */
	CommandCursor.prototype.maxTimeMS = function(value) {
	  if(this.s.topology.lastIsMaster().minWireVersion > 2) {
	    this.s.cmd.maxTimeMS = value;
	  }
	  return this;
	}
	
	define.classMethod('maxTimeMS', {callback: false, promise:false, returns: [CommandCursor]});
	
	CommandCursor.prototype.get = CommandCursor.prototype.toArray;
	
	define.classMethod('get', {callback: true, promise:false});
	
	// Inherited methods
	define.classMethod('toArray', {callback: true, promise:true});
	define.classMethod('each', {callback: true, promise:false});
	define.classMethod('forEach', {callback: true, promise:false});
	define.classMethod('next', {callback: true, promise:true});
	define.classMethod('close', {callback: true, promise:true});
	define.classMethod('isClosed', {callback: false, promise:false, returns: [Boolean]});
	define.classMethod('rewind', {callback: false, promise:false});
	define.classMethod('bufferedCount', {callback: false, promise:false, returns: [Number]});
	define.classMethod('readBufferedDocuments', {callback: false, promise:false, returns: [Array]});
	
	/**
	 * Get the next available document from the cursor, returns null if no more documents are available.
	 * @function CommandCursor.prototype.next
	 * @param {CommandCursor~resultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * The callback format for results
	 * @callback CommandCursor~toArrayResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object[]} documents All the documents the satisfy the cursor.
	 */
	
	/**
	 * Returns an array of documents. The caller is responsible for making sure that there
	 * is enough memory to store the results. Note that the array only contain partial
	 * results when this cursor had been previouly accessed.
	 * @method CommandCursor.prototype.toArray
	 * @param {CommandCursor~toArrayResultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * The callback format for results
	 * @callback CommandCursor~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {(object|null)} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Iterates over all the documents for this cursor. As with **{cursor.toArray}**,
	 * not all of the elements will be iterated if this cursor had been previouly accessed.
	 * In that case, **{cursor.rewind}** can be used to reset the cursor. However, unlike
	 * **{cursor.toArray}**, the cursor will only hold a maximum of batch size elements
	 * at any given time if batch size is specified. Otherwise, the caller is responsible
	 * for making sure that the entire result can fit the memory.
	 * @method CommandCursor.prototype.each
	 * @param {CommandCursor~resultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	/**
	 * Close the cursor, sending a KillCursor command and emitting close.
	 * @method CommandCursor.prototype.close
	 * @param {CommandCursor~resultCallback} [callback] The result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * Is the cursor closed
	 * @method CommandCursor.prototype.isClosed
	 * @return {boolean}
	 */
	
	/**
	 * Clone the cursor
	 * @function CommandCursor.prototype.clone
	 * @return {CommandCursor}
	 */
	
	/**
	 * Resets the cursor
	 * @function CommandCursor.prototype.rewind
	 * @return {CommandCursor}
	 */
	
	/**
	 * The callback format for the forEach iterator method
	 * @callback CommandCursor~iteratorCallback
	 * @param {Object} doc An emitted document for the iterator
	 */
	
	/**
	 * The callback error format for the forEach iterator method
	 * @callback CommandCursor~endCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 */
	
	/*
	 * Iterates over all the documents for this cursor using the iterator, callback pattern.
	 * @method CommandCursor.prototype.forEach
	 * @param {CommandCursor~iteratorCallback} iterator The iteration callback.
	 * @param {CommandCursor~endCallback} callback The end callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	CommandCursor.INIT = 0;
	CommandCursor.OPEN = 1;
	CommandCursor.CLOSED = 2;
	
	module.exports = CommandCursor;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var common = __webpack_require__(203)
		, utils = __webpack_require__(194)
	  , toError = __webpack_require__(194).toError
		, f = __webpack_require__(77).format
		, handleCallback = __webpack_require__(194).handleCallback
		, shallowClone = utils.shallowClone
	  , WriteError = common.WriteError
	  , BulkWriteResult = common.BulkWriteResult
	  , LegacyOp = common.LegacyOp
	  , ObjectID = __webpack_require__(156).BSON.ObjectID
	  , Define = __webpack_require__(196)
		, BSON = __webpack_require__(156).BSON
	  , Batch = common.Batch
	  , mergeBatchResults = common.mergeBatchResults;
	
	var bson = new BSON.BSONPure();
	
	/**
	 * Create a FindOperatorsOrdered instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @return {FindOperatorsOrdered} a FindOperatorsOrdered instance.
	 */
	var FindOperatorsOrdered = function(self) {
	  this.s = self.s;
	}
	
	/**
	 * Add a single update document to the bulk operation
	 *
	 * @method
	 * @param {object} doc update operations
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	FindOperatorsOrdered.prototype.update = function(updateDocument) {
	  // Perform upsert
	  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
	
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , u: updateDocument
	    , multi: true
	    , upsert: upsert
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the update document to the list
	  return addToOperationsList(this, common.UPDATE, document);
	}
	
	/**
	 * Add a single update one document to the bulk operation
	 *
	 * @method
	 * @param {object} doc update operations
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	FindOperatorsOrdered.prototype.updateOne = function(updateDocument) {
	  // Perform upsert
	  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
	
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , u: updateDocument
	    , multi: false
	    , upsert: upsert
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the update document to the list
	  return addToOperationsList(this, common.UPDATE, document);
	}
	
	/**
	 * Add a replace one operation to the bulk operation
	 *
	 * @method
	 * @param {object} doc the new document to replace the existing one with
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	FindOperatorsOrdered.prototype.replaceOne = function(updateDocument) {
	  this.updateOne(updateDocument);
	}
	
	/**
	 * Upsert modifier for update bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {FindOperatorsOrdered}
	 */
	FindOperatorsOrdered.prototype.upsert = function() {
	  this.s.currentOp.upsert = true;
	  return this;
	}
	
	/**
	 * Add a remove one operation to the bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	FindOperatorsOrdered.prototype.deleteOne = function() {
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , limit: 1
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the remove document to the list
	  return addToOperationsList(this, common.REMOVE, document);
	}
	
	// Backward compatibility
	FindOperatorsOrdered.prototype.removeOne = FindOperatorsOrdered.prototype.deleteOne;
	
	/**
	 * Add a remove operation to the bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	FindOperatorsOrdered.prototype.delete = function() {
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , limit: 0
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the remove document to the list
	  return addToOperationsList(this, common.REMOVE, document);
	}
	
	// Backward compatibility
	FindOperatorsOrdered.prototype.remove = FindOperatorsOrdered.prototype.delete;
	
	// Add to internal list of documents
	var addToOperationsList = function(_self, docType, document) {
	  // Get the bsonSize
	  var bsonSize = bson.calculateObjectSize(document, false);
	
	  // Throw error if the doc is bigger than the max BSON size
	  if(bsonSize >= _self.s.maxBatchSizeBytes) {
			throw toError("document is larger than the maximum size " + _self.s.maxBatchSizeBytes);
		}
	
	  // Create a new batch object if we don't have a current one
	  if(_self.s.currentBatch == null) _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
	
	  // Check if we need to create a new batch
	  if(((_self.s.currentBatchSize + 1) >= _self.s.maxWriteBatchSize)
	    || ((_self.s.currentBatchSizeBytes +  _self.s.currentBatchSizeBytes) >= _self.s.maxBatchSizeBytes)
	    || (_self.s.currentBatch.batchType != docType)) {
	    // Save the batch to the execution stack
	    _self.s.batches.push(_self.s.currentBatch);
	
	    // Create a new batch
	    _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
	
	    // Reset the current size trackers
	    _self.s.currentBatchSize = 0;
	    _self.s.currentBatchSizeBytes = 0;
	  } else {
	    // Update current batch size
	    _self.s.currentBatchSize = _self.s.currentBatchSize + 1;
	    _self.s.currentBatchSizeBytes = _self.s.currentBatchSizeBytes + bsonSize;
	  }
	
	  if(docType == common.INSERT) {
	    _self.s.bulkResult.insertedIds.push({index: _self.s.currentIndex, _id: document._id});
	  }
	
	  // We have an array of documents
	  if(Array.isArray(document)) {
	    throw toError("operation passed in cannot be an Array");
	  } else {
	    _self.s.currentBatch.originalIndexes.push(_self.s.currentIndex);
	    _self.s.currentBatch.operations.push(document)
			_self.s.currentBatchSizeBytes = _self.s.currentBatchSizeBytes + bsonSize;
	    _self.s.currentIndex = _self.s.currentIndex + 1;
	  }
	
	  // Return self
	  return _self;
	}
	
	/**
	 * Create a new OrderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @property {number} length Get the number of operations in the bulk.
	 * @return {OrderedBulkOperation} a OrderedBulkOperation instance.
	 */
	function OrderedBulkOperation(topology, collection, options) {
		options = options == null ? {} : options;
		// TODO Bring from driver information in isMaster
		var self = this;
		var executed = false;
	
		// Current item
		var currentOp = null;
	
		// Handle to the bson serializer, used to calculate running sizes
		var bson = topology.bson;
	
		// Namespace for the operation
	  var namespace = collection.collectionName;
	
	  // Set max byte size
		var maxBatchSizeBytes = topology.isMasterDoc && topology.isMasterDoc.maxBsonObjectSize
	    ? topology.isMasterDoc.maxBsonObjectSize : (1024*1025*16);
		var maxWriteBatchSize = topology.isMasterDoc && topology.isMasterDoc.maxWriteBatchSize
	    ? topology.isMasterDoc.maxWriteBatchSize : 1000;
	
	  // Get the write concern
	  var writeConcern = common.writeConcern(shallowClone(options), collection, options);
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(198).Promise;
	  }
	
	  // Current batch
	  var currentBatch = null;
	  var currentIndex = 0;
	  var currentBatchSize = 0;
	  var currentBatchSizeBytes = 0;
	  var batches = [];
	
	  // Final results
	  var bulkResult = {
	  	  ok: 1
	    , writeErrors: []
	    , writeConcernErrors: []
	    , insertedIds: []
	    , nInserted: 0
	    , nUpserted: 0
	    , nMatched: 0
	    , nModified: 0
	    , nRemoved: 0
	    , upserted: []
	  };
	
	  // Internal state
	  this.s = {
	    // Final result
	      bulkResult: bulkResult
	    // Current batch state
	    , currentBatch: null
	    , currentIndex: 0
	    , currentBatchSize: 0
	    , currentBatchSizeBytes: 0
	    , batches: []
	    // Write concern
	    , writeConcern: writeConcern
	    // Max batch size options
	    , maxBatchSizeBytes: maxBatchSizeBytes
	    , maxWriteBatchSize: maxWriteBatchSize
	    // Namespace
	    , namespace: namespace
	    // BSON
	    , bson: bson
	    // Topology
	    , topology: topology
	    // Options
	    , options: options
	    // Current operation
	    , currentOp: currentOp
	    // Executed
	    , executed: executed
	    // Collection
	    , collection: collection
	    // Promise Library
	    , promiseLibrary: promiseLibrary
			// Fundamental error
			, err: null
	    // Bypass validation
	    , bypassDocumentValidation: typeof options.bypassDocumentValidation == 'boolean' ? options.bypassDocumentValidation : false
	  }
	}
	
	var define = OrderedBulkOperation.define = new Define('OrderedBulkOperation', OrderedBulkOperation, false);
	
	OrderedBulkOperation.prototype.raw = function(op) {
	  var key = Object.keys(op)[0];
	
	  // Set up the force server object id
	  var forceServerObjectId = typeof this.s.options.forceServerObjectId == 'boolean'
	    ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId;
	
	  // Update operations
	  if((op.updateOne && op.updateOne.q)
	    || (op.updateMany && op.updateMany.q)
	    || (op.replaceOne && op.replaceOne.q)) {
	    op[key].multi = op.updateOne || op.replaceOne ? false : true;
	    return addToOperationsList(this, common.UPDATE, op[key]);
	  }
	
	  // Crud spec update format
	  if(op.updateOne || op.updateMany || op.replaceOne) {
	    var multi = op.updateOne || op.replaceOne ? false : true;
	    var operation = {q: op[key].filter, u: op[key].update || op[key].replacement, multi: multi}
	    operation.upsert = op[key].upsert ? true: false;
	    return addToOperationsList(this, common.UPDATE, operation);
	  }
	
	  // Remove operations
	  if(op.removeOne || op.removeMany || (op.deleteOne && op.deleteOne.q) || op.deleteMany && op.deleteMany.q) {
	    op[key].limit = op.removeOne ? 1 : 0;
	    return addToOperationsList(this, common.REMOVE, op[key]);
	  }
	
	  // Crud spec delete operations, less efficient
	  if(op.deleteOne || op.deleteMany) {
	    var limit = op.deleteOne ? 1 : 0;
	    var operation = {q: op[key].filter, limit: limit}
	    return addToOperationsList(this, common.REMOVE, operation);
	  }
	
	  // Insert operations
	  if(op.insertOne && op.insertOne.document == null) {
	    if(forceServerObjectId !== true && op.insertOne._id == null) op.insertOne._id = new ObjectID();
	    return addToOperationsList(this, common.INSERT, op.insertOne);
	  } else if(op.insertOne && op.insertOne.document) {
	    if(forceServerObjectId !== true && op.insertOne.document._id == null) op.insertOne.document._id = new ObjectID();
	    return addToOperationsList(this, common.INSERT, op.insertOne.document);
	  }
	
	  if(op.insertMany) {
	    for(var i = 0; i < op.insertMany.length; i++) {
	      if(forceServerObjectId !== true && op.insertMany[i]._id == null) op.insertMany[i]._id = new ObjectID();
	      addToOperationsList(this, common.INSERT, op.insertMany[i]);
	    }
	
	    return;
	  }
	
	  // No valid type of operation
	  throw toError("bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany");
	}
	
	/**
	 * Add a single insert document to the bulk operation
	 *
	 * @param {object} doc the document to insert
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	OrderedBulkOperation.prototype.insert = function(document) {
	  if(this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null) document._id = new ObjectID();
	  return addToOperationsList(this, common.INSERT, document);
	}
	
	/**
	 * Initiate a find operation for an update/updateOne/remove/removeOne/replaceOne
	 *
	 * @method
	 * @param {object} selector The selector for the bulk operation.
	 * @throws {MongoError}
	 * @return {FindOperatorsOrdered}
	 */
	OrderedBulkOperation.prototype.find = function(selector) {
	  if (!selector) {
	    throw toError("Bulk find operation must specify a selector");
	  }
	
	  // Save a current selector
	  this.s.currentOp = {
	    selector: selector
	  }
	
	  return new FindOperatorsOrdered(this);
	}
	
	Object.defineProperty(OrderedBulkOperation.prototype, 'length', {
	  enumerable: true,
	  get: function() {
	    return this.s.currentIndex;
	  }
	});
	
	//
	// Execute next write command in a chain
	var executeCommands = function(self, callback) {
	  if(self.s.batches.length == 0) {
	    return handleCallback(callback, null, new BulkWriteResult(self.s.bulkResult));
	  }
	
	  // Ordered execution of the command
	  var batch = self.s.batches.shift();
	
	  var resultHandler = function(err, result) {
			// Error is a driver related error not a bulk op error, terminate
			if(err && err.driver || err && err.message) {
				return handleCallback(callback, err);
			}
	
	    // If we have and error
	    if(err) err.ok = 0;
	    // Merge the results together
	    var mergeResult = mergeBatchResults(true, batch, self.s.bulkResult, err, result);
	    if(mergeResult != null) {
	      return handleCallback(callback, null, new BulkWriteResult(self.s.bulkResult));
	    }
	
	    // If we are ordered and have errors and they are
	    // not all replication errors terminate the operation
	    if(self.s.bulkResult.writeErrors.length > 0) {
	      return handleCallback(callback, toError(self.s.bulkResult.writeErrors[0]), new BulkWriteResult(self.s.bulkResult));
	    }
	
	    // Execute the next command in line
	    executeCommands(self, callback);
	  }
	
	  var finalOptions = {ordered: true}
	  if(self.s.writeConcern != null) {
	    finalOptions.writeConcern = self.s.writeConcern;
	  }
	
		// Set an operationIf if provided
		if(self.operationId) {
			resultHandler.operationId = self.operationId;
		}
	
		// Serialize functions
		if(self.s.options.serializeFunctions) {
			finalOptions.serializeFunctions = true
		}
	
	  // Serialize functions
	  if(self.s.options.ignoreUndefined) {
	    finalOptions.ignoreUndefined = true
	  }
	
	  // Is the bypassDocumentValidation options specific
	  if(self.s.bypassDocumentValidation == true) {
	    finalOptions.bypassDocumentValidation = true;
	  }
	
	  try {
	    if(batch.batchType == common.INSERT) {
	      self.s.topology.insert(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    } else if(batch.batchType == common.UPDATE) {
	      self.s.topology.update(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    } else if(batch.batchType == common.REMOVE) {
	      self.s.topology.remove(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    }
	  } catch(err) {
	    // Force top level error
	    err.ok = 0;
	    // Merge top level error and return
	    handleCallback(callback, null, mergeBatchResults(false, batch, self.s.bulkResult, err, null));
	  }
	}
	
	/**
	 * The callback format for results
	 * @callback OrderedBulkOperation~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {BulkWriteResult} result The bulk write result.
	 */
	
	/**
	 * Execute the ordered bulk operation
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.fsync=false] Specify a file sync write concern.
	 * @param {OrderedBulkOperation~resultCallback} [callback] The result callback
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	OrderedBulkOperation.prototype.execute = function(_writeConcern, callback) {
	  var self = this;
	  if(this.s.executed) throw new toError("batch cannot be re-executed");
	  if(typeof _writeConcern == 'function') {
	    callback = _writeConcern;
	  } else {
	    this.s.writeConcern = _writeConcern;
	  }
	
	  // If we have current batch
	  if(this.s.currentBatch) this.s.batches.push(this.s.currentBatch)
	
	  // If we have no operations in the bulk raise an error
	  if(this.s.batches.length == 0) {
	    throw toError("Invalid Operation, No operations in bulk");
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') {
			return executeCommands(this, callback);
		}
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    executeCommands(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('execute', {callback: true, promise:false});
	
	/**
	 * Returns an unordered batch object
	 * @ignore
	 */
	var initializeOrderedBulkOp = function(topology, collection, options) {
		return new OrderedBulkOperation(topology, collection, options);
	}
	
	initializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;
	module.exports = initializeOrderedBulkOp;
	module.exports.Bulk = OrderedBulkOperation;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var utils = __webpack_require__(194),
	  Long = __webpack_require__(156).BSON.Long,
	  Timestamp = __webpack_require__(156).BSON.Timestamp;
	
	// Error codes
	var UNKNOWN_ERROR = 8;
	var INVALID_BSON_ERROR = 22;
	var WRITE_CONCERN_ERROR = 64;
	var MULTIPLE_ERROR = 65;
	
	// Insert types
	var INSERT = 1;
	var UPDATE = 2;
	var REMOVE = 3
	
	
	// Get write concern
	var writeConcern = function(target, col, options) {
	  if(options.w != null || options.j != null || options.fsync != null) {
	    target.writeConcern = options;
	  } else if(col.writeConcern.w != null || col.writeConcern.j != null || col.writeConcern.fsync != null) {
	    target.writeConcern = col.writeConcern;
	  }
	
	  return target
	}
	
	/**
	 * Helper function to define properties
	 * @ignore
	 */
	var defineReadOnlyProperty = function(self, name, value) {
	  Object.defineProperty(self, name, {
	      enumerable: true
	    , get: function() {
	      return value;
	    }
	  });
	}
	
	/**
	 * Keeps the state of a unordered batch so we can rewrite the results
	 * correctly after command execution
	 * @ignore
	 */
	var Batch = function(batchType, originalZeroIndex) {
	  this.originalZeroIndex = originalZeroIndex;
	  this.currentIndex = 0;
	  this.originalIndexes = [];
	  this.batchType = batchType;
	  this.operations = [];
	  this.size = 0;
	  this.sizeBytes = 0;
	}
	
	/**
	 * Wraps a legacy operation so we can correctly rewrite it's error
	 * @ignore
	 */
	var LegacyOp = function(batchType, operation, index) {
	  this.batchType = batchType;
	  this.index = index;
	  this.operation = operation;
	}
	
	/**
	 * Create a new BulkWriteResult instance (INTERNAL TYPE, do not instantiate directly)
	 *
	 * @class
	 * @property {boolean} ok Did bulk operation correctly execute
	 * @property {number} nInserted number of inserted documents
	 * @property {number} nUpdated number of documents updated logically
	 * @property {number} nUpserted Number of upserted documents
	 * @property {number} nModified Number of documents updated physically on disk
	 * @property {number} nRemoved Number of removed documents
	 * @return {BulkWriteResult} a BulkWriteResult instance
	 */
	var BulkWriteResult = function(bulkResult) {
	  defineReadOnlyProperty(this, "ok", bulkResult.ok);
	  defineReadOnlyProperty(this, "nInserted", bulkResult.nInserted);
	  defineReadOnlyProperty(this, "nUpserted", bulkResult.nUpserted);
	  defineReadOnlyProperty(this, "nMatched", bulkResult.nMatched);
	  defineReadOnlyProperty(this, "nModified", bulkResult.nModified);
	  defineReadOnlyProperty(this, "nRemoved", bulkResult.nRemoved);
	
	  /**
	   * Return an array of inserted ids
	   *
	   * @return {object[]}
	   */
	  this.getInsertedIds = function() {
	    return bulkResult.insertedIds;
	  }
	
	  /**
	   * Return an array of upserted ids
	   *
	   * @return {object[]}
	   */
	  this.getUpsertedIds = function() {
	    return bulkResult.upserted;
	  }
	
	  /**
	   * Return the upserted id at position x
	   *
	   * @param {number} index the number of the upserted id to return, returns undefined if no result for passed in index
	   * @return {object}
	   */
	  this.getUpsertedIdAt = function(index) {
	    return bulkResult.upserted[index];
	  }
	
	  /**
	   * Return raw internal result
	   *
	   * @return {object}
	   */
	  this.getRawResponse = function() {
	    return bulkResult;
	  }
	
	  /**
	   * Returns true if the bulk operation contains a write error
	   *
	   * @return {boolean}
	   */
	  this.hasWriteErrors = function() {
	    return bulkResult.writeErrors.length > 0;
	  }
	
	  /**
	   * Returns the number of write errors off the bulk operation
	   *
	   * @return {number}
	   */
	  this.getWriteErrorCount = function() {
	    return bulkResult.writeErrors.length;
	  }
	
	  /**
	   * Returns a specific write error object
	   *
	   * @return {WriteError}
	   */
	  this.getWriteErrorAt = function(index) {
	    if(index < bulkResult.writeErrors.length) {
	      return bulkResult.writeErrors[index];
	    }
	    return null;
	  }
	
	  /**
	   * Retrieve all write errors
	   *
	   * @return {object[]}
	   */
	  this.getWriteErrors = function() {
	    return bulkResult.writeErrors;
	  }
	
	  /**
	   * Retrieve lastOp if available
	   *
	   * @return {object}
	   */
	  this.getLastOp = function() {
	    return bulkResult.lastOp;
	  }
	
	  /**
	   * Retrieve the write concern error if any
	   *
	   * @return {WriteConcernError}
	   */
	  this.getWriteConcernError = function() {
	    if(bulkResult.writeConcernErrors.length == 0) {
	      return null;
	    } else if(bulkResult.writeConcernErrors.length == 1) {
	      // Return the error
	      return bulkResult.writeConcernErrors[0];
	    } else {
	
	      // Combine the errors
	      var errmsg = "";
	      for(var i = 0; i < bulkResult.writeConcernErrors.length; i++) {
	        var err = bulkResult.writeConcernErrors[i];
	        errmsg = errmsg + err.errmsg;
	
	        // TODO: Something better
	        if(i == 0) errmsg = errmsg + " and ";
	      }
	
	      return new WriteConcernError({ errmsg : errmsg, code : WRITE_CONCERN_ERROR });
	    }
	  }
	
	  this.toJSON = function() {
	    return bulkResult;
	  }
	
	  this.toString = function() {
	    return "BulkWriteResult(" + this.toJSON(bulkResult) + ")";
	  }
	
	  this.isOk = function() {
	    return bulkResult.ok == 1;
	  }
	}
	
	/**
	 * Create a new WriteConcernError instance (INTERNAL TYPE, do not instantiate directly)
	 *
	 * @class
	 * @property {number} code Write concern error code.
	 * @property {string} errmsg Write concern error message.
	 * @return {WriteConcernError} a WriteConcernError instance
	 */
	var WriteConcernError = function(err) {
	  if(!(this instanceof WriteConcernError)) return new WriteConcernError(err);
	
	  // Define properties
	  defineReadOnlyProperty(this, "code", err.code);
	  defineReadOnlyProperty(this, "errmsg", err.errmsg);
	
	  this.toJSON = function() {
	    return {code: err.code, errmsg: err.errmsg};
	  }
	
	  this.toString = function() {
	    return "WriteConcernError(" + err.errmsg + ")";
	  }
	}
	
	/**
	 * Create a new WriteError instance (INTERNAL TYPE, do not instantiate directly)
	 *
	 * @class
	 * @property {number} code Write concern error code.
	 * @property {number} index Write concern error original bulk operation index.
	 * @property {string} errmsg Write concern error message.
	 * @return {WriteConcernError} a WriteConcernError instance
	 */
	var WriteError = function(err) {
	  if(!(this instanceof WriteError)) return new WriteError(err);
	
	  // Define properties
	  defineReadOnlyProperty(this, "code", err.code);
	  defineReadOnlyProperty(this, "index", err.index);
	  defineReadOnlyProperty(this, "errmsg", err.errmsg);
	
	  //
	  // Define access methods
	  this.getOperation = function() {
	    return err.op;
	  }
	
	  this.toJSON = function() {
	    return {code: err.code, index: err.index, errmsg: err.errmsg, op: err.op};
	  }
	
	  this.toString = function() {
	    return "WriteError(" + JSON.stringify(this.toJSON()) + ")";
	  }
	}
	
	/**
	 * Merges results into shared data structure
	 * @ignore
	 */
	var mergeBatchResults = function(ordered, batch, bulkResult, err, result) {
	  // If we have an error set the result to be the err object
	  if(err) {
	    result = err;
	  } else if(result && result.result) {
	    result = result.result;
	  } else if(result == null) {
	    return;
	  }
	
	  // Do we have a top level error stop processing and return
	  if(result.ok == 0 && bulkResult.ok == 1) {
	    bulkResult.ok = 0;
	
	    var writeError = {
	        index: 0
	      , code: result.code || 0
	      , errmsg: result.message
	      , op: batch.operations[0]
	    };
	
	    bulkResult.writeErrors.push(new WriteError(writeError));
	    return;
	  } else if(result.ok == 0 && bulkResult.ok == 0) {
	    return;
	  }
	
	  // Deal with opTime if available
	  if(result.opTime || result.lastOp) {
	    var opTime = result.lastOp || result.opTime;
	    var lastOpTS = null;
	    var lastOpT = null;
	
	    // We have a time stamp
	    if(opTime instanceof Timestamp) {
	      if(bulkResult.lastOp == null) {
	        bulkResult.lastOp = opTime;
	      } else if(opTime.greaterThan(bulkResult.lastOp)) {
	        bulkResult.lastOp = opTime;
	      }
	    } else {
	      // Existing TS
	      if(bulkResult.lastOp) {
	        lastOpTS = typeof bulkResult.lastOp.ts == 'number'
	          ? Long.fromNumber(bulkResult.lastOp.ts) : bulkResult.lastOp.ts;
	        lastOpT = typeof bulkResult.lastOp.t == 'number'
	          ? Long.fromNumber(bulkResult.lastOp.t) : bulkResult.lastOp.t;
	      }
	
	      // Current OpTime TS
	      var opTimeTS = typeof opTime.ts == 'number'
	        ? Long.fromNumber(opTime.ts) : opTime.ts;
	      var opTimeT = typeof opTime.t == 'number'
	        ? Long.fromNumber(opTime.t) : opTime.t;
	
	      // Compare the opTime's
	      if(bulkResult.lastOp == null) {
	        bulkResult.lastOp = opTime;
	      } else if(opTimeTS.greaterThan(lastOpTS)) {
	        bulkResult.lastOp = opTime;
	      } else if(opTimeTS.equals(lastOpTS)) {
	        if(opTimeT.greaterThan(lastOpT)) {
	          bulkResult.lastOp = opTime;
	        }
	      }
	    }
	  }
	
	  // If we have an insert Batch type
	  if(batch.batchType == INSERT && result.n) {
	    bulkResult.nInserted = bulkResult.nInserted + result.n;
	  }
	
	  // If we have an insert Batch type
	  if(batch.batchType == REMOVE && result.n) {
	    bulkResult.nRemoved = bulkResult.nRemoved + result.n;
	  }
	
	  var nUpserted = 0;
	
	  // We have an array of upserted values, we need to rewrite the indexes
	  if(Array.isArray(result.upserted)) {
	    nUpserted = result.upserted.length;
	
	    for(var i = 0; i < result.upserted.length; i++) {
	      bulkResult.upserted.push({
	          index: result.upserted[i].index + batch.originalZeroIndex
	        , _id: result.upserted[i]._id
	      });
	    }
	  } else if(result.upserted) {
	
	    nUpserted = 1;
	
	    bulkResult.upserted.push({
	        index: batch.originalZeroIndex
	      , _id: result.upserted
	    });
	  }
	
	  // If we have an update Batch type
	  if(batch.batchType == UPDATE && result.n) {
	    var nModified = result.nModified;
	    bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
	    bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
	
	    if(typeof nModified == 'number') {
	      bulkResult.nModified = bulkResult.nModified + nModified;
	    } else {
	      bulkResult.nModified = null;
	    }
	  }
	
	  if(Array.isArray(result.writeErrors)) {
	    for(var i = 0; i < result.writeErrors.length; i++) {
	
	      var writeError = {
	          index: batch.originalZeroIndex + result.writeErrors[i].index
	        , code: result.writeErrors[i].code
	        , errmsg: result.writeErrors[i].errmsg
	        , op: batch.operations[result.writeErrors[i].index]
	      };
	
	      bulkResult.writeErrors.push(new WriteError(writeError));
	    }
	  }
	
	  if(result.writeConcernError) {
	    bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
	  }
	}
	
	//
	// Clone the options
	var cloneOptions = function(options) {
	  var clone = {};
	  var keys = Object.keys(options);
	  for(var i = 0; i < keys.length; i++) {
	    clone[keys[i]] = options[keys[i]];
	  }
	
	  return clone;
	}
	
	// Exports symbols
	exports.BulkWriteResult = BulkWriteResult;
	exports.WriteError = WriteError;
	exports.Batch = Batch;
	exports.LegacyOp = LegacyOp;
	exports.mergeBatchResults = mergeBatchResults;
	exports.cloneOptions = cloneOptions;
	exports.writeConcern = writeConcern;
	exports.INVALID_BSON_ERROR = INVALID_BSON_ERROR;
	exports.WRITE_CONCERN_ERROR = WRITE_CONCERN_ERROR;
	exports.MULTIPLE_ERROR = MULTIPLE_ERROR;
	exports.UNKNOWN_ERROR = UNKNOWN_ERROR;
	exports.INSERT = INSERT;
	exports.UPDATE = UPDATE;
	exports.REMOVE = REMOVE;


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var common = __webpack_require__(203)
		, utils = __webpack_require__(194)
	  , toError = __webpack_require__(194).toError
	  , f = __webpack_require__(77).format
		, handleCallback = __webpack_require__(194).handleCallback
	  , shallowClone = utils.shallowClone
	  , WriteError = common.WriteError
	  , BulkWriteResult = common.BulkWriteResult
	  , LegacyOp = common.LegacyOp
	  , ObjectID = __webpack_require__(156).BSON.ObjectID
		, BSON = __webpack_require__(156).BSON
	  , Define = __webpack_require__(196)
	  , Batch = common.Batch
	  , mergeBatchResults = common.mergeBatchResults;
	
	var bson = new BSON.BSONPure();
	
	/**
	 * Create a FindOperatorsUnordered instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @property {number} length Get the number of operations in the bulk.
	 * @return {FindOperatorsUnordered} a FindOperatorsUnordered instance.
	 */
	var FindOperatorsUnordered = function(self) {
	  this.s = self.s;
	}
	
	/**
	 * Add a single update document to the bulk operation
	 *
	 * @method
	 * @param {object} doc update operations
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.update = function(updateDocument) {
	  // Perform upsert
	  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
	
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , u: updateDocument
	    , multi: true
	    , upsert: upsert
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the update document to the list
	  return addToOperationsList(this, common.UPDATE, document);
	}
	
	/**
	 * Add a single update one document to the bulk operation
	 *
	 * @method
	 * @param {object} doc update operations
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.updateOne = function(updateDocument) {
	  // Perform upsert
	  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
	
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , u: updateDocument
	    , multi: false
	    , upsert: upsert
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the update document to the list
	  return addToOperationsList(this, common.UPDATE, document);
	}
	
	/**
	 * Add a replace one operation to the bulk operation
	 *
	 * @method
	 * @param {object} doc the new document to replace the existing one with
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.replaceOne = function(updateDocument) {
	  this.updateOne(updateDocument);
	}
	
	/**
	 * Upsert modifier for update bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.upsert = function() {
	  this.s.currentOp.upsert = true;
	  return this;
	}
	
	/**
	 * Add a remove one operation to the bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.removeOne = function() {
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , limit: 1
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the remove document to the list
	  return addToOperationsList(this, common.REMOVE, document);
	}
	
	/**
	 * Add a remove operation to the bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.remove = function() {
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , limit: 0
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the remove document to the list
	  return addToOperationsList(this, common.REMOVE, document);
	}
	
	//
	// Add to the operations list
	//
	var addToOperationsList = function(_self, docType, document) {
	  // Get the bsonSize
	  var bsonSize = bson.calculateObjectSize(document, false);
	  // Throw error if the doc is bigger than the max BSON size
	  if(bsonSize >= _self.s.maxBatchSizeBytes) throw toError("document is larger than the maximum size " + _self.s.maxBatchSizeBytes);
	  // Holds the current batch
	  _self.s.currentBatch = null;
	  // Get the right type of batch
	  if(docType == common.INSERT) {
	    _self.s.currentBatch = _self.s.currentInsertBatch;
	  } else if(docType == common.UPDATE) {
	    _self.s.currentBatch = _self.s.currentUpdateBatch;
	  } else if(docType == common.REMOVE) {
	    _self.s.currentBatch = _self.s.currentRemoveBatch;
	  }
	
	  // Create a new batch object if we don't have a current one
	  if(_self.s.currentBatch == null) _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
	
	  // Check if we need to create a new batch
	  if(((_self.s.currentBatch.size + 1) >= _self.s.maxWriteBatchSize)
	    || ((_self.s.currentBatch.sizeBytes + bsonSize) >= _self.s.maxBatchSizeBytes)
	    || (_self.s.currentBatch.batchType != docType)) {
	    // Save the batch to the execution stack
	    _self.s.batches.push(_self.s.currentBatch);
	
	    // Create a new batch
	    _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
	  }
	
	  // We have an array of documents
	  if(Array.isArray(document)) {
	    throw toError("operation passed in cannot be an Array");
	  } else {
	    _self.s.currentBatch.operations.push(document);
	    _self.s.currentBatch.originalIndexes.push(_self.s.currentIndex);
	    _self.s.currentIndex = _self.s.currentIndex + 1;
	  }
	
	  // Save back the current Batch to the right type
	  if(docType == common.INSERT) {
	    _self.s.currentInsertBatch = _self.s.currentBatch;
	    _self.s.bulkResult.insertedIds.push({index: _self.s.currentIndex, _id: document._id});
	  } else if(docType == common.UPDATE) {
	    _self.s.currentUpdateBatch = _self.s.currentBatch;
	  } else if(docType == common.REMOVE) {
	    _self.s.currentRemoveBatch = _self.s.currentBatch;
	  }
	
	  // Update current batch size
	  _self.s.currentBatch.size = _self.s.currentBatch.size + 1;
	  _self.s.currentBatch.sizeBytes = _self.s.currentBatch.sizeBytes + bsonSize;
	
	  // Return self
	  return _self;
	}
	
	/**
	 * Create a new UnorderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @return {UnorderedBulkOperation} a UnorderedBulkOperation instance.
	 */
	var UnorderedBulkOperation = function(topology, collection, options) {
		options = options == null ? {} : options;
	
		// Contains reference to self
		var self = this;
		// Get the namesspace for the write operations
	  var namespace = collection.collectionName;
	  // Used to mark operation as executed
	  var executed = false;
	
		// Current item
	  // var currentBatch = null;
		var currentOp = null;
		var currentIndex = 0;
	  var batches = [];
	
	  // The current Batches for the different operations
	  var currentInsertBatch = null;
	  var currentUpdateBatch = null;
	  var currentRemoveBatch = null;
	
		// Handle to the bson serializer, used to calculate running sizes
		var bson = topology.bson;
	
	  // Set max byte size
	  var maxBatchSizeBytes = topology.isMasterDoc && topology.isMasterDoc.maxBsonObjectSize
	    ? topology.isMasterDoc.maxBsonObjectSize : (1024*1025*16);
	  var maxWriteBatchSize = topology.isMasterDoc && topology.isMasterDoc.maxWriteBatchSize
	    ? topology.isMasterDoc.maxWriteBatchSize : 1000;
	
	  // Get the write concern
	  var writeConcern = common.writeConcern(shallowClone(options), collection, options);
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(198).Promise;
	  }
	
	  // Final results
	  var bulkResult = {
	  	  ok: 1
	    , writeErrors: []
	    , writeConcernErrors: []
	    , insertedIds: []
	    , nInserted: 0
	    , nUpserted: 0
	    , nMatched: 0
	    , nModified: 0
	    , nRemoved: 0
	    , upserted: []
	  };
	
	  // Internal state
	  this.s = {
	    // Final result
	      bulkResult: bulkResult
	    // Current batch state
	    , currentInsertBatch: null
	    , currentUpdateBatch: null
	    , currentRemoveBatch: null
	    , currentBatch: null
	    , currentIndex: 0
	    , batches: []
	    // Write concern
	    , writeConcern: writeConcern
	    // Max batch size options
	    , maxBatchSizeBytes: maxBatchSizeBytes
	    , maxWriteBatchSize: maxWriteBatchSize
	    // Namespace
	    , namespace: namespace
	    // BSON
	    , bson: bson
	    // Topology
	    , topology: topology
	    // Options
	    , options: options
	    // Current operation
	    , currentOp: currentOp
	    // Executed
	    , executed: executed
	    // Collection
	    , collection: collection
	    // Promise Library
	    , promiseLibrary: promiseLibrary
	    // Bypass validation
	    , bypassDocumentValidation: typeof options.bypassDocumentValidation == 'boolean' ? options.bypassDocumentValidation : false
	  }
	}
	
	var define = UnorderedBulkOperation.define = new Define('UnorderedBulkOperation', UnorderedBulkOperation, false);
	
	/**
	 * Add a single insert document to the bulk operation
	 *
	 * @param {object} doc the document to insert
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	UnorderedBulkOperation.prototype.insert = function(document) {
	  if(this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null) document._id = new ObjectID();
	  return addToOperationsList(this, common.INSERT, document);
	}
	
	/**
	 * Initiate a find operation for an update/updateOne/remove/removeOne/replaceOne
	 *
	 * @method
	 * @param {object} selector The selector for the bulk operation.
	 * @throws {MongoError}
	 * @return {FindOperatorsUnordered}
	 */
	UnorderedBulkOperation.prototype.find = function(selector) {
	  if (!selector) {
	    throw toError("Bulk find operation must specify a selector");
	  }
	
	  // Save a current selector
	  this.s.currentOp = {
	    selector: selector
	  }
	
	  return new FindOperatorsUnordered(this);
	}
	
	Object.defineProperty(UnorderedBulkOperation.prototype, 'length', {
	  enumerable: true,
	  get: function() {
	    return this.s.currentIndex;
	  }
	});
	
	UnorderedBulkOperation.prototype.raw = function(op) {
	  var key = Object.keys(op)[0];
	
	  // Set up the force server object id
	  var forceServerObjectId = typeof this.s.options.forceServerObjectId == 'boolean'
	    ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId;
	
	  // Update operations
	  if((op.updateOne && op.updateOne.q)
	    || (op.updateMany && op.updateMany.q)
	    || (op.replaceOne && op.replaceOne.q)) {
	    op[key].multi = op.updateOne || op.replaceOne ? false : true;
	    return addToOperationsList(this, common.UPDATE, op[key]);
	  }
	
	  // Crud spec update format
	  if(op.updateOne || op.updateMany || op.replaceOne) {
	    var multi = op.updateOne || op.replaceOne ? false : true;
	    var operation = {q: op[key].filter, u: op[key].update || op[key].replacement, multi: multi}
	    if(op[key].upsert) operation.upsert = true;
	    return addToOperationsList(this, common.UPDATE, operation);
	  }
	
	  // Remove operations
	  if(op.removeOne || op.removeMany || (op.deleteOne && op.deleteOne.q) || op.deleteMany && op.deleteMany.q) {
	    op[key].limit = op.removeOne ? 1 : 0;
	    return addToOperationsList(this, common.REMOVE, op[key]);
	  }
	
	  // Crud spec delete operations, less efficient
	  if(op.deleteOne || op.deleteMany) {
	    var limit = op.deleteOne ? 1 : 0;
	    var operation = {q: op[key].filter, limit: limit}
	    return addToOperationsList(this, common.REMOVE, operation);
	  }
	
	  // Insert operations
	  if(op.insertOne && op.insertOne.document == null) {
	    if(forceServerObjectId !== true && op.insertOne._id == null) op.insertOne._id = new ObjectID();
	    return addToOperationsList(this, common.INSERT, op.insertOne);
	  } else if(op.insertOne && op.insertOne.document) {
	    if(forceServerObjectId !== true && op.insertOne.document._id == null) op.insertOne.document._id = new ObjectID();
	    return addToOperationsList(this, common.INSERT, op.insertOne.document);
	  }
	
	  if(op.insertMany) {
	    for(var i = 0; i < op.insertMany.length; i++) {
	      if(forceServerObjectId !== true && op.insertMany[i]._id == null) op.insertMany[i]._id = new ObjectID();
	      addToOperationsList(this, common.INSERT, op.insertMany[i]);
	    }
	
	    return;
	  }
	
	  // No valid type of operation
	  throw toError("bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany");
	}
	
	//
	// Execute the command
	var executeBatch = function(self, batch, callback) {
	  var finalOptions = {ordered: false}
	  if(self.s.writeConcern != null) {
	    finalOptions.writeConcern = self.s.writeConcern;
	  }
	
	  var resultHandler = function(err, result) {
			// Error is a driver related error not a bulk op error, terminate
			if(err && err.driver || err && err.message) {
				return handleCallback(callback, err);
			}
	
	    // If we have and error
	    if(err) err.ok = 0;
	    handleCallback(callback, null, mergeBatchResults(false, batch, self.s.bulkResult, err, result));
	  }
	
		// Set an operationIf if provided
		if(self.operationId) {
			resultHandler.operationId = self.operationId;
		}
	
		// Serialize functions
		if(self.s.options.serializeFunctions) {
			finalOptions.serializeFunctions = true
		}
	
	  // Is the bypassDocumentValidation options specific
	  if(self.s.bypassDocumentValidation == true) {
	    finalOptions.bypassDocumentValidation = true;
	  }
	
	  try {
	    if(batch.batchType == common.INSERT) {
	      self.s.topology.insert(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    } else if(batch.batchType == common.UPDATE) {
	      self.s.topology.update(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    } else if(batch.batchType == common.REMOVE) {
	      self.s.topology.remove(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    }
	  } catch(err) {
	    // Force top level error
	    err.ok = 0;
	    // Merge top level error and return
	    handleCallback(callback, null, mergeBatchResults(false, batch, self.s.bulkResult, err, null));
	  }
	}
	
	//
	// Execute all the commands
	var executeBatches = function(self, callback) {
	  var numberOfCommandsToExecute = self.s.batches.length;
		var error = null;
	  // Execute over all the batches
	  for(var i = 0; i < self.s.batches.length; i++) {
	    executeBatch(self, self.s.batches[i], function(err, result) {
				// Driver layer error capture it
				if(err) error = err;
				// Count down the number of commands left to execute
	      numberOfCommandsToExecute = numberOfCommandsToExecute - 1;
	
	      // Execute
	      if(numberOfCommandsToExecute == 0) {
					// Driver level error
					if(error) return handleCallback(callback, error);
					// Treat write errors
	        var error = self.s.bulkResult.writeErrors.length > 0 ? toError(self.s.bulkResult.writeErrors[0]) : null;
	        handleCallback(callback, error, new BulkWriteResult(self.s.bulkResult));
	      }
	    });
	  }
	}
	
	/**
	 * The callback format for results
	 * @callback UnorderedBulkOperation~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {BulkWriteResult} result The bulk write result.
	 */
	
	/**
	 * Execute the ordered bulk operation
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.fsync=false] Specify a file sync write concern.
	 * @param {UnorderedBulkOperation~resultCallback} [callback] The result callback
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	UnorderedBulkOperation.prototype.execute = function(_writeConcern, callback) {
	  var self = this;
	  if(this.s.executed) throw toError("batch cannot be re-executed");
	  if(typeof _writeConcern == 'function') {
	    callback = _writeConcern;
	  } else {
	    this.s.writeConcern = _writeConcern;
	  }
	
	  // If we have current batch
	  if(this.s.currentInsertBatch) this.s.batches.push(this.s.currentInsertBatch);
	  if(this.s.currentUpdateBatch) this.s.batches.push(this.s.currentUpdateBatch);
	  if(this.s.currentRemoveBatch) this.s.batches.push(this.s.currentRemoveBatch);
	
	  // If we have no operations in the bulk raise an error
	  if(this.s.batches.length == 0) {
	    throw toError("Invalid Operation, No operations in bulk");
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return executeBatches(this, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    executeBatches(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('execute', {callback: true, promise:false});
	
	/**
	 * Returns an unordered batch object
	 * @ignore
	 */
	var initializeUnorderedBulkOp = function(topology, collection, options) {
		return new UnorderedBulkOperation(topology, collection, options);
	}
	
	initializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;
	module.exports = initializeUnorderedBulkOp;
	module.exports.Bulk = UnorderedBulkOperation;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {"use strict";
	
	/**
	 * @fileOverview GridFS is a tool for MongoDB to store files to the database.
	 * Because of the restrictions of the object size the database can hold, a
	 * facility to split a file into several chunks is needed. The {@link GridStore}
	 * class offers a simplified api to interact with files while managing the
	 * chunks of split files behind the scenes. More information about GridFS can be
	 * found <a href="http://www.mongodb.org/display/DOCS/GridFS">here</a>.
	 *
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   GridStore = require('mongodb').GridStore,
	 *   ObjectID = require('mongodb').ObjectID,
	 *   test = require('assert');
	 *
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   var gridStore = new GridStore(db, null, "w");
	 *   gridStore.open(function(err, gridStore) {
	 *     gridStore.write("hello world!", function(err, gridStore) {
	 *       gridStore.close(function(err, result) {
	 *
	 *         // Let's read the file using object Id
	 *         GridStore.read(db, result._id, function(err, data) {
	 *           test.equal('hello world!', data);
	 *           db.close();
	 *           test.done();
	 *         });
	 *       });
	 *     });
	 *   });
	 * });
	 */
	var Chunk = __webpack_require__(206),
	  ObjectID = __webpack_require__(156).BSON.ObjectID,
	  ReadPreference = __webpack_require__(195),
	  Buffer = __webpack_require__(9).Buffer,
	  Collection = __webpack_require__(207),
	  fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
	  timers = __webpack_require__(8),
	  f = __webpack_require__(77).format,
	  util = __webpack_require__(77),
	  Define = __webpack_require__(196),
	  MongoError = __webpack_require__(156).MongoError,
	  inherits = util.inherits,
	  Duplex = __webpack_require__(54).Duplex || __webpack_require__(55).Duplex,
	  shallowClone = __webpack_require__(194).shallowClone;
	
	var REFERENCE_BY_FILENAME = 0,
	  REFERENCE_BY_ID = 1;
	
	/**
	 * Namespace provided by the mongodb-core and node.js
	 * @external Duplex
	 */
	
	/**
	 * Create a new GridStore instance
	 *
	 * Modes
	 *  - **"r"** - read only. This is the default mode.
	 *  - **"w"** - write in truncate mode. Existing data will be overwriten.
	 *
	 * @class
	 * @param {Db} db A database instance to interact with.
	 * @param {object} [id] optional unique id for this file
	 * @param {string} [filename] optional filename for this file, no unique constrain on the field
	 * @param {string} mode set the mode for this file.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.fsync=false] Specify a file sync write concern.
	 * @param {string} [options.root=null] Root collection to use. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.
	 * @param {string} [options.content_type=null] MIME type of the file. Defaults to **{GridStore.DEFAULT_CONTENT_TYPE}**.
	 * @param {number} [options.chunk_size=261120] Size for the chunk. Defaults to **{Chunk.DEFAULT_CHUNK_SIZE}**.
	 * @param {object} [options.metadata=null] Arbitrary data the user wants to store.
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @property {number} chunkSize Get the gridstore chunk size.
	 * @property {number} md5 The md5 checksum for this file.
	 * @property {number} chunkNumber The current chunk number the gridstore has materialized into memory
	 * @return {GridStore} a GridStore instance.
	 * @deprecated Use GridFSBucket API instead
	 */
	var GridStore = function GridStore(db, id, filename, mode, options) {
	  if(!(this instanceof GridStore)) return new GridStore(db, id, filename, mode, options);
	  var self = this;
	  this.db = db;
	
	  // Handle options
	  if(typeof options === 'undefined') options = {};
	  // Handle mode
	  if(typeof mode === 'undefined') {
	    mode = filename;
	    filename = undefined;
	  } else if(typeof mode == 'object') {
	    options = mode;
	    mode = filename;
	    filename = undefined;
	  }
	
	  if(id instanceof ObjectID) {
	    this.referenceBy = REFERENCE_BY_ID;
	    this.fileId = id;
	    this.filename = filename;
	  } else if(typeof filename == 'undefined') {
	    this.referenceBy = REFERENCE_BY_FILENAME;
	    this.filename = id;
	    if (mode.indexOf('w') != null) {
	      this.fileId = new ObjectID();
	    }
	  } else {
	    this.referenceBy = REFERENCE_BY_ID;
	    this.fileId = id;
	    this.filename = filename;
	  }
	
	  // Set up the rest
	  this.mode = mode == null ? "r" : mode;
	  this.options = options || {};
	
	  // Opened
	  this.isOpen = false;
	
	  // Set the root if overridden
	  this.root = this.options['root'] == null ? GridStore.DEFAULT_ROOT_COLLECTION : this.options['root'];
	  this.position = 0;
	  this.readPreference = this.options.readPreference || db.options.readPreference || ReadPreference.PRIMARY;
	  this.writeConcern = _getWriteConcern(db, this.options);
	  // Set default chunk size
	  this.internalChunkSize = this.options['chunkSize'] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options['chunkSize'];
	
	  // Get the promiseLibrary
	  var promiseLibrary = this.options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(198).Promise;
	  }
	
	  // Set the promiseLibrary
	  this.promiseLibrary = promiseLibrary;
	
	  Object.defineProperty(this, "chunkSize", { enumerable: true
	   , get: function () {
	       return this.internalChunkSize;
	     }
	   , set: function(value) {
	       if(!(this.mode[0] == "w" && this.position == 0 && this.uploadDate == null)) {
	         this.internalChunkSize = this.internalChunkSize;
	       } else {
	         this.internalChunkSize = value;
	       }
	     }
	  });
	
	  Object.defineProperty(this, "md5", { enumerable: true
	   , get: function () {
	       return this.internalMd5;
	     }
	  });
	
	  Object.defineProperty(this, "chunkNumber", { enumerable: true
	   , get: function () {
	       return this.currentChunk && this.currentChunk.chunkNumber ? this.currentChunk.chunkNumber : null;
	     }
	  });
	}
	
	var define = GridStore.define = new Define('Gridstore', GridStore, true);
	
	/**
	 * The callback format for the Gridstore.open method
	 * @callback GridStore~openCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {GridStore} gridStore The GridStore instance if the open method was successful.
	 */
	
	/**
	 * Opens the file from the database and initialize this object. Also creates a
	 * new one if file does not exist.
	 *
	 * @method
	 * @param {GridStore~openCallback} [callback] this will be called after executing this method
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.open = function(callback) {
	  var self = this;
	  if( this.mode != "w" && this.mode != "w+" && this.mode != "r"){
	    throw MongoError.create({message: "Illegal mode " + this.mode, driver:true});
	  }
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return open(self, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    open(self, function(err, store) {
	      if(err) return reject(err);
	      resolve(store);
	    })
	  });
	};
	
	var open = function(self, callback) {
	  // Get the write concern
	  var writeConcern = _getWriteConcern(self.db, self.options);
	
	  // If we are writing we need to ensure we have the right indexes for md5's
	  if((self.mode == "w" || self.mode == "w+")) {
	    // Get files collection
	    var collection = self.collection();
	    // Put index on filename
	    collection.ensureIndex([['filename', 1]], writeConcern, function(err, index) {
	      // Get chunk collection
	      var chunkCollection = self.chunkCollection();
	      // Make an unique index for compatibility with mongo-cxx-driver:legacy
	      var chunkIndexOptions = shallowClone(writeConcern);
	      chunkIndexOptions.unique = true;
	      // Ensure index on chunk collection
	      chunkCollection.ensureIndex([['files_id', 1], ['n', 1]], chunkIndexOptions, function(err, index) {
	        // Open the connection
	        _open(self, writeConcern, function(err, r) {
	          if(err) return callback(err);
	          self.isOpen = true;
	          callback(err, r);
	        });
	      });
	    });
	  } else {
	    // Open the gridstore
	    _open(self, writeConcern, function(err, r) {
	      if(err) return callback(err);
	      self.isOpen = true;
	      callback(err, r);
	    });
	  }
	}
	
	// Push the definition for open
	define.classMethod('open', {callback: true, promise:true});
	
	/**
	 * Verify if the file is at EOF.
	 *
	 * @method
	 * @return {boolean} true if the read/write head is at the end of this file.
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.eof = function() {
	  return this.position == this.length ? true : false;
	}
	
	define.classMethod('eof', {callback: false, promise:false, returns: [Boolean]});
	
	/**
	 * The callback result format.
	 * @callback GridStore~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object} result The result from the callback.
	 */
	
	/**
	 * Retrieves a single character from this file.
	 *
	 * @method
	 * @param {GridStore~resultCallback} [callback] this gets called after this method is executed. Passes null to the first parameter and the character read to the second or null to the second if the read/write head is at the end of the file.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.getc = function(callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return eof(self, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    eof(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	}
	
	var eof = function(self, callback) {
	  if(self.eof()) {
	    callback(null, null);
	  } else if(self.currentChunk.eof()) {
	    nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) {
	      self.currentChunk = chunk;
	      self.position = self.position + 1;
	      callback(err, self.currentChunk.getc());
	    });
	  } else {
	    self.position = self.position + 1;
	    callback(null, self.currentChunk.getc());
	  }
	}
	
	define.classMethod('getc', {callback: true, promise:true});
	
	/**
	 * Writes a string to the file with a newline character appended at the end if
	 * the given string does not have one.
	 *
	 * @method
	 * @param {string} string the string to write.
	 * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.puts = function(string, callback) {
	  var self = this;
	  var finalString = string.match(/\n$/) == null ? string + "\n" : string;
	  // We provided a callback leg
	  if(typeof callback == 'function') return this.write(finalString, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    self.write(finalString, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	}
	
	define.classMethod('puts', {callback: true, promise:true});
	
	/**
	 * Return a modified Readable stream including a possible transform method.
	 *
	 * @method
	 * @return {GridStoreStream}
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.stream = function() {
	  return new GridStoreStream(this);
	}
	
	define.classMethod('stream', {callback: false, promise:false, returns: [GridStoreStream]});
	
	/**
	 * Writes some data. This method will work properly only if initialized with mode "w" or "w+".
	 *
	 * @method
	 * @param {(string|Buffer)} data the data to write.
	 * @param {boolean} [close] closes this file after writing if set to true.
	 * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.write = function write(data, close, callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return _writeNormal(this, data, close, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    _writeNormal(self, data, close, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	}
	
	define.classMethod('write', {callback: true, promise:true});
	
	/**
	 * Handles the destroy part of a stream
	 *
	 * @method
	 * @result {null}
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.destroy = function destroy() {
	  // close and do not emit any more events. queued data is not sent.
	  if(!this.writable) return;
	  this.readable = false;
	  if(this.writable) {
	    this.writable = false;
	    this._q.length = 0;
	    this.emit('close');
	  }
	}
	
	define.classMethod('destroy', {callback: false, promise:false});
	
	/**
	 * Stores a file from the file system to the GridFS database.
	 *
	 * @method
	 * @param {(string|Buffer|FileHandle)} file the file to store.
	 * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.writeFile = function (file, callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return writeFile(self, file, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    writeFile(self, file, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var writeFile = function(self, file, callback) {
	  if (typeof file === 'string') {
	    fs.open(file, 'r', function (err, fd) {
	      if(err) return callback(err);
	      self.writeFile(fd, callback);
	    });
	    return;
	  }
	
	  self.open(function (err, self) {
	    if(err) return callback(err, self);
	
	    fs.fstat(file, function (err, stats) {
	      if(err) return callback(err, self);
	
	      var offset = 0;
	      var index = 0;
	      var numberOfChunksLeft = Math.min(stats.size / self.chunkSize);
	
	      // Write a chunk
	      var writeChunk = function() {
	        fs.read(file, self.chunkSize, offset, 'binary', function(err, data, bytesRead) {
	          if(err) return callback(err, self);
	
	          offset = offset + bytesRead;
	
	          // Create a new chunk for the data
	          var chunk = new Chunk(self, {n:index++}, self.writeConcern);
	          chunk.write(data, function(err, chunk) {
	            if(err) return callback(err, self);
	
	            chunk.save({}, function(err, result) {
	              if(err) return callback(err, self);
	
	              self.position = self.position + data.length;
	
	              // Point to current chunk
	              self.currentChunk = chunk;
	
	              if(offset >= stats.size) {
	                fs.close(file);
	                self.close(function(err, result) {
	                  if(err) return callback(err, self);
	                  return callback(null, self);
	                });
	              } else {
	                return process.nextTick(writeChunk);
	              }
	            });
	          });
	        });
	      }
	
	      // Process the first write
	      process.nextTick(writeChunk);
	    });
	  });
	}
	
	define.classMethod('writeFile', {callback: true, promise:true});
	
	/**
	 * Saves this file to the database. This will overwrite the old entry if it
	 * already exists. This will work properly only if mode was initialized to
	 * "w" or "w+".
	 *
	 * @method
	 * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.close = function(callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return close(self, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    close(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var close = function(self, callback) {
	  if(self.mode[0] == "w") {
	    // Set up options
	    var options = self.writeConcern;
	
	    if(self.currentChunk != null && self.currentChunk.position > 0) {
	      self.currentChunk.save({}, function(err, chunk) {
	        if(err && typeof callback == 'function') return callback(err);
	
	        self.collection(function(err, files) {
	          if(err && typeof callback == 'function') return callback(err);
	
	          // Build the mongo object
	          if(self.uploadDate != null) {
	            buildMongoObject(self, function(err, mongoObject) {
	              if(err) {
	                if(typeof callback == 'function') return callback(err); else throw err;
	              }
	
	              files.save(mongoObject, options, function(err) {
	                if(typeof callback == 'function')
	                  callback(err, mongoObject);
	              });
	            });
	          } else {
	            self.uploadDate = new Date();
	            buildMongoObject(self, function(err, mongoObject) {
	              if(err) {
	                if(typeof callback == 'function') return callback(err); else throw err;
	              }
	
	              files.save(mongoObject, options, function(err) {
	                if(typeof callback == 'function')
	                  callback(err, mongoObject);
	              });
	            });
	          }
	        });
	      });
	    } else {
	      self.collection(function(err, files) {
	        if(err && typeof callback == 'function') return callback(err);
	
	        self.uploadDate = new Date();
	        buildMongoObject(self, function(err, mongoObject) {
	          if(err) {
	            if(typeof callback == 'function') return callback(err); else throw err;
	          }
	
	          files.save(mongoObject, options, function(err) {
	            if(typeof callback == 'function')
	              callback(err, mongoObject);
	          });
	        });
	      });
	    }
	  } else if(self.mode[0] == "r") {
	    if(typeof callback == 'function')
	      callback(null, null);
	  } else {
	    if(typeof callback == 'function')
	      callback(MongoError.create({message: f("Illegal mode %s", self.mode), driver:true}));
	  }
	}
	
	define.classMethod('close', {callback: true, promise:true});
	
	/**
	 * The collection callback format.
	 * @callback GridStore~collectionCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection} collection The collection from the command execution.
	 */
	
	/**
	 * Retrieve this file's chunks collection.
	 *
	 * @method
	 * @param {GridStore~collectionCallback} callback the command callback.
	 * @return {Collection}
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.chunkCollection = function(callback) {
	  if(typeof callback == 'function')
	    return this.db.collection((this.root + ".chunks"), callback);
	  return this.db.collection((this.root + ".chunks"));
	};
	
	define.classMethod('chunkCollection', {callback: true, promise:false, returns: [Collection]});
	
	/**
	 * Deletes all the chunks of this file in the database.
	 *
	 * @method
	 * @param {GridStore~resultCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.unlink = function(callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return unlink(self, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    unlink(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var unlink = function(self, callback) {
	  deleteChunks(self, function(err) {
	    if(err!==null) {
	      err.message = "at deleteChunks: " + err.message;
	      return callback(err);
	    }
	
	    self.collection(function(err, collection) {
	      if(err!==null) {
	        err.message = "at collection: " + err.message;
	        return callback(err);
	      }
	
	      collection.remove({'_id':self.fileId}, self.writeConcern, function(err) {
	        callback(err, self);
	      });
	    });
	  });
	}
	
	define.classMethod('unlink', {callback: true, promise:true});
	
	/**
	 * Retrieves the file collection associated with this object.
	 *
	 * @method
	 * @param {GridStore~collectionCallback} callback the command callback.
	 * @return {Collection}
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.collection = function(callback) {
	  if(typeof callback == 'function')
	    this.db.collection(this.root + ".files", callback);
	  return this.db.collection(this.root + ".files");
	};
	
	define.classMethod('collection', {callback: true, promise:false, returns: [Collection]});
	
	/**
	 * The readlines callback format.
	 * @callback GridStore~readlinesCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {string[]} strings The array of strings returned.
	 */
	
	/**
	 * Read the entire file as a list of strings splitting by the provided separator.
	 *
	 * @method
	 * @param {string} [separator] The character to be recognized as the newline separator.
	 * @param {GridStore~readlinesCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.readlines = function(separator, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  separator = args.length ? args.shift() : "\n";
	  separator = separator || "\n";
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return readlines(self, separator, callback);
	
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    readlines(self, separator, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var readlines = function(self, separator, callback) {
	  self.read(function(err, data) {
	    if(err) return callback(err);
	
	    var items = data.toString().split(separator);
	    items = items.length > 0 ? items.splice(0, items.length - 1) : [];
	    for(var i = 0; i < items.length; i++) {
	      items[i] = items[i] + separator;
	    }
	
	    callback(null, items);
	  });
	}
	
	define.classMethod('readlines', {callback: true, promise:true});
	
	/**
	 * Deletes all the chunks of this file in the database if mode was set to "w" or
	 * "w+" and resets the read/write head to the initial position.
	 *
	 * @method
	 * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.rewind = function(callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return rewind(self, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    rewind(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var rewind = function(self, callback) {
	  if(self.currentChunk.chunkNumber != 0) {
	    if(self.mode[0] == "w") {
	      deleteChunks(self, function(err, gridStore) {
	        if(err) return callback(err);
	        self.currentChunk = new Chunk(self, {'n': 0}, self.writeConcern);
	        self.position = 0;
	        callback(null, self);
	      });
	    } else {
	      self.currentChunk(0, function(err, chunk) {
	        if(err) return callback(err);
	        self.currentChunk = chunk;
	        self.currentChunk.rewind();
	        self.position = 0;
	        callback(null, self);
	      });
	    }
	  } else {
	    self.currentChunk.rewind();
	    self.position = 0;
	    callback(null, self);
	  }
	}
	
	define.classMethod('rewind', {callback: true, promise:true});
	
	/**
	 * The read callback format.
	 * @callback GridStore~readCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Buffer} data The data read from the GridStore object
	 */
	
	/**
	 * Retrieves the contents of this file and advances the read/write head. Works with Buffers only.
	 *
	 * There are 3 signatures for this method:
	 *
	 * (callback)
	 * (length, callback)
	 * (length, buffer, callback)
	 *
	 * @method
	 * @param {number} [length] the number of characters to read. Reads all the characters from the read/write head to the EOF if not specified.
	 * @param {(string|Buffer)} [buffer] a string to hold temporary data. This is used for storing the string data read so far when recursively calling this method.
	 * @param {GridStore~readCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.read = function(length, buffer, callback) {
	  var self = this;
	
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  length = args.length ? args.shift() : null;
	  buffer = args.length ? args.shift() : null;
	  // We provided a callback leg
	  if(typeof callback == 'function') return read(self, length, buffer, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    read(self, length, buffer, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	}
	
	var read = function(self, length, buffer, callback) {
	  // The data is a c-terminated string and thus the length - 1
	  var finalLength = length == null ? self.length - self.position : length;
	  var finalBuffer = buffer == null ? new Buffer(finalLength) : buffer;
	  // Add a index to buffer to keep track of writing position or apply current index
	  finalBuffer._index = buffer != null && buffer._index != null ? buffer._index : 0;
	
	  if((self.currentChunk.length() - self.currentChunk.position + finalBuffer._index) >= finalLength) {
	    var slice = self.currentChunk.readSlice(finalLength - finalBuffer._index);
	    // Copy content to final buffer
	    slice.copy(finalBuffer, finalBuffer._index);
	    // Update internal position
	    self.position = self.position + finalBuffer.length;
	    // Check if we don't have a file at all
	    if(finalLength == 0 && finalBuffer.length == 0) return callback(MongoError.create({message: "File does not exist", driver:true}), null);
	    // Else return data
	    return callback(null, finalBuffer);
	  }
	
	  // Read the next chunk
	  var slice = self.currentChunk.readSlice(self.currentChunk.length() - self.currentChunk.position);
	  // Copy content to final buffer
	  slice.copy(finalBuffer, finalBuffer._index);
	  // Update index position
	  finalBuffer._index += slice.length;
	
	  // Load next chunk and read more
	  nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) {
	    if(err) return callback(err);
	
	    if(chunk.length() > 0) {
	      self.currentChunk = chunk;
	      self.read(length, finalBuffer, callback);
	    } else {
	      if(finalBuffer._index > 0) {
	        callback(null, finalBuffer)
	      } else {
	        callback(MongoError.create({message: "no chunks found for file, possibly corrupt", driver:true}), null);
	      }
	    }
	  });
	}
	
	define.classMethod('read', {callback: true, promise:true});
	
	/**
	 * The tell callback format.
	 * @callback GridStore~tellCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {number} position The current read position in the GridStore.
	 */
	
	/**
	 * Retrieves the position of the read/write head of this file.
	 *
	 * @method
	 * @param {number} [length] the number of characters to read. Reads all the characters from the read/write head to the EOF if not specified.
	 * @param {(string|Buffer)} [buffer] a string to hold temporary data. This is used for storing the string data read so far when recursively calling this method.
	 * @param {GridStore~tellCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.tell = function(callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return callback(null, this.position);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    resolve(self.position);
	  });
	};
	
	define.classMethod('tell', {callback: true, promise:true});
	
	/**
	 * The tell callback format.
	 * @callback GridStore~gridStoreCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {GridStore} gridStore The gridStore.
	 */
	
	/**
	 * Moves the read/write head to a new location.
	 *
	 * There are 3 signatures for this method
	 *
	 * Seek Location Modes
	 *  - **GridStore.IO_SEEK_SET**, **(default)** set the position from the start of the file.
	 *  - **GridStore.IO_SEEK_CUR**, set the position from the current position in the file.
	 *  - **GridStore.IO_SEEK_END**, set the position from the end of the file.
	 *
	 * @method
	 * @param {number} [position] the position to seek to
	 * @param {number} [seekLocation] seek mode. Use one of the Seek Location modes.
	 * @param {GridStore~gridStoreCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.seek = function(position, seekLocation, callback) {
	  var self = this;
	
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  seekLocation = args.length ? args.shift() : null;
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return seek(self, position, seekLocation, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    seek(self, position, seekLocation, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	}
	
	var seek = function(self, position, seekLocation, callback) {
	  // Seek only supports read mode
	  if(self.mode != 'r') {
	    return callback(MongoError.create({message: "seek is only supported for mode r", driver:true}))
	  }
	
	  var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;
	  var finalPosition = position;
	  var targetPosition = 0;
	
	  // Calculate the position
	  if(seekLocationFinal == GridStore.IO_SEEK_CUR) {
	    targetPosition = self.position + finalPosition;
	  } else if(seekLocationFinal == GridStore.IO_SEEK_END) {
	    targetPosition = self.length + finalPosition;
	  } else {
	    targetPosition = finalPosition;
	  }
	
	  // Get the chunk
	  var newChunkNumber = Math.floor(targetPosition/self.chunkSize);
	  var seekChunk = function() {
	    nthChunk(self, newChunkNumber, function(err, chunk) {
	      if(err) return callback(err, null);
	      if(chunk == null) return callback(new Error('no chunk found'));
	
	      // Set the current chunk
	      self.currentChunk = chunk;
	      self.position = targetPosition;
	      self.currentChunk.position = (self.position % self.chunkSize);
	      callback(err, self);
	    });
	  };
	
	  seekChunk();
	}
	
	define.classMethod('seek', {callback: true, promise:true});
	
	/**
	 * @ignore
	 */
	var _open = function(self, options, callback) {
	  var collection = self.collection();
	  // Create the query
	  var query = self.referenceBy == REFERENCE_BY_ID ? {_id:self.fileId} : {filename:self.filename};
	  query = null == self.fileId && self.filename == null ? null : query;
	  options.readPreference = self.readPreference;
	
	  // Fetch the chunks
	  if(query != null) {
	    collection.findOne(query, options, function(err, doc) {
	      if(err) return error(err);
	
	      // Check if the collection for the files exists otherwise prepare the new one
	      if(doc != null) {
	        self.fileId = doc._id;
	        // Prefer a new filename over the existing one if this is a write
	        self.filename = ((self.mode == 'r') || (self.filename == undefined)) ? doc.filename : self.filename;
	        self.contentType = doc.contentType;
	        self.internalChunkSize = doc.chunkSize;
	        self.uploadDate = doc.uploadDate;
	        self.aliases = doc.aliases;
	        self.length = doc.length;
	        self.metadata = doc.metadata;
	        self.internalMd5 = doc.md5;
	      } else if (self.mode != 'r') {
	        self.fileId = self.fileId == null ? new ObjectID() : self.fileId;
	        self.contentType = GridStore.DEFAULT_CONTENT_TYPE;
	        self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
	        self.length = 0;
	      } else {
	        self.length = 0;
	        var txtId = self.fileId instanceof ObjectID ? self.fileId.toHexString() : self.fileId;
	        return error(MongoError.create({message: f("file with id %s not opened for writing", (self.referenceBy == REFERENCE_BY_ID ? txtId : self.filename)), driver:true}), self);
	      }
	
	      // Process the mode of the object
	      if(self.mode == "r") {
	        nthChunk(self, 0, options, function(err, chunk) {
	          if(err) return error(err);
	          self.currentChunk = chunk;
	          self.position = 0;
	          callback(null, self);
	        });
	      } else if(self.mode == "w" && doc) {
	        // Delete any existing chunks
	        deleteChunks(self, options, function(err, result) {
	          if(err) return error(err);
	          self.currentChunk = new Chunk(self, {'n':0}, self.writeConcern);
	          self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];
	          self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
	          self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
	          self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
	          self.position = 0;
	          callback(null, self);
	        });
	      } else if(self.mode == "w") {
	        self.currentChunk = new Chunk(self, {'n':0}, self.writeConcern);
	        self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];
	        self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
	        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
	        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
	        self.position = 0;
	        callback(null, self);
	      } else if(self.mode == "w+") {
	        nthChunk(self, lastChunkNumber(self), options, function(err, chunk) {
	          if(err) return error(err);
	          // Set the current chunk
	          self.currentChunk = chunk == null ? new Chunk(self, {'n':0}, self.writeConcern) : chunk;
	          self.currentChunk.position = self.currentChunk.data.length();
	          self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
	          self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
	          self.position = self.length;
	          callback(null, self);
	        });
	      }
	    });
	  } else {
	    // Write only mode
	    self.fileId = null == self.fileId ? new ObjectID() : self.fileId;
	    self.contentType = GridStore.DEFAULT_CONTENT_TYPE;
	    self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
	    self.length = 0;
	
	    var collection2 = self.chunkCollection();
	    // No file exists set up write mode
	    if(self.mode == "w") {
	      // Delete any existing chunks
	      deleteChunks(self, options, function(err, result) {
	        if(err) return error(err);
	        self.currentChunk = new Chunk(self, {'n':0}, self.writeConcern);
	        self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];
	        self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
	        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
	        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
	        self.position = 0;
	        callback(null, self);
	      });
	    } else if(self.mode == "w+") {
	      nthChunk(self, lastChunkNumber(self), options, function(err, chunk) {
	        if(err) return error(err);
	        // Set the current chunk
	        self.currentChunk = chunk == null ? new Chunk(self, {'n':0}, self.writeConcern) : chunk;
	        self.currentChunk.position = self.currentChunk.data.length();
	        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
	        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
	        self.position = self.length;
	        callback(null, self);
	      });
	    }
	  }
	
	  // only pass error to callback once
	  function error (err) {
	    if(error.err) return;
	    callback(error.err = err);
	  }
	};
	
	/**
	 * @ignore
	 */
	var writeBuffer = function(self, buffer, close, callback) {
	  if(typeof close === "function") { callback = close; close = null; }
	  var finalClose = typeof close == 'boolean' ? close : false;
	
	  if(self.mode != "w") {
	    callback(MongoError.create({message: f("file with id %s not opened for writing", (self.referenceBy == REFERENCE_BY_ID ? self.referenceBy : self.filename)), driver:true}), null);
	  } else {
	    if(self.currentChunk.position + buffer.length >= self.chunkSize) {
	      // Write out the current Chunk and then keep writing until we have less data left than a chunkSize left
	      // to a new chunk (recursively)
	      var previousChunkNumber = self.currentChunk.chunkNumber;
	      var leftOverDataSize = self.chunkSize - self.currentChunk.position;
	      var firstChunkData = buffer.slice(0, leftOverDataSize);
	      var leftOverData = buffer.slice(leftOverDataSize);
	      // A list of chunks to write out
	      var chunksToWrite = [self.currentChunk.write(firstChunkData)];
	      // If we have more data left than the chunk size let's keep writing new chunks
	      while(leftOverData.length >= self.chunkSize) {
	        // Create a new chunk and write to it
	        var newChunk = new Chunk(self, {'n': (previousChunkNumber + 1)}, self.writeConcern);
	        var firstChunkData = leftOverData.slice(0, self.chunkSize);
	        leftOverData = leftOverData.slice(self.chunkSize);
	        // Update chunk number
	        previousChunkNumber = previousChunkNumber + 1;
	        // Write data
	        newChunk.write(firstChunkData);
	        // Push chunk to save list
	        chunksToWrite.push(newChunk);
	      }
	
	      // Set current chunk with remaining data
	      self.currentChunk = new Chunk(self, {'n': (previousChunkNumber + 1)}, self.writeConcern);
	      // If we have left over data write it
	      if(leftOverData.length > 0) self.currentChunk.write(leftOverData);
	
	      // Update the position for the gridstore
	      self.position = self.position + buffer.length;
	      // Total number of chunks to write
	      var numberOfChunksToWrite = chunksToWrite.length;
	
	      for(var i = 0; i < chunksToWrite.length; i++) {
	        chunksToWrite[i].save({}, function(err, result) {
	          if(err) return callback(err);
	
	          numberOfChunksToWrite = numberOfChunksToWrite - 1;
	
	          if(numberOfChunksToWrite <= 0) {
	            // We care closing the file before returning
	            if(finalClose) {
	              return self.close(function(err, result) {
	                callback(err, self);
	              });
	            }
	
	            // Return normally
	            return callback(null, self);
	          }
	        });
	      }
	    } else {
	      // Update the position for the gridstore
	      self.position = self.position + buffer.length;
	      // We have less data than the chunk size just write it and callback
	      self.currentChunk.write(buffer);
	      // We care closing the file before returning
	      if(finalClose) {
	        return self.close(function(err, result) {
	          callback(err, self);
	        });
	      }
	      // Return normally
	      return callback(null, self);
	    }
	  }
	};
	
	/**
	 * Creates a mongoDB object representation of this object.
	 *
	 *        <pre><code>
	 *        {
	 *          '_id' : , // {number} id for this file
	 *          'filename' : , // {string} name for this file
	 *          'contentType' : , // {string} mime type for this file
	 *          'length' : , // {number} size of this file?
	 *          'chunksize' : , // {number} chunk size used by this file
	 *          'uploadDate' : , // {Date}
	 *          'aliases' : , // {array of string}
	 *          'metadata' : , // {string}
	 *        }
	 *        </code></pre>
	 *
	 * @ignore
	 */
	var buildMongoObject = function(self, callback) {
	  // Calcuate the length
	  var mongoObject = {
	    '_id': self.fileId,
	    'filename': self.filename,
	    'contentType': self.contentType,
	    'length': self.position ? self.position : 0,
	    'chunkSize': self.chunkSize,
	    'uploadDate': self.uploadDate,
	    'aliases': self.aliases,
	    'metadata': self.metadata
	  };
	
	  var md5Command = {filemd5:self.fileId, root:self.root};
	  self.db.command(md5Command, function(err, results) {
	    if(err) return callback(err);
	
	    mongoObject.md5 = results.md5;
	    callback(null, mongoObject);
	  });
	};
	
	/**
	 * Gets the nth chunk of this file.
	 * @ignore
	 */
	var nthChunk = function(self, chunkNumber, options, callback) {
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  options = options || self.writeConcern;
	  options.readPreference = self.readPreference;
	  // Get the nth chunk
	  self.chunkCollection().findOne({'files_id':self.fileId, 'n':chunkNumber}, options, function(err, chunk) {
	    if(err) return callback(err);
	
	    var finalChunk = chunk == null ? {} : chunk;
	    callback(null, new Chunk(self, finalChunk, self.writeConcern));
	  });
	};
	
	/**
	 * @ignore
	 */
	var lastChunkNumber = function(self) {
	  return Math.floor((self.length ? self.length - 1 : 0)/self.chunkSize);
	};
	
	/**
	 * Deletes all the chunks of this file in the database.
	 *
	 * @ignore
	 */
	var deleteChunks = function(self, options, callback) {
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  options = options || self.writeConcern;
	
	  if(self.fileId != null) {
	    self.chunkCollection().remove({'files_id':self.fileId}, options, function(err, result) {
	      if(err) return callback(err, false);
	      callback(null, true);
	    });
	  } else {
	    callback(null, true);
	  }
	};
	
	/**
	* The collection to be used for holding the files and chunks collection.
	*
	* @classconstant DEFAULT_ROOT_COLLECTION
	**/
	GridStore.DEFAULT_ROOT_COLLECTION = 'fs';
	
	/**
	* Default file mime type
	*
	* @classconstant DEFAULT_CONTENT_TYPE
	**/
	GridStore.DEFAULT_CONTENT_TYPE = 'binary/octet-stream';
	
	/**
	* Seek mode where the given length is absolute.
	*
	* @classconstant IO_SEEK_SET
	**/
	GridStore.IO_SEEK_SET = 0;
	
	/**
	* Seek mode where the given length is an offset to the current read/write head.
	*
	* @classconstant IO_SEEK_CUR
	**/
	GridStore.IO_SEEK_CUR = 1;
	
	/**
	* Seek mode where the given length is an offset to the end of the file.
	*
	* @classconstant IO_SEEK_END
	**/
	GridStore.IO_SEEK_END = 2;
	
	/**
	 * Checks if a file exists in the database.
	 *
	 * @method
	 * @static
	 * @param {Db} db the database to query.
	 * @param {string} name The name of the file to look for.
	 * @param {string} [rootCollection] The root collection that holds the files and chunks collection. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {GridStore~resultCallback} [callback] result from exists.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.exist = function(db, fileIdObject, rootCollection, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  rootCollection = args.length ? args.shift() : null;
	  options = args.length ? args.shift() : {};
	  options = options || {};
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(198).Promise;
	  }
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return exists(db, fileIdObject, rootCollection, options, callback);
	  // Return promise
	  return new promiseLibrary(function(resolve, reject) {
	    exists(db, fileIdObject, rootCollection, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var exists = function(db, fileIdObject, rootCollection, options, callback) {
	  // Establish read preference
	  var readPreference = options.readPreference || ReadPreference.PRIMARY;
	  // Fetch collection
	  var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
	  db.collection(rootCollectionFinal + ".files", function(err, collection) {
	    if(err) return callback(err);
	
	    // Build query
	    var query = (typeof fileIdObject == 'string' || Object.prototype.toString.call(fileIdObject) == '[object RegExp]' )
	      ? {'filename':fileIdObject}
	      : {'_id':fileIdObject};    // Attempt to locate file
	
	    // We have a specific query
	    if(fileIdObject != null
	      && typeof fileIdObject == 'object'
	      && Object.prototype.toString.call(fileIdObject) != '[object RegExp]') {
	      query = fileIdObject;
	    }
	
	    // Check if the entry exists
	    collection.findOne(query, {readPreference:readPreference}, function(err, item) {
	      if(err) return callback(err);
	      callback(null, item == null ? false : true);
	    });
	  });
	}
	
	define.staticMethod('exist', {callback: true, promise:true});
	
	/**
	 * Gets the list of files stored in the GridFS.
	 *
	 * @method
	 * @static
	 * @param {Db} db the database to query.
	 * @param {string} [rootCollection] The root collection that holds the files and chunks collection. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {GridStore~resultCallback} [callback] result from exists.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.list = function(db, rootCollection, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  rootCollection = args.length ? args.shift() : null;
	  options = args.length ? args.shift() : {};
	  options = options || {};
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(198).Promise;
	  }
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return list(db, rootCollection, options, callback);
	  // Return promise
	  return new promiseLibrary(function(resolve, reject) {
	    list(db, rootCollection, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var list = function(db, rootCollection, options, callback) {
	  // Ensure we have correct values
	  if(rootCollection != null && typeof rootCollection == 'object') {
	    options = rootCollection;
	    rootCollection = null;
	  }
	
	  // Establish read preference
	  var readPreference = options.readPreference || ReadPreference.PRIMARY;
	  // Check if we are returning by id not filename
	  var byId = options['id'] != null ? options['id'] : false;
	  // Fetch item
	  var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
	  var items = [];
	  db.collection((rootCollectionFinal + ".files"), function(err, collection) {
	    if(err) return callback(err);
	
	    collection.find({}, {readPreference:readPreference}, function(err, cursor) {
	      if(err) return callback(err);
	
	      cursor.each(function(err, item) {
	        if(item != null) {
	          items.push(byId ? item._id : item.filename);
	        } else {
	          callback(err, items);
	        }
	      });
	    });
	  });
	}
	
	define.staticMethod('list', {callback: true, promise:true});
	
	/**
	 * Reads the contents of a file.
	 *
	 * This method has the following signatures
	 *
	 * (db, name, callback)
	 * (db, name, length, callback)
	 * (db, name, length, offset, callback)
	 * (db, name, length, offset, options, callback)
	 *
	 * @method
	 * @static
	 * @param {Db} db the database to query.
	 * @param {string} name The name of the file.
	 * @param {number} [length] The size of data to read.
	 * @param {number} [offset] The offset from the head of the file of which to start reading from.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {GridStore~readCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.read = function(db, name, length, offset, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  length = args.length ? args.shift() : null;
	  offset = args.length ? args.shift() : null;
	  options = args.length ? args.shift() : null;
	  options = options || {};
	
	  // Get the promiseLibrary
	  var promiseLibrary = options ? options.promiseLibrary : null;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(198).Promise;
	  }
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return readStatic(db, name, length, offset, options, callback);
	  // Return promise
	  return new promiseLibrary(function(resolve, reject) {
	    readStatic(db, name, length, offset, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var readStatic = function(db, name, length, offset, options, callback) {
	  new GridStore(db, name, "r", options).open(function(err, gridStore) {
	    if(err) return callback(err);
	    // Make sure we are not reading out of bounds
	    if(offset && offset >= gridStore.length) return callback("offset larger than size of file", null);
	    if(length && length > gridStore.length) return callback("length is larger than the size of the file", null);
	    if(offset && length && (offset + length) > gridStore.length) return callback("offset and length is larger than the size of the file", null);
	
	    if(offset != null) {
	      gridStore.seek(offset, function(err, gridStore) {
	        if(err) return callback(err);
	        gridStore.read(length, callback);
	      });
	    } else {
	      gridStore.read(length, callback);
	    }
	  });
	}
	
	define.staticMethod('read', {callback: true, promise:true});
	
	/**
	 * Read the entire file as a list of strings splitting by the provided separator.
	 *
	 * @method
	 * @static
	 * @param {Db} db the database to query.
	 * @param {(String|object)} name the name of the file.
	 * @param {string} [separator] The character to be recognized as the newline separator.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {GridStore~readlinesCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.readlines = function(db, name, separator, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  separator = args.length ? args.shift() : null;
	  options = args.length ? args.shift() : null;
	  options = options || {};
	
	  // Get the promiseLibrary
	  var promiseLibrary = options ? options.promiseLibrary : null;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(198).Promise;
	  }
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return readlinesStatic(db, name, separator, options, callback);
	  // Return promise
	  return new promiseLibrary(function(resolve, reject) {
	    readlinesStatic(db, name, separator, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var readlinesStatic = function(db, name, separator, options, callback) {
	  var finalSeperator = separator == null ? "\n" : separator;
	  new GridStore(db, name, "r", options).open(function(err, gridStore) {
	    if(err) return callback(err);
	    gridStore.readlines(finalSeperator, callback);
	  });
	}
	
	define.staticMethod('readlines', {callback: true, promise:true});
	
	/**
	 * Deletes the chunks and metadata information of a file from GridFS.
	 *
	 * @method
	 * @static
	 * @param {Db} db The database to query.
	 * @param {(string|array)} names The name/names of the files to delete.
	 * @param {object} [options=null] Optional settings.
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {GridStore~resultCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.unlink = function(db, names, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() : {};
	  options = options || {};
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(198).Promise;
	  }
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return unlinkStatic(self, db, names, options, callback);
	
	  // Return promise
	  return new promiseLibrary(function(resolve, reject) {
	    unlinkStatic(self, db, names, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var unlinkStatic = function(self, db, names, options, callback) {
	  // Get the write concern
	  var writeConcern = _getWriteConcern(db, options);
	
	  // List of names
	  if(names.constructor == Array) {
	    var tc = 0;
	    for(var i = 0; i < names.length; i++) {
	      ++tc;
	      GridStore.unlink(db, names[i], options, function(result) {
	        if(--tc == 0) {
	            callback(null, self);
	        }
	      });
	    }
	  } else {
	    new GridStore(db, names, "w", options).open(function(err, gridStore) {
	      if(err) return callback(err);
	      deleteChunks(gridStore, function(err, result) {
	        if(err) return callback(err);
	        gridStore.collection(function(err, collection) {
	          if(err) return callback(err);
	          collection.remove({'_id':gridStore.fileId}, writeConcern, function(err, result) {
	            callback(err, self);
	          });
	        });
	      });
	    });
	  }
	}
	
	define.staticMethod('unlink', {callback: true, promise:true});
	
	/**
	 *  @ignore
	 */
	var _writeNormal = function(self, data, close, callback) {
	  // If we have a buffer write it using the writeBuffer method
	  if(Buffer.isBuffer(data)) {
	    return writeBuffer(self, data, close, callback);
	  } else {
	    return writeBuffer(self, new Buffer(data, 'binary'), close, callback);
	  }
	}
	
	/**
	 * @ignore
	 */
	var _setWriteConcernHash = function(options) {
	  var finalOptions = {};
	  if(options.w != null) finalOptions.w = options.w;
	  if(options.journal == true) finalOptions.j = options.journal;
	  if(options.j == true) finalOptions.j = options.j;
	  if(options.fsync == true) finalOptions.fsync = options.fsync;
	  if(options.wtimeout != null) finalOptions.wtimeout = options.wtimeout;
	  return finalOptions;
	}
	
	/**
	 * @ignore
	 */
	var _getWriteConcern = function(self, options) {
	  // Final options
	  var finalOptions = {w:1};
	  options = options || {};
	
	  // Local options verification
	  if(options.w != null || typeof options.j == 'boolean' || typeof options.journal == 'boolean' || typeof options.fsync == 'boolean') {
	    finalOptions = _setWriteConcernHash(options);
	  } else if(options.safe != null && typeof options.safe == 'object') {
	    finalOptions = _setWriteConcernHash(options.safe);
	  } else if(typeof options.safe == "boolean") {
	    finalOptions = {w: (options.safe ? 1 : 0)};
	  } else if(self.options.w != null || typeof self.options.j == 'boolean' || typeof self.options.journal == 'boolean' || typeof self.options.fsync == 'boolean') {
	    finalOptions = _setWriteConcernHash(self.options);
	  } else if(self.safe && (self.safe.w != null || typeof self.safe.j == 'boolean' || typeof self.safe.journal == 'boolean' || typeof self.safe.fsync == 'boolean')) {
	    finalOptions = _setWriteConcernHash(self.safe);
	  } else if(typeof self.safe == "boolean") {
	    finalOptions = {w: (self.safe ? 1 : 0)};
	  }
	
	  // Ensure we don't have an invalid combination of write concerns
	  if(finalOptions.w < 1
	    && (finalOptions.journal == true || finalOptions.j == true || finalOptions.fsync == true)) throw MongoError.create({message: "No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true", driver:true});
	
	  // Return the options
	  return finalOptions;
	}
	
	/**
	 * Create a new GridStoreStream instance (INTERNAL TYPE, do not instantiate directly)
	 *
	 * @class
	 * @extends external:Duplex
	 * @return {GridStoreStream} a GridStoreStream instance.
	 * @deprecated Use GridFSBucket API instead
	 */
	var GridStoreStream = function(gs) {
	  var self = this;
	  // Initialize the duplex stream
	  Duplex.call(this);
	
	  // Get the gridstore
	  this.gs = gs;
	
	  // End called
	  this.endCalled = false;
	
	  // If we have a seek
	  this.totalBytesToRead = this.gs.length - this.gs.position;
	  this.seekPosition = this.gs.position;
	}
	
	//
	// Inherit duplex
	inherits(GridStoreStream, Duplex);
	
	GridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe;
	
	// Set up override
	GridStoreStream.prototype.pipe = function(destination) {
	  var self = this;
	
	  // Only open gridstore if not already open
	  if(!self.gs.isOpen) {
	    self.gs.open(function(err) {
	      if(err) return self.emit('error', err);
	      self.totalBytesToRead = self.gs.length - self.gs.position;
	      self._pipe.apply(self, [destination]);
	    });
	  } else {
	    self.totalBytesToRead = self.gs.length - self.gs.position;
	    self._pipe.apply(self, [destination]);
	  }
	
	  return destination;
	}
	
	// Called by stream
	GridStoreStream.prototype._read = function(n) {
	  var self = this;
	
	  var read = function() {
	    // Read data
	    self.gs.read(length, function(err, buffer) {
	      if(err && !self.endCalled) return self.emit('error', err);
	
	      // Stream is closed
	      if(self.endCalled || buffer == null) return self.push(null);
	      // Remove bytes read
	      if(buffer.length <= self.totalBytesToRead) {
	        self.totalBytesToRead = self.totalBytesToRead - buffer.length;
	        self.push(buffer);
	      } else if(buffer.length > self.totalBytesToRead) {
	        self.totalBytesToRead = self.totalBytesToRead - buffer._index;
	        self.push(buffer.slice(0, buffer._index));
	      }
	
	      // Finished reading
	      if(self.totalBytesToRead <= 0) {
	        self.endCalled = true;
	      }
	    });
	  }
	
	  // Set read length
	  var length = self.gs.length < self.gs.chunkSize ? self.gs.length - self.seekPosition : self.gs.chunkSize;
	  if(!self.gs.isOpen) {
	    self.gs.open(function(err, gs) {
	      self.totalBytesToRead = self.gs.length - self.gs.position;
	      if(err) return self.emit('error', err);
	      read();
	    });
	  } else {
	    read();
	  }
	}
	
	GridStoreStream.prototype.destroy = function() {
	  this.pause();
	  this.endCalled = true;
	  this.gs.close();
	  this.emit('end');
	}
	
	GridStoreStream.prototype.write = function(chunk, encoding, callback) {
	  var self = this;
	  if(self.endCalled) return self.emit('error', MongoError.create({message: 'attempting to write to stream after end called', driver:true}))
	  // Do we have to open the gridstore
	  if(!self.gs.isOpen) {
	    self.gs.open(function() {
	      self.gs.isOpen = true;
	      self.gs.write(chunk, function() {
	        process.nextTick(function() {
	          self.emit('drain');
	        });
	      });
	    });
	    return false;
	  } else {
	    self.gs.write(chunk, function() {
	      self.emit('drain');
	    });
	    return true;
	  }
	}
	
	GridStoreStream.prototype.end = function(chunk, encoding, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  chunk = args.length ? args.shift() : null;
	  encoding = args.length ? args.shift() : null;
	  self.endCalled = true;
	
	  if(chunk) {
	    self.gs.write(chunk, function() {
	      self.gs.close(function() {
	        if(typeof callback == 'function') callback();
	        self.emit('end')
	      });
	    });
	  }
	
	  self.gs.close(function() {
	    if(typeof callback == 'function') callback();
	    self.emit('end')
	  });
	}
	
	/**
	 * The read() method pulls some data out of the internal buffer and returns it. If there is no data available, then it will return null.
	 * @function external:Duplex#read
	 * @param {number} size Optional argument to specify how much data to read.
	 * @return {(String | Buffer | null)}
	 */
	
	/**
	 * Call this function to cause the stream to return strings of the specified encoding instead of Buffer objects.
	 * @function external:Duplex#setEncoding
	 * @param {string} encoding The encoding to use.
	 * @return {null}
	 */
	
	/**
	 * This method will cause the readable stream to resume emitting data events.
	 * @function external:Duplex#resume
	 * @return {null}
	 */
	
	/**
	 * This method will cause a stream in flowing-mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.
	 * @function external:Duplex#pause
	 * @return {null}
	 */
	
	/**
	 * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.
	 * @function external:Duplex#pipe
	 * @param {Writable} destination The destination for writing data
	 * @param {object} [options] Pipe options
	 * @return {null}
	 */
	
	/**
	 * This method will remove the hooks set up for a previous pipe() call.
	 * @function external:Duplex#unpipe
	 * @param {Writable} [destination] The destination for writing data
	 * @return {null}
	 */
	
	/**
	 * This is useful in certain cases where a stream is being consumed by a parser, which needs to "un-consume" some data that it has optimistically pulled out of the source, so that the stream can be passed on to some other party.
	 * @function external:Duplex#unshift
	 * @param {(Buffer|string)} chunk Chunk of data to unshift onto the read queue.
	 * @return {null}
	 */
	
	/**
	 * Versions of Node prior to v0.10 had streams that did not implement the entire Streams API as it is today. (See "Compatibility" below for more information.)
	 * @function external:Duplex#wrap
	 * @param {Stream} stream An "old style" readable stream.
	 * @return {null}
	 */
	
	/**
	 * This method writes some data to the underlying system, and calls the supplied callback once the data has been fully handled.
	 * @function external:Duplex#write
	 * @param {(string|Buffer)} chunk The data to write
	 * @param {string} encoding The encoding, if chunk is a String
	 * @param {function} callback Callback for when this chunk of data is flushed
	 * @return {boolean}
	 */
	
	/**
	 * Call this method when no more data will be written to the stream. If supplied, the callback is attached as a listener on the finish event.
	 * @function external:Duplex#end
	 * @param {(string|Buffer)} chunk The data to write
	 * @param {string} encoding The encoding, if chunk is a String
	 * @param {function} callback Callback for when this chunk of data is flushed
	 * @return {null}
	 */
	
	/**
	 * GridStoreStream stream data event, fired for each document in the cursor.
	 *
	 * @event GridStoreStream#data
	 * @type {object}
	 */
	
	/**
	 * GridStoreStream stream end event
	 *
	 * @event GridStoreStream#end
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream close event
	 *
	 * @event GridStoreStream#close
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream readable event
	 *
	 * @event GridStoreStream#readable
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream drain event
	 *
	 * @event GridStoreStream#drain
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream finish event
	 *
	 * @event GridStoreStream#finish
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream pipe event
	 *
	 * @event GridStoreStream#pipe
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream unpipe event
	 *
	 * @event GridStoreStream#unpipe
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream error event
	 *
	 * @event GridStoreStream#error
	 * @type {null}
	 */
	
	/**
	 * @ignore
	 */
	module.exports = GridStore;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(6)))

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";
	
	var Binary = __webpack_require__(156).BSON.Binary,
	  ObjectID = __webpack_require__(156).BSON.ObjectID;
	
	/**
	 * Class for representing a single chunk in GridFS.
	 *
	 * @class
	 *
	 * @param file {GridStore} The {@link GridStore} object holding this chunk.
	 * @param mongoObject {object} The mongo object representation of this chunk.
	 *
	 * @throws Error when the type of data field for {@link mongoObject} is not
	 *     supported. Currently supported types for data field are instances of
	 *     {@link String}, {@link Array}, {@link Binary} and {@link Binary}
	 *     from the bson module
	 *
	 * @see Chunk#buildMongoObject
	 */
	var Chunk = function(file, mongoObject, writeConcern) {
	  if(!(this instanceof Chunk)) return new Chunk(file, mongoObject);
	
	  this.file = file;
	  var self = this;
	  var mongoObjectFinal = mongoObject == null ? {} : mongoObject;
	  this.writeConcern = writeConcern || {w:1};
	  this.objectId = mongoObjectFinal._id == null ? new ObjectID() : mongoObjectFinal._id;
	  this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
	  this.data = new Binary();
	
	  if(mongoObjectFinal.data == null) {
	  } else if(typeof mongoObjectFinal.data == "string") {
	    var buffer = new Buffer(mongoObjectFinal.data.length);
	    buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, 'binary');
	    this.data = new Binary(buffer);
	  } else if(Array.isArray(mongoObjectFinal.data)) {
	    var buffer = new Buffer(mongoObjectFinal.data.length);
	    var data = mongoObjectFinal.data.join('');
	    buffer.write(data, 0, data.length, 'binary');
	    this.data = new Binary(buffer);
	  } else if(mongoObjectFinal.data._bsontype === 'Binary') {
	    this.data = mongoObjectFinal.data;
	  } else if(Buffer.isBuffer(mongoObjectFinal.data)) {
	  } else {
	    throw Error("Illegal chunk format");
	  }
	
	  // Update position
	  this.internalPosition = 0;
	};
	
	/**
	 * Writes a data to this object and advance the read/write head.
	 *
	 * @param data {string} the data to write
	 * @param callback {function(*, GridStore)} This will be called after executing
	 *     this method. The first parameter will contain null and the second one
	 *     will contain a reference to this object.
	 */
	Chunk.prototype.write = function(data, callback) {
	  this.data.write(data, this.internalPosition, data.length, 'binary');
	  this.internalPosition = this.data.length();
	  if(callback != null) return callback(null, this);
	  return this;
	};
	
	/**
	 * Reads data and advances the read/write head.
	 *
	 * @param length {number} The length of data to read.
	 *
	 * @return {string} The data read if the given length will not exceed the end of
	 *     the chunk. Returns an empty String otherwise.
	 */
	Chunk.prototype.read = function(length) {
	  // Default to full read if no index defined
	  length = length == null || length == 0 ? this.length() : length;
	
	  if(this.length() - this.internalPosition + 1 >= length) {
	    var data = this.data.read(this.internalPosition, length);
	    this.internalPosition = this.internalPosition + length;
	    return data;
	  } else {
	    return '';
	  }
	};
	
	Chunk.prototype.readSlice = function(length) {
	  if ((this.length() - this.internalPosition) >= length) {
	    var data = null;
	    if (this.data.buffer != null) { //Pure BSON
	      data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);
	    } else { //Native BSON
	      data = new Buffer(length);
	      length = this.data.readInto(data, this.internalPosition);
	    }
	    this.internalPosition = this.internalPosition + length;
	    return data;
	  } else {
	    return null;
	  }
	};
	
	/**
	 * Checks if the read/write head is at the end.
	 *
	 * @return {boolean} Whether the read/write head has reached the end of this
	 *     chunk.
	 */
	Chunk.prototype.eof = function() {
	  return this.internalPosition == this.length() ? true : false;
	};
	
	/**
	 * Reads one character from the data of this chunk and advances the read/write
	 * head.
	 *
	 * @return {string} a single character data read if the the read/write head is
	 *     not at the end of the chunk. Returns an empty String otherwise.
	 */
	Chunk.prototype.getc = function() {
	  return this.read(1);
	};
	
	/**
	 * Clears the contents of the data in this chunk and resets the read/write head
	 * to the initial position.
	 */
	Chunk.prototype.rewind = function() {
	  this.internalPosition = 0;
	  this.data = new Binary();
	};
	
	/**
	 * Saves this chunk to the database. Also overwrites existing entries having the
	 * same id as this chunk.
	 *
	 * @param callback {function(*, GridStore)} This will be called after executing
	 *     this method. The first parameter will contain null and the second one
	 *     will contain a reference to this object.
	 */
	Chunk.prototype.save = function(options, callback) {
	  var self = this;
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  self.file.chunkCollection(function(err, collection) {
	    if(err) return callback(err);
	
	    // Merge the options
	    var writeOptions = { upsert: true };
	    for(var name in options) writeOptions[name] = options[name];
	    for(var name in self.writeConcern) writeOptions[name] = self.writeConcern[name];
	
	    if(self.data.length() > 0) {
	      self.buildMongoObject(function(mongoObject) {
	        var options = {forceServerObjectId:true};
	        for(var name in self.writeConcern) {
	          options[name] = self.writeConcern[name];
	        }
	
	        collection.replaceOne({'_id':self.objectId}, mongoObject, writeOptions, function(err, collection) {
	          callback(err, self);
	        });
	      });
	    } else {
	      callback(null, self);
	    }
	    // });
	  });
	};
	
	/**
	 * Creates a mongoDB object representation of this chunk.
	 *
	 * @param callback {function(Object)} This will be called after executing this
	 *     method. The object will be passed to the first parameter and will have
	 *     the structure:
	 *
	 *        <pre><code>
	 *        {
	 *          '_id' : , // {number} id for this chunk
	 *          'files_id' : , // {number} foreign key to the file collection
	 *          'n' : , // {number} chunk number
	 *          'data' : , // {bson#Binary} the chunk data itself
	 *        }
	 *        </code></pre>
	 *
	 * @see <a href="http://www.mongodb.org/display/DOCS/GridFS+Specification#GridFSSpecification-{{chunks}}">MongoDB GridFS Chunk Object Structure</a>
	 */
	Chunk.prototype.buildMongoObject = function(callback) {
	  var mongoObject = {
	    'files_id': this.file.fileId,
	    'n': this.chunkNumber,
	    'data': this.data};
	  // If we are saving using a specific ObjectId
	  if(this.objectId != null) mongoObject._id = this.objectId;
	
	  callback(mongoObject);
	};
	
	/**
	 * @return {number} the length of the data
	 */
	Chunk.prototype.length = function() {
	  return this.data.length();
	};
	
	/**
	 * The position of the read/write head
	 * @name position
	 * @lends Chunk#
	 * @field
	 */
	Object.defineProperty(Chunk.prototype, "position", { enumerable: true
	  , get: function () {
	      return this.internalPosition;
	    }
	  , set: function(value) {
	      this.internalPosition = value;
	    }
	});
	
	/**
	 * The default chunk size
	 * @constant
	 */
	Chunk.DEFAULT_CHUNK_SIZE = 1024 * 255;
	
	module.exports = Chunk;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {"use strict";
	
	var checkCollectionName = __webpack_require__(194).checkCollectionName
	  , ObjectID = __webpack_require__(156).BSON.ObjectID
	  , Long = __webpack_require__(156).BSON.Long
	  , Code = __webpack_require__(156).BSON.Code
	  , f = __webpack_require__(77).format
	  , AggregationCursor = __webpack_require__(193)
	  , MongoError = __webpack_require__(156).MongoError
	  , shallowClone = __webpack_require__(194).shallowClone
	  , isObject = __webpack_require__(194).isObject
	  , toError = __webpack_require__(194).toError
	  , normalizeHintField = __webpack_require__(194).normalizeHintField
	  , handleCallback = __webpack_require__(194).handleCallback
	  , decorateCommand = __webpack_require__(194).decorateCommand
	  , formattedOrderClause = __webpack_require__(194).formattedOrderClause
	  , ReadPreference = __webpack_require__(195)
	  , CoreReadPreference = __webpack_require__(156).ReadPreference
	  , CommandCursor = __webpack_require__(201)
	  , Define = __webpack_require__(196)
	  , Cursor = __webpack_require__(197)
	  , unordered = __webpack_require__(204)
	  , ordered = __webpack_require__(202);
	
	/**
	 * @fileOverview The **Collection** class is an internal class that embodies a MongoDB collection
	 * allowing for insert/update/remove/find and other command operation on that MongoDB collection.
	 *
	 * **COLLECTION Cannot directly be instantiated**
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Create a collection we want to drop later
	 *   var col = db.collection('createIndexExample1');
	 *   // Show that duplicate records got dropped
	 *   col.find({}).toArray(function(err, items) {
	 *     test.equal(null, err);
	 *     test.equal(4, items.length);
	 *     db.close();
	 *   });
	 * });
	 */
	
	/**
	 * Create a new Collection instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @property {string} collectionName Get the collection name.
	 * @property {string} namespace Get the full collection namespace.
	 * @property {object} writeConcern The current write concern values.
	 * @property {object} readConcern The current read concern values.
	 * @property {object} hint Get current index hint for collection.
	 * @return {Collection} a Collection instance.
	 */
	var Collection = function(db, topology, dbName, name, pkFactory, options) {
	  checkCollectionName(name);
	  var self = this;
	  // Unpack variables
	  var internalHint = null;
	  var opts = options != null && ('object' === typeof options) ? options : {};
	  var slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;
	  var serializeFunctions = options == null || options.serializeFunctions == null ? db.serializeFunctions : options.serializeFunctions;
	  var raw = options == null || options.raw == null ? db.raw : options.raw;
	  var readPreference = null;
	  var collectionHint = null;
	  var namespace = f("%s.%s", dbName, name);
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(198).Promise;
	  }
	
	  // Assign the right collection level readPreference
	  if(options && options.readPreference) {
	    readPreference = options.readPreference;
	  } else if(db.options.readPreference) {
	    readPreference = db.options.readPreference;
	  }
	
	  // Set custom primary key factory if provided
	  pkFactory = pkFactory == null
	    ? ObjectID
	    : pkFactory;
	
	  // Internal state
	  this.s = {
	    // Set custom primary key factory if provided
	      pkFactory: pkFactory
	    // Db
	    , db: db
	    // Topology
	    , topology: topology
	    // dbName
	    , dbName: dbName
	    // Options
	    , options: options
	    // Namespace
	    , namespace: namespace
	    // Read preference
	    , readPreference: readPreference
	    // Raw
	    , raw: raw
	    // SlaveOK
	    , slaveOk: slaveOk
	    // Serialize functions
	    , serializeFunctions: serializeFunctions
	    // internalHint
	    , internalHint: internalHint
	    // collectionHint
	    , collectionHint: collectionHint
	    // Name
	    , name: name
	    // Promise library
	    , promiseLibrary: promiseLibrary
	    // Read Concern
	    , readConcern: options.readConcern
	  }
	}
	
	var define = Collection.define = new Define('Collection', Collection, false);
	
	Object.defineProperty(Collection.prototype, 'collectionName', {
	  enumerable: true, get: function() { return this.s.name; }
	});
	
	Object.defineProperty(Collection.prototype, 'namespace', {
	  enumerable: true, get: function() { return this.s.namespace; }
	});
	
	Object.defineProperty(Collection.prototype, 'readConcern', {
	  enumerable: true, get: function() { return this.s.readConcern || {level: 'local'}; }
	});
	
	Object.defineProperty(Collection.prototype, 'writeConcern', {
	  enumerable:true,
	  get: function() {
	    var ops = {};
	    if(this.s.options.w != null) ops.w = this.s.options.w;
	    if(this.s.options.j != null) ops.j = this.s.options.j;
	    if(this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
	    if(this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
	    return ops;
	  }
	});
	
	/**
	 * @ignore
	 */
	Object.defineProperty(Collection.prototype, "hint", {
	    enumerable: true
	  , get: function () { return this.s.collectionHint; }
	  , set: function (v) { this.s.collectionHint = normalizeHintField(v); }
	});
	
	/**
	 * Creates a cursor for a query that can be used to iterate over results from MongoDB
	 * @method
	 * @param {object} query The cursor query object.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Collection.prototype.find = function() {
	  var options
	    , args = Array.prototype.slice.call(arguments, 0)
	    , has_callback = typeof args[args.length - 1] === 'function'
	    , has_weird_callback = typeof args[0] === 'function'
	    , callback = has_callback ? args.pop() : (has_weird_callback ? args.shift() : null)
	    , len = args.length
	    , selector = len >= 1 ? args[0] : {}
	    , fields = len >= 2 ? args[1] : undefined;
	
	  if(len === 1 && has_weird_callback) {
	    // backwards compat for callback?, options case
	    selector = {};
	    options = args[0];
	  }
	
	  if(len === 2 && fields !== undefined && !Array.isArray(fields)) {
	    var fieldKeys = Object.keys(fields);
	    var is_option = false;
	
	    for(var i = 0; i < fieldKeys.length; i++) {
	      if(testForFields[fieldKeys[i]] != null) {
	        is_option = true;
	        break;
	      }
	    }
	
	    if(is_option) {
	      options = fields;
	      fields = undefined;
	    } else {
	      options = {};
	    }
	  } else if(len === 2 && Array.isArray(fields) && !Array.isArray(fields[0])) {
	    var newFields = {};
	    // Rewrite the array
	    for(var i = 0; i < fields.length; i++) {
	      newFields[fields[i]] = 1;
	    }
	    // Set the fields
	    fields = newFields;
	  }
	
	  if(3 === len) {
	    options = args[2];
	  }
	
	  // Ensure selector is not null
	  selector = selector == null ? {} : selector;
	  // Validate correctness off the selector
	  var object = selector;
	  if(Buffer.isBuffer(object)) {
	    var object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
	    if(object_size != object.length)  {
	      var error = new Error("query selector raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
	      error.name = 'MongoError';
	      throw error;
	    }
	  }
	
	  // Validate correctness of the field selector
	  var object = fields;
	  if(Buffer.isBuffer(object)) {
	    var object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
	    if(object_size != object.length)  {
	      var error = new Error("query fields raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
	      error.name = 'MongoError';
	      throw error;
	    }
	  }
	
	  // Check special case where we are using an objectId
	  if(selector instanceof ObjectID || (selector != null && selector._bsontype == 'ObjectID')) {
	    selector = {_id:selector};
	  }
	
	  // If it's a serialized fields field we need to just let it through
	  // user be warned it better be good
	  if(options && options.fields && !(Buffer.isBuffer(options.fields))) {
	    fields = {};
	
	    if(Array.isArray(options.fields)) {
	      if(!options.fields.length) {
	        fields['_id'] = 1;
	      } else {
	        for (var i = 0, l = options.fields.length; i < l; i++) {
	          fields[options.fields[i]] = 1;
	        }
	      }
	    } else {
	      fields = options.fields;
	    }
	  }
	
	  if (!options) options = {};
	
	  var newOptions = {};
	  // Make a shallow copy of options
	  for (var key in options) {
	    newOptions[key] = options[key];
	  }
	
	  // Unpack options
	  newOptions.skip = len > 3 ? args[2] : options.skip ? options.skip : 0;
	  newOptions.limit = len > 3 ? args[3] : options.limit ? options.limit : 0;
	  newOptions.raw = options.raw != null && typeof options.raw === 'boolean' ? options.raw : this.s.raw;
	  newOptions.hint = options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;
	  newOptions.timeout = len == 5 ? args[4] : typeof options.timeout === 'undefined' ? undefined : options.timeout;
	  // // If we have overridden slaveOk otherwise use the default db setting
	  newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk;
	
	  // Add read preference if needed
	  newOptions = getReadPreference(this, newOptions, this.s.db, this);
	  // Set slave ok to true if read preference different from primary
	  if(newOptions.readPreference != null
	    && (newOptions.readPreference != 'primary' || newOptions.readPreference.mode != 'primary')) {
	    newOptions.slaveOk = true;
	  }
	
	  // Ensure the query is an object
	  if(selector != null && typeof selector != 'object') {
	    throw MongoError.create({message: "query selector must be an object", driver:true });
	  }
	
	  // Build the find command
	  var findCommand = {
	      find: this.s.namespace
	    , limit: newOptions.limit
	    , skip: newOptions.skip
	    , query: selector
	  }
	
	  // Ensure we use the right await data option
	  if(typeof newOptions.awaitdata == 'boolean')  {
	    newOptions.awaitData = newOptions.awaitdata
	  };
	
	  // Translate to new command option noCursorTimeout
	  if(typeof newOptions.timeout == 'boolean') newOptions.noCursorTimeout = newOptions.timeout;
	
	  // Merge in options to command
	  for(var name in newOptions) {
	    if(newOptions[name] != null) findCommand[name] = newOptions[name];
	  }
	
	  // Format the fields
	  var formatFields = function(fields) {
	    var object = {};
	    if(Array.isArray(fields)) {
	      for(var i = 0; i < fields.length; i++) {
	        if(Array.isArray(fields[i])) {
	          object[fields[i][0]] = fields[i][1];
	        } else {
	          object[fields[i][0]] = 1;
	        }
	      }
	    } else {
	      object = fields;
	    }
	
	    return object;
	  }
	
	  // Special treatment for the fields selector
	  if(fields) findCommand.fields = formatFields(fields);
	
	  // Add db object to the new options
	  newOptions.db = this.s.db;
	
	  // Add the promise library
	  newOptions.promiseLibrary = this.s.promiseLibrary;
	
	  // Set raw if available at collection level
	  if(newOptions.raw == null && this.s.raw) newOptions.raw = this.s.raw;
	
	  // Sort options
	  if(findCommand.sort)
	    findCommand.sort = formattedOrderClause(findCommand.sort);
	
	  // Set the readConcern
	  if(this.s.readConcern) {
	    findCommand.readConcern = this.s.readConcern;
	  }
	
	  // Create the cursor
	  if(typeof callback == 'function') return handleCallback(callback, null, this.s.topology.cursor(this.s.namespace, findCommand, newOptions));
	  return this.s.topology.cursor(this.s.namespace, findCommand, newOptions);
	}
	
	define.classMethod('find', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,
	 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
	 * can be overridden by setting the **forceServerObjectId** flag.
	 *
	 * @method
	 * @param {object} doc Document to insert.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {Collection~insertOneWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.insertOne = function(doc, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	  if(Array.isArray(doc) && typeof callback == 'function') {
	    return callback(MongoError.create({message: 'doc parameter must be an object', driver:true }));
	  } else if(Array.isArray(doc)) {
	    return new this.s.promiseLibrary(function(resolve, reject) {
	      reject(MongoError.create({message: 'doc parameter must be an object', driver:true }));
	    });
	  }
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return insertOne(self, doc, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    insertOne(self, doc, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var insertOne = function(self, doc, options, callback) {
	  insertDocuments(self, [doc], options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    // Workaround for pre 2.6 servers
	    if(r == null) return callback(null, {result: {ok:1}});
	    // Add values to top level to ensure crud spec compatibility
	    r.insertedCount = r.result.n;
	    r.insertedId = doc._id;
	    if(callback) callback(null, r);
	  });
	}
	
	var mapInserManyResults = function(docs, r) {
	  var ids = r.getInsertedIds();
	  var keys = Object.keys(ids);
	  var finalIds = new Array(keys.length);
	
	  for(var i = 0; i < keys.length; i++) {
	    if(ids[keys[i]]._id) {
	      finalIds[ids[keys[i]].index] = ids[keys[i]]._id;
	    }
	  }
	
	  var finalResult = {
	    result: {ok: 1, n: r.insertedCount},
	    ops: docs,
	    insertedCount: r.insertedCount,
	    insertedIds: finalIds
	  };
	
	  if(r.getLastOp()) {
	    finalResult.result.opTime = r.getLastOp();
	  }
	
	  return finalResult;
	}
	
	define.classMethod('insertOne', {callback: true, promise:true});
	
	/**
	 * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
	 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
	 * can be overridden by setting the **forceServerObjectId** flag.
	 *
	 * @method
	 * @param {object[]} docs Documents to insert.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {Collection~insertWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.insertMany = function(docs, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {ordered:true};
	  if(!Array.isArray(docs) && typeof callback == 'function') {
	    return callback(MongoError.create({message: 'docs parameter must be an array of documents', driver:true }));
	  } else if(!Array.isArray(docs)) {
	    return new this.s.promiseLibrary(function(resolve, reject) {
	      reject(MongoError.create({message: 'docs parameter must be an array of documents', driver:true }));
	    });
	  }
	
	  // Get the write concern options
	  if(typeof options.checkKeys != 'boolean') {
	    options.checkKeys = true;
	  }
	
	  // If keep going set unordered
	  options['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;
	
	  // Set up the force server object id
	  var forceServerObjectId = typeof options.forceServerObjectId == 'boolean'
	    ? options.forceServerObjectId : self.s.db.options.forceServerObjectId;
	
	  // Do we want to force the server to assign the _id key
	  if(forceServerObjectId !== true) {
	    // Add _id if not specified
	    for(var i = 0; i < docs.length; i++) {
	      if(docs[i]._id == null) docs[i]._id = self.s.pkFactory.createPk();
	    }
	  }
	
	  // Generate the bulk write operations
	  var operations = [{
	    insertMany: docs
	  }];
	
	  // Execute using callback
	  if(typeof callback == 'function') return bulkWrite(self, operations, options, function(err, r) {
	    if(err) return callback(err, r);
	    callback(null, mapInserManyResults(docs, r));
	  });
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    bulkWrite(self, operations, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(mapInserManyResults(docs, r));
	    });
	  });
	}
	
	define.classMethod('insertMany', {callback: true, promise:true});
	
	/**
	 * @typedef {Object} Collection~BulkWriteOpResult
	 * @property {number} insertedCount Number of documents inserted.
	 * @property {number} matchedCount Number of documents matched for update.
	 * @property {number} modifiedCount Number of documents modified.
	 * @property {number} deletedCount Number of documents deleted.
	 * @property {number} upsertedCount Number of documents upserted.
	 * @property {object} insertedIds Inserted document generated Id's, hash key is the index of the originating operation
	 * @property {object} upsertedIds Upserted document generated Id's, hash key is the index of the originating operation
	 * @property {object} result The command result object.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~bulkWriteOpCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~BulkWriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Perform a bulkWrite operation without a fluent API
	 *
	 * Legal operation types are
	 *
	 *  { insertOne: { document: { a: 1 } } }
	 *
	 *  { updateOne: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }
	 *
	 *  { updateMany: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }
	 *
	 *  { deleteOne: { filter: {c:1} } }
	 *
	 *  { deleteMany: { filter: {c:1} } }
	 *
	 *  { replaceOne: { filter: {c:3}, replacement: {c:4}, upsert:true}}
	 *
	 * If documents passed in do not contain the **_id** field,
	 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
	 * can be overridden by setting the **forceServerObjectId** flag.
	 *
	 * @method
	 * @param {object[]} operations Bulk operations to perform.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.ordered=true] Execute write operation in ordered or unordered fashion.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {Collection~bulkWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.bulkWrite = function(operations, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {ordered:true};
	
	  if(!Array.isArray(operations)) {
	    throw MongoError.create({message: "operations must be an array of documents", driver:true });
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return bulkWrite(self, operations, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    bulkWrite(self, operations, options, function(err, r) {
	      if(err && r == null) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var bulkWrite = function(self, operations, options, callback) {
	  // Add ignoreUndfined
	  if(self.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = self.s.options.ignoreUndefined;
	  }
	
	  // Create the bulk operation
	  var bulk = options.ordered == true || options.ordered == null ? self.initializeOrderedBulkOp(options) : self.initializeUnorderedBulkOp(options);
	
	  // for each op go through and add to the bulk
	  try {
	    for(var i = 0; i < operations.length; i++) {
	      bulk.raw(operations[i]);
	    }
	  } catch(err) {
	    return callback(err, null);
	  }
	
	  // Final options for write concern
	  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
	  var writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};
	
	  // Execute the bulk
	  bulk.execute(writeCon, function(err, r) {
	    // We have connection level error
	    if(!r && err) return callback(err, null);
	    // We have single error
	    if(r && r.hasWriteErrors() && r.getWriteErrorCount() == 1) {
	      return callback(toError(r.getWriteErrorAt(0)), r);
	    }
	
	    // if(err) return callback(err);
	    r.insertedCount = r.nInserted;
	    r.matchedCount = r.nMatched;
	    r.modifiedCount = r.nModified || 0;
	    r.deletedCount = r.nRemoved;
	    r.upsertedCount = r.getUpsertedIds().length;
	    r.upsertedIds = {};
	    r.insertedIds = {};
	
	    // Update the n
	    r.n = r.insertedCount;
	
	    // Inserted documents
	    var inserted = r.getInsertedIds();
	    // Map inserted ids
	    for(var i = 0; i < inserted.length; i++) {
	      r.insertedIds[inserted[i].index] = inserted[i]._id;
	    }
	
	    // Upserted documents
	    var upserted = r.getUpsertedIds();
	    // Map upserted ids
	    for(var i = 0; i < upserted.length; i++) {
	      r.upsertedIds[upserted[i].index] = upserted[i]._id;
	    }
	
	    // Check if we have write errors
	    if(r.hasWriteErrors()) {
	      // Get all the errors
	      var errors = r.getWriteErrors();
	      // Return the MongoError object
	      return callback(toError({
	        message: 'write operation failed', code: errors[0].code, writeErrors: errors
	      }), r);
	    }
	
	    // Check if we have a writeConcern error
	    if(r.getWriteConcernError()) {
	      // Return the MongoError object
	      return callback(toError(r.getWriteConcernError()), r);
	    }
	
	    // Return the results
	    callback(null, r);
	  });
	}
	
	var insertDocuments = function(self, docs, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	  // Ensure we are operating on an array op docs
	  docs = Array.isArray(docs) ? docs : [docs];
	
	  // Get the write concern options
	  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
	  if(typeof finalOptions.checkKeys != 'boolean') finalOptions.checkKeys = true;
	
	  // If keep going set unordered
	  if(finalOptions.keepGoing == true) finalOptions.ordered = false;
	  finalOptions['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;
	
	  // Set up the force server object id
	  var forceServerObjectId = typeof options.forceServerObjectId == 'boolean'
	    ? options.forceServerObjectId : self.s.db.options.forceServerObjectId;
	
	  // Add _id if not specified
	  if(forceServerObjectId !== true){
	    for(var i = 0; i < docs.length; i++) {
	      if(docs[i]._id == null) docs[i]._id = self.s.pkFactory.createPk();
	    }
	  }
	
	  // File inserts
	  self.s.topology.insert(self.s.namespace, docs, finalOptions, function(err, result) {
	    if(callback == null) return;
	    if(err) return handleCallback(callback, err);
	    if(result == null) return handleCallback(callback, null, null);
	    if(result.result.code) return handleCallback(callback, toError(result.result));
	    if(result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0]));
	    // Add docs to the list
	    result.ops = docs;
	    // Return the results
	    handleCallback(callback, null, result);
	  });
	}
	
	define.classMethod('bulkWrite', {callback: true, promise:true});
	
	/**
	 * @typedef {Object} Collection~WriteOpResult
	 * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
	 * @property {object} connection The connection object used for the operation.
	 * @property {object} result The command result object.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~writeOpCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~WriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * @typedef {Object} Collection~insertWriteOpResult
	 * @property {Number} insertedCount The total amount of documents inserted.
	 * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
	 * @property {ObjectId[]} insertedIds All the generated _id's for the inserted documents.
	 * @property {object} connection The connection object used for the operation.
	 * @property {object} result The raw command result object returned from MongoDB (content might vary by server version).
	 * @property {Number} result.ok Is 1 if the command executed correctly.
	 * @property {Number} result.n The total count of documents inserted.
	 */
	
	/**
	 * @typedef {Object} Collection~insertOneWriteOpResult
	 * @property {Number} insertedCount The total amount of documents inserted.
	 * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
	 * @property {ObjectId} insertedId The driver generated ObjectId for the insert operation.
	 * @property {object} connection The connection object used for the operation.
	 * @property {object} result The raw command result object returned from MongoDB (content might vary by server version).
	 * @property {Number} result.ok Is 1 if the command executed correctly.
	 * @property {Number} result.n The total count of documents inserted.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~insertWriteOpCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~insertWriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~insertOneWriteOpCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~insertOneWriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
	 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
	 * can be overridden by setting the **forceServerObjectId** flag.
	 *
	 * @method
	 * @param {(object|object[])} docs Documents to insert.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {Collection~insertWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use insertOne, insertMany or bulkWrite
	 */
	Collection.prototype.insert = function(docs, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {ordered:false};
	  docs = !Array.isArray(docs) ? [docs] : docs;
	
	  if(options.keepGoing == true) {
	    options.ordered = false;
	  }
	
	  return this.insertMany(docs, options, callback);
	}
	
	define.classMethod('insert', {callback: true, promise:true});
	
	/**
	 * @typedef {Object} Collection~updateWriteOpResult
	 * @property {Object} result The raw result returned from MongoDB, field will vary depending on server version.
	 * @property {Number} result.ok Is 1 if the command executed correctly.
	 * @property {Number} result.n The total count of documents scanned.
	 * @property {Number} result.nModified The total count of documents modified.
	 * @property {Object} connection The connection object used for the operation.
	 * @property {Number} matchedCount The number of documents that matched the filter.
	 * @property {Number} modifiedCount The number of documents that were modified.
	 * @property {Number} upsertedCount The number of documents upserted.
	 * @property {Object} upsertedId The upserted id.
	 * @property {ObjectId} upsertedId._id The upserted _id returned from the server.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~updateWriteOpCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~updateWriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Update a single document on MongoDB
	 * @method
	 * @param {object} filter The Filter used to select the document to update
	 * @param {object} update The update operations to be applied to the document
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.upsert=false] Update operation is an upsert.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {Collection~updateWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.updateOne = function(filter, update, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = shallowClone(options)
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return updateOne(self, filter, update, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    updateOne(self, filter, update, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var updateOne = function(self, filter, update, options, callback) {
	  // Set single document update
	  options.multi = false;
	  // Execute update
	  updateDocuments(self, filter, update, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    if(r == null) return callback(null, {result: {ok:1}});
	    r.matchedCount = r.result.n;
	    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
	    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
	    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
	    if(callback) callback(null, r);
	  });
	}
	
	define.classMethod('updateOne', {callback: true, promise:true});
	
	/**
	 * Replace a document on MongoDB
	 * @method
	 * @param {object} filter The Filter used to select the document to update
	 * @param {object} doc The Document that replaces the matching document
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.upsert=false] Update operation is an upsert.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {Collection~updateWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.replaceOne = function(filter, update, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = shallowClone(options)
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return replaceOne(self, filter, update, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    replaceOne(self, filter, update, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var replaceOne = function(self, filter, update, options, callback) {
	  // Set single document update
	  options.multi = false;
	  // Execute update
	  updateDocuments(self, filter, update, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    if(r == null) return callback(null, {result: {ok:1}});
	    r.matchedCount = r.result.n;
	    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
	    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
	    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
	    r.ops = [update];
	    if(callback) callback(null, r);
	  });
	}
	
	define.classMethod('replaceOne', {callback: true, promise:true});
	
	/**
	 * Update multiple documents on MongoDB
	 * @method
	 * @param {object} filter The Filter used to select the document to update
	 * @param {object} update The update operations to be applied to the document
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.upsert=false] Update operation is an upsert.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~updateWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.updateMany = function(filter, update, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = shallowClone(options)
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return updateMany(self, filter, update, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    updateMany(self, filter, update, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var updateMany = function(self, filter, update, options, callback) {
	  // Set single document update
	  options.multi = true;
	  // Execute update
	  updateDocuments(self, filter, update, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    if(r == null) return callback(null, {result: {ok:1}});
	    r.matchedCount = r.result.n;
	    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
	    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
	    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
	    if(callback) callback(null, r);
	  });
	}
	
	define.classMethod('updateMany', {callback: true, promise:true});
	
	var updateDocuments = function(self, selector, document, options, callback) {
	  if('function' === typeof options) callback = options, options = null;
	  if(options == null) options = {};
	  if(!('function' === typeof callback)) callback = null;
	
	  // If we are not providing a selector or document throw
	  if(selector == null || typeof selector != 'object') return callback(toError("selector must be a valid JavaScript object"));
	  if(document == null || typeof document != 'object') return callback(toError("document must be a valid JavaScript object"));
	
	  // Get the write concern options
	  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
	
	  // Do we return the actual result document
	  // Either use override on the function, or go back to default on either the collection
	  // level or db
	  finalOptions['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;
	
	  // Execute the operation
	  var op = {q: selector, u: document};
	  op.upsert = typeof options.upsert == 'boolean' ? options.upsert : false;
	  op.multi = typeof options.multi == 'boolean' ? options.multi : false;
	
	  // Update options
	  self.s.topology.update(self.s.namespace, [op], finalOptions, function(err, result) {
	    if(callback == null) return;
	    if(err) return handleCallback(callback, err, null);
	    if(result == null) return handleCallback(callback, null, null);
	    if(result.result.code) return handleCallback(callback, toError(result.result));
	    if(result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0]));
	    // Return the results
	    handleCallback(callback, null, result);
	  });
	}
	
	/**
	 * Updates documents.
	 * @method
	 * @param {object} selector The selector for the update operation.
	 * @param {object} document The update document.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.upsert=false] Update operation is an upsert.
	 * @param {boolean} [options.multi=false] Update one/all documents with operation.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {Collection~writeOpCallback} [callback] The command result callback
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated use updateOne, updateMany or bulkWrite
	 */
	Collection.prototype.update = function(selector, document, options, callback) {
	  var self = this;
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return updateDocuments(self, selector, document, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    updateDocuments(self, selector, document, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('update', {callback: true, promise:true});
	
	/**
	 * @typedef {Object} Collection~deleteWriteOpResult
	 * @property {Object} result The raw result returned from MongoDB, field will vary depending on server version.
	 * @property {Number} result.ok Is 1 if the command executed correctly.
	 * @property {Number} result.n The total count of documents deleted.
	 * @property {Object} connection The connection object used for the operation.
	 * @property {Number} deletedCount The number of documents deleted.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~deleteWriteOpCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~deleteWriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Delete a document on MongoDB
	 * @method
	 * @param {object} filter The Filter used to select the document to remove
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~deleteWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.deleteOne = function(filter, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  var options = shallowClone(options);
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return deleteOne(self, filter, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    deleteOne(self, filter, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var deleteOne = function(self, filter, options, callback) {
	  options.single = true;
	  removeDocuments(self, filter, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    if(r == null) return callback(null, {result: {ok:1}});
	    r.deletedCount = r.result.n;
	    if(callback) callback(null, r);
	  });
	}
	
	define.classMethod('deleteOne', {callback: true, promise:true});
	
	Collection.prototype.removeOne = Collection.prototype.deleteOne;
	
	define.classMethod('removeOne', {callback: true, promise:true});
	
	/**
	 * Delete multiple documents on MongoDB
	 * @method
	 * @param {object} filter The Filter used to select the documents to remove
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~deleteWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.deleteMany = function(filter, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  var options = shallowClone(options);
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return deleteMany(self, filter, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    deleteMany(self, filter, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var deleteMany = function(self, filter, options, callback) {
	  options.single = false;
	  removeDocuments(self, filter, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    if(r == null) return callback(null, {result: {ok:1}});
	    r.deletedCount = r.result.n;
	    if(callback) callback(null, r);
	  });
	}
	
	var removeDocuments = function(self, selector, options, callback) {
	  if(typeof options == 'function') {
	    callback = options, options = {};
	  } else if (typeof selector === 'function') {
	    callback = selector;
	    options = {};
	    selector = {};
	  }
	
	  // Create an empty options object if the provided one is null
	  options = options || {};
	
	  // Get the write concern options
	  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
	
	  // If selector is null set empty
	  if(selector == null) selector = {};
	
	  // Build the op
	  var op = {q: selector, limit: 0};
	  if(options.single) op.limit = 1;
	
	  // Execute the remove
	  self.s.topology.remove(self.s.namespace, [op], finalOptions, function(err, result) {
	    if(callback == null) return;
	    if(err) return handleCallback(callback, err, null);
	    if(result == null) return handleCallback(callback, null, null);
	    if(result.result.code) return handleCallback(callback, toError(result.result));
	    if(result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0]));
	    // Return the results
	    handleCallback(callback, null, result);
	  });
	}
	
	define.classMethod('deleteMany', {callback: true, promise:true});
	
	Collection.prototype.removeMany = Collection.prototype.deleteMany;
	
	define.classMethod('removeMany', {callback: true, promise:true});
	
	/**
	 * Remove documents.
	 * @method
	 * @param {object} selector The selector for the update operation.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.single=false] Removes the first document found.
	 * @param {Collection~writeOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated use deleteOne, deleteMany or bulkWrite
	 */
	Collection.prototype.remove = function(selector, options, callback) {
	  var self = this;
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return removeDocuments(self, selector, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    removeDocuments(self, selector, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('remove', {callback: true, promise:true});
	
	/**
	 * Save a document. Simple full document replacement function. Not recommended for efficiency, use atomic
	 * operators and update instead for more efficient operations.
	 * @method
	 * @param {object} doc Document to save
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~writeOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated use insertOne, insertMany, updateOne or updateMany
	 */
	Collection.prototype.save = function(doc, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return save(self, doc, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    save(self, doc, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var save = function(self, doc, options, callback) {
	  // Get the write concern options
	  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
	  // Establish if we need to perform an insert or update
	  if(doc._id != null) {
	    finalOptions.upsert = true;
	    return updateDocuments(self, {_id: doc._id}, doc, finalOptions, callback);
	  }
	
	  // Insert the document
	  insertDocuments(self, [doc], options, function(err, r) {
	    if(callback == null) return;
	    if(doc == null) return handleCallback(callback, null, null);
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, null, r);
	  });
	}
	
	define.classMethod('save', {callback: true, promise:true});
	
	/**
	 * The callback format for results
	 * @callback Collection~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Fetches the first document that matches the query
	 * @method
	 * @param {object} query Query for find Operation
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.limit=0] Sets the limit of documents returned in the query.
	 * @param {(array|object)} [options.sort=null] Set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.
	 * @param {object} [options.fields=null] The fields to return in the query. Object of fields to include or exclude (not both), {'a':1}
	 * @param {number} [options.skip=0] Set to skip N documents ahead in your query (useful for pagination).
	 * @param {Object} [options.hint=null] Tell the query to use specific indexes in the query. Object of indexes to use, {'_id':1}
	 * @param {boolean} [options.explain=false] Explain the query instead of returning the data.
	 * @param {boolean} [options.snapshot=false] Snapshot query.
	 * @param {boolean} [options.timeout=false] Specify if the cursor can timeout.
	 * @param {boolean} [options.tailable=false] Specify if the cursor is tailable.
	 * @param {number} [options.batchSize=0] Set the batchSize for the getMoreCommand when iterating over the query results.
	 * @param {boolean} [options.returnKey=false] Only return the index key.
	 * @param {number} [options.maxScan=null] Limit the number of items to scan.
	 * @param {number} [options.min=null] Set index bounds.
	 * @param {number} [options.max=null] Set index bounds.
	 * @param {boolean} [options.showDiskLoc=false] Show disk location of results.
	 * @param {string} [options.comment=null] You can put a $comment field on a query to make looking in the profiler logs simpler.
	 * @param {boolean} [options.raw=false] Return all BSON documents as Raw Buffer documents.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {boolean} [options.partial=false] Specify if the cursor should return partial results when querying against a sharded system
	 * @param {number} [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated use find().limit(1).next(function(err, doc){})
	 */
	Collection.prototype.findOne = function() {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  var callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	
	  // Execute using callback
	  if(typeof callback == 'function') return findOne(self, args, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    findOne(self, args, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var findOne = function(self, args, callback) {
	  var cursor = self.find.apply(self, args).limit(-1).batchSize(1);
	  // Return the item
	  cursor.next(function(err, item) {
	    if(err != null) return handleCallback(callback, toError(err), null);
	    handleCallback(callback, null, item);
	  });
	}
	
	define.classMethod('findOne', {callback: true, promise:true});
	
	/**
	 * The callback format for the collection method, must be used if strict is specified
	 * @callback Collection~collectionResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection} collection The collection instance.
	 */
	
	/**
	 * Rename the collection.
	 *
	 * @method
	 * @param {string} newName New name of of the collection.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.dropTarget=false] Drop the target name collection if it previously exists.
	 * @param {Collection~collectionResultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.rename = function(newName, opt, callback) {
	  var self = this;
	  if(typeof opt == 'function') callback = opt, opt = {};
	  opt = opt || {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return rename(self, newName, opt, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    rename(self, newName, opt, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var rename = function(self, newName, opt, callback) {
	  // Check the collection name
	  checkCollectionName(newName);
	  // Build the command
	  var renameCollection = f("%s.%s", self.s.dbName, self.s.name);
	  var toCollection =  f("%s.%s", self.s.dbName, newName);
	  var dropTarget = typeof opt.dropTarget == 'boolean' ? opt.dropTarget : false;
	  var cmd = {'renameCollection':renameCollection, 'to':toCollection, 'dropTarget':dropTarget};
	
	  // Execute against admin
	  self.s.db.admin().command(cmd, opt, function(err, doc) {
	    if(err) return handleCallback(callback, err, null);
	    // We have an error
	    if(doc.errmsg) return handleCallback(callback, toError(doc), null);
	    try {
	      return handleCallback(callback, null, new Collection(self.s.db, self.s.topology, self.s.dbName, newName, self.s.pkFactory, self.s.options));
	    } catch(err) {
	      return handleCallback(callback, toError(err), null);
	    }
	  });
	}
	
	define.classMethod('rename', {callback: true, promise:true});
	
	/**
	 * Drop the collection from the database, removing it permanently. New accesses will create a new collection.
	 *
	 * @method
	 * @param {Collection~resultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.drop = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return self.s.db.dropCollection(self.s.name, callback);
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.dropCollection(self.s.name, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('drop', {callback: true, promise:true});
	
	/**
	 * Returns the options of the collection.
	 *
	 * @method
	 * @param {Collection~resultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.options = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return options(self, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    options(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var options = function(self, callback) {
	  self.s.db.listCollections({name: self.s.name}).toArray(function(err, collections) {
	    if(err) return handleCallback(callback, err);
	    if(collections.length == 0) {
	      return handleCallback(callback, MongoError.create({message: f("collection %s not found", self.s.namespace), driver:true }));
	    }
	
	    handleCallback(callback, err, collections[0].options || null);
	  });
	}
	
	define.classMethod('options', {callback: true, promise:true});
	
	/**
	 * Returns if the collection is a capped collection
	 *
	 * @method
	 * @param {Collection~resultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.isCapped = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return isCapped(self, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    isCapped(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var isCapped = function(self, callback) {
	  self.options(function(err, document) {
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, null, document && document.capped);
	  });
	}
	
	define.classMethod('isCapped', {callback: true, promise:true});
	
	/**
	 * Creates an index on the db and collection collection.
	 * @method
	 * @param {(string|object)} fieldOrSpec Defines the index.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.unique=false] Creates an unique index.
	 * @param {boolean} [options.sparse=false] Creates a sparse index.
	 * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
	 * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
	 * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
	 * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
	 * @param {number} [options.v=null] Specify the format version of the indexes.
	 * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
	 * @param {number} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.createIndex = function(fieldOrSpec, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() || {} : {};
	  options = typeof callback === 'function' ? options : callback;
	  options = options == null ? {} : options;
	
	  // Execute using callback
	  if(typeof callback == 'function') return createIndex(self, fieldOrSpec, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    createIndex(self, fieldOrSpec, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var createIndex = function(self, fieldOrSpec, options, callback) {
	  self.s.db.createIndex(self.s.name, fieldOrSpec, options, callback);
	}
	
	define.classMethod('createIndex', {callback: true, promise:true});
	
	/**
	 * Creates multiple indexes in the collection, this method is only supported for
	 * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported
	 * error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
	 * @method
	 * @param {array} indexSpecs An array of index specifications to be created
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.createIndexes = function(indexSpecs, callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return createIndexes(self, indexSpecs, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    createIndexes(self, indexSpecs, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var createIndexes = function(self, indexSpecs, callback) {
	  // Ensure we generate the correct name if the parameter is not set
	  for(var i = 0; i < indexSpecs.length; i++) {
	    if(indexSpecs[i].name == null) {
	      var keys = [];
	
	      for(var name in indexSpecs[i].key) {
	        keys.push(f('%s_%s', name, indexSpecs[i].key[name]));
	      }
	
	      // Set the name
	      indexSpecs[i].name = keys.join('_');
	    }
	  }
	
	  // Execute the index
	  self.s.db.command({
	    createIndexes: self.s.name, indexes: indexSpecs
	  }, { readPreference: ReadPreference.PRIMARY }, callback);
	}
	
	define.classMethod('createIndexes', {callback: true, promise:true});
	
	/**
	 * Drops an index from this collection.
	 * @method
	 * @param {string} indexName Name of the index to drop.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.dropIndex = function(indexName, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() || {} : {};
	  // Run only against primary
	  options.readPreference = ReadPreference.PRIMARY;
	
	  // Execute using callback
	  if(typeof callback == 'function') return dropIndex(self, indexName, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    dropIndex(self, indexName, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var dropIndex = function(self, indexName, options, callback) {
	  // Delete index command
	  var cmd = {'deleteIndexes':self.s.name, 'index':indexName};
	
	  // Execute command
	  self.s.db.command(cmd, options, function(err, result) {
	    if(typeof callback != 'function') return;
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, null, result);
	  });
	}
	
	define.classMethod('dropIndex', {callback: true, promise:true});
	
	/**
	 * Drops all indexes from this collection.
	 * @method
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.dropIndexes = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return dropIndexes(self, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    dropIndexes(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var dropIndexes = function(self, callback) {
	  self.dropIndex('*', function (err, result) {
	    if(err) return handleCallback(callback, err, false);
	    handleCallback(callback, null, true);
	  });
	}
	
	define.classMethod('dropIndexes', {callback: true, promise:true});
	
	/**
	 * Drops all indexes from this collection.
	 * @method
	 * @deprecated use dropIndexes
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {Promise} returns Promise if no [callback] passed
	 */
	Collection.prototype.dropAllIndexes = Collection.prototype.dropIndexes;
	
	define.classMethod('dropAllIndexes', {callback: true, promise:true});
	
	/**
	 * Reindex all indexes on the collection
	 * Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
	 * @method
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.reIndex = function(options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return reIndex(self, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    reIndex(self, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var reIndex = function(self, options, callback) {
	  // Reindex
	  var cmd = {'reIndex':self.s.name};
	
	  // Execute the command
	  self.s.db.command(cmd, options, function(err, result) {
	    if(callback == null) return;
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, null, result.ok ? true : false);
	  });
	}
	
	define.classMethod('reIndex', {callback: true, promise:true});
	
	/**
	 * Get the list of all indexes information for the collection.
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.batchSize=null] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @return {CommandCursor}
	 */
	Collection.prototype.listIndexes = function(options) {
	  options = options || {};
	  // Clone the options
	  options = shallowClone(options);
	  // Determine the read preference in the options.
	  options = getReadPreference(this, options, this.s.db, this);
	  // Set the CommandCursor constructor
	  options.cursorFactory = CommandCursor;
	  // Set the promiseLibrary
	  options.promiseLibrary = this.s.promiseLibrary;
	
	  if(!this.s.topology.capabilities()) {
	    throw new MongoError('cannot connect to server');
	  }
	
	  // We have a list collections command
	  if(this.s.topology.capabilities().hasListIndexesCommand) {
	    // Cursor options
	    var cursor = options.batchSize ? {batchSize: options.batchSize} : {}
	    // Build the command
	    var command = { listIndexes: this.s.name, cursor: cursor };
	    // Execute the cursor
	    var cursor = this.s.topology.cursor(f('%s.$cmd', this.s.dbName), command, options);
	    // Do we have a readPreference, apply it
	    if(options.readPreference) cursor.setReadPreference(options.readPreference);
	    // Return the cursor
	    return cursor;
	  }
	
	  // Get the namespace
	  var ns = f('%s.system.indexes', this.s.dbName);
	  // Get the query
	  var cursor = this.s.topology.cursor(ns, {find: ns, query: {ns: this.s.namespace}}, options);
	  // Do we have a readPreference, apply it
	  if(options.readPreference) cursor.setReadPreference(options.readPreference);
	  // Set the passed in batch size if one was provided
	  if(options.batchSize) cursor = cursor.batchSize(options.batchSize);
	  // Return the cursor
	  return cursor;
	};
	
	define.classMethod('listIndexes', {callback: false, promise:false, returns: [CommandCursor]});
	
	/**
	 * Ensures that an index exists, if it does not it creates it
	 * @method
	 * @deprecated use createIndexes instead
	 * @param {(string|object)} fieldOrSpec Defines the index.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.unique=false] Creates an unique index.
	 * @param {boolean} [options.sparse=false] Creates a sparse index.
	 * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
	 * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
	 * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
	 * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
	 * @param {number} [options.v=null] Specify the format version of the indexes.
	 * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
	 * @param {number} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.ensureIndex = function(fieldOrSpec, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return ensureIndex(self, fieldOrSpec, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    ensureIndex(self, fieldOrSpec, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var ensureIndex = function(self, fieldOrSpec, options, callback) {
	  self.s.db.ensureIndex(self.s.name, fieldOrSpec, options, callback);
	}
	
	define.classMethod('ensureIndex', {callback: true, promise:true});
	
	/**
	 * Checks if one or more indexes exist on the collection, fails on first non-existing index
	 * @method
	 * @param {(string|array)} indexes One or more index names to check.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.indexExists = function(indexes, callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return indexExists(self, indexes, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    indexExists(self, indexes, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var indexExists = function(self, indexes, callback) {
	  self.indexInformation(function(err, indexInformation) {
	    // If we have an error return
	    if(err != null) return handleCallback(callback, err, null);
	    // Let's check for the index names
	    if(!Array.isArray(indexes)) return handleCallback(callback, null, indexInformation[indexes] != null);
	    // Check in list of indexes
	    for(var i = 0; i < indexes.length; i++) {
	      if(indexInformation[indexes[i]] == null) {
	        return handleCallback(callback, null, false);
	      }
	    }
	
	    // All keys found return true
	    return handleCallback(callback, null, true);
	  });
	}
	
	define.classMethod('indexExists', {callback: true, promise:true});
	
	/**
	 * Retrieves this collections index info.
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.full=false] Returns the full raw index information.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.indexInformation = function(options, callback) {
	  var self = this;
	  // Unpack calls
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() || {} : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return indexInformation(self, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    indexInformation(self, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var indexInformation = function(self, options, callback) {
	  self.s.db.indexInformation(self.s.name, options, callback);
	}
	
	define.classMethod('indexInformation', {callback: true, promise:true});
	
	/**
	 * The callback format for results
	 * @callback Collection~countCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {number} result The count of documents that matched the query.
	 */
	
	/**
	 * Count number of matching documents in the db to a query.
	 * @method
	 * @param {object} query The query for the count.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.limit=null] The limit of documents to count.
	 * @param {boolean} [options.skip=null] The number of documents to skip for the count.
	 * @param {string} [options.hint=null] An index name hint for the query.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Collection~countCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.count = function(query, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  var queryOption = args.length ? args.shift() || {} : {};
	  var optionsOption = args.length ? args.shift() || {} : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return count(self, queryOption, optionsOption, callback);
	
	  // Check if query is empty
	  query = query || {};
	  options = options || {};
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    count(self, query, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var count = function(self, query, options, callback) {
	  var skip = options.skip;
	  var limit = options.limit;
	  var hint = options.hint;
	  var maxTimeMS = options.maxTimeMS;
	
	  // Final query
	  var cmd = {
	    'count': self.s.name, 'query': query
	  };
	
	  // Add limit and skip if defined
	  if(typeof skip == 'number') cmd.skip = skip;
	  if(typeof limit == 'number') cmd.limit = limit;
	  if(hint) options.hint = hint;
	
	  options = shallowClone(options);
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(self, options, self.s.db, self);
	
	  // Do we have a readConcern specified
	  if(self.s.readConcern) {
	    cmd.readConcern = self.s.readConcern;
	  }
	
	  // Execute command
	  self.s.db.command(cmd, options, function(err, result) {
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, null, result.n);
	  });
	}
	
	define.classMethod('count', {callback: true, promise:true});
	
	/**
	 * The distinct command returns returns a list of distinct values for the given key across a collection.
	 * @method
	 * @param {string} key Field of the document to find distinct values for.
	 * @param {object} query The query for filtering the set of documents to which we apply the distinct filter.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.distinct = function(key, query, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  var queryOption = args.length ? args.shift() || {} : {};
	  var optionsOption = args.length ? args.shift() || {} : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return distinct(self, key, queryOption, optionsOption, callback);
	
	  // Ensure the query and options are set
	  query = query || {};
	  options = options || {};
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    distinct(self, key, query, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var distinct = function(self, key, query, options, callback) {
	  // maxTimeMS option
	  var maxTimeMS = options.maxTimeMS;
	
	  // Distinct command
	  var cmd = {
	    'distinct': self.s.name, 'key': key, 'query': query
	  };
	
	  options = shallowClone(options);
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(self, options, self.s.db, self);
	
	  // Do we have a readConcern specified
	  if(self.s.readConcern) {
	    cmd.readConcern = self.s.readConcern;
	  }
	
	  // Execute the command
	  self.s.db.command(cmd, options, function(err, result) {
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, null, result.values);
	  });
	}
	
	define.classMethod('distinct', {callback: true, promise:true});
	
	/**
	 * Retrieve all the indexes on the collection.
	 * @method
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.indexes = function(callback) {
	  var self = this;
	  // Execute using callback
	  if(typeof callback == 'function') return indexes(self, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    indexes(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var indexes = function(self, callback) {
	  self.s.db.indexInformation(self.s.name, {full:true}, callback);
	}
	
	define.classMethod('indexes', {callback: true, promise:true});
	
	/**
	 * Get all the collection statistics.
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.scale=null] Divide the returned sizes by scale value.
	 * @param {Collection~resultCallback} [callback] The collection result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.stats = function(options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  // Fetch all commands
	  options = args.length ? args.shift() || {} : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return stats(self, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    stats(self, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var stats = function(self, options, callback) {
	  // Build command object
	  var commandObject = {
	    collStats:self.s.name
	  }
	
	  // Check if we have the scale value
	  if(options['scale'] != null) commandObject['scale'] = options['scale'];
	
	  options = shallowClone(options);
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(self, options, self.s.db, self);
	
	  // Execute the command
	  self.s.db.command(commandObject, options, callback);
	}
	
	define.classMethod('stats', {callback: true, promise:true});
	
	/**
	 * @typedef {Object} Collection~findAndModifyWriteOpResult
	 * @property {object} value Document returned from findAndModify command.
	 * @property {object} lastErrorObject The raw lastErrorObject returned from the command.
	 * @property {Number} ok Is 1 if the command executed correctly.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~findAndModifyCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~findAndModifyWriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
	 *
	 * @method
	 * @param {object} filter Document selection filter.
	 * @param {object} [options=null] Optional settings.
	 * @param {object} [options.projection=null] Limits the fields to return for all matching documents.
	 * @param {object} [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
	 * @param {number} [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
	 * @param {Collection~findAndModifyCallback} [callback] The collection result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.findOneAndDelete = function(filter, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Basic validation
	  if(filter == null || typeof filter != 'object') throw toError('filter parameter must be an object');
	
	  // Execute using callback
	  if(typeof callback == 'function') return findOneAndDelete(self, filter, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    options = options || {};
	
	    findOneAndDelete(self, filter, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var findOneAndDelete = function(self, filter, options, callback) {
	  // Final options
	  var finalOptions = shallowClone(options);
	  finalOptions['fields'] = options.projection;
	  finalOptions['remove'] = true;
	  // Execute find and Modify
	  self.findAndModify(
	      filter
	    , options.sort
	    , null
	    , finalOptions
	    , callback
	  );
	}
	
	define.classMethod('findOneAndDelete', {callback: true, promise:true});
	
	/**
	 * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
	 *
	 * @method
	 * @param {object} filter Document selection filter.
	 * @param {object} replacement Document replacing the matching document.
	 * @param {object} [options=null] Optional settings.
	 * @param {object} [options.projection=null] Limits the fields to return for all matching documents.
	 * @param {object} [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
	 * @param {number} [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
	 * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.
	 * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
	 * @param {Collection~findAndModifyCallback} [callback] The collection result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.findOneAndReplace = function(filter, replacement, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Basic validation
	  if(filter == null || typeof filter != 'object') throw toError('filter parameter must be an object');
	  if(replacement == null || typeof replacement != 'object') throw toError('replacement parameter must be an object');
	
	  // Execute using callback
	  if(typeof callback == 'function') return findOneAndReplace(self, filter, replacement, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    options = options || {};
	
	    findOneAndReplace(self, filter, replacement, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var findOneAndReplace = function(self, filter, replacement, options, callback) {
	  // Final options
	  var finalOptions = shallowClone(options);
	  finalOptions['fields'] = options.projection;
	  finalOptions['update'] = true;
	  finalOptions['new'] = typeof options.returnOriginal == 'boolean' ? !options.returnOriginal : false;
	  finalOptions['upsert'] = typeof options.upsert == 'boolean' ? options.upsert : false;
	
	  // Execute findAndModify
	  self.findAndModify(
	      filter
	    , options.sort
	    , replacement
	    , finalOptions
	    , callback
	  );
	}
	
	define.classMethod('findOneAndReplace', {callback: true, promise:true});
	
	/**
	 * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
	 *
	 * @method
	 * @param {object} filter Document selection filter.
	 * @param {object} update Update operations to be performed on the document
	 * @param {object} [options=null] Optional settings.
	 * @param {object} [options.projection=null] Limits the fields to return for all matching documents.
	 * @param {object} [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
	 * @param {number} [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
	 * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.
	 * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
	 * @param {Collection~findAndModifyCallback} [callback] The collection result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.findOneAndUpdate = function(filter, update, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Basic validation
	  if(filter == null || typeof filter != 'object') throw toError('filter parameter must be an object');
	  if(update == null || typeof update != 'object') throw toError('update parameter must be an object');
	
	  // Execute using callback
	  if(typeof callback == 'function') return findOneAndUpdate(self, filter, update, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    options = options || {};
	
	    findOneAndUpdate(self, filter, update, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var findOneAndUpdate = function(self, filter, update, options, callback) {
	  // Final options
	  var finalOptions = shallowClone(options);
	  finalOptions['fields'] = options.projection;
	  finalOptions['update'] = true;
	  finalOptions['new'] = typeof options.returnOriginal == 'boolean' ? !options.returnOriginal : false;
	  finalOptions['upsert'] = typeof options.upsert == 'boolean' ? options.upsert : false;
	
	  // Execute findAndModify
	  self.findAndModify(
	      filter
	    , options.sort
	    , update
	    , finalOptions
	    , callback
	  );
	}
	
	define.classMethod('findOneAndUpdate', {callback: true, promise:true});
	
	/**
	 * Find and update a document.
	 * @method
	 * @param {object} query Query object to locate the object to modify.
	 * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
	 * @param {object} doc The fields/vals to be updated.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.remove=false] Set to true to remove the object before returning.
	 * @param {boolean} [options.upsert=false] Perform an upsert operation.
	 * @param {boolean} [options.new=false] Set to true if you want to return the modified object rather than the original. Ignored for remove.
	 * @param {object} [options.fields=null] Object containing the field projection for the result returned from the operation.
	 * @param {Collection~findAndModifyCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead
	 */
	Collection.prototype.findAndModify = function(query, sort, doc, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  sort = args.length ? args.shift() || [] : [];
	  doc = args.length ? args.shift() : null;
	  options = args.length ? args.shift() || {} : {};
	
	  // Clone options
	  var options = shallowClone(options);
	  // Force read preference primary
	  options.readPreference = ReadPreference.PRIMARY;
	
	  // Execute using callback
	  if(typeof callback == 'function') return findAndModify(self, query, sort, doc, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    options = options || {};
	
	    findAndModify(self, query, sort, doc, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var findAndModify = function(self, query, sort, doc, options, callback) {
	  // Create findAndModify command object
	  var queryObject = {
	     'findandmodify': self.s.name
	   , 'query': query
	  };
	
	  sort = formattedOrderClause(sort);
	  if(sort) {
	    queryObject.sort = sort;
	  }
	
	  queryObject.new = options.new ? true : false;
	  queryObject.remove = options.remove ? true : false;
	  queryObject.upsert = options.upsert ? true : false;
	
	  if(options.fields) {
	    queryObject.fields = options.fields;
	  }
	
	  if(doc && !options.remove) {
	    queryObject.update = doc;
	  }
	
	  // Either use override on the function, or go back to default on either the collection
	  // level or db
	  if(options['serializeFunctions'] != null) {
	    options['serializeFunctions'] = options['serializeFunctions'];
	  } else {
	    options['serializeFunctions'] = self.s.serializeFunctions;
	  }
	
	  // No check on the documents
	  options.checkKeys = false;
	
	  // Get the write concern settings
	  var finalOptions = writeConcern(options, self.s.db, self, options);
	
	  // Decorate the findAndModify command with the write Concern
	  if(finalOptions.writeConcern) {
	    queryObject.writeConcern = finalOptions.writeConcern;
	  }
	
	  // Have we specified bypassDocumentValidation
	  if(typeof finalOptions.bypassDocumentValidation == 'boolean') {
	    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
	  }
	
	  // Execute the command
	  self.s.db.command(queryObject
	    , options, function(err, result) {
	      if(err) return handleCallback(callback, err, null);
	      return handleCallback(callback, null, result);
	  });
	}
	
	define.classMethod('findAndModify', {callback: true, promise:true});
	
	/**
	 * Find and remove a document.
	 * @method
	 * @param {object} query Query object to locate the object to modify.
	 * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated use findOneAndDelete instead
	 */
	Collection.prototype.findAndRemove = function(query, sort, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  sort = args.length ? args.shift() || [] : [];
	  options = args.length ? args.shift() || {} : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return findAndRemove(self, query, sort, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    findAndRemove(self, query, sort, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var findAndRemove = function(self, query, sort, options, callback) {
	  // Add the remove option
	  options['remove'] = true;
	  // Execute the callback
	  self.findAndModify(query, sort, null, options, callback);
	}
	
	define.classMethod('findAndRemove', {callback: true, promise:true});
	
	/**
	 * Execute an aggregation framework pipeline against the collection, needs MongoDB >= 2.2
	 * @method
	 * @param {object} pipeline Array containing all the aggregation framework commands for the execution.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.cursor=null] Return the query as cursor, on 2.6 > it returns as a real cursor on pre 2.6 it returns as an emulated cursor.
	 * @param {number} [options.cursor.batchSize=null] The batchSize for the cursor
	 * @param {boolean} [options.explain=false] Explain returns the aggregation execution plan (requires mongodb 2.6 >).
	 * @param {boolean} [options.allowDiskUse=false] allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 >).
	 * @param {number} [options.maxTimeMS=null] maxTimeMS specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {(null|AggregationCursor)}
	 */
	Collection.prototype.aggregate = function(pipeline, options, callback) {
	  var self = this;
	  if(Array.isArray(pipeline)) {
	    // Set up callback if one is provided
	    if(typeof options == 'function') {
	      callback = options;
	      options = {};
	    }
	
	    // If we have no options or callback we are doing
	    // a cursor based aggregation
	    if(options == null && callback == null) {
	      options = {};
	    }
	  } else {
	    // Aggregation pipeline passed as arguments on the method
	    var args = Array.prototype.slice.call(arguments, 0);
	    // Get the callback
	    callback = args.pop();
	    // Get the possible options object
	    var opts = args[args.length - 1];
	    // If it contains any of the admissible options pop it of the args
	    options = opts && (opts.readPreference
	      || opts.explain || opts.cursor || opts.out
	      || opts.maxTimeMS || opts.allowDiskUse) ? args.pop() : {};
	      // Left over arguments is the pipeline
	    pipeline = args;
	  }
	
	  // Ignore readConcern option
	  var ignoreReadConcern = false;
	
	  // If out was specified
	  if(typeof options.out == 'string') {
	    pipeline.push({$out: options.out});
	    ignoreReadConcern = true;
	  } else if(pipeline.length > 0 && pipeline[pipeline.length - 1]['$out']) {
	    ignoreReadConcern = true;
	  }
	
	  // Build the command
	  var command = { aggregate : this.s.name, pipeline : pipeline};
	
	  // If we have bypassDocumentValidation set
	  if(typeof options.bypassDocumentValidation == 'boolean') {
	    command.bypassDocumentValidation = options.bypassDocumentValidation;
	  }
	
	  // Do we have a readConcern specified
	  if(!ignoreReadConcern && this.s.readConcern) {
	    command.readConcern = this.s.readConcern;
	  }
	
	  // If we have allowDiskUse defined
	  if(options.allowDiskUse) command.allowDiskUse = options.allowDiskUse;
	  if(typeof options.maxTimeMS == 'number') command.maxTimeMS = options.maxTimeMS;
	
	  options = shallowClone(options);
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(this, options, this.s.db, this);
	
	  // If explain has been specified add it
	  if(options.explain) command.explain = options.explain;
	
	  // Validate that cursor options is valid
	  if(options.cursor != null && typeof options.cursor != 'object') {
	    throw toError('cursor options must be an object');
	  }
	
	  // promiseLibrary
	  options.promiseLibrary = this.s.promiseLibrary;
	
	  // Set the AggregationCursor constructor
	  options.cursorFactory = AggregationCursor;
	  if(typeof callback != 'function') {
	    if(!this.s.topology.capabilities()) {
	      throw new MongoError('cannot connect to server');
	    }
	
	    if(this.s.topology.capabilities().hasAggregationCursor) {
	      options.cursor = options.cursor || { batchSize : 1000 };
	      command.cursor = options.cursor;
	    }
	
	    // Allow disk usage command
	    if(typeof options.allowDiskUse == 'boolean') command.allowDiskUse = options.allowDiskUse;
	    if(typeof options.maxTimeMS == 'number') command.maxTimeMS = options.maxTimeMS;
	
	    // Execute the cursor
	    return this.s.topology.cursor(this.s.namespace, command, options);
	  }
	
	  var cursor = null;
	  // We do not allow cursor
	  if(options.cursor) {
	    return this.s.topology.cursor(this.s.namespace, command, options);
	  }
	
	  // Execute the command
	  this.s.db.command(command, options, function(err, result) {
	    if(err) {
	      handleCallback(callback, err);
	    } else if(result['err'] || result['errmsg']) {
	      handleCallback(callback, toError(result));
	    } else if(typeof result == 'object' && result['serverPipeline']) {
	      handleCallback(callback, null, result['serverPipeline']);
	    } else if(typeof result == 'object' && result['stages']) {
	      handleCallback(callback, null, result['stages']);
	    } else {
	      handleCallback(callback, null, result.result);
	    }
	  });
	}
	
	define.classMethod('aggregate', {callback: true, promise:false});
	
	/**
	 * The callback format for results
	 * @callback Collection~parallelCollectionScanCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Cursor[]} cursors A list of cursors returned allowing for parallel reading of collection.
	 */
	
	/**
	 * Return N number of parallel cursors for a collection allowing parallel reading of entire collection. There are
	 * no ordering guarantees for returned results.
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.batchSize=null] Set the batchSize for the getMoreCommand when iterating over the query results.
	 * @param {number} [options.numCursors=1] The maximum number of parallel command cursors to return (the number of returned cursors will be in the range 1:numCursors)
	 * @param {boolean} [options.raw=false] Return all BSON documents as Raw Buffer documents.
	 * @param {Collection~parallelCollectionScanCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.parallelCollectionScan = function(options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {numCursors: 1};
	  // Set number of cursors to 1
	  options.numCursors = options.numCursors || 1;
	  options.batchSize = options.batchSize || 1000;
	
	  options = shallowClone(options);
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(this, options, this.s.db, this);
	
	  // Add a promiseLibrary
	  options.promiseLibrary = this.s.promiseLibrary;
	
	  // Execute using callback
	  if(typeof callback == 'function') return parallelCollectionScan(self, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    parallelCollectionScan(self, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var parallelCollectionScan = function(self, options, callback) {
	  // Create command object
	  var commandObject = {
	      parallelCollectionScan: self.s.name
	    , numCursors: options.numCursors
	  }
	
	  // Do we have a readConcern specified
	  if(self.s.readConcern) {
	    commandObject.readConcern = self.s.readConcern;
	  }
	
	  // Store the raw value
	  var raw = options.raw;
	  delete options['raw'];
	
	  // Execute the command
	  self.s.db.command(commandObject, options, function(err, result) {
	    if(err) return handleCallback(callback, err, null);
	    if(result == null) return handleCallback(callback, new Error("no result returned for parallelCollectionScan"), null);
	
	    var cursors = [];
	    // Add the raw back to the option
	    if(raw) options.raw = raw;
	    // Create command cursors for each item
	    for(var i = 0; i < result.cursors.length; i++) {
	      var rawId = result.cursors[i].cursor.id
	      // Convert cursorId to Long if needed
	      var cursorId = typeof rawId == 'number' ? Long.fromNumber(rawId) : rawId;
	
	      // Command cursor options
	      var cmd = {
	          batchSize: options.batchSize
	        , cursorId: cursorId
	        , items: result.cursors[i].cursor.firstBatch
	      }
	
	      // Add a command cursor
	      cursors.push(self.s.topology.cursor(self.s.namespace, cursorId, options));
	    }
	
	    handleCallback(callback, null, cursors);
	  });
	}
	
	define.classMethod('parallelCollectionScan', {callback: true, promise:true});
	
	/**
	 * Execute the geoNear command to search for items in the collection
	 *
	 * @method
	 * @param {number} x Point to search on the x axis, ensure the indexes are ordered in the same order.
	 * @param {number} y Point to search on the y axis, ensure the indexes are ordered in the same order.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.num=null] Max number of results to return.
	 * @param {number} [options.minDistance=null] Include results starting at minDistance from a point (2.6 or higher)
	 * @param {number} [options.maxDistance=null] Include results up to maxDistance from the point.
	 * @param {number} [options.distanceMultiplier=null] Include a value to multiply the distances with allowing for range conversions.
	 * @param {object} [options.query=null] Filter the results by a query.
	 * @param {boolean} [options.spherical=false] Perform query using a spherical model.
	 * @param {boolean} [options.uniqueDocs=false] The closest location in a document to the center of the search region will always be returned MongoDB > 2.X.
	 * @param {boolean} [options.includeLocs=false] Include the location data fields in the top level of the results MongoDB > 2.X.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.geoNear = function(x, y, options, callback) {
	  var self = this;
	  var point = typeof(x) == 'object' && x
	    , args = Array.prototype.slice.call(arguments, point?1:2);
	
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  // Fetch all commands
	  options = args.length ? args.shift() || {} : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return geoNear(self, x, y, point, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    geoNear(self, x, y, point, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var geoNear = function(self, x, y, point, options, callback) {
	  // Build command object
	  var commandObject = {
	    geoNear:self.s.name,
	    near: point || [x, y]
	  }
	
	  options = shallowClone(options);
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(self, options, self.s.db, self);
	
	  // Exclude readPreference and existing options to prevent user from
	  // shooting themselves in the foot
	  var exclude = {
	    readPreference: true,
	    geoNear: true,
	    near: true
	  };
	
	  // Filter out any excluded objects
	  commandObject = decorateCommand(commandObject, options, exclude);
	
	  // Do we have a readConcern specified
	  if(self.s.readConcern) {
	    commandObject.readConcern = self.s.readConcern;
	  }
	
	  // Execute the command
	  self.s.db.command(commandObject, options, function (err, res) {
	    if(err) return handleCallback(callback, err);
	    if(res.err || res.errmsg) return handleCallback(callback, toError(res));
	    // should we only be returning res.results here? Not sure if the user
	    // should see the other return information
	    handleCallback(callback, null, res);
	  });
	}
	
	define.classMethod('geoNear', {callback: true, promise:true});
	
	/**
	 * Execute a geo search using a geo haystack index on a collection.
	 *
	 * @method
	 * @param {number} x Point to search on the x axis, ensure the indexes are ordered in the same order.
	 * @param {number} y Point to search on the y axis, ensure the indexes are ordered in the same order.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.maxDistance=null] Include results up to maxDistance from the point.
	 * @param {object} [options.search=null] Filter the results by a query.
	 * @param {number} [options.limit=false] Max number of results to return.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.geoHaystackSearch = function(x, y, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  // Fetch all commands
	  options = args.length ? args.shift() || {} : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return geoHaystackSearch(self, x, y, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    geoHaystackSearch(self, x, y, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var geoHaystackSearch = function(self, x, y, options, callback) {
	  // Build command object
	  var commandObject = {
	    geoSearch: self.s.name,
	    near: [x, y]
	  }
	
	  // Remove read preference from hash if it exists
	  commandObject = decorateCommand(commandObject, options, {readPreference: true});
	
	  options = shallowClone(options);
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(self, options, self.s.db, self);
	
	  // Do we have a readConcern specified
	  if(self.s.readConcern) {
	    commandObject.readConcern = self.s.readConcern;
	  }
	
	  // Execute the command
	  self.s.db.command(commandObject, options, function (err, res) {
	    if(err) return handleCallback(callback, err);
	    if(res.err || res.errmsg) handleCallback(callback, utils.toError(res));
	    // should we only be returning res.results here? Not sure if the user
	    // should see the other return information
	    handleCallback(callback, null, res);
	  });
	}
	
	define.classMethod('geoHaystackSearch', {callback: true, promise:true});
	
	/**
	 * Group function helper
	 * @ignore
	 */
	// var groupFunction = function () {
	//   var c = db[ns].find(condition);
	//   var map = new Map();
	//   var reduce_function = reduce;
	//
	//   while (c.hasNext()) {
	//     var obj = c.next();
	//     var key = {};
	//
	//     for (var i = 0, len = keys.length; i < len; ++i) {
	//       var k = keys[i];
	//       key[k] = obj[k];
	//     }
	//
	//     var aggObj = map.get(key);
	//
	//     if (aggObj == null) {
	//       var newObj = Object.extend({}, key);
	//       aggObj = Object.extend(newObj, initial);
	//       map.put(key, aggObj);
	//     }
	//
	//     reduce_function(obj, aggObj);
	//   }
	//
	//   return { "result": map.values() };
	// }.toString();
	var groupFunction = 'function () {\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) {\nvar obj = c.next();\nvar key = {};\n\nfor (var i = 0, len = keys.length; i < len; ++i) {\nvar k = keys[i];\nkey[k] = obj[k];\n}\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) {\nvar newObj = Object.extend({}, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n}\n\nreduce_function(obj, aggObj);\n}\n\nreturn { "result": map.values() };\n}';
	
	/**
	 * Run a group command across a collection
	 *
	 * @method
	 * @param {(object|array|function|code)} keys An object, array or function expressing the keys to group by.
	 * @param {object} condition An optional condition that must be true for a row to be considered.
	 * @param {object} initial Initial value of the aggregation counter object.
	 * @param {(function|Code)} reduce The reduce function aggregates (reduces) the objects iterated
	 * @param {(function|Code)} finalize An optional function to be run on each item in the result set just before the item is returned.
	 * @param {boolean} command Specify if you wish to run using the internal group command or using eval, default is true.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.group = function(keys, condition, initial, reduce, finalize, command, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 3);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  // Fetch all commands
	  reduce = args.length ? args.shift() : null;
	  finalize = args.length ? args.shift() : null;
	  command = args.length ? args.shift() : null;
	  options = args.length ? args.shift() || {} : {};
	
	  // Make sure we are backward compatible
	  if(!(typeof finalize == 'function')) {
	    command = finalize;
	    finalize = null;
	  }
	
	  if (!Array.isArray(keys) && keys instanceof Object && typeof(keys) !== 'function' && !(keys instanceof Code)) {
	    keys = Object.keys(keys);
	  }
	
	  if(typeof reduce === 'function') {
	    reduce = reduce.toString();
	  }
	
	  if(typeof finalize === 'function') {
	    finalize = finalize.toString();
	  }
	
	  // Set up the command as default
	  command = command == null ? true : command;
	
	  // Execute using callback
	  if(typeof callback == 'function') return group(self, keys, condition, initial, reduce, finalize, command, options, callback);
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    group(self, keys, condition, initial, reduce, finalize, command, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var group = function(self, keys, condition, initial, reduce, finalize, command, options, callback) {
	  // Execute using the command
	  if(command) {
	    var reduceFunction = reduce instanceof Code
	        ? reduce
	        : new Code(reduce);
	
	    var selector = {
	      group: {
	          'ns': self.s.name
	        , '$reduce': reduceFunction
	        , 'cond': condition
	        , 'initial': initial
	        , 'out': "inline"
	      }
	    };
	
	    // if finalize is defined
	    if(finalize != null) selector.group['finalize'] = finalize;
	    // Set up group selector
	    if ('function' === typeof keys || keys instanceof Code) {
	      selector.group.$keyf = keys instanceof Code
	        ? keys
	        : new Code(keys);
	    } else {
	      var hash = {};
	      keys.forEach(function (key) {
	        hash[key] = 1;
	      });
	      selector.group.key = hash;
	    }
	
	    options = shallowClone(options);
	    // Ensure we have the right read preference inheritance
	    options = getReadPreference(self, options, self.s.db, self);
	
	    // Do we have a readConcern specified
	    if(self.s.readConcern) {
	      selector.readConcern = self.s.readConcern;
	    }
	
	    // Execute command
	    self.s.db.command(selector, options, function(err, result) {
	      if(err) return handleCallback(callback, err, null);
	      handleCallback(callback, null, result.retval);
	    });
	  } else {
	    // Create execution scope
	    var scope = reduce != null && reduce instanceof Code
	      ? reduce.scope
	      : {};
	
	    scope.ns = self.s.name;
	    scope.keys = keys;
	    scope.condition = condition;
	    scope.initial = initial;
	
	    // Pass in the function text to execute within mongodb.
	    var groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');
	
	    self.s.db.eval(new Code(groupfn, scope), function (err, results) {
	      if (err) return handleCallback(callback, err, null);
	      handleCallback(callback, null, results.result || results);
	    });
	  }
	}
	
	define.classMethod('group', {callback: true, promise:true});
	
	/**
	 * Functions that are passed as scope args must
	 * be converted to Code instances.
	 * @ignore
	 */
	function processScope (scope) {
	  if(!isObject(scope)) {
	    return scope;
	  }
	
	  var keys = Object.keys(scope);
	  var i = keys.length;
	  var key;
	  var new_scope = {};
	
	  while (i--) {
	    key = keys[i];
	    if ('function' == typeof scope[key]) {
	      new_scope[key] = new Code(String(scope[key]));
	    } else {
	      new_scope[key] = processScope(scope[key]);
	    }
	  }
	
	  return new_scope;
	}
	
	/**
	 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
	 *
	 * @method
	 * @param {(function|string)} map The mapping function.
	 * @param {(function|string)} reduce The reduce function.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.out=null] Sets the output target for the map reduce job. *{inline:1} | {replace:'collectionName'} | {merge:'collectionName'} | {reduce:'collectionName'}*
	 * @param {object} [options.query=null] Query filter object.
	 * @param {object} [options.sort=null] Sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces.
	 * @param {number} [options.limit=null] Number of objects to return from collection.
	 * @param {boolean} [options.keeptemp=false] Keep temporary data.
	 * @param {(function|string)} [options.finalize=null] Finalize function.
	 * @param {object} [options.scope=null] Can pass in variables that can be access from map/reduce/finalize.
	 * @param {boolean} [options.jsMode=false] It is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X.
	 * @param {boolean} [options.verbose=false] Provide statistics on job execution time.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.mapReduce = function(map, reduce, options, callback) {
	  var self = this;
	  if('function' === typeof options) callback = options, options = {};
	  // Out must allways be defined (make sure we don't break weirdly on pre 1.8+ servers)
	  if(null == options.out) {
	    throw new Error("the out option parameter must be defined, see mongodb docs for possible values");
	  }
	
	  if('function' === typeof map) {
	    map = map.toString();
	  }
	
	  if('function' === typeof reduce) {
	    reduce = reduce.toString();
	  }
	
	  if('function' === typeof options.finalize) {
	    options.finalize = options.finalize.toString();
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return mapReduce(self, map, reduce, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    mapReduce(self, map, reduce, options, function(err, r, r1) {
	      if(err) return reject(err);
	      if(!r1) return resolve(r);
	      resolve({results: r, stats: r1});
	    });
	  });
	}
	
	var mapReduce = function(self, map, reduce, options, callback) {
	  var mapCommandHash = {
	      mapreduce: self.s.name
	    , map: map
	    , reduce: reduce
	  };
	
	  // Add any other options passed in
	  for(var n in options) {
	    if('scope' == n) {
	      mapCommandHash[n] = processScope(options[n]);
	    } else {
	      mapCommandHash[n] = options[n];
	    }
	  }
	
	  options = shallowClone(options);
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(self, options, self.s.db, self);
	
	  // If we have a read preference and inline is not set as output fail hard
	  if((options.readPreference != false && options.readPreference != 'primary')
	    && options['out'] && (options['out'].inline != 1 && options['out'] != 'inline')) {
	      options.readPreference = 'primary';
	  } else if(self.s.readConcern) {
	    mapCommandHash.readConcern = self.s.readConcern;
	  }
	
	  // Is bypassDocumentValidation specified
	  if(typeof options.bypassDocumentValidation == 'boolean') {
	    mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;
	  }
	
	  // Execute command
	  self.s.db.command(mapCommandHash, {readPreference:options.readPreference}, function (err, result) {
	    if(err) return handleCallback(callback, err);
	    // Check if we have an error
	    if(1 != result.ok || result.err || result.errmsg) {
	      return handleCallback(callback, toError(result));
	    }
	
	    // Create statistics value
	    var stats = {};
	    if(result.timeMillis) stats['processtime'] = result.timeMillis;
	    if(result.counts) stats['counts'] = result.counts;
	    if(result.timing) stats['timing'] = result.timing;
	
	    // invoked with inline?
	    if(result.results) {
	      // If we wish for no verbosity
	      if(options['verbose'] == null || !options['verbose']) {
	        return handleCallback(callback, null, result.results);
	      }
	
	      return handleCallback(callback, null, result.results, stats);
	    }
	
	    // The returned collection
	    var collection = null;
	
	    // If we have an object it's a different db
	    if(result.result != null && typeof result.result == 'object') {
	      var doc = result.result;
	      collection = self.s.db.db(doc.db).collection(doc.collection);
	    } else {
	      // Create a collection object that wraps the result collection
	      collection = self.s.db.collection(result.result)
	    }
	
	    // If we wish for no verbosity
	    if(options['verbose'] == null || !options['verbose']) {
	      return handleCallback(callback, err, collection);
	    }
	
	    // Return stats as third set of values
	    handleCallback(callback, err, collection, stats);
	  });
	}
	
	define.classMethod('mapReduce', {callback: true, promise:true});
	
	/**
	 * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @return {UnorderedBulkOperation}
	 */
	Collection.prototype.initializeUnorderedBulkOp = function(options) {
	  options = options || {};
	  options.promiseLibrary = this.s.promiseLibrary;
	  return unordered(this.s.topology, this, options);
	}
	
	define.classMethod('initializeUnorderedBulkOp', {callback: false, promise:false, returns: [ordered.UnorderedBulkOperation]});
	
	/**
	 * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {OrderedBulkOperation} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.initializeOrderedBulkOp = function(options) {
	  options = options || {};
	  options.promiseLibrary = this.s.promiseLibrary;
	  return ordered(this.s.topology, this, options);
	}
	
	define.classMethod('initializeOrderedBulkOp', {callback: false, promise:false, returns: [ordered.OrderedBulkOperation]});
	
	// Get write concern
	var writeConcern = function(target, db, col, options) {
	  if(options.w != null || options.j != null || options.fsync != null) {
	    var opts = {};
	    if(options.w != null) opts.w = options.w;
	    if(options.wtimeout != null) opts.wtimeout = options.wtimeout;
	    if(options.j != null) opts.j = options.j;
	    if(options.fsync != null) opts.fsync = options.fsync;
	    target.writeConcern = opts;
	  } else if(col.writeConcern.w != null || col.writeConcern.j != null || col.writeConcern.fsync != null) {
	    target.writeConcern = col.writeConcern;
	  } else if(db.writeConcern.w != null || db.writeConcern.j != null || db.writeConcern.fsync != null) {
	    target.writeConcern = db.writeConcern;
	  }
	
	  return target
	}
	
	// Figure out the read preference
	var getReadPreference = function(self, options, db, coll) {
	  var r = null
	  if(options.readPreference) {
	    r = options.readPreference
	  } else if(self.s.readPreference) {
	    r = self.s.readPreference
	  } else if(db.readPreference) {
	    r = db.readPreference;
	  }
	
	  if(r instanceof ReadPreference) {
	    options.readPreference = new CoreReadPreference(r.mode, r.tags);
	  } else if(typeof r == 'string') {
	    options.readPreference = new CoreReadPreference(r);
	  } else if(r && !(r instanceof ReadPreference) && typeof r == 'object') {
	    var mode = r.mode || r.preference;
	    if (mode && typeof mode == 'string') {
	      options.readPreference = new CoreReadPreference(mode, r.tags);
	    }
	  }
	
	  return options;
	}
	
	var testForFields = {
	    limit: 1, sort: 1, fields:1, skip: 1, hint: 1, explain: 1, snapshot: 1, timeout: 1, tailable: 1, tailableRetryInterval: 1
	  , numberOfRetries: 1, awaitdata: 1, awaitData: 1, exhaust: 1, batchSize: 1, returnKey: 1, maxScan: 1, min: 1, max: 1, showDiskLoc: 1
	  , comment: 1, raw: 1, readPreference: 1, partial: 1, read: 1, dbName: 1, oplogReplay: 1, connection: 1, maxTimeMS: 1, transforms: 1
	}
	
	module.exports = Collection;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(9).Buffer))

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var EventEmitter = __webpack_require__(3).EventEmitter
	  , inherits = __webpack_require__(77).inherits
	  , CServer = __webpack_require__(156).Server
	  , Cursor = __webpack_require__(197)
	  , AggregationCursor = __webpack_require__(193)
	  , CommandCursor = __webpack_require__(201)
	  , f = __webpack_require__(77).format
	  , ServerCapabilities = __webpack_require__(209).ServerCapabilities
	  , Store = __webpack_require__(209).Store
	  , Define = __webpack_require__(196)
	  , MongoError = __webpack_require__(156).MongoError
	  , shallowClone = __webpack_require__(194).shallowClone
	  , MAX_JS_INT = __webpack_require__(194).MAX_JS_INT;
	
	/**
	 * @fileOverview The **Server** class is a class that represents a single server topology and is
	 * used to construct connections.
	 *
	 * **Server Should not be used, use MongoClient.connect**
	 * @example
	 * var Db = require('mongodb').Db,
	 *   Server = require('mongodb').Server,
	 *   test = require('assert');
	 * // Connect using single Server
	 * var db = new Db('test', new Server('localhost', 27017););
	 * db.open(function(err, db) {
	 *   // Get an additional db
	 *   db.close();
	 * });
	 */
	
	/**
	 * Creates a new Server instance
	 * @class
	 * @deprecated
	 * @param {string} host The host for the server, can be either an IP4, IP6 or domain socket style host.
	 * @param {number} [port] The server port if IP4.
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.
	 * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)
	 * @param {object} [options.sslValidate=true] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {array} [options.sslCA=null] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslCert=null] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslKey=null] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslPass=null] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {object} [options.socketOptions=null] Socket options
	 * @param {boolean} [options.socketOptions.autoReconnect=true] Reconnect on error.
	 * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.
	 * @param {number} [options.socketOptions.keepAlive=0] TCP KeepAlive on the socket with a X ms delay before start.
	 * @param {number} [options.socketOptions.connectTimeoutMS=0] TCP Connection timeout setting
	 * @param {number} [options.socketOptions.socketTimeoutMS=0] TCP Socket timeout setting
	 * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times
	 * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries
	 * @fires Server#connect
	 * @fires Server#close
	 * @fires Server#error
	 * @fires Server#timeout
	 * @fires Server#parseError
	 * @fires Server#reconnect
	 * @return {Server} a Server instance.
	 */
	var Server = function(host, port, options) {
	  options = options || {};
	  if(!(this instanceof Server)) return new Server(host, port, options);
	  EventEmitter.call(this);
	  var self = this;
	
	  // Store option defaults
	  var storeOptions = {
	      force: false
	    , bufferMaxEntries: -1
	  }
	
	  // If we have "unlimited" set to max Number
	  if(storeOptions.bufferMaxEntries == -1) {
	    storeOptions.bufferMaxEntries = MAX_JS_INT;
	  }
	
	  // Shared global store
	  var store = options.store || new Store(self, storeOptions);
	
	  // Detect if we have a socket connection
	  if(host.indexOf('\/') != -1) {
	    if(port != null && typeof port == 'object') {
	      options = port;
	      port = null;
	    }
	  } else if(port == null) {
	    throw MongoError.create({message: 'port must be specified', driver:true});
	  }
	
	  // Clone options
	  var clonedOptions = shallowClone(options);
	  clonedOptions.host = host;
	  clonedOptions.port = port;
	
	  // Reconnect
	  var reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;
	  reconnect = typeof options.autoReconnect == 'boolean' ? options.autoReconnect : reconnect;
	  var emitError = typeof options.emitError == 'boolean' ? options.emitError : true;
	  var poolSize = typeof options.poolSize == 'number' ? options.poolSize : 5;
	
	  // Socket options passed down
	  if(options.socketOptions) {
	    if(options.socketOptions.connectTimeoutMS) {
	      this.connectTimeoutMS = options.socketOptions.connectTimeoutMS;
	      clonedOptions.connectionTimeout = options.socketOptions.connectTimeoutMS;
	    }
	
	    if(options.socketOptions.socketTimeoutMS) {
	      clonedOptions.socketTimeout = options.socketOptions.socketTimeoutMS;
	    }
	
	    if(typeof options.socketOptions.keepAlive == 'number') {
	      clonedOptions.keepAliveInitialDelay = options.socketOptions.keepAlive;
	      clonedOptions.keepAlive = true;
	    }
	
	    if(typeof options.socketOptions.noDelay == 'boolean') {
	      clonedOptions.noDelay = options.socketOptions.noDelay;
	    }
	  }
	
	  // Add the cursor factory function
	  clonedOptions.cursorFactory = Cursor;
	  clonedOptions.reconnect = reconnect;
	  clonedOptions.emitError = emitError;
	  clonedOptions.size = poolSize;
	
	  // Translate the options
	  if(clonedOptions.sslCA) clonedOptions.ca = clonedOptions.sslCA;
	  if(typeof clonedOptions.sslValidate == 'boolean') clonedOptions.rejectUnauthorized = clonedOptions.sslValidate;
	  if(clonedOptions.sslKey) clonedOptions.key = clonedOptions.sslKey;
	  if(clonedOptions.sslCert) clonedOptions.cert = clonedOptions.sslCert;
	  if(clonedOptions.sslPass) clonedOptions.passphrase = clonedOptions.sslPass;
	
	  // Add the non connection store
	  clonedOptions.disconnectHandler = store;
	
	  // Create an instance of a server instance from mongodb-core
	  var server = new CServer(clonedOptions);
	  // Server capabilities
	  var sCapabilities = null;
	
	  // Define the internal properties
	  this.s = {
	    // Create an instance of a server instance from mongodb-core
	      server: server
	    // Server capabilities
	    , sCapabilities: null
	    // Cloned options
	    , clonedOptions: clonedOptions
	    // Reconnect
	    , reconnect: reconnect
	    // Emit error
	    , emitError: emitError
	    // Pool size
	    , poolSize: poolSize
	    // Store Options
	    , storeOptions: storeOptions
	    // Store
	    , store: store
	    // Host
	    , host: host
	    // Port
	    , port: port
	    // Options
	    , options: options
	  }
	
	  // BSON property
	  Object.defineProperty(this, 'bson', {
	    enumerable: true, get: function() {
	      return self.s.server.bson;
	    }
	  });
	
	  // Last ismaster
	  Object.defineProperty(this, 'isMasterDoc', {
	    enumerable:true, get: function() {
	      return self.s.server.lastIsMaster();
	    }
	  });
	
	  // Last ismaster
	  Object.defineProperty(this, 'poolSize', {
	    enumerable:true, get: function() { return self.s.server.connections().length; }
	  });
	
	  Object.defineProperty(this, 'autoReconnect', {
	    enumerable:true, get: function() { return self.s.reconnect; }
	  });
	
	  Object.defineProperty(this, 'host', {
	    enumerable:true, get: function() { return self.s.host; }
	  });
	
	  Object.defineProperty(this, 'port', {
	    enumerable:true, get: function() { return self.s.port; }
	  });
	}
	
	inherits(Server, EventEmitter);
	
	var define = Server.define = new Define('Server', Server, false);
	
	Server.prototype.parserType = function() {
	  return this.s.server.parserType();
	}
	
	define.classMethod('parserType', {callback: false, promise:false, returns: [String]});
	
	// Connect
	Server.prototype.connect = function(db, _options, callback) {
	  var self = this;
	  if('function' === typeof _options) callback = _options, _options = {};
	  if(_options == null) _options = {};
	  if(!('function' === typeof callback)) callback = null;
	  self.s.options = _options;
	
	  // Update bufferMaxEntries
	  self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;
	
	  // Error handler
	  var connectErrorHandler = function(event) {
	    return function(err) {
	      // Remove all event handlers
	      var events = ['timeout', 'error', 'close'];
	      events.forEach(function(e) {
	        self.s.server.removeListener(e, connectHandlers[e]);
	      });
	
	      self.s.server.removeListener('connect', connectErrorHandler);
	
	      // Try to callback
	      try {
	        callback(err);
	      } catch(err) {
	        process.nextTick(function() { throw err; })
	      }
	    }
	  }
	
	  // Actual handler
	  var errorHandler = function(event) {
	    return function(err) {
	      if(event != 'error') {
	        self.emit(event, err);
	      }
	    }
	  }
	
	  // Error handler
	  var reconnectHandler = function(err) {
	    self.emit('reconnect', self);
	    self.s.store.execute();
	  }
	
	  // Destroy called on topology, perform cleanup
	  var destroyHandler = function() {
	    self.s.store.flush();
	  }
	
	  // Connect handler
	  var connectHandler = function() {
	    // Clear out all the current handlers left over
	    ["timeout", "error", "close", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	      'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed', 'topologyOpening',
	      'topologyClosed', 'topologyDescriptionChanged'].forEach(function(e) {
	      self.s.server.removeAllListeners(e);
	    });
	
	    // Set up listeners
	    self.s.server.once('timeout', errorHandler('timeout'));
	    self.s.server.once('error', errorHandler('error'));
	    self.s.server.on('close', errorHandler('close'));
	    // Only called on destroy
	    self.s.server.once('destroy', destroyHandler);
	
	    // relay the event
	    var relay = function(event) {
	      return function(t, server) {
	        self.emit(event, t, server);
	      }
	    }
	
	    // Set up SDAM listeners
	    self.s.server.on('serverDescriptionChanged', relay('serverDescriptionChanged'));
	    self.s.server.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));
	    self.s.server.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));
	    self.s.server.on('serverHearbeatFailed', relay('serverHearbeatFailed'));
	    self.s.server.on('serverOpening', relay('serverOpening'));
	    self.s.server.on('serverClosed', relay('serverClosed'));
	    self.s.server.on('topologyOpening', relay('topologyOpening'));
	    self.s.server.on('topologyClosed', relay('topologyClosed'));
	    self.s.server.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));
	
	    // Emit open event
	    self.emit('open', null, self);
	
	    // Return correctly
	    try {
	      callback(null, self);
	    } catch(err) {
	      console.log(err.stack)
	      process.nextTick(function() { throw err; })
	    }
	  }
	
	  // Set up listeners
	  var connectHandlers = {
	    timeout: connectErrorHandler('timeout'),
	    error: connectErrorHandler('error'),
	    close: connectErrorHandler('close')
	  };
	
	  // Add the event handlers
	  self.s.server.once('timeout', connectHandlers.timeout);
	  self.s.server.once('error', connectHandlers.error);
	  self.s.server.once('close', connectHandlers.close);
	  self.s.server.once('connect', connectHandler);
	  // Reconnect server
	  self.s.server.on('reconnect', reconnectHandler);
	
	  // Start connection
	  self.s.server.connect(_options);
	}
	
	// Server capabilities
	Server.prototype.capabilities = function() {
	  if(this.s.sCapabilities) return this.s.sCapabilities;
	  if(this.s.server.lastIsMaster() == null) return null;
	  this.s.sCapabilities = new ServerCapabilities(this.s.server.lastIsMaster());
	  return this.s.sCapabilities;
	}
	
	define.classMethod('capabilities', {callback: false, promise:false, returns: [ServerCapabilities]});
	
	// Command
	Server.prototype.command = function(ns, cmd, options, callback) {
	  this.s.server.command(ns, cmd, options, callback);
	}
	
	define.classMethod('command', {callback: true, promise:false});
	
	// Insert
	Server.prototype.insert = function(ns, ops, options, callback) {
	  this.s.server.insert(ns, ops, options, callback);
	}
	
	define.classMethod('insert', {callback: true, promise:false});
	
	// Update
	Server.prototype.update = function(ns, ops, options, callback) {
	  this.s.server.update(ns, ops, options, callback);
	}
	
	define.classMethod('update', {callback: true, promise:false});
	
	// Remove
	Server.prototype.remove = function(ns, ops, options, callback) {
	  this.s.server.remove(ns, ops, options, callback);
	}
	
	define.classMethod('remove', {callback: true, promise:false});
	
	// IsConnected
	Server.prototype.isConnected = function() {
	  return this.s.server.isConnected();
	}
	
	Server.prototype.isDestroyed = function() {
	  return this.s.server.isDestroyed();
	}
	
	define.classMethod('isConnected', {callback: false, promise:false, returns: [Boolean]});
	
	// Insert
	Server.prototype.cursor = function(ns, cmd, options) {
	  options.disconnectHandler = this.s.store;
	  return this.s.server.cursor(ns, cmd, options);
	}
	
	define.classMethod('cursor', {callback: false, promise:false, returns: [Cursor, AggregationCursor, CommandCursor]});
	
	Server.prototype.setBSONParserType = function(type) {
	  return this.s.server.setBSONParserType(type);
	}
	
	Server.prototype.lastIsMaster = function() {
	  return this.s.server.lastIsMaster();
	}
	
	Server.prototype.close = function(forceClosed) {
	  this.s.server.destroy();
	  // We need to wash out all stored processes
	  if(forceClosed == true) {
	    this.s.storeOptions.force = forceClosed;
	    this.s.store.flush();
	  }
	}
	
	define.classMethod('close', {callback: false, promise:false});
	
	Server.prototype.auth = function() {
	  var args = Array.prototype.slice.call(arguments, 0);
	  this.s.server.auth.apply(this.s.server, args);
	}
	
	define.classMethod('auth', {callback: true, promise:false});
	
	/**
	 * All raw connections
	 * @method
	 * @return {array}
	 */
	Server.prototype.connections = function() {
	  return this.s.server.connections();
	}
	
	define.classMethod('connections', {callback: false, promise:false, returns:[Array]});
	
	/**
	 * Server connect event
	 *
	 * @event Server#connect
	 * @type {object}
	 */
	
	/**
	 * Server close event
	 *
	 * @event Server#close
	 * @type {object}
	 */
	
	/**
	 * Server reconnect event
	 *
	 * @event Server#reconnect
	 * @type {object}
	 */
	
	/**
	 * Server error event
	 *
	 * @event Server#error
	 * @type {MongoError}
	 */
	
	/**
	 * Server timeout event
	 *
	 * @event Server#timeout
	 * @type {object}
	 */
	
	/**
	 * Server parseError event
	 *
	 * @event Server#parseError
	 * @type {object}
	 */
	
	module.exports = Server;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var MongoError = __webpack_require__(156).MongoError
	  , f = __webpack_require__(77).format;
	
	// The store of ops
	var Store = function(topology, storeOptions) {
	  var self = this;
	  var storedOps = [];
	  storeOptions = storeOptions || {force:false, bufferMaxEntries: -1}
	
	  // Internal state
	  this.s = {
	      storedOps: storedOps
	    , storeOptions: storeOptions
	    , topology: topology
	  }
	
	  Object.defineProperty(this, 'length', {
	    enumerable:true, get: function() { return self.s.storedOps.length; }
	  });
	}
	
	Store.prototype.add = function(opType, ns, ops, options, callback) {
	  if(this.s.storeOptions.force) {
	    return callback(MongoError.create({message: "db closed by application", driver:true}));
	  }
	
	  if(this.s.storeOptions.bufferMaxEntries == 0) {
	    return callback(MongoError.create({message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver:true }));
	  }
	
	  if(this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
	    while(this.s.storedOps.length > 0) {
	      var op = this.s.storedOps.shift();
	      op.c(MongoError.create({message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver:true }));
	    }
	
	    return;
	  }
	
	  this.s.storedOps.push({t: opType, n: ns, o: ops, op: options, c: callback})
	}
	
	Store.prototype.addObjectAndMethod = function(opType, object, method, params, callback) {
	  if(this.s.storeOptions.force) {
	    return callback(MongoError.create({message: "db closed by application", driver:true }));
	  }
	
	  if(this.s.storeOptions.bufferMaxEntries == 0) {
	    return callback(MongoError.create({message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver:true }));
	  }
	
	  if(this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
	    while(this.s.storedOps.length > 0) {
	      var op = this.s.storedOps.shift();
	      op.c(MongoError.create({message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver:true }));
	    }
	
	    return;
	  }
	
	  this.s.storedOps.push({t: opType, m: method, o: object, p: params, c: callback})
	}
	
	Store.prototype.flush = function() {
	  while(this.s.storedOps.length > 0) {
	    this.s.storedOps.shift().c(MongoError.create({message: f("no connection available for operation"), driver:true }));
	  }
	}
	
	Store.prototype.execute = function() {
	  // Get current ops
	  var ops = this.s.storedOps;
	  // Reset the ops
	  this.s.storedOps = [];
	
	  // Execute all the stored ops
	  while(ops.length > 0) {
	    var op = ops.shift();
	
	    if(op.t == 'cursor') {
	      op.o[op.m].apply(op.o, op.p);
	    } else {
	      this.s.topology[op.t](op.n, op.o, op.op, op.c);
	    }
	  }
	}
	
	Store.prototype.all = function() {
	  return this.s.storedOps;
	}
	
	// Server capabilities
	var ServerCapabilities = function(ismaster) {
	  var setup_get_property = function(object, name, value) {
	    Object.defineProperty(object, name, {
	        enumerable: true
	      , get: function () { return value; }
	    });
	  }
	
	  // Capabilities
	  var aggregationCursor = false;
	  var writeCommands = false;
	  var textSearch = false;
	  var authCommands = false;
	  var listCollections = false;
	  var listIndexes = false;
	  var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1000;
	
	  if(ismaster.minWireVersion >= 0) {
	    textSearch = true;
	  }
	
	  if(ismaster.maxWireVersion >= 1) {
	    aggregationCursor = true;
	    authCommands = true;
	  }
	
	  if(ismaster.maxWireVersion >= 2) {
	    writeCommands = true;
	  }
	
	  if(ismaster.maxWireVersion >= 3) {
	    listCollections = true;
	    listIndexes = true;
	  }
	
	  // If no min or max wire version set to 0
	  if(ismaster.minWireVersion == null) {
	    ismaster.minWireVersion = 0;
	  }
	
	  if(ismaster.maxWireVersion == null) {
	    ismaster.maxWireVersion = 0;
	  }
	
	  // Map up read only parameters
	  setup_get_property(this, "hasAggregationCursor", aggregationCursor);
	  setup_get_property(this, "hasWriteCommands", writeCommands);
	  setup_get_property(this, "hasTextSearch", textSearch);
	  setup_get_property(this, "hasAuthCommands", authCommands);
	  setup_get_property(this, "hasListCollectionsCommand", listCollections);
	  setup_get_property(this, "hasListIndexesCommand", listIndexes);
	  setup_get_property(this, "minWireVersion", ismaster.minWireVersion);
	  setup_get_property(this, "maxWireVersion", ismaster.maxWireVersion);
	  setup_get_property(this, "maxNumberOfDocsInBatch", maxNumberOfDocsInBatch);
	}
	
	exports.Store = Store;
	exports.ServerCapabilities = ServerCapabilities;


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var EventEmitter = __webpack_require__(3).EventEmitter
	  , inherits = __webpack_require__(77).inherits
	  , f = __webpack_require__(77).format
	  , Server = __webpack_require__(208)
	  , Mongos = __webpack_require__(211)
	  , Cursor = __webpack_require__(197)
	  , AggregationCursor = __webpack_require__(193)
	  , CommandCursor = __webpack_require__(201)
	  , ReadPreference = __webpack_require__(195)
	  , MongoCR = __webpack_require__(156).MongoCR
	  , MongoError = __webpack_require__(156).MongoError
	  , ServerCapabilities = __webpack_require__(209).ServerCapabilities
	  , Store = __webpack_require__(209).Store
	  , Define = __webpack_require__(196)
	  , CServer = __webpack_require__(156).Server
	  , CReplSet = __webpack_require__(156).ReplSet
	  , CoreReadPreference = __webpack_require__(156).ReadPreference
	  , shallowClone = __webpack_require__(194).shallowClone
	  , MAX_JS_INT = __webpack_require__(194).MAX_JS_INT;
	
	/**
	 * @fileOverview The **ReplSet** class is a class that represents a Replicaset topology and is
	 * used to construct connections.
	 *
	 * **ReplSet Should not be used, use MongoClient.connect**
	 * @example
	 * var Db = require('mongodb').Db,
	 *   ReplSet = require('mongodb').ReplSet,
	 *   Server = require('mongodb').Server,
	 *   test = require('assert');
	 * // Connect using ReplSet
	 * var server = new Server('localhost', 27017);
	 * var db = new Db('test', new ReplSet([server]));
	 * db.open(function(err, db) {
	 *   // Get an additional db
	 *   db.close();
	 * });
	 */
	
	/**
	 * Creates a new ReplSet instance
	 * @class
	 * @deprecated
	 * @param {Server[]} servers A seedlist of servers participating in the replicaset.
	 * @param {object} [options=null] Optional settings.
	 * @param {booelan} [options.ha=true] Turn on high availability monitoring.
	 * @param {number} [options.haInterval=10000] Time between each replicaset status check.
	 * @param {string} options.replicaSet The name of the replicaset to connect to.
	 * @param {number} [options.secondaryAcceptableLatencyMS=15] Sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15) ms)
	 * @param {boolean} [options.connectWithNoPrimary=false] Sets if the driver should connect even if no primary is available
	 * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.
	 * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {object} [options.sslValidate=true] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {array} [options.sslCA=null] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslCert=null] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslKey=null] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslPass=null] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {object} [options.socketOptions=null] Socket options
	 * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.
	 * @param {number} [options.socketOptions.keepAlive=0] TCP KeepAlive on the socket with a X ms delay before start.
	 * @param {number} [options.socketOptions.connectTimeoutMS=10000] TCP Connection timeout setting
	 * @param {number} [options.socketOptions.socketTimeoutMS=0] TCP Socket timeout setting
	 * @fires ReplSet#connect
	 * @fires ReplSet#ha
	 * @fires ReplSet#joined
	 * @fires ReplSet#left
	 * @fires ReplSet#fullsetup
	 * @fires ReplSet#open
	 * @fires ReplSet#close
	 * @fires ReplSet#error
	 * @fires ReplSet#timeout
	 * @fires ReplSet#parseError
	 * @return {ReplSet} a ReplSet instance.
	 */
	var ReplSet = function(servers, options) {
	  if(!(this instanceof ReplSet)) return new ReplSet(servers, options);
	  options = options || {};
	  var self = this;
	
	  // Ensure all the instances are Server
	  for(var i = 0; i < servers.length; i++) {
	    if(!(servers[i] instanceof Server)) {
	      throw MongoError.create({message: "all seed list instances must be of the Server type", driver:true});
	    }
	  }
	
	  // Store option defaults
	  var storeOptions = {
	      force: false
	    , bufferMaxEntries: -1
	  }
	
	  // If we have "unlimited" set to max Number
	  if(storeOptions.bufferMaxEntries == -1) {
	    storeOptions.bufferMaxEntries = MAX_JS_INT;
	  }
	
	  // Shared global store
	  var store = options.store || new Store(self, storeOptions);
	
	  // Set up event emitter
	  EventEmitter.call(this);
	
	  // Debug tag
	  var tag = options.tag;
	
	  // Build seed list
	  var seedlist = servers.map(function(x) {
	    return {host: x.host, port: x.port}
	  });
	
	  // Final options
	  var finalOptions = shallowClone(options);
	
	  // Default values
	  finalOptions.size = typeof options.poolSize == 'number' ? options.poolSize : 5;
	  finalOptions.reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;
	  finalOptions.emitError = typeof options.emitError == 'boolean' ? options.emitError : true;
	  finalOptions.cursorFactory = Cursor;
	
	  // Add the store
	  finalOptions.disconnectHandler = store;
	
	  // Socket options passed down
	  if(options.socketOptions) {
	    if(options.socketOptions.connectTimeoutMS) {
	      this.connectTimeoutMS = options.socketOptions.connectTimeoutMS;
	      finalOptions.connectionTimeout = options.socketOptions.connectTimeoutMS;
	    }
	
	    if(options.socketOptions.socketTimeoutMS) {
	      finalOptions.socketTimeout = options.socketOptions.socketTimeoutMS;
	    }
	  }
	
	  // Get the name
	  var replicaSet = options.replicaSet || options.rs_name;
	
	  // Set up options
	  finalOptions.setName = replicaSet;
	
	  // Are we running in debug mode
	  var debug = typeof options.debug == 'boolean' ? options.debug : false;
	  if(debug) {
	    finalOptions.debug = debug;
	  }
	
	  // Map keep alive setting
	  if(options.socketOptions && typeof options.socketOptions.keepAlive == 'number') {
	    finalOptions.keepAlive = true;
	    if(typeof options.socketOptions.keepAlive == 'number') {
	      finalOptions.keepAliveInitialDelay = options.socketOptions.keepAlive;
	    }
	  }
	
	  // Connection timeout
	  if(options.socketOptions && typeof options.socketOptions.connectionTimeout == 'number') {
	    finalOptions.connectionTimeout = options.socketOptions.connectionTimeout;
	  }
	
	  // Socket timeout
	  if(options.socketOptions && typeof options.socketOptions.socketTimeout == 'number') {
	    finalOptions.socketTimeout = options.socketOptions.socketTimeout;
	  }
	
	  // noDelay
	  if(options.socketOptions && typeof options.socketOptions.noDelay == 'boolean') {
	    finalOptions.noDelay = options.socketOptions.noDelay;
	  }
	
	  if(typeof options.secondaryAcceptableLatencyMS == 'number') {
	    finalOptions.acceptableLatency = options.secondaryAcceptableLatencyMS;
	  }
	
	  if(options.connectWithNoPrimary == true) {
	    finalOptions.secondaryOnlyConnectionAllowed = true;
	  }
	
	  // Add the non connection store
	  finalOptions.disconnectHandler = store;
	
	  // Translate the options
	  if(options.sslCA) finalOptions.ca = options.sslCA;
	  if(typeof options.sslValidate == 'boolean') finalOptions.rejectUnauthorized = options.sslValidate;
	  if(options.sslKey) finalOptions.key = options.sslKey;
	  if(options.sslCert) finalOptions.cert = options.sslCert;
	  if(options.sslPass) finalOptions.passphrase = options.sslPass;
	  if(options.checkServerIdentity) finalOptions.checkServerIdentity = options.checkServerIdentity;
	
	  // Create the ReplSet
	  var replset = new CReplSet(seedlist, finalOptions)
	  // Server capabilities
	  var sCapabilities = null;
	
	  // Listen to reconnect event
	  replset.on('reconnect', function() {
	    self.emit('reconnect');
	    store.execute();
	  });
	
	  // Internal state
	  this.s = {
	    // Replicaset
	    replset: replset
	    // Server capabilities
	    , sCapabilities: null
	    // Debug tag
	    , tag: options.tag
	    // Store options
	    , storeOptions: storeOptions
	    // Cloned options
	    , clonedOptions: finalOptions
	    // Store
	    , store: store
	    // Options
	    , options: options
	  }
	
	  // Debug
	  if(debug) {
	    // Last ismaster
	    Object.defineProperty(this, 'replset', {
	      enumerable:true, get: function() { return replset; }
	    });
	  }
	
	  // Last ismaster
	  Object.defineProperty(this, 'isMasterDoc', {
	    enumerable:true, get: function() { return replset.lastIsMaster(); }
	  });
	
	  // BSON property
	  Object.defineProperty(this, 'bson', {
	    enumerable: true, get: function() {
	      return replset.bson;
	    }
	  });
	
	  Object.defineProperty(this, 'haInterval', {
	    enumerable:true, get: function() { return replset.haInterval; }
	  });
	}
	
	/**
	 * @ignore
	 */
	inherits(ReplSet, EventEmitter);
	
	var define = ReplSet.define = new Define('ReplSet', ReplSet, false);
	
	// Ensure the right read Preference object
	var translateReadPreference = function(options) {
	  if(typeof options.readPreference == 'string') {
	    options.readPreference = new CoreReadPreference(options.readPreference);
	  } else if(options.readPreference instanceof ReadPreference) {
	    options.readPreference = new CoreReadPreference(options.readPreference.mode
	      , options.readPreference.tags);
	  }
	
	  return options;
	}
	
	ReplSet.prototype.parserType = function() {
	  return this.s.replset.parserType();
	}
	
	define.classMethod('parserType', {callback: false, promise:false, returns: [String]});
	
	// Connect method
	ReplSet.prototype.connect = function(db, _options, callback) {
	  var self = this;
	  if('function' === typeof _options) callback = _options, _options = {};
	  if(_options == null) _options = {};
	  if(!('function' === typeof callback)) callback = null;
	  self.s.options = _options;
	
	  // Update bufferMaxEntries
	  self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;
	
	  // Actual handler
	  var errorHandler = function(event) {
	    return function(err) {
	      if(event != 'error') {
	        self.emit(event, err);
	      }
	    }
	  }
	
	  // Connect handler
	  var connectHandler = function() {
	    // Clear out all the current handlers left over
	    ["timeout", "error", "close", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	      'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed', 'topologyOpening',
	      'topologyClosed', 'topologyDescriptionChanged'].forEach(function(e) {
	      self.s.replset.removeAllListeners(e);
	    });
	
	    // Set up listeners
	    self.s.replset.once('timeout', errorHandler('timeout'));
	    self.s.replset.once('error', errorHandler('error'));
	    self.s.replset.once('close', errorHandler('close'));
	
	    // relay the event
	    var relay = function(event) {
	      return function(t, server) {
	        self.emit(event, t, server);
	      }
	    }
	
	    // Replset events relay
	    var replsetRelay = function(event) {
	      return function(t, server) {
	        self.emit(event, t, server.lastIsMaster(), server);
	      }
	    }
	
	    // Relay ha
	    var relayHa = function(t, state) {
	      self.emit('ha', t, state);
	
	      if(t == 'start') {
	        self.emit('ha_connect', t, state);
	      } else if(t == 'end') {
	        self.emit('ha_ismaster', t, state);
	      }
	    }
	
	    // Set up serverConfig listeners
	    self.s.replset.on('joined', replsetRelay('joined'));
	    self.s.replset.on('left', relay('left'));
	    self.s.replset.on('ping', relay('ping'));
	    self.s.replset.on('ha', relayHa);
	
	    // Set up SDAM listeners
	    self.s.replset.on('serverDescriptionChanged', relay('serverDescriptionChanged'));
	    self.s.replset.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));
	    self.s.replset.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));
	    self.s.replset.on('serverHearbeatFailed', relay('serverHearbeatFailed'));
	    self.s.replset.on('serverOpening', relay('serverOpening'));
	    self.s.replset.on('serverClosed', relay('serverClosed'));
	    self.s.replset.on('topologyOpening', relay('topologyOpening'));
	    self.s.replset.on('topologyClosed', relay('topologyClosed'));
	    self.s.replset.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));
	
	    self.s.replset.on('fullsetup', function(topology) {
	      self.emit('fullsetup', null, self);
	    });
	
	    self.s.replset.on('all', function(topology) {
	      self.emit('all', null, self);
	    });
	
	    // Emit open event
	    self.emit('open', null, self);
	
	    // Return correctly
	    try {
	      callback(null, self);
	    } catch(err) {
	      process.nextTick(function() { throw err; })
	    }
	  }
	
	  // Error handler
	  var connectErrorHandler = function(event) {
	    return function(err) {
	      ['timeout', 'error', 'close'].forEach(function(e) {
	        self.s.replset.removeListener(e, connectErrorHandler);
	      });
	
	      self.s.replset.removeListener('connect', connectErrorHandler);
	      // Destroy the replset
	      self.s.replset.destroy();
	
	      // Try to callback
	      try {
	        callback(err);
	      } catch(err) {
	        if(!self.s.replset.isConnected())
	          process.nextTick(function() { throw err; })
	      }
	    }
	  }
	
	  // Set up listeners
	  self.s.replset.once('timeout', connectErrorHandler('timeout'));
	  self.s.replset.once('error', connectErrorHandler('error'));
	  self.s.replset.once('close', connectErrorHandler('close'));
	  self.s.replset.once('connect', connectHandler);
	
	  // Start connection
	  self.s.replset.connect(_options);
	}
	
	// Server capabilities
	ReplSet.prototype.capabilities = function() {
	  if(this.s.sCapabilities) return this.s.sCapabilities;
	  if(this.s.replset.lastIsMaster() == null) return null;
	  this.s.sCapabilities = new ServerCapabilities(this.s.replset.lastIsMaster());
	  return this.s.sCapabilities;
	}
	
	define.classMethod('capabilities', {callback: false, promise:false, returns: [ServerCapabilities]});
	
	// Command
	ReplSet.prototype.command = function(ns, cmd, options, callback) {
	  options = translateReadPreference(options);
	  this.s.replset.command(ns, cmd, options, callback);
	}
	
	define.classMethod('command', {callback: true, promise:false});
	
	// Insert
	ReplSet.prototype.insert = function(ns, ops, options, callback) {
	  this.s.replset.insert(ns, ops, options, callback);
	}
	
	define.classMethod('insert', {callback: true, promise:false});
	
	// Update
	ReplSet.prototype.update = function(ns, ops, options, callback) {
	  this.s.replset.update(ns, ops, options, callback);
	}
	
	define.classMethod('update', {callback: true, promise:false});
	
	// Remove
	ReplSet.prototype.remove = function(ns, ops, options, callback) {
	  this.s.replset.remove(ns, ops, options, callback);
	}
	
	define.classMethod('remove', {callback: true, promise:false});
	
	// Destroyed
	ReplSet.prototype.isDestroyed = function() {
	  return this.s.replset.isDestroyed();
	}
	
	// IsConnected
	ReplSet.prototype.isConnected = function() {
	  return this.s.replset.isConnected();
	}
	
	define.classMethod('isConnected', {callback: false, promise:false, returns: [Boolean]});
	
	ReplSet.prototype.setBSONParserType = function(type) {
	  return this.s.replset.setBSONParserType(type);
	}
	
	// Insert
	ReplSet.prototype.cursor = function(ns, cmd, options) {
	  options = translateReadPreference(options);
	  options.disconnectHandler = this.s.store;
	  return this.s.replset.cursor(ns, cmd, options);
	}
	
	define.classMethod('cursor', {callback: false, promise:false, returns: [Cursor, AggregationCursor, CommandCursor]});
	
	ReplSet.prototype.lastIsMaster = function() {
	  return this.s.replset.lastIsMaster();
	}
	
	ReplSet.prototype.close = function(forceClosed) {
	  var self = this;
	  this.s.replset.destroy();
	  // We need to wash out all stored processes
	  if(forceClosed == true) {
	    this.s.storeOptions.force = forceClosed;
	    this.s.store.flush();
	  }
	
	  var events = ['timeout', 'error', 'close', 'joined', 'left'];
	  events.forEach(function(e) {
	    self.removeAllListeners(e);
	  });
	}
	
	define.classMethod('close', {callback: false, promise:false});
	
	ReplSet.prototype.auth = function() {
	  var args = Array.prototype.slice.call(arguments, 0);
	  this.s.replset.auth.apply(this.s.replset, args);
	}
	
	define.classMethod('auth', {callback: true, promise:false});
	
	/**
	 * All raw connections
	 * @method
	 * @return {array}
	 */
	ReplSet.prototype.connections = function() {
	  return this.s.replset.connections();
	}
	
	define.classMethod('connections', {callback: false, promise:false, returns:[Array]});
	
	/**
	 * A replset connect event, used to verify that the connection is up and running
	 *
	 * @event ReplSet#connect
	 * @type {ReplSet}
	 */
	
	/**
	 * The replset high availability event
	 *
	 * @event ReplSet#ha
	 * @type {function}
	 * @param {string} type The stage in the high availability event (start|end)
	 * @param {boolean} data.norepeat This is a repeating high availability process or a single execution only
	 * @param {number} data.id The id for this high availability request
	 * @param {object} data.state An object containing the information about the current replicaset
	 */
	
	/**
	 * A server member left the replicaset
	 *
	 * @event ReplSet#left
	 * @type {function}
	 * @param {string} type The type of member that left (primary|secondary|arbiter)
	 * @param {Server} server The server object that left
	 */
	
	/**
	 * A server member joined the replicaset
	 *
	 * @event ReplSet#joined
	 * @type {function}
	 * @param {string} type The type of member that joined (primary|secondary|arbiter)
	 * @param {Server} server The server object that joined
	 */
	
	/**
	 * ReplSet open event, emitted when replicaset can start processing commands.
	 *
	 * @event ReplSet#open
	 * @type {Replset}
	 */
	
	/**
	 * ReplSet fullsetup event, emitted when all servers in the topology have been connected to.
	 *
	 * @event ReplSet#fullsetup
	 * @type {Replset}
	 */
	
	/**
	 * ReplSet close event
	 *
	 * @event ReplSet#close
	 * @type {object}
	 */
	
	/**
	 * ReplSet error event, emitted if there is an error listener.
	 *
	 * @event ReplSet#error
	 * @type {MongoError}
	 */
	
	/**
	 * ReplSet timeout event
	 *
	 * @event ReplSet#timeout
	 * @type {object}
	 */
	
	/**
	 * ReplSet parseError event
	 *
	 * @event ReplSet#parseError
	 * @type {object}
	 */
	
	module.exports = ReplSet;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var EventEmitter = __webpack_require__(3).EventEmitter
	  , inherits = __webpack_require__(77).inherits
	  , f = __webpack_require__(77).format
	  , ServerCapabilities = __webpack_require__(209).ServerCapabilities
	  , MongoCR = __webpack_require__(156).MongoCR
	  , MongoError = __webpack_require__(156).MongoError
	  , CMongos = __webpack_require__(156).Mongos
	  , Cursor = __webpack_require__(197)
	  , AggregationCursor = __webpack_require__(193)
	  , CommandCursor = __webpack_require__(201)
	  , Define = __webpack_require__(196)
	  , Server = __webpack_require__(208)
	  , Store = __webpack_require__(209).Store
	  , shallowClone = __webpack_require__(194).shallowClone
	  , MAX_JS_INT = __webpack_require__(194).MAX_JS_INT;
	
	/**
	 * @fileOverview The **Mongos** class is a class that represents a Mongos Proxy topology and is
	 * used to construct connections.
	 *
	 * **Mongos Should not be used, use MongoClient.connect**
	 * @example
	 * var Db = require('mongodb').Db,
	 *   Mongos = require('mongodb').Mongos,
	 *   Server = require('mongodb').Server,
	 *   test = require('assert');
	 * // Connect using Mongos
	 * var server = new Server('localhost', 27017);
	 * var db = new Db('test', new Mongos([server]));
	 * db.open(function(err, db) {
	 *   // Get an additional db
	 *   db.close();
	 * });
	 */
	
	/**
	 * Creates a new Mongos instance
	 * @class
	 * @deprecated
	 * @param {Server[]} servers A seedlist of servers participating in the replicaset.
	 * @param {object} [options=null] Optional settings.
	 * @param {booelan} [options.ha=true] Turn on high availability monitoring.
	 * @param {number} [options.haInterval=5000] Time between each replicaset status check.
	 * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.
	 * @param {number} [options.acceptableLatencyMS=15] Cutoff latency point in MS for MongoS proxy selection
	 * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {object} [options.sslValidate=true] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {array} [options.sslCA=null] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslCert=null] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslKey=null] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslPass=null] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {object} [options.socketOptions=null] Socket options
	 * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.
	 * @param {number} [options.socketOptions.keepAlive=0] TCP KeepAlive on the socket with a X ms delay before start.
	 * @param {number} [options.socketOptions.connectTimeoutMS=0] TCP Connection timeout setting
	 * @param {number} [options.socketOptions.socketTimeoutMS=0] TCP Socket timeout setting
	 * @fires Mongos#connect
	 * @fires Mongos#ha
	 * @fires Mongos#joined
	 * @fires Mongos#left
	 * @fires Mongos#fullsetup
	 * @fires Mongos#open
	 * @fires Mongos#close
	 * @fires Mongos#error
	 * @fires Mongos#timeout
	 * @fires Mongos#parseError
	 * @return {Mongos} a Mongos instance.
	 */
	var Mongos = function(servers, options) {
	  if(!(this instanceof Mongos)) return new Mongos(servers, options);
	  options = options || {};
	  var self = this;
	
	  // Ensure all the instances are Server
	  for(var i = 0; i < servers.length; i++) {
	    if(!(servers[i] instanceof Server)) {
	      throw MongoError.create({message: "all seed list instances must be of the Server type", driver:true});
	    }
	  }
	
	  // Store option defaults
	  var storeOptions = {
	      force: false
	    , bufferMaxEntries: -1
	  }
	
	  // If we have "unlimited" set to max Number
	  if(storeOptions.bufferMaxEntries == -1) {
	    storeOptions.bufferMaxEntries = MAX_JS_INT;
	  }
	
	  // Shared global store
	  var store = options.store || new Store(self, storeOptions);
	
	  // Set up event emitter
	  EventEmitter.call(this);
	
	  // Debug tag
	  var tag = options.tag;
	
	  // Build seed list
	  var seedlist = servers.map(function(x) {
	    return {host: x.host, port: x.port}
	  });
	
	  // Final options
	  var finalOptions = shallowClone(options);
	
	  // Default values
	  finalOptions.size = typeof options.poolSize == 'number' ? options.poolSize : 5;
	  finalOptions.reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;
	  finalOptions.emitError = typeof options.emitError == 'boolean' ? options.emitError : true;
	  finalOptions.cursorFactory = Cursor;
	
	  // Add the store
	  finalOptions.disconnectHandler = store;
	
	  // Ensure we change the sslCA option to ca if available
	  if(options.sslCA) finalOptions.ca = options.sslCA;
	  if(typeof options.sslValidate == 'boolean') finalOptions.rejectUnauthorized = options.sslValidate;
	  if(options.sslKey) finalOptions.key = options.sslKey;
	  if(options.sslCert) finalOptions.cert = options.sslCert;
	  if(options.sslPass) finalOptions.passphrase = options.sslPass;
	  if(options.checkServerIdentity) finalOptions.checkServerIdentity = options.checkServerIdentity;
	
	  // Socket options passed down
	  if(options.socketOptions) {
	    if(options.socketOptions.connectTimeoutMS) {
	      this.connectTimeoutMS = options.socketOptions.connectTimeoutMS;
	      finalOptions.connectionTimeout = options.socketOptions.connectTimeoutMS;
	    }
	    if(options.socketOptions.socketTimeoutMS)
	      finalOptions.socketTimeout = options.socketOptions.socketTimeoutMS;
	  }
	
	  // Are we running in debug mode
	  var debug = typeof options.debug == 'boolean' ? options.debug : false;
	  if(debug) {
	    finalOptions.debug = debug;
	  }
	
	  // Map keep alive setting
	  if(options.socketOptions && typeof options.socketOptions.keepAlive == 'number') {
	    finalOptions.keepAlive = true;
	    if(typeof options.socketOptions.keepAlive == 'number') {
	      finalOptions.keepAliveInitialDelay = options.socketOptions.keepAlive;
	    }
	  }
	
	  // Connection timeout
	  if(options.socketOptions && typeof options.socketOptions.connectionTimeout == 'number') {
	    finalOptions.connectionTimeout = options.socketOptions.connectionTimeout;
	  }
	
	  // Socket timeout
	  if(options.socketOptions && typeof options.socketOptions.socketTimeout == 'number') {
	    finalOptions.socketTimeout = options.socketOptions.socketTimeout;
	  }
	
	  // noDelay
	  if(options.socketOptions && typeof options.socketOptions.noDelay == 'boolean') {
	    finalOptions.noDelay = options.socketOptions.noDelay;
	  }
	
	  if(typeof options.acceptableLatencyMS == 'number') {
	    finalOptions.localThresholdMS = options.acceptableLatencyMS || 15;
	  }
	
	  // Add the non connection store
	  finalOptions.disconnectHandler = store;
	
	  // Create the Mongos
	  var mongos = new CMongos(seedlist, finalOptions)
	  // Server capabilities
	  var sCapabilities = null;
	  // Add auth prbufferMaxEntriesoviders
	  mongos.addAuthProvider('mongocr', new MongoCR());
	
	  // Internal state
	  this.s = {
	    // Create the Mongos
	      mongos: mongos
	    // Server capabilities
	    , sCapabilities: sCapabilities
	    // Debug turned on
	    , debug: debug
	    // Store option defaults
	    , storeOptions: storeOptions
	    // Cloned options
	    , clonedOptions: finalOptions
	    // Actual store of callbacks
	    , store: store
	    // Options
	    , options: options
	  }
	
	
	  // Last ismaster
	  Object.defineProperty(this, 'isMasterDoc', {
	    enumerable:true, get: function() { return self.s.mongos.lastIsMaster(); }
	  });
	
	  // Last ismaster
	  Object.defineProperty(this, 'numberOfConnectedServers', {
	    enumerable:true, get: function() {
	      return self.s.mongos.s.mongosState.connectedServers().length;
	    }
	  });
	
	  // BSON property
	  Object.defineProperty(this, 'bson', {
	    enumerable: true, get: function() {
	      return self.s.mongos.bson;
	    }
	  });
	
	  Object.defineProperty(this, 'haInterval', {
	    enumerable:true, get: function() { return self.s.mongos.haInterval; }
	  });
	}
	
	/**
	 * @ignore
	 */
	inherits(Mongos, EventEmitter);
	
	var define = Mongos.define = new Define('Mongos', Mongos, false);
	
	// Connect
	Mongos.prototype.connect = function(db, _options, callback) {
	  var self = this;
	  if('function' === typeof _options) callback = _options, _options = {};
	  if(_options == null) _options = {};
	  if(!('function' === typeof callback)) callback = null;
	  self.s.options = _options;
	
	  // Update bufferMaxEntries
	  self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;
	
	  // Error handler
	  var connectErrorHandler = function(event) {
	    return function(err) {
	      // Remove all event handlers
	      var events = ['timeout', 'error', 'close'];
	      events.forEach(function(e) {
	        self.removeListener(e, connectErrorHandler);
	      });
	
	      self.s.mongos.removeListener('connect', connectErrorHandler);
	
	      // Try to callback
	      try {
	        callback(err);
	      } catch(err) {
	        process.nextTick(function() { throw err; })
	      }
	    }
	  }
	
	  // Actual handler
	  var errorHandler = function(event) {
	    return function(err) {
	      if(event != 'error') {
	        self.emit(event, err);
	      }
	    }
	  }
	
	  // Error handler
	  var reconnectHandler = function(err) {
	    self.emit('reconnect');
	    self.s.store.execute();
	  }
	
	  // Connect handler
	  var connectHandler = function() {
	    // Clear out all the current handlers left over
	    ["timeout", "error", "close", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	      'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed', 'topologyOpening',
	      'topologyClosed', 'topologyDescriptionChanged'].forEach(function(e) {
	      self.s.mongos.removeAllListeners(e);
	    });
	
	    // Set up listeners
	    self.s.mongos.once('timeout', errorHandler('timeout'));
	    self.s.mongos.once('error', errorHandler('error'));
	    self.s.mongos.once('close', errorHandler('close'));
	
	    // relay the event
	    var relay = function(event) {
	      return function(t, server) {
	        self.emit(event, t, server);
	      }
	    }
	
	    // Set up SDAM listeners
	    self.s.mongos.on('serverDescriptionChanged', relay('serverDescriptionChanged'));
	    self.s.mongos.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));
	    self.s.mongos.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));
	    self.s.mongos.on('serverHearbeatFailed', relay('serverHearbeatFailed'));
	    self.s.mongos.on('serverOpening', relay('serverOpening'));
	    self.s.mongos.on('serverClosed', relay('serverClosed'));
	    self.s.mongos.on('topologyOpening', relay('topologyOpening'));
	    self.s.mongos.on('topologyClosed', relay('topologyClosed'));
	    self.s.mongos.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));
	
	    // Set up serverConfig listeners
	    self.s.mongos.on('joined', relay('joined'));
	    self.s.mongos.on('left', relay('left'));
	    self.s.mongos.on('fullsetup', relay('fullsetup'));
	
	    // Emit open event
	    self.emit('open', null, self);
	
	    // Return correctly
	    try {
	      callback(null, self);
	    } catch(err) {
	      process.nextTick(function() { throw err; })
	    }
	  }
	
	  // Set up listeners
	  self.s.mongos.once('timeout', connectErrorHandler('timeout'));
	  self.s.mongos.once('error', connectErrorHandler('error'));
	  self.s.mongos.once('close', connectErrorHandler('close'));
	  self.s.mongos.once('connect', connectHandler);
	  // Reconnect server
	  self.s.mongos.on('reconnect', reconnectHandler);
	
	  // Start connection
	  self.s.mongos.connect(_options);
	}
	
	Mongos.prototype.parserType = function() {
	  return this.s.mongos.parserType();
	}
	
	define.classMethod('parserType', {callback: false, promise:false, returns: [String]});
	
	// Server capabilities
	Mongos.prototype.capabilities = function() {
	  if(this.s.sCapabilities) return this.s.sCapabilities;
	  if(this.s.mongos.lastIsMaster() == null) return null;
	  this.s.sCapabilities = new ServerCapabilities(this.s.mongos.lastIsMaster());
	  return this.s.sCapabilities;
	}
	
	define.classMethod('capabilities', {callback: false, promise:false, returns: [ServerCapabilities]});
	
	// Command
	Mongos.prototype.command = function(ns, cmd, options, callback) {
	  this.s.mongos.command(ns, cmd, options, callback);
	}
	
	define.classMethod('command', {callback: true, promise:false});
	
	// Insert
	Mongos.prototype.insert = function(ns, ops, options, callback) {
	  this.s.mongos.insert(ns, ops, options, function(e, m) {
	    callback(e, m)
	  });
	}
	
	define.classMethod('insert', {callback: true, promise:false});
	
	// Update
	Mongos.prototype.update = function(ns, ops, options, callback) {
	  this.s.mongos.update(ns, ops, options, callback);
	}
	
	define.classMethod('update', {callback: true, promise:false});
	
	// Remove
	Mongos.prototype.remove = function(ns, ops, options, callback) {
	  this.s.mongos.remove(ns, ops, options, callback);
	}
	
	define.classMethod('remove', {callback: true, promise:false});
	
	// Destroyed
	Mongos.prototype.isDestroyed = function() {
	  return this.s.mongos.isDestroyed();
	}
	
	// IsConnected
	Mongos.prototype.isConnected = function() {
	  return this.s.mongos.isConnected();
	}
	
	define.classMethod('isConnected', {callback: false, promise:false, returns: [Boolean]});
	
	// Insert
	Mongos.prototype.cursor = function(ns, cmd, options) {
	  options.disconnectHandler = this.s.store;
	  return this.s.mongos.cursor(ns, cmd, options);
	}
	
	define.classMethod('cursor', {callback: false, promise:false, returns: [Cursor, AggregationCursor, CommandCursor]});
	
	Mongos.prototype.setBSONParserType = function(type) {
	  return this.s.mongos.setBSONParserType(type);
	}
	
	Mongos.prototype.lastIsMaster = function() {
	  return this.s.mongos.lastIsMaster();
	}
	
	Mongos.prototype.close = function(forceClosed) {
	  this.s.mongos.destroy();
	  // We need to wash out all stored processes
	  if(forceClosed == true) {
	    this.s.storeOptions.force = forceClosed;
	    this.s.store.flush();
	  }
	}
	
	define.classMethod('close', {callback: false, promise:false});
	
	Mongos.prototype.auth = function() {
	  var args = Array.prototype.slice.call(arguments, 0);
	  this.s.mongos.auth.apply(this.s.mongos, args);
	}
	
	define.classMethod('auth', {callback: true, promise:false});
	
	/**
	 * All raw connections
	 * @method
	 * @return {array}
	 */
	Mongos.prototype.connections = function() {
	  return this.s.mongos.connections();
	}
	
	define.classMethod('connections', {callback: false, promise:false, returns:[Array]});
	
	/**
	 * A mongos connect event, used to verify that the connection is up and running
	 *
	 * @event Mongos#connect
	 * @type {Mongos}
	 */
	
	/**
	 * The mongos high availability event
	 *
	 * @event Mongos#ha
	 * @type {function}
	 * @param {string} type The stage in the high availability event (start|end)
	 * @param {boolean} data.norepeat This is a repeating high availability process or a single execution only
	 * @param {number} data.id The id for this high availability request
	 * @param {object} data.state An object containing the information about the current replicaset
	 */
	
	/**
	 * A server member left the mongos set
	 *
	 * @event Mongos#left
	 * @type {function}
	 * @param {string} type The type of member that left (primary|secondary|arbiter)
	 * @param {Server} server The server object that left
	 */
	
	/**
	 * A server member joined the mongos set
	 *
	 * @event Mongos#joined
	 * @type {function}
	 * @param {string} type The type of member that joined (primary|secondary|arbiter)
	 * @param {Server} server The server object that joined
	 */
	
	/**
	 * Mongos fullsetup event, emitted when all proxies in the topology have been connected to.
	 *
	 * @event Mongos#fullsetup
	 * @type {Mongos}
	 */
	
	/**
	 * Mongos open event, emitted when mongos can start processing commands.
	 *
	 * @event Mongos#open
	 * @type {Mongos}
	 */
	
	/**
	 * Mongos close event
	 *
	 * @event Mongos#close
	 * @type {object}
	 */
	
	/**
	 * Mongos error event, emitted if there is an error listener.
	 *
	 * @event Mongos#error
	 * @type {MongoError}
	 */
	
	/**
	 * Mongos timeout event
	 *
	 * @event Mongos#timeout
	 * @type {object}
	 */
	
	/**
	 * Mongos parseError event
	 *
	 * @event Mongos#parseError
	 * @type {object}
	 */
	
	module.exports = Mongos;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {"use strict";
	
	var EventEmitter = __webpack_require__(3).EventEmitter
	  , inherits = __webpack_require__(77).inherits
	  , getSingleProperty = __webpack_require__(194).getSingleProperty
	  , shallowClone = __webpack_require__(194).shallowClone
	  , parseIndexOptions = __webpack_require__(194).parseIndexOptions
	  , debugOptions = __webpack_require__(194).debugOptions
	  , CommandCursor = __webpack_require__(201)
	  , handleCallback = __webpack_require__(194).handleCallback
	  , toError = __webpack_require__(194).toError
	  , ReadPreference = __webpack_require__(195)
	  , f = __webpack_require__(77).format
	  , Admin = __webpack_require__(213)
	  , Code = __webpack_require__(156).BSON.Code
	  , CoreReadPreference = __webpack_require__(156).ReadPreference
	  , MongoError = __webpack_require__(156).MongoError
	  , ObjectID = __webpack_require__(156).ObjectID
	  , Define = __webpack_require__(196)
	  , Logger = __webpack_require__(156).Logger
	  , Collection = __webpack_require__(207)
	  , crypto = __webpack_require__(70);
	
	var debugFields = ['authSource', 'w', 'wtimeout', 'j', 'native_parser', 'forceServerObjectId'
	  , 'serializeFunctions', 'raw', 'promoteLongs', 'bufferMaxEntries', 'numberOfRetries', 'retryMiliSeconds'
	  , 'readPreference', 'pkFactory'];
	
	/**
	 * @fileOverview The **Db** class is a class that represents a MongoDB Database.
	 *
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Get an additional db
	 *   var testDb = db.db('test');
	 *   db.close();
	 * });
	 */
	
	/**
	 * Creates a new Db instance
	 * @class
	 * @param {string} databaseName The name of the database this instance represents.
	 * @param {(Server|ReplSet|Mongos)} topology The server topology for the database.
	 * @param {object} [options=null] Optional settings.
	 * @param {string} [options.authSource=null] If the database authentication is dependent on another databaseName.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
	 * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
	 * @param {number} [options.bufferMaxEntries=-1] Sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {object} [options.readConcern=null] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)
	 * @param {object} [options.readConcern.level='local'] Specify a read concern level for the collection operations, one of [local|majority]. (only MongoDB 3.2 or higher supported)
	 * @property {(Server|ReplSet|Mongos)} serverConfig Get the current db topology.
	 * @property {number} bufferMaxEntries Current bufferMaxEntries value for the database
	 * @property {string} databaseName The name of the database this instance represents.
	 * @property {object} options The options associated with the db instance.
	 * @property {boolean} native_parser The current value of the parameter native_parser.
	 * @property {boolean} slaveOk The current slaveOk value for the db instance.
	 * @property {object} writeConcern The current write concern values.
	 * @property {object} topology Access the topology object (single server, replicaset or mongos).
	 * @fires Db#close
	 * @fires Db#authenticated
	 * @fires Db#reconnect
	 * @fires Db#error
	 * @fires Db#timeout
	 * @fires Db#parseError
	 * @fires Db#fullsetup
	 * @return {Db} a Db instance.
	 */
	var Db = function(databaseName, topology, options) {
	  options = options || {};
	  if(!(this instanceof Db)) return new Db(databaseName, topology, options);
	  EventEmitter.call(this);
	  var self = this;
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(198).Promise;
	  }
	
	  // Ensure we put the promiseLib in the options
	  options.promiseLibrary = promiseLibrary;
	
	  // var self = this;  // Internal state of the db object
	  this.s = {
	    // Database name
	      databaseName: databaseName
	    // DbCache
	    , dbCache: {}
	    // Children db's
	    , children: []
	    // Topology
	    , topology: topology
	    // Options
	    , options: options
	    // Logger instance
	    , logger: Logger('Db', options)
	    // Get the bson parser
	    , bson: topology ? topology.bson : null
	    // Authsource if any
	    , authSource: options.authSource
	    // Unpack read preference
	    , readPreference: options.readPreference
	    // Set buffermaxEntries
	    , bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : -1
	    // Parent db (if chained)
	    , parentDb: options.parentDb || null
	    // Set up the primary key factory or fallback to ObjectID
	    , pkFactory: options.pkFactory || ObjectID
	    // Get native parser
	    , nativeParser: options.nativeParser || options.native_parser
	    // Promise library
	    , promiseLibrary: promiseLibrary
	    // No listener
	    , noListener: typeof options.noListener == 'boolean' ? options.noListener : false
	    // ReadConcern
	    , readConcern: options.readConcern
	  }
	
	  // Ensure we have a valid db name
	  validateDatabaseName(self.s.databaseName);
	
	  // If we have specified the type of parser
	  if(typeof self.s.nativeParser == 'boolean') {
	    if(self.s.nativeParser) {
	      topology.setBSONParserType("c++");
	    } else {
	      topology.setBSONParserType("js");
	    }
	  }
	
	  // Add a read Only property
	  getSingleProperty(this, 'serverConfig', self.s.topology);
	  getSingleProperty(this, 'bufferMaxEntries', self.s.bufferMaxEntries);
	  getSingleProperty(this, 'databaseName', self.s.databaseName);
	
	  // This is a child db, do not register any listeners
	  if(options.parentDb) return;
	  if(this.s.noListener) return;
	
	  // Add listeners
	  topology.on('error', createListener(self, 'error', self));
	  topology.on('timeout', createListener(self, 'timeout', self));
	  topology.on('close', createListener(self, 'close', self));
	  topology.on('parseError', createListener(self, 'parseError', self));
	  topology.once('open', createListener(self, 'open', self));
	  topology.once('fullsetup', createListener(self, 'fullsetup', self));
	  topology.once('all', createListener(self, 'all', self));
	  topology.on('reconnect', createListener(self, 'reconnect', self));
	}
	
	inherits(Db, EventEmitter);
	
	var define = Db.define = new Define('Db', Db, false);
	
	// Topology
	Object.defineProperty(Db.prototype, 'topology', {
	  enumerable:true,
	  get: function() { return this.s.topology; }
	});
	
	// Options
	Object.defineProperty(Db.prototype, 'options', {
	  enumerable:true,
	  get: function() { return this.s.options; }
	});
	
	// Running native parser
	Object.defineProperty(Db.prototype, 'native_parser', {
	  enumerable:true,
	  get: function() { return this.s.topology.parserType() == 'c++'; }
	});
	
	// slaveOk specified
	Object.defineProperty(Db.prototype, 'slaveOk', {
	  enumerable:true,
	  get: function() {
	    if(this.s.options.readPreference != null
	      && (this.s.options.readPreference != 'primary' || this.s.options.readPreference.mode != 'primary')) {
	      return true;
	    }
	    return false;
	  }
	});
	
	// get the write Concern
	Object.defineProperty(Db.prototype, 'writeConcern', {
	  enumerable:true,
	  get: function() {
	    var ops = {};
	    if(this.s.options.w != null) ops.w = this.s.options.w;
	    if(this.s.options.j != null) ops.j = this.s.options.j;
	    if(this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
	    if(this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
	    return ops;
	  }
	});
	
	/**
	 * The callback format for the Db.open method
	 * @callback Db~openCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Db} db The Db instance if the open method was successful.
	 */
	
	// Internal method
	var open = function(self, callback) {
	  self.s.topology.connect(self, self.s.options, function(err, topology) {
	    if(callback == null) return;
	    var internalCallback = callback;
	    callback == null;
	
	    if(err) {
	      self.close();
	      return internalCallback(err);
	    }
	
	    internalCallback(null, self);
	  });
	}
	
	/**
	 * Open the database
	 * @method
	 * @param {Db~openCallback} [callback] Callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.open = function(callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return open(self, callback);
	  // Return promise
	  return new self.s.promiseLibrary(function(resolve, reject) {
	    open(self, function(err, db) {
	      if(err) return reject(err);
	      resolve(db);
	    })
	  });
	}
	
	define.classMethod('open', {callback: true, promise:true});
	
	/**
	 * Converts provided read preference to CoreReadPreference
	 * @param {(ReadPreference|string|object)} readPreference the user provided read preference
	 * @return {CoreReadPreference}
	 */
	var convertReadPreference = function(readPreference) {
	  if(readPreference && typeof readPreference == 'string') {
	    return new CoreReadPreference(readPreference);
	  } else if(readPreference instanceof ReadPreference) {
	    return new CoreReadPreference(readPreference.mode, readPreference.tags);
	  } else if(readPreference && typeof readPreference == 'object') {
	    var mode = readPreference.mode || readPreference.preference;
	    if (mode && typeof mode == 'string') {
	      readPreference = new CoreReadPreference(mode, readPreference.tags);
	    }
	  }
	  return readPreference;
	}
	
	/**
	 * The callback format for results
	 * @callback Db~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object} result The result object if the command was executed successfully.
	 */
	
	var executeCommand = function(self, command, options, callback) {
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	  // Get the db name we are executing against
	  var dbName = options.dbName || options.authdb || self.s.databaseName;
	  // If we have a readPreference set
	  if(options.readPreference == null && self.s.readPreference) {
	    options.readPreference = self.s.readPreference;
	  }
	
	  // Convert the readPreference
	  if(options.readPreference) {
	    options.readPreference = convertReadPreference(options.readPreference);
	  }
	
	  // Debug information
	  if(self.s.logger.isDebug()) self.s.logger.debug(f('executing command %s against %s with options [%s]'
	    , JSON.stringify(command), f('%s.$cmd', dbName), JSON.stringify(debugOptions(debugFields, options))));
	
	  // Execute command
	  self.s.topology.command(f('%s.$cmd', dbName), command, options, function(err, result) {
	    if(err) return handleCallback(callback, err);
	    if(options.full) return handleCallback(callback, null, result);
	    handleCallback(callback, null, result.result);
	  });
	}
	
	/**
	 * Execute a command
	 * @method
	 * @param {object} command The command hash
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.command = function(command, options, callback) {
	  var self = this;
	  // Change the callback
	  if(typeof options == 'function') callback = options, options = {};
	  // Clone the options
	  options = shallowClone(options);
	
	  // Do we have a callback
	  if(typeof callback == 'function') return executeCommand(self, command, options, callback);
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    executeCommand(self, command, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('command', {callback: true, promise:true});
	
	/**
	 * The callback format for results
	 * @callback Db~noResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {null} result Is not set to a value
	 */
	
	/**
	 * Close the db and its underlying connections
	 * @method
	 * @param {boolean} force Force close, emitting no events
	 * @param {Db~noResultCallback} [callback] The result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.close = function(force, callback) {
	  if(typeof force == 'function') callback = force, force = false;
	  this.s.topology.close(force);
	  var self = this;
	
	  // Fire close event if any listeners
	  if(this.listeners('close').length > 0) {
	    this.emit('close');
	
	    // If it's the top level db emit close on all children
	    if(this.parentDb == null) {
	      // Fire close on all children
	      for(var i = 0; i < this.s.children.length; i++) {
	        this.s.children[i].emit('close');
	      }
	    }
	
	    // Remove listeners after emit
	    self.removeAllListeners('close');
	  }
	
	  // Close parent db if set
	  if(this.s.parentDb) this.s.parentDb.close();
	  // Callback after next event loop tick
	  if(typeof callback == 'function') return process.nextTick(function() {
	    handleCallback(callback, null);
	  })
	
	  // Return dummy promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    resolve();
	  });
	}
	
	define.classMethod('close', {callback: true, promise:true});
	
	/**
	 * Return the Admin db instance
	 * @method
	 * @return {Admin} return the new Admin db instance
	 */
	Db.prototype.admin = function() {
	  return new Admin(this, this.s.topology, this.s.promiseLibrary);
	};
	
	define.classMethod('admin', {callback: false, promise:false, returns: [Admin]});
	
	/**
	 * The callback format for the collection method, must be used if strict is specified
	 * @callback Db~collectionResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection} collection The collection instance.
	 */
	
	/**
	 * Fetch a specific collection (containing the actual collection information). If the application does not use strict mode you can
	 * can use it without a callback in the following way: `var collection = db.collection('mycollection');`
	 *
	 * @method
	 * @param {string} name the collection name we wish to access.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
	 * @param {object} [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.strict=false] Returns an error if the collection does not exist
	 * @param {object} [options.readConcern=null] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)
	 * @param {object} [options.readConcern.level='local'] Specify a read concern level for the collection operations, one of [local|majority]. (only MongoDB 3.2 or higher supported)
	 * @param {Db~collectionResultCallback} callback The collection result callback
	 * @return {Collection} return the new Collection instance if not in strict mode
	 */
	Db.prototype.collection = function(name, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	  options = shallowClone(options);
	  // Set the promise library
	  options.promiseLibrary = this.s.promiseLibrary;
	
	  // If we have not set a collection level readConcern set the db level one
	  options.readConcern = options.readConcern || this.s.readConcern;
	
	  // Do we have ignoreUndefined set
	  if(this.s.options.ignoreUndefined) {
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute
	  if(options == null || !options.strict) {
	    try {
	      var collection = new Collection(this, this.s.topology, this.s.databaseName, name, this.s.pkFactory, options);
	      if(callback) callback(null, collection);
	      return collection;
	    } catch(err) {
	      if(callback) return callback(err);
	      throw err;
	    }
	  }
	
	  // Strict mode
	  if(typeof callback != 'function') {
	    throw toError(f("A callback is required in strict mode. While getting collection %s.", name));
	  }
	
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) {
	    return callback(new MongoError('topology was destroyed'));
	  }
	
	  // Strict mode
	  this.listCollections({name:name}).toArray(function(err, collections) {
	    if(err != null) return handleCallback(callback, err, null);
	    if(collections.length == 0) return handleCallback(callback, toError(f("Collection %s does not exist. Currently in strict mode.", name)), null);
	
	    try {
	      return handleCallback(callback, null, new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options));
	    } catch(err) {
	      return handleCallback(callback, err, null);
	    }
	  });
	}
	
	define.classMethod('collection', {callback: true, promise:false, returns: [Collection]});
	
	var createCollection = function(self, name, options, callback) {
	  // Get the write concern options
	  var finalOptions = writeConcern(shallowClone(options), self, options);
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	
	  // Check if we have the name
	  self.listCollections({name: name}).toArray(function(err, collections) {
	    if(err != null) return handleCallback(callback, err, null);
	    if(collections.length > 0 && finalOptions.strict) {
	      return handleCallback(callback, MongoError.create({message: f("Collection %s already exists. Currently in strict mode.", name), driver:true}), null);
	    } else if (collections.length > 0) {
	      try { return handleCallback(callback, null, new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options)); }
	      catch(err) { return handleCallback(callback, err); }
	    }
	
	    // Create collection command
	    var cmd = {'create':name};
	
	    // Add all optional parameters
	    for(var n in options) {
	      if(options[n] != null && typeof options[n] != 'function')
	        cmd[n] = options[n];
	    }
	
	    // Execute command
	    self.command(cmd, finalOptions, function(err, result) {
	      if(err) return handleCallback(callback, err);
	      handleCallback(callback, null, new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options));
	    });
	  });
	}
	
	/**
	 * Create a new collection on a server with the specified options. Use this to create capped collections.
	 *
	 * @method
	 * @param {string} name the collection name we wish to access.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
	 * @param {object} [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.strict=false] Returns an error if the collection does not exist
	 * @param {boolean} [options.capped=false] Create a capped collection.
	 * @param {number} [options.size=null] The size of the capped collection in bytes.
	 * @param {number} [options.max=null] The maximum number of documents in the capped collection.
	 * @param {boolean} [options.autoIndexId=true] Create an index on the _id field of the document, True by default on MongoDB 2.2 or higher off for version < 2.2.
	 * @param {Db~collectionResultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.createCollection = function(name, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  name = args.length ? args.shift() : null;
	  options = args.length ? args.shift() || {} : {};
	
	  // Do we have a promisesLibrary
	  options.promiseLibrary = options.promiseLibrary || this.s.promiseLibrary;
	
	  // Check if the callback is in fact a string
	  if(typeof callback == 'string') name = callback;
	
	  // Execute the fallback callback
	  if(typeof callback == 'function') return createCollection(self, name, options, callback);
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    createCollection(self, name, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('createCollection', {callback: true, promise:true});
	
	/**
	 * Get all the db statistics.
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.scale=null] Divide the returned sizes by scale value.
	 * @param {Db~resultCallback} [callback] The collection result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.stats = function(options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	  // Build command object
	  var commandObject = { dbStats:true };
	  // Check if we have the scale value
	  if(options['scale'] != null) commandObject['scale'] = options['scale'];
	  // Execute the command
	  return this.command(commandObject, options, callback);
	}
	
	define.classMethod('stats', {callback: true, promise:true});
	
	// Transformation methods for cursor results
	var listCollectionsTranforms = function(databaseName) {
	  var matching = f('%s.', databaseName);
	
	  return {
	    doc: function(doc) {
	      var index = doc.name.indexOf(matching);
	      // Remove database name if available
	      if(doc.name && index == 0) {
	        doc.name = doc.name.substr(index + matching.length);
	      }
	
	      return doc;
	    }
	  }
	}
	
	/**
	 * Get the list of all collection information for the specified db.
	 *
	 * @method
	 * @param {object} filter Query to filter collections by
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.batchSize=null] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @return {CommandCursor}
	 */
	Db.prototype.listCollections = function(filter, options) {
	  filter = filter || {};
	  options = options || {};
	
	  // Shallow clone the object
	  options = shallowClone(options);
	  // Set the promise library
	  options.promiseLibrary = this.s.promiseLibrary;
	
	  // Ensure valid readPreference
	  if(options.readPreference) {
	    options.readPreference = convertReadPreference(options.readPreference);
	  }
	
	  // We have a list collections command
	  if(this.serverConfig.capabilities().hasListCollectionsCommand) {
	    // Cursor options
	    var cursor = options.batchSize ? {batchSize: options.batchSize} : {}
	    // Build the command
	    var command = { listCollections : true, filter: filter, cursor: cursor };
	    // Set the AggregationCursor constructor
	    options.cursorFactory = CommandCursor;
	    // Create the cursor
	    var cursor = this.s.topology.cursor(f('%s.$cmd', this.s.databaseName), command, options);
	    // Do we have a readPreference, apply it
	    if(options.readPreference) {
	      cursor.setReadPreference(options.readPreference);
	    }
	    // Return the cursor
	    return cursor;
	  }
	
	  // We cannot use the listCollectionsCommand
	  if(!this.serverConfig.capabilities().hasListCollectionsCommand) {
	    // If we have legacy mode and have not provided a full db name filter it
	    if(typeof filter.name == 'string' && !(new RegExp('^' + this.databaseName + '\\.').test(filter.name))) {
	      filter = shallowClone(filter);
	      filter.name = f('%s.%s', this.s.databaseName, filter.name);
	    }
	  }
	
	  // No filter, filter by current database
	  if(filter == null) {
	    filter.name = f('/%s/', this.s.databaseName);
	  }
	
	  // Rewrite the filter to use $and to filter out indexes
	  if(filter.name) {
	    filter = {$and: [{name: filter.name}, {name:/^((?!\$).)*$/}]};
	  } else {
	    filter = {name:/^((?!\$).)*$/};
	  }
	
	  // Return options
	  var _options = {transforms: listCollectionsTranforms(this.s.databaseName)}
	  // Get the cursor
	  var cursor = this.collection(Db.SYSTEM_NAMESPACE_COLLECTION).find(filter, _options);
	  // Do we have a readPreference, apply it
	  if(options.readPreference) cursor.setReadPreference(options.readPreference);
	  // Set the passed in batch size if one was provided
	  if(options.batchSize) cursor = cursor.batchSize(options.batchSize);
	  // We have a fallback mode using legacy systems collections
	  return cursor;
	};
	
	define.classMethod('listCollections', {callback: false, promise:false, returns: [CommandCursor]});
	
	var evaluate = function(self, code, parameters, options, callback) {
	  var finalCode = code;
	  var finalParameters = [];
	
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	
	  // If not a code object translate to one
	  if(!(finalCode instanceof Code)) finalCode = new Code(finalCode);
	  // Ensure the parameters are correct
	  if(parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') {
	    finalParameters = [parameters];
	  } else if(parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') {
	    finalParameters = parameters;
	  }
	
	  // Create execution selector
	  var cmd = {'$eval':finalCode, 'args':finalParameters};
	  // Check if the nolock parameter is passed in
	  if(options['nolock']) {
	    cmd['nolock'] = options['nolock'];
	  }
	
	  // Set primary read preference
	  options.readPreference = new CoreReadPreference(ReadPreference.PRIMARY);
	
	  // Execute the command
	  self.command(cmd, options, function(err, result) {
	    if(err) return handleCallback(callback, err, null);
	    if(result && result.ok == 1) return handleCallback(callback, null, result.retval);
	    if(result) return handleCallback(callback, MongoError.create({message: f("eval failed: %s", result.errmsg), driver:true}), null);
	    handleCallback(callback, err, result);
	  });
	}
	
	/**
	 * Evaluate JavaScript on the server
	 *
	 * @method
	 * @param {Code} code JavaScript to execute on server.
	 * @param {(object|array)} parameters The parameters for the call.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.nolock=false] Tell MongoDB not to block on the evaulation of the javascript.
	 * @param {Db~resultCallback} [callback] The results callback
	 * @deprecated Eval is deprecated on MongoDB 3.2 and forward
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.eval = function(code, parameters, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  parameters = args.length ? args.shift() : parameters;
	  options = args.length ? args.shift() || {} : {};
	
	  // Check if the callback is in fact a string
	  if(typeof callback == 'function') return evaluate(self, code, parameters, options, callback);
	  // Execute the command
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    evaluate(self, code, parameters, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	define.classMethod('eval', {callback: true, promise:true});
	
	/**
	 * Rename a collection.
	 *
	 * @method
	 * @param {string} fromCollection Name of current collection to rename.
	 * @param {string} toCollection New name of of the collection.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.dropTarget=false] Drop the target name collection if it previously exists.
	 * @param {Db~collectionResultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.renameCollection = function(fromCollection, toCollection, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	  // Add return new collection
	  options.new_collection = true;
	
	  // Check if the callback is in fact a string
	  if(typeof callback == 'function') {
	    return this.collection(fromCollection).rename(toCollection, options, callback);
	  }
	
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.collection(fromCollection).rename(toCollection, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	define.classMethod('renameCollection', {callback: true, promise:true});
	
	/**
	 * Drop a collection from the database, removing it permanently. New accesses will create a new collection.
	 *
	 * @method
	 * @param {string} name Name of collection to drop
	 * @param {Db~resultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.dropCollection = function(name, callback) {
	  var self = this;
	
	  // Command to execute
	  var cmd = {'drop':name}
	
	  // Check if the callback is in fact a string
	  if(typeof callback == 'function') return this.command(cmd, this.s.options, function(err, result) {
	    // Did the user destroy the topology
	    if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	    if(err) return handleCallback(callback, err);
	    if(result.ok) return handleCallback(callback, null, true);
	    handleCallback(callback, null, false);
	  });
	
	  // Execute the command
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    // Execute command
	    self.command(cmd, self.s.options, function(err, result) {
	      // Did the user destroy the topology
	      if(self.serverConfig && self.serverConfig.isDestroyed()) return reject(new MongoError('topology was destroyed'));
	      if(err) return reject(err);
	      if(result.ok) return resolve(true);
	      resolve(false);
	    });
	  });
	};
	
	define.classMethod('dropCollection', {callback: true, promise:true});
	
	/**
	 * Drop a database, removing it permanently from the server.
	 *
	 * @method
	 * @param {Db~resultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.dropDatabase = function(callback) {
	  var self = this;
	  // Drop database command
	  var cmd = {'dropDatabase':1};
	
	  // Check if the callback is in fact a string
	  if(typeof callback == 'function') return this.command(cmd, this.s.options, function(err, result) {
	    // Did the user destroy the topology
	    if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	    if(callback == null) return;
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, null, result.ok ? true : false);
	  });
	
	  // Execute the command
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    // Execute command
	    self.command(cmd, self.s.options, function(err, result) {
	      // Did the user destroy the topology
	      if(self.serverConfig && self.serverConfig.isDestroyed()) return reject(new MongoError('topology was destroyed'));
	      if(err) return reject(err);
	      if(result.ok) return resolve(true);
	      resolve(false);
	    });
	  });
	}
	
	define.classMethod('dropDatabase', {callback: true, promise:true});
	
	/**
	 * The callback format for the collections method.
	 * @callback Db~collectionsResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection[]} collections An array of all the collections objects for the db instance.
	 */
	var collections = function(self, callback) {
	  // Let's get the collection names
	  self.listCollections().toArray(function(err, documents) {
	    if(err != null) return handleCallback(callback, err, null);
	    // Filter collections removing any illegal ones
	    documents = documents.filter(function(doc) {
	      return doc.name.indexOf('$') == -1;
	    });
	
	    // Return the collection objects
	    handleCallback(callback, null, documents.map(function(d) {
	      return new Collection(self, self.s.topology, self.s.databaseName, d.name.replace(self.s.databaseName + ".", ''), self.s.pkFactory, self.s.options);
	    }));
	  });
	}
	
	/**
	 * Fetch all collections for the current db.
	 *
	 * @method
	 * @param {Db~collectionsResultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.collections = function(callback) {
	  var self = this;
	
	  // Return the callback
	  if(typeof callback == 'function') return collections(self, callback);
	  // Return the promise
	  return new self.s.promiseLibrary(function(resolve, reject) {
	    collections(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	define.classMethod('collections', {callback: true, promise:true});
	
	/**
	 * Runs a command on the database as admin.
	 * @method
	 * @param {object} command The command hash
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.maxTimeMS=null] Number of milliseconds to wait before aborting the query.
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.executeDbAdminCommand = function(selector, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Ensure valid readPreference
	  if(options.readPreference
	    && !(options.readPreference instanceof ReadPreference)
	    && typeof options.readPreference == 'object') {
	    var mode = options.readPreference.mode || options.readPreference.preference;
	    if (mode && typeof mode == 'string') {
	      options.readPreference = new ReadPreference(mode, readPreference.tags);
	    }
	  }
	
	  // Return the callback
	  if(typeof callback == 'function') return self.s.topology.command('admin.$cmd', selector, options, function(err, result) {
	    // Did the user destroy the topology
	    if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, null, result.result);
	  });
	
	  // Return promise
	  return new self.s.promiseLibrary(function(resolve, reject) {
	    self.s.topology.command('admin.$cmd', selector, options, function(err, result) {
	      // Did the user destroy the topology
	      if(self.serverConfig && self.serverConfig.isDestroyed()) return reject(new MongoError('topology was destroyed'));
	      if(err) return reject(err);
	      resolve(result.result);
	    });
	  });
	};
	
	define.classMethod('executeDbAdminCommand', {callback: true, promise:true});
	
	/**
	 * Creates an index on the db and collection collection.
	 * @method
	 * @param {string} name Name of the collection to create the index on.
	 * @param {(string|object)} fieldOrSpec Defines the index.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.unique=false] Creates an unique index.
	 * @param {boolean} [options.sparse=false] Creates a sparse index.
	 * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
	 * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
	 * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
	 * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
	 * @param {number} [options.v=null] Specify the format version of the indexes.
	 * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
	 * @param {number} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
	 * @param {object} [options.partialFilterExpression=null] Creates a partial index based on the given filter object (MongoDB 3.2 or higher)
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.createIndex = function(name, fieldOrSpec, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() || {} : {};
	  options = typeof callback === 'function' ? options : callback;
	  options = options == null ? {} : options;
	  // Shallow clone the options
	  options = shallowClone(options);
	  // Run only against primary
	  options.readPreference = ReadPreference.PRIMARY;
	
	  // If we have a callback fallback
	  if(typeof callback == 'function') return createIndex(self, name, fieldOrSpec, options, callback);
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    createIndex(self, name, fieldOrSpec, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var createIndex = function(self, name, fieldOrSpec, options, callback) {
	  // Get the write concern options
	  var finalOptions = writeConcern({}, self, options);
	  // Ensure we have a callback
	  if(finalOptions.writeConcern && typeof callback != 'function') {
	    throw MongoError.create({message: "Cannot use a writeConcern without a provided callback", driver:true});
	  }
	
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	
	  // Attempt to run using createIndexes command
	  createIndexUsingCreateIndexes(self, name, fieldOrSpec, options, function(err, result) {
	    if(err == null) return handleCallback(callback, err, result);
	
	    // 67 = 'CannotCreateIndex', means that the server recognized
	    // `createIndex` as a command and so we don't need to fallback to
	    // an insert.
	    if(err.code === 67 || err.code == 11000) {
	      return handleCallback(callback, err, result);
	    }
	
	    // Create command
	    var doc = createCreateIndexCommand(self, name, fieldOrSpec, options);
	    // Set no key checking
	    finalOptions.checkKeys = false;
	    // Insert document
	    self.s.topology.insert(f("%s.%s", self.s.databaseName, Db.SYSTEM_INDEX_COLLECTION), doc, finalOptions, function(err, result) {
	      if(callback == null) return;
	      if(err) return handleCallback(callback, err);
	      if(result == null) return handleCallback(callback, null, null);
	      if(result.result.writeErrors) return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);
	      handleCallback(callback, null, doc.name);
	    });
	  });
	}
	
	define.classMethod('createIndex', {callback: true, promise:true});
	
	/**
	 * Ensures that an index exists, if it does not it creates it
	 * @method
	 * @deprecated since version 2.0
	 * @param {string} name The index name
	 * @param {(string|object)} fieldOrSpec Defines the index.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.unique=false] Creates an unique index.
	 * @param {boolean} [options.sparse=false] Creates a sparse index.
	 * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
	 * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
	 * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
	 * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
	 * @param {number} [options.v=null] Specify the format version of the indexes.
	 * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
	 * @param {number} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.ensureIndex = function(name, fieldOrSpec, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // If we have a callback fallback
	  if(typeof callback == 'function') return ensureIndex(self, name, fieldOrSpec, options, callback);
	
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    ensureIndex(self, name, fieldOrSpec, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var ensureIndex = function(self, name, fieldOrSpec, options, callback) {
	  // Get the write concern options
	  var finalOptions = writeConcern({}, self, options);
	  // Create command
	  var selector = createCreateIndexCommand(self, name, fieldOrSpec, options);
	  var index_name = selector.name;
	
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	
	  // Default command options
	  var commandOptions = {};
	  // Check if the index allready exists
	  self.indexInformation(name, finalOptions, function(err, indexInformation) {
	    if(err != null && err.code != 26) return handleCallback(callback, err, null);
	    // If the index does not exist, create it
	    if(indexInformation == null || !indexInformation[index_name])  {
	      self.createIndex(name, fieldOrSpec, options, callback);
	    } else {
	      if(typeof callback === 'function') return handleCallback(callback, null, index_name);
	    }
	  });
	}
	
	define.classMethod('ensureIndex', {callback: true, promise:true});
	
	Db.prototype.addChild = function(db) {
	  if(this.s.parentDb) return this.s.parentDb.addChild(db);
	  this.s.children.push(db);
	}
	
	/**
	 * Create a new Db instance sharing the current socket connections. Be aware that the new db instances are
	 * related in a parent-child relationship to the original instance so that events are correctly emitted on child
	 * db instances. Child db instances are cached so performing db('db1') twice will return the same instance.
	 * You can control these behaviors with the options noListener and returnNonCachedInstance.
	 *
	 * @method
	 * @param {string} name The name of the database we want to use.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.noListener=false] Do not make the db an event listener to the original connection.
	 * @param {boolean} [options.returnNonCachedInstance=false] Control if you want to return a cached instance or have a new one created
	 * @return {Db}
	 */
	Db.prototype.db = function(dbName, options) {
	  options = options || {};
	  // Copy the options and add out internal override of the not shared flag
	  for(var key in this.options) {
	    options[key] = this.options[key];
	  }
	
	  // Do we have the db in the cache already
	  if(this.s.dbCache[dbName] && options.returnNonCachedInstance !== true) {
	    return this.s.dbCache[dbName];
	  }
	
	  // Add current db as parentDb
	  if(options.noListener == null || options.noListener == false) {
	    options.parentDb = this;
	  }
	
	  // Add promiseLibrary
	  options.promiseLibrary = this.s.promiseLibrary;
	
	  // Return the db object
	  var db = new Db(dbName, this.s.topology, options)
	
	  // Add as child
	  if(options.noListener == null || options.noListener == false) {
	    this.addChild(db);
	  }
	
	  // Add the db to the cache
	  this.s.dbCache[dbName] = db;
	  // Return the database
	  return db;
	};
	
	define.classMethod('db', {callback: false, promise:false, returns: [Db]});
	
	var _executeAuthCreateUserCommand = function(self, username, password, options, callback) {
	  // Special case where there is no password ($external users)
	  if(typeof username == 'string'
	    && password != null && typeof password == 'object') {
	    options = password;
	    password = null;
	  }
	
	  // Unpack all options
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  // Error out if we digestPassword set
	  if(options.digestPassword != null) {
	    throw toError("The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option.");
	  }
	
	  // Get additional values
	  var customData = options.customData != null ? options.customData : {};
	  var roles = Array.isArray(options.roles) ? options.roles : [];
	  var maxTimeMS = typeof options.maxTimeMS == 'number' ? options.maxTimeMS : null;
	
	  // If not roles defined print deprecated message
	  if(roles.length == 0) {
	    console.log("Creating a user without roles is deprecated in MongoDB >= 2.6");
	  }
	
	  // Get the error options
	  var commandOptions = {writeCommand:true};
	  if(options['dbName']) commandOptions.dbName = options['dbName'];
	
	  // Add maxTimeMS to options if set
	  if(maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;
	
	  // Check the db name and add roles if needed
	  if((self.databaseName.toLowerCase() == 'admin' || options.dbName == 'admin') && !Array.isArray(options.roles)) {
	    roles = ['root']
	  } else if(!Array.isArray(options.roles)) {
	    roles = ['dbOwner']
	  }
	
	  // Build the command to execute
	  var command = {
	      createUser: username
	    , customData: customData
	    , roles: roles
	    , digestPassword:false
	  }
	
	  // Apply write concern to command
	  command = writeConcern(command, self, options);
	
	  // Use node md5 generator
	  var md5 = crypto.createHash('md5');
	  // Generate keys used for authentication
	  md5.update(username + ":mongo:" + password);
	  var userPassword = md5.digest('hex');
	
	  // No password
	  if(typeof password == 'string') {
	    command.pwd = userPassword;
	  }
	
	  // Force write using primary
	  commandOptions.readPreference = CoreReadPreference.primary;
	
	  // Execute the command
	  self.command(command, commandOptions, function(err, result) {
	    if(err && err.ok == 0 && err.code == undefined) return handleCallback(callback, {code: -5000}, null);
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, !result.ok ? toError(result) : null
	      , result.ok ? [{user: username, pwd: ''}] : null);
	  })
	}
	
	var addUser = function(self, username, password, options, callback) {
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	  // Attempt to execute auth command
	  _executeAuthCreateUserCommand(self, username, password, options, function(err, r) {
	    // We need to perform the backward compatible insert operation
	    if(err && err.code == -5000) {
	      var finalOptions = writeConcern(shallowClone(options), self, options);
	      // Use node md5 generator
	      var md5 = crypto.createHash('md5');
	      // Generate keys used for authentication
	      md5.update(username + ":mongo:" + password);
	      var userPassword = md5.digest('hex');
	
	      // If we have another db set
	      var db = options.dbName ? self.db(options.dbName) : self;
	
	      // Fetch a user collection
	      var collection = db.collection(Db.SYSTEM_USER_COLLECTION);
	
	      // Check if we are inserting the first user
	      collection.count({}, function(err, count) {
	        // We got an error (f.ex not authorized)
	        if(err != null) return handleCallback(callback, err, null);
	        // Check if the user exists and update i
	        collection.find({user: username}, {dbName: options['dbName']}).toArray(function(err, documents) {
	          // We got an error (f.ex not authorized)
	          if(err != null) return handleCallback(callback, err, null);
	          // Add command keys
	          finalOptions.upsert = true;
	
	          // We have a user, let's update the password or upsert if not
	          collection.update({user: username},{$set: {user: username, pwd: userPassword}}, finalOptions, function(err, results, full) {
	            if(count == 0 && err) return handleCallback(callback, null, [{user:username, pwd:userPassword}]);
	            if(err) return handleCallback(callback, err, null)
	            handleCallback(callback, null, [{user:username, pwd:userPassword}]);
	          });
	        });
	      });
	
	      return;
	    }
	
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, err, r);
	  });
	}
	
	/**
	 * Add a user to the database.
	 * @method
	 * @param {string} username The username.
	 * @param {string} password The password.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {object} [options.customData=null] Custom data associated with the user (only Mongodb 2.6 or higher)
	 * @param {object[]} [options.roles=null] Roles associated with the created user (only Mongodb 2.6 or higher)
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.addUser = function(username, password, options, callback) {
	  // Unpack the parameters
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() || {} : {};
	
	  // If we have a callback fallback
	  if(typeof callback == 'function') return addUser(self, username, password, options, callback);
	
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    addUser(self, username, password, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	define.classMethod('addUser', {callback: true, promise:true});
	
	var _executeAuthRemoveUserCommand = function(self, username, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	  // Get the error options
	  var commandOptions = {writeCommand:true};
	  if(options['dbName']) commandOptions.dbName = options['dbName'];
	
	  // Get additional values
	  var maxTimeMS = typeof options.maxTimeMS == 'number' ? options.maxTimeMS : null;
	
	  // Add maxTimeMS to options if set
	  if(maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;
	
	  // Build the command to execute
	  var command = {
	    dropUser: username
	  }
	
	  // Apply write concern to command
	  command = writeConcern(command, self, options);
	
	  // Force write using primary
	  commandOptions.readPreference = CoreReadPreference.primary;
	
	  // Execute the command
	  self.command(command, commandOptions, function(err, result) {
	    if(err && !err.ok && err.code == undefined) return handleCallback(callback, {code: -5000});
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, null, result.ok ? true : false);
	  })
	}
	
	var removeUser = function(self, username, options, callback) {
	  // Attempt to execute command
	  _executeAuthRemoveUserCommand(self, username, options, function(err, result) {
	    if(err && err.code == -5000) {
	      var finalOptions = writeConcern(shallowClone(options), self, options);
	      // If we have another db set
	      var db = options.dbName ? self.db(options.dbName) : self;
	
	      // Fetch a user collection
	      var collection = db.collection(Db.SYSTEM_USER_COLLECTION);
	
	      // Locate the user
	      collection.findOne({user: username}, {}, function(err, user) {
	        if(user == null) return handleCallback(callback, err, false);
	        collection.remove({user: username}, finalOptions, function(err, result) {
	          handleCallback(callback, err, true);
	        });
	      });
	
	      return;
	    }
	
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, err, result);
	  });
	}
	
	define.classMethod('removeUser', {callback: true, promise:true});
	
	/**
	 * Remove a user from a database
	 * @method
	 * @param {string} username The username.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.removeUser = function(username, options, callback) {
	  // Unpack the parameters
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() || {} : {};
	
	  // If we have a callback fallback
	  if(typeof callback == 'function') return removeUser(self, username, options, callback);
	
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    removeUser(self, username, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var authenticate = function(self, username, password, options, callback) {
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	
	  // the default db to authenticate against is 'self'
	  // if authententicate is called from a retry context, it may be another one, like admin
	  var authdb = options.authdb ? options.authdb : options.dbName;
	  authdb = options.authSource ? options.authSource : authdb;
	  authdb = authdb ? authdb : self.databaseName;
	
	  // Callback
	  var _callback = function(err, result) {
	    if(self.listeners('authenticated').length > 0) {
	      self.emit('authenticated', err, result);
	    }
	
	    // Return to caller
	    handleCallback(callback, err, result);
	  }
	
	  // authMechanism
	  var authMechanism = options.authMechanism || '';
	  authMechanism = authMechanism.toUpperCase();
	
	  // If classic auth delegate to auth command
	  if(authMechanism == 'MONGODB-CR') {
	    self.s.topology.auth('mongocr', authdb, username, password, function(err, result) {
	      if(err) return handleCallback(callback, err, false);
	      _callback(null, true);
	    });
	  } else if(authMechanism == 'PLAIN') {
	    self.s.topology.auth('plain', authdb, username, password, function(err, result) {
	      if(err) return handleCallback(callback, err, false);
	      _callback(null, true);
	    });
	  } else if(authMechanism == 'MONGODB-X509') {
	    self.s.topology.auth('x509', authdb, username, password, function(err, result) {
	      if(err) return handleCallback(callback, err, false);
	      _callback(null, true);
	    });
	  } else if(authMechanism == 'SCRAM-SHA-1') {
	    self.s.topology.auth('scram-sha-1', authdb, username, password, function(err, result) {
	      if(err) return handleCallback(callback, err, false);
	      _callback(null, true);
	    });
	  } else if(authMechanism == 'GSSAPI') {
	    if(process.platform == 'win32') {
	      self.s.topology.auth('sspi', authdb, username, password, options, function(err, result) {
	        if(err) return handleCallback(callback, err, false);
	        _callback(null, true);
	      });
	    } else {
	      self.s.topology.auth('gssapi', authdb, username, password, options, function(err, result) {
	        if(err) return handleCallback(callback, err, false);
	        _callback(null, true);
	      });
	    }
	  } else if(authMechanism == 'DEFAULT') {
	    self.s.topology.auth('default', authdb, username, password, function(err, result) {
	      if(err) return handleCallback(callback, err, false);
	      _callback(null, true);
	    });
	  } else {
	    handleCallback(callback, MongoError.create({message: f("authentication mechanism %s not supported", options.authMechanism), driver:true}));
	  }
	}
	
	/**
	 * Authenticate a user against the server.
	 * @method
	 * @param {string} username The username.
	 * @param {string} [password] The password.
	 * @param {object} [options=null] Optional settings.
	 * @param {string} [options.authMechanism=MONGODB-CR] The authentication mechanism to use, GSSAPI, MONGODB-CR, MONGODB-X509, PLAIN
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.authenticate = function(username, password, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  var self = this;
	  // Shallow copy the options
	  options = shallowClone(options);
	
	  // Set default mechanism
	  if(!options.authMechanism) {
	    options.authMechanism = 'DEFAULT';
	  } else if(options.authMechanism != 'GSSAPI'
	    && options.authMechanism != 'DEFAULT'
	    && options.authMechanism != 'MONGODB-CR'
	    && options.authMechanism != 'MONGODB-X509'
	    && options.authMechanism != 'SCRAM-SHA-1'
	    && options.authMechanism != 'PLAIN') {
	      return handleCallback(callback, MongoError.create({message: "only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, SCRAM-SHA-1 or MONGODB-CR is supported by authMechanism", driver:true}));
	  }
	
	  // If we have a callback fallback
	  if(typeof callback == 'function') return authenticate(self, username, password, options, function(err, r) {
	    // Support failed auth method
	    if(err && err.message && err.message.indexOf('saslStart') != -1) err.code = 59;
	    // Reject error
	    if(err) return callback(err, r);
	    callback(null, r);
	  });
	
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    authenticate(self, username, password, options, function(err, r) {
	      // Support failed auth method
	      if(err && err.message && err.message.indexOf('saslStart') != -1) err.code = 59;
	      // Reject error
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	define.classMethod('authenticate', {callback: true, promise:true});
	
	/**
	 * Logout user from server, fire off on all connections and remove all auth info
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {string} [options.dbName=null] Logout against different database than current.
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.logout = function(options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() || {} : {};
	
	  // logout command
	  var cmd = {'logout':1};
	
	  // Add onAll to login to ensure all connection are logged out
	  options.onAll = true;
	
	  // We authenticated against a different db use that
	  if(this.s.authSource) options.dbName = this.s.authSource;
	
	  // Execute the command
	  if(typeof callback == 'function') return this.command(cmd, options, function(err, result) {
	    // Did the user destroy the topology
	    if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	    if(err) return handleCallback(callback, err, false);
	    handleCallback(callback, null, true)
	  });
	
	  // Return promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.command(cmd, options, function(err, result) {
	      // Did the user destroy the topology
	      if(self.serverConfig && self.serverConfig.isDestroyed()) return reject(new MongoError('topology was destroyed'));
	      if(err) return reject(err);
	      resolve(true);
	    });
	  });
	}
	
	define.classMethod('logout', {callback: true, promise:true});
	
	// Figure out the read preference
	var getReadPreference = function(options, db) {
	  if(options.readPreference) return options;
	  if(db.readPreference) options.readPreference = db.readPreference;
	  return options;
	}
	
	/**
	 * Retrieves this collections index info.
	 * @method
	 * @param {string} name The name of the collection.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.full=false] Returns the full raw index information.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.indexInformation = function(name, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // If we have a callback fallback
	  if(typeof callback == 'function') return indexInformation(self, name, options, callback);
	
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    indexInformation(self, name, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var indexInformation = function(self, name, options, callback) {
	    // If we specified full information
	  var full = options['full'] == null ? false : options['full'];
	
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	
	  // Process all the results from the index command and collection
	  var processResults = function(indexes) {
	    // Contains all the information
	    var info = {};
	    // Process all the indexes
	    for(var i = 0; i < indexes.length; i++) {
	      var index = indexes[i];
	      // Let's unpack the object
	      info[index.name] = [];
	      for(var name in index.key) {
	        info[index.name].push([name, index.key[name]]);
	      }
	    }
	
	    return info;
	  }
	
	  // Get the list of indexes of the specified collection
	  self.collection(name).listIndexes().toArray(function(err, indexes) {
	    if(err) return callback(toError(err));
	    if(!Array.isArray(indexes)) return handleCallback(callback, null, []);
	    if(full) return handleCallback(callback, null, indexes);
	    handleCallback(callback, null, processResults(indexes));
	  });
	}
	
	define.classMethod('indexInformation', {callback: true, promise:true});
	
	var createCreateIndexCommand = function(db, name, fieldOrSpec, options) {
	  var indexParameters = parseIndexOptions(fieldOrSpec);
	  var fieldHash = indexParameters.fieldHash;
	  var keys = indexParameters.keys;
	
	  // Generate the index name
	  var indexName = typeof options.name == 'string' ? options.name : indexParameters.name;
	  var selector = {
	    'ns': db.databaseName + "." + name, 'key': fieldHash, 'name': indexName
	  }
	
	  // Ensure we have a correct finalUnique
	  var finalUnique = options == null || 'object' === typeof options ? false : options;
	  // Set up options
	  options = options == null || typeof options == 'boolean' ? {} : options;
	
	  // Add all the options
	  var keysToOmit = Object.keys(selector);
	  for(var optionName in options) {
	    if(keysToOmit.indexOf(optionName) == -1) {
	      selector[optionName] = options[optionName];
	    }
	  }
	
	  if(selector['unique'] == null) selector['unique'] = finalUnique;
	
	  // Remove any write concern operations
	  var removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference'];
	  for(var i = 0; i < removeKeys.length; i++) {
	    delete selector[removeKeys[i]];
	  }
	
	  // Return the command creation selector
	  return selector;
	}
	
	var createIndexUsingCreateIndexes = function(self, name, fieldOrSpec, options, callback) {
	  // Build the index
	  var indexParameters = parseIndexOptions(fieldOrSpec);
	  // Generate the index name
	  var indexName = typeof options.name == 'string' ? options.name : indexParameters.name;
	  // Set up the index
	  var indexes = [{ name: indexName, key: indexParameters.fieldHash }];
	  // merge all the options
	  var keysToOmit = Object.keys(indexes[0]);
	  for(var optionName in options) {
	    if(keysToOmit.indexOf(optionName) == -1) {
	      indexes[0][optionName] = options[optionName];
	    }
	
	    // Remove any write concern operations
	    var removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference'];
	    for(var i = 0; i < removeKeys.length; i++) {
	      delete indexes[0][removeKeys[i]];
	    }
	  }
	
	  // Create command, apply write concern to command
	  var cmd = writeConcern({createIndexes: name, indexes: indexes}, self, options);
	
	  // Build the command
	  self.command(cmd, options, function(err, result) {
	    if(err) return handleCallback(callback, err, null);
	    if(result.ok == 0) return handleCallback(callback, toError(result), null);
	    // Return the indexName for backward compatibility
	    handleCallback(callback, null, indexName);
	  });
	}
	
	// Validate the database name
	var validateDatabaseName = function(databaseName) {
	  if(typeof databaseName !== 'string') throw MongoError.create({message: "database name must be a string", driver:true});
	  if(databaseName.length === 0) throw MongoError.create({message: "database name cannot be the empty string", driver:true});
	  if(databaseName == '$external') return;
	
	  var invalidChars = [" ", ".", "$", "/", "\\"];
	  for(var i = 0; i < invalidChars.length; i++) {
	    if(databaseName.indexOf(invalidChars[i]) != -1) throw MongoError.create({message: "database names cannot contain the character '" + invalidChars[i] + "'", driver:true});
	  }
	}
	
	// Get write concern
	var writeConcern = function(target, db, options) {
	  if(options.w != null || options.j != null || options.fsync != null) {
	    var opts = {};
	    if(options.w) opts.w = options.w;
	    if(options.wtimeout) opts.wtimeout = options.wtimeout;
	    if(options.j) opts.j = options.j;
	    if(options.fsync) opts.fsync = options.fsync;
	    target.writeConcern = opts;
	  } else if(db.writeConcern.w != null || db.writeConcern.j != null || db.writeConcern.fsync != null) {
	    target.writeConcern = db.writeConcern;
	  }
	
	  return target
	}
	
	// Add listeners to topology
	var createListener = function(self, e, object) {
	  var listener = function(err) {
	    if(object.listeners(e).length > 0) {
	      object.emit(e, err, self);
	
	      // Emit on all associated db's if available
	      for(var i = 0; i < self.s.children.length; i++) {
	        self.s.children[i].emit(e, err, self.s.children[i]);
	      }
	    }
	  }
	  return listener;
	}
	
	
	/**
	 * Unref all sockets
	 * @method
	 */
	Db.prototype.unref = function(options, callback) {
	  this.s.topology.unref();
	}
	
	/**
	 * Db close event
	 *
	 * Emitted after a socket closed against a single server or mongos proxy.
	 *
	 * @event Db#close
	 * @type {MongoError}
	 */
	
	/**
	 * Db authenticated event
	 *
	 * Emitted after all server members in the topology (single server, replicaset or mongos) have successfully authenticated.
	 *
	 * @event Db#authenticated
	 * @type {object}
	 */
	
	/**
	 * Db reconnect event
	 *
	 *  * Server: Emitted when the driver has reconnected and re-authenticated.
	 *  * ReplicaSet: N/A
	 *  * Mongos: Emitted when the driver reconnects and re-authenticates successfully against a Mongos.
	 *
	 * @event Db#reconnect
	 * @type {object}
	 */
	
	/**
	 * Db error event
	 *
	 * Emitted after an error occurred against a single server or mongos proxy.
	 *
	 * @event Db#error
	 * @type {MongoError}
	 */
	
	/**
	 * Db timeout event
	 *
	 * Emitted after a socket timeout occurred against a single server or mongos proxy.
	 *
	 * @event Db#timeout
	 * @type {MongoError}
	 */
	
	/**
	 * Db parseError event
	 *
	 * The parseError event is emitted if the driver detects illegal or corrupt BSON being received from the server.
	 *
	 * @event Db#parseError
	 * @type {MongoError}
	 */
	
	/**
	 * Db fullsetup event, emitted when all servers in the topology have been connected to at start up time.
	 *
	 * * Server: Emitted when the driver has connected to the single server and has authenticated.
	 * * ReplSet: Emitted after the driver has attempted to connect to all replicaset members.
	 * * Mongos: Emitted after the driver has attempted to connect to all mongos proxies.
	 *
	 * @event Db#fullsetup
	 * @type {Db}
	 */
	
	// Constants
	Db.SYSTEM_NAMESPACE_COLLECTION = "system.namespaces";
	Db.SYSTEM_INDEX_COLLECTION = "system.indexes";
	Db.SYSTEM_PROFILE_COLLECTION = "system.profile";
	Db.SYSTEM_USER_COLLECTION = "system.users";
	Db.SYSTEM_COMMAND_COLLECTION = "$cmd";
	Db.SYSTEM_JS_COLLECTION = "system.js";
	
	module.exports = Db;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(6)))

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var toError = __webpack_require__(194).toError,
	  Define = __webpack_require__(196),
	  shallowClone = __webpack_require__(194).shallowClone;
	
	/**
	 * @fileOverview The **Admin** class is an internal class that allows convenient access to
	 * the admin functionality and commands for MongoDB.
	 *
	 * **ADMIN Cannot directly be instantiated**
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Use the admin database for the operation
	 *   var adminDb = db.admin();
	 *
	 *   // List all the available databases
	 *   adminDb.listDatabases(function(err, dbs) {
	 *     test.equal(null, err);
	 *     test.ok(dbs.databases.length > 0);
	 *     db.close();
	 *   });
	 * });
	 */
	
	/**
	 * Create a new Admin instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @return {Admin} a collection instance.
	 */
	var Admin = function(db, topology, promiseLibrary) {
	  if(!(this instanceof Admin)) return new Admin(db, topology);
	  var self = this;
	
	  // Internal state
	  this.s = {
	      db: db
	    , topology: topology
	    , promiseLibrary: promiseLibrary
	  }
	}
	
	var define = Admin.define = new Define('Admin', Admin, false);
	
	/**
	 * The callback format for results
	 * @callback Admin~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Execute a command
	 * @method
	 * @param {object} command The command hash
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.maxTimeMS=null] Number of milliseconds to wait before aborting the query.
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.command = function(command, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return this.s.db.executeDbAdminCommand(command, options, function(err, doc) {
	    return callback != null ? callback(err, doc) : null;
	  });
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.executeDbAdminCommand(command, options, function(err, doc) {
	      if(err) return reject(err);
	      resolve(doc);
	    });
	  });
	}
	
	define.classMethod('command', {callback: true, promise:true});
	
	/**
	 * Retrieve the server information for the current
	 * instance of the db client
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.buildInfo = function(callback) {
	  var self = this;
	  // Execute using callback
	  if(typeof callback == 'function') return this.serverInfo(callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.serverInfo(function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('buildInfo', {callback: true, promise:true});
	
	/**
	 * Retrieve the server information for the current
	 * instance of the db client
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.serverInfo = function(callback) {
	  var self = this;
	  // Execute using callback
	  if(typeof callback == 'function') return this.s.db.executeDbAdminCommand({buildinfo:1}, function(err, doc) {
	    if(err != null) return callback(err, null);
	    callback(null, doc);
	  });
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.executeDbAdminCommand({buildinfo:1}, function(err, doc) {
	      if(err) return reject(err);
	      resolve(doc);
	    });
	  });
	}
	
	define.classMethod('serverInfo', {callback: true, promise:true});
	
	/**
	 * Retrieve this db's server status.
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.serverStatus = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return serverStatus(self, callback)
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    serverStatus(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var serverStatus = function(self, callback) {
	  self.s.db.executeDbAdminCommand({serverStatus: 1}, function(err, doc) {
	    if(err == null && doc.ok === 1) {
	      callback(null, doc);
	    } else {
	      if(err) return callback(err, false);
	      return callback(toError(doc), false);
	    }
	  });
	}
	
	define.classMethod('serverStatus', {callback: true, promise:true});
	
	/**
	 * Retrieve the current profiling Level for MongoDB
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.profilingLevel = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return profilingLevel(self, callback)
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    profilingLevel(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var profilingLevel = function(self, callback) {
	  self.s.db.executeDbAdminCommand({profile:-1}, function(err, doc) {
	    doc = doc;
	
	    if(err == null && doc.ok === 1) {
	      var was = doc.was;
	      if(was == 0) return callback(null, "off");
	      if(was == 1) return callback(null, "slow_only");
	      if(was == 2) return callback(null, "all");
	        return callback(new Error("Error: illegal profiling level value " + was), null);
	    } else {
	      err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
	    }
	  });
	}
	
	define.classMethod('profilingLevel', {callback: true, promise:true});
	
	/**
	 * Ping the MongoDB server and retrieve results
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.ping = function(options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	
	  // Execute using callback
	  if(typeof callback == 'function') return this.s.db.executeDbAdminCommand({ping: 1}, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.executeDbAdminCommand({ping: 1}, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('ping', {callback: true, promise:true});
	
	/**
	 * Authenticate a user against the server.
	 * @method
	 * @param {string} username The username.
	 * @param {string} [password] The password.
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.authenticate = function(username, password, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = shallowClone(options);
	  options.authdb = 'admin';
	  
	  // Execute using callback
	  if(typeof callback == 'function') return this.s.db.authenticate(username, password, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.authenticate(username, password, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('authenticate', {callback: true, promise:true});
	
	/**
	 * Logout user from server, fire off on all connections and remove all auth info
	 * @method
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.logout = function(callback) {
	  var self = this;
	  // Execute using callback
	  if(typeof callback == 'function') return this.s.db.logout({authdb: 'admin'}, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.logout({authdb: 'admin'}, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('logout', {callback: true, promise:true});
	
	// Get write concern
	var writeConcern = function(options, db) {
	  options = shallowClone(options);
	
	  // If options already contain write concerns return it
	  if(options.w || options.wtimeout || options.j || options.fsync) {
	    return options;
	  }
	
	  // Set db write concern if available
	  if(db.writeConcern) {
	    if(options.w) options.w = db.writeConcern.w;
	    if(options.wtimeout) options.wtimeout = db.writeConcern.wtimeout;
	    if(options.j) options.j = db.writeConcern.j;
	    if(options.fsync) options.fsync = db.writeConcern.fsync;
	  }
	
	  // Return modified options
	  return options;
	}
	
	/**
	 * Add a user to the database.
	 * @method
	 * @param {string} username The username.
	 * @param {string} password The password.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.fsync=false] Specify a file sync write concern.
	 * @param {object} [options.customData=null] Custom data associated with the user (only Mongodb 2.6 or higher)
	 * @param {object[]} [options.roles=null] Roles associated with the created user (only Mongodb 2.6 or higher)
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.addUser = function(username, password, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() : {};
	  options = options || {};
	  // Get the options
	  options = writeConcern(options, self.s.db)
	  // Set the db name to admin
	  options.dbName = 'admin';
	
	  // Execute using callback
	  if(typeof callback == 'function')
	    return self.s.db.addUser(username, password, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.addUser(username, password, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('addUser', {callback: true, promise:true});
	
	/**
	 * Remove a user from a database
	 * @method
	 * @param {string} username The username.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.fsync=false] Specify a file sync write concern.
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.removeUser = function(username, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() : {};
	  options = options || {};
	  // Get the options
	  options = writeConcern(options, self.s.db)
	  // Set the db name
	  options.dbName = 'admin';
	
	  // Execute using callback
	  if(typeof callback == 'function')
	    return self.s.db.removeUser(username, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.removeUser(username, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('removeUser', {callback: true, promise:true});
	
	/**
	 * Set the current profiling level of MongoDB
	 *
	 * @param {string} level The new profiling level (off, slow_only, all).
	 * @param {Admin~resultCallback} [callback] The command result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.setProfilingLevel = function(level, callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return setProfilingLevel(self, level, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    setProfilingLevel(self, level, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var setProfilingLevel = function(self, level, callback) {
	  var command = {};
	  var profile = 0;
	
	  if(level == "off") {
	    profile = 0;
	  } else if(level == "slow_only") {
	    profile = 1;
	  } else if(level == "all") {
	    profile = 2;
	  } else {
	    return callback(new Error("Error: illegal profiling level value " + level));
	  }
	
	  // Set up the profile number
	  command['profile'] = profile;
	
	  self.s.db.executeDbAdminCommand(command, function(err, doc) {
	    doc = doc;
	
	    if(err == null && doc.ok === 1)
	      return callback(null, level);
	    return err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
	  });
	}
	
	define.classMethod('setProfilingLevel', {callback: true, promise:true});
	
	/**
	 * Retrive the current profiling information for MongoDB
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.profilingInfo = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return profilingInfo(self, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    profilingInfo(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var profilingInfo = function(self, callback) {
	  try {
	    self.s.topology.cursor("admin.system.profile", { find: 'system.profile', query: {}}, {}).toArray(callback);
	  } catch (err) {
	    return callback(err, null);
	  }
	}
	
	define.classMethod('profilingLevel', {callback: true, promise:true});
	
	/**
	 * Validate an existing collection
	 *
	 * @param {string} collectionName The name of the collection to validate.
	 * @param {object} [options=null] Optional settings.
	 * @param {Admin~resultCallback} [callback] The command result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.validateCollection = function(collectionName, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() : {};
	  options = options || {};
	
	  // Execute using callback
	  if(typeof callback == 'function')
	    return validateCollection(self, collectionName, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    validateCollection(self, collectionName, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var validateCollection = function(self, collectionName, options, callback) {
	  var command = {validate: collectionName};
	  var keys = Object.keys(options);
	
	  // Decorate command with extra options
	  for(var i = 0; i < keys.length; i++) {
	    if(options.hasOwnProperty(keys[i])) {
	      command[keys[i]] = options[keys[i]];
	    }
	  }
	
	  self.s.db.command(command, function(err, doc) {
	    if(err != null) return callback(err, null);
	
	    if(doc.ok === 0)
	      return callback(new Error("Error with validate command"), null);
	    if(doc.result != null && doc.result.constructor != String)
	      return callback(new Error("Error with validation data"), null);
	    if(doc.result != null && doc.result.match(/exception|corrupt/) != null)
	      return callback(new Error("Error: invalid collection " + collectionName), null);
	    if(doc.valid != null && !doc.valid)
	      return callback(new Error("Error: invalid collection " + collectionName), null);
	
	    return callback(null, doc);
	  });
	}
	
	define.classMethod('validateCollection', {callback: true, promise:true});
	
	/**
	 * List the available databases
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.listDatabases = function(callback) {
	  var self = this;
	  // Execute using callback
	  if(typeof callback == 'function') return self.s.db.executeDbAdminCommand({listDatabases:1}, {}, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.executeDbAdminCommand({listDatabases:1}, {}, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('listDatabases', {callback: true, promise:true});
	
	/**
	 * Get ReplicaSet status
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.replSetGetStatus = function(callback) {
	  var self = this;
	  // Execute using callback
	  if(typeof callback == 'function') return replSetGetStatus(self, callback);
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    replSetGetStatus(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var replSetGetStatus = function(self, callback) {
	  self.s.db.executeDbAdminCommand({replSetGetStatus:1}, function(err, doc) {
	    if(err == null && doc.ok === 1)
	      return callback(null, doc);
	    if(err) return callback(err, false);
	    callback(toError(doc), false);
	  });
	}
	
	define.classMethod('replSetGetStatus', {callback: true, promise:true});
	
	module.exports = Admin;


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {"use strict";
	
	var parse = __webpack_require__(215)
	  , Server = __webpack_require__(208)
	  , Mongos = __webpack_require__(211)
	  , ReplSet = __webpack_require__(210)
	  , Define = __webpack_require__(196)
	  , ReadPreference = __webpack_require__(195)
	  , Db = __webpack_require__(212);
	
	/**
	 * @fileOverview The **MongoClient** class is a class that allows for making Connections to MongoDB.
	 *
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Get an additional db
	 *   db.close();
	 * });
	 */
	
	/**
	 * Creates a new MongoClient instance
	 * @class
	 * @return {MongoClient} a MongoClient instance.
	 */
	function MongoClient() {
	  /**
	   * The callback format for results
	   * @callback MongoClient~connectCallback
	   * @param {MongoError} error An error instance representing the error during the execution.
	   * @param {Db} db The connected database.
	   */
	
	  /**
	   * Connect to MongoDB using a url as documented at
	   *
	   *  docs.mongodb.org/manual/reference/connection-string/
	   *
	   * Note that for replicasets the replicaSet query parameter is required in the 2.0 driver
	   *
	   * @method
	   * @param {string} url The connection URI string
	   * @param {object} [options=null] Optional settings.
	   * @param {boolean} [options.uri_decode_auth=false] Uri decode the user name and password for authentication
	   * @param {object} [options.db=null] A hash of options to set on the db object, see **Db constructor**
	   * @param {object} [options.server=null] A hash of options to set on the server objects, see **Server** constructor**
	   * @param {object} [options.replSet=null] A hash of options to set on the replSet object, see **ReplSet** constructor**
	   * @param {object} [options.mongos=null] A hash of options to set on the mongos object, see **Mongos** constructor**
	   * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	   * @param {MongoClient~connectCallback} [callback] The command result callback
	   * @return {Promise} returns Promise if no callback passed
	   */
	  this.connect = MongoClient.connect;
	}
	
	var define = MongoClient.define = new Define('MongoClient', MongoClient, false);
	
	/**
	 * Connect to MongoDB using a url as documented at
	 *
	 *  docs.mongodb.org/manual/reference/connection-string/
	 *
	 * Note that for replicasets the replicaSet query parameter is required in the 2.0 driver
	 *
	 * @method
	 * @static
	 * @param {string} url The connection URI string
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.uri_decode_auth=false] Uri decode the user name and password for authentication
	 * @param {object} [options.db=null] A hash of options to set on the db object, see **Db constructor**
	 * @param {object} [options.server=null] A hash of options to set on the server objects, see **Server** constructor**
	 * @param {object} [options.replSet=null] A hash of options to set on the replSet object, see **ReplSet** constructor**
	 * @param {object} [options.mongos=null] A hash of options to set on the mongos object, see **Mongos** constructor**
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {MongoClient~connectCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	MongoClient.connect = function(url, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = typeof args[args.length - 1] == 'function' ? args.pop() : null;
	  options = args.length ? args.shift() : null;
	  options = options || {};
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(198).Promise;
	  }
	
	  // Return a promise
	  if(typeof callback != 'function') {
	    return new promiseLibrary(function(resolve, reject) {
	      connect(url, options, function(err, db) {
	        if(err) return reject(err);
	        resolve(db);
	      });
	    });
	  }
	
	  // Fallback to callback based connect
	  connect(url, options, callback);
	}
	
	define.staticMethod('connect', {callback: true, promise:true});
	
	var serverOptions = ['poolSize', 'ssl', 'sslValidate', 'checkServerIdentity',
	  'sslCA', 'sslCert', 'sslKey', 'sslPass', 'autoReconnect', 'noDelay',
	  'keepAlive', 'connectionTimeoutMS', 'socketTimeoutMS', 'reconnectTries',
	  'reconnectInterval'];
	
	var replsetOptions = ['ha', 'haInterval', 'replicaSet', 'secondaryAcceptableLatencyMS',
	  'connectWithNoPrimary', 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate',
	  'sslCA', 'sslCert', 'sslKey', 'sslPass', 'noDelay', 'keepAlive', 'connectTimeoutMS',
	  'socketTimeoutMS'];
	
	var mongosOptions = ['ha', 'haInterval', 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate',
	  'sslCA', 'sslCert', 'sslKey', 'sslPass', 'noDelay', 'keepAlive', 'connectTimeoutMS',
	  'socketTimeoutMS', 'acceptableLatencyMS'];
	
	var dbOptions = ['authSource', 'w', 'wtimeout', 'j', 'native_parser', 'forceServerObjectId',
	  'serializeFunctions', 'ignoreUndefined', 'raw', 'promoteLongs', 'bufferMaxEntries', 'readPreference',
	  'pkFactory', 'promiseLibrary', 'readConcern']
	
	/*
	 * Merge top level options into final options object
	 */
	var mergeTopLevel = function(object, options) {
	  if(!object.server_options) object.server_options = {};
	  if(!object.db_options) object.db_options = {};
	  if(!object.rs_options) object.rs_options = {};
	  if(!object.mongos_options) object.mongos_options = {};
	
	  for(var name in options) {
	    if(serverOptions.indexOf(name) != -1) {
	      object.server_options[name] = options[name];
	    }
	
	    if(replsetOptions.indexOf(name) != -1) {
	      object.rs_options[name] = options[name];
	    }
	
	    if(mongosOptions.indexOf(name) != -1) {
	      object.mongos_options[name] = options[name];
	    }
	
	    if(dbOptions.indexOf(name) != -1) {
	      object.db_options[name] = options[name];
	    }
	  }
	
	  return object;
	}
	
	/*
	 * Connect using MongoClient
	 */
	var connect = function(url, options, callback) {
	  var serverOptions = options.server || {};
	  var mongosOptions = options.mongos || {};
	  var replSetServersOptions = options.replSet || options.replSetServers || {};
	  var dbOptions = options.db || {};
	
	  // If callback is null throw an exception
	  if(callback == null)
	    throw new Error("no callback function provided");
	
	  // Parse the string
	  var object = parse(url, options);
	
	  // Merge in any options for db in options object
	  if(dbOptions) {
	    for(var name in dbOptions) object.db_options[name] = dbOptions[name];
	  }
	
	  // Added the url to the options
	  object.db_options.url = url;
	
	  // Merge in any options for server in options object
	  if(serverOptions) {
	    for(var name in serverOptions) object.server_options[name] = serverOptions[name];
	  }
	
	  // Merge in any replicaset server options
	  if(replSetServersOptions) {
	    for(var name in replSetServersOptions) object.rs_options[name] = replSetServersOptions[name];
	  }
	
	  if(replSetServersOptions.ssl
	    || replSetServersOptions.sslValidate
	    || replSetServersOptions.checkServerIdentity
	    || replSetServersOptions.sslCA
	    || replSetServersOptions.sslCert
	    || replSetServersOptions.sslKey
	    || replSetServersOptions.sslPass) {
	    object.server_options.ssl = replSetServersOptions.ssl;
	    object.server_options.sslValidate = replSetServersOptions.sslValidate;
	    object.server_options.checkServerIdentity = replSetServersOptions.checkServerIdentity;
	    object.server_options.sslCA = replSetServersOptions.sslCA;
	    object.server_options.sslCert = replSetServersOptions.sslCert;
	    object.server_options.sslKey = replSetServersOptions.sslKey;
	    object.server_options.sslPass = replSetServersOptions.sslPass;
	  }
	
	  // Merge in any replicaset server options
	  if(mongosOptions) {
	    for(var name in mongosOptions) object.mongos_options[name] = mongosOptions[name];
	  }
	
	  if(typeof object.server_options.poolSize == 'number') {
	    if(!object.mongos_options.poolSize) object.mongos_options.poolSize = object.server_options.poolSize;
	    if(!object.rs_options.poolSize) object.rs_options.poolSize = object.server_options.poolSize;
	  }
	
	  if(mongosOptions.ssl
	    || mongosOptions.sslValidate
	    || mongosOptions.checkServerIdentity
	    || mongosOptions.sslCA
	    || mongosOptions.sslCert
	    || mongosOptions.sslKey
	    || mongosOptions.sslPass) {
	    object.server_options.ssl = mongosOptions.ssl;
	    object.server_options.sslValidate = mongosOptions.sslValidate;
	    object.server_options.checkServerIdentity = mongosOptions.checkServerIdentity;
	    object.server_options.sslCA = mongosOptions.sslCA;
	    object.server_options.sslCert = mongosOptions.sslCert;
	    object.server_options.sslKey = mongosOptions.sslKey;
	    object.server_options.sslPass = mongosOptions.sslPass;
	  }
	
	  // Set the promise library
	  object.db_options.promiseLibrary = options.promiseLibrary;
	
	  // We need to ensure that the list of servers are only either direct members or mongos
	  // they cannot be a mix of monogs and mongod's
	  var totalNumberOfServers = object.servers.length;
	  var totalNumberOfMongosServers = 0;
	  var totalNumberOfMongodServers = 0;
	  var serverConfig = null;
	  var errorServers = {};
	
	  // Failure modes
	  if(object.servers.length == 0) throw new Error("connection string must contain at least one seed host");
	
	  // If we have no db setting for the native parser try to set the c++ one first
	  object.db_options.native_parser = _setNativeParser(object.db_options);
	  // If no auto_reconnect is set, set it to true as default for single servers
	  if(typeof object.server_options.auto_reconnect != 'boolean') {
	    object.server_options.auto_reconnect = true;
	  }
	
	  // Merge in the top level options if any specified
	  object = mergeTopLevel(object, options);
	
	  // If we have more than a server, it could be replicaset or mongos list
	  // need to verify that it's one or the other and fail if it's a mix
	  // Connect to all servers and run ismaster
	  for(var i = 0; i < object.servers.length; i++) {
	    // Set up socket options
	    var providedSocketOptions = object.server_options.socketOptions || {};
	
	    var _server_options = {
	        poolSize:1
	      , socketOptions: {
	          connectTimeoutMS: providedSocketOptions.connectTimeoutMS || (1000 * 120)
	        , socketTimeoutMS:  providedSocketOptions.socketTimeoutMS || (1000 * 120)
	      }
	      , auto_reconnect:false};
	
	    // Ensure we have ssl setup for the servers
	    if(object.server_options.ssl) {
	      _server_options.ssl = object.server_options.ssl;
	      _server_options.sslValidate = object.server_options.sslValidate;
	      _server_options.checkServerIdentity = object.server_options.checkServerIdentity;
	      _server_options.sslCA = object.server_options.sslCA;
	      _server_options.sslCert = object.server_options.sslCert;
	      _server_options.sslKey = object.server_options.sslKey;
	      _server_options.sslPass = object.server_options.sslPass;
	    } else if(object.rs_options.ssl) {
	      _server_options.ssl = object.rs_options.ssl;
	      _server_options.sslValidate = object.rs_options.sslValidate;
	      _server_options.checkServerIdentity = object.rs_options.checkServerIdentity;
	      _server_options.sslCA = object.rs_options.sslCA;
	      _server_options.sslCert = object.rs_options.sslCert;
	      _server_options.sslKey = object.rs_options.sslKey;
	      _server_options.sslPass = object.rs_options.sslPass;
	    }
	
	    // Error
	    var error = null;
	    // Set up the Server object
	    var _server = object.servers[i].domain_socket
	        ? new Server(object.servers[i].domain_socket, _server_options)
	        : new Server(object.servers[i].host, object.servers[i].port, _server_options);
	
	    var connectFunction = function(__server) {
	      // Attempt connect
	      new Db(object.dbName, __server, {w:1, native_parser:false, promiseLibrary:options.promiseLibrary}).open(function(err, db) {
	        // Update number of servers
	        totalNumberOfServers = totalNumberOfServers - 1;
	
	        // If no error do the correct checks
	        if(!err) {
	          // Close the connection
	          db.close();
	          // Get the last ismaster document
	          var isMasterDoc = db.serverConfig.isMasterDoc;
	
	          // Check what type of server we have
	          if(isMasterDoc.setName) {
	            totalNumberOfMongodServers++;
	          }
	
	          if(isMasterDoc.msg && isMasterDoc.msg == "isdbgrid") totalNumberOfMongosServers++;
	        } else {
	          error = err;
	          errorServers[__server.host + ":" + __server.port] = __server;
	        }
	
	        if(totalNumberOfServers == 0) {
	          // Error out
	          if(totalNumberOfMongodServers == 0 && totalNumberOfMongosServers == 0 && error) {
	            return callback(error, null);
	          }
	
	          // If we have a mix of mongod and mongos, throw an error
	          if(totalNumberOfMongosServers > 0 && totalNumberOfMongodServers > 0) {
	            if(db) db.close();
	            return process.nextTick(function() {
	              try {
	                callback(new Error("cannot combine a list of replicaset seeds and mongos seeds"));
	              } catch (err) {
	                throw err
	              }
	            })
	          }
	
	          if(totalNumberOfMongodServers == 0
	            && totalNumberOfMongosServers == 0
	            && object.servers.length == 1
	            && (!object.rs_options.replicaSet || !object.rs_options.rs_name)) {
	
	            var obj = object.servers[0];
	            serverConfig = obj.domain_socket ?
	                new Server(obj.domain_socket, object.server_options)
	              : new Server(obj.host, obj.port, object.server_options);
	
	          } else if(totalNumberOfMongodServers > 0
	            || totalNumberOfMongosServers > 0
	            || object.rs_options.replicaSet || object.rs_options.rs_name) {
	
	            var finalServers = object.servers
	              .filter(function(serverObj) {
	                return errorServers[serverObj.host + ":" + serverObj.port] == null;
	              })
	              .map(function(serverObj) {
	                return serverObj.domain_socket ?
	                  new Server(serverObj.domain_socket, 27017, object.server_options)
	                : new Server(serverObj.host, serverObj.port, object.server_options);
	              });
	
	            // Clean out any error servers
	            errorServers = {};
	
	            // Set up the final configuration
	            if(totalNumberOfMongodServers > 0) {
	              try {
	
	                // If no replicaset name was provided, we wish to perform a
	                // direct connection
	                if(totalNumberOfMongodServers == 1
	                  && (!object.rs_options.replicaSet && !object.rs_options.rs_name)) {
	                  serverConfig = finalServers[0];
	                } else if(totalNumberOfMongodServers == 1) {
	                  object.rs_options.replicaSet = object.rs_options.replicaSet || object.rs_options.rs_name;
	                  serverConfig = new ReplSet(finalServers, object.rs_options);
	                } else {
	                  serverConfig = new ReplSet(finalServers, object.rs_options);
	                }
	
	              } catch(err) {
	                return callback(err, null);
	              }
	            } else {
	              serverConfig = new Mongos(finalServers, object.mongos_options);
	            }
	          }
	
	          if(serverConfig == null) {
	            return process.nextTick(function() {
	              try {
	                callback(new Error("Could not locate any valid servers in initial seed list"));
	              } catch (err) {
	                if(db) db.close();
	                throw err
	              }
	            });
	          }
	
	          // Ensure no firing of open event before we are ready
	          serverConfig.emitOpen = false;
	          // Set up all options etc and connect to the database
	          _finishConnecting(serverConfig, object, options, callback)
	        }
	      });
	    }
	
	    // Wrap the context of the call
	    connectFunction(_server);
	  }
	}
	
	var _setNativeParser = function(db_options) {
	  if(typeof db_options.native_parser == 'boolean') return db_options.native_parser;
	
	  try {
	    __webpack_require__(156).BSON.BSONNative.BSON;
	    return true;
	  } catch(err) {
	    return false;
	  }
	}
	
	var _finishConnecting = function(serverConfig, object, options, callback) {
	  // If we have a readPreference passed in by the db options
	  if(typeof object.db_options.readPreference == 'string') {
	    object.db_options.readPreference = new ReadPreference(object.db_options.readPreference);
	  } else if(typeof object.db_options.read_preference == 'string') {
	    object.db_options.readPreference = new ReadPreference(object.db_options.read_preference);
	  }
	
	  // Do we have readPreference tags
	  if(object.db_options.readPreference && object.db_options.readPreferenceTags) {
	    object.db_options.readPreference.tags = object.db_options.readPreferenceTags;
	  } else if(object.db_options.readPreference && object.db_options.read_preference_tags) {
	    object.db_options.readPreference.tags = object.db_options.read_preference_tags;
	  }
	
	  // Get the socketTimeoutMS
	  var socketTimeoutMS = object.server_options.socketOptions.socketTimeoutMS || 0;
	
	  // If we have a replset, override with replicaset socket timeout option if available
	  if(serverConfig instanceof ReplSet) {
	    socketTimeoutMS = object.rs_options.socketOptions.socketTimeoutMS || socketTimeoutMS;
	  }
	
	  // Set socketTimeout to the same as the connectTimeoutMS or 30 sec
	  serverConfig.connectTimeoutMS = serverConfig.connectTimeoutMS || 30000;
	  serverConfig.socketTimeoutMS = serverConfig.connectTimeoutMS;
	
	  // Set up the db options
	  var db = new Db(object.dbName, serverConfig, object.db_options);
	  // Open the db
	  db.open(function(err, db){
	
	    if(err) {
	      return process.nextTick(function() {
	        try {
	          callback(err, null);
	        } catch (err) {
	          if(db) db.close();
	          throw err
	        }
	      });
	    }
	
	    // Reset the socket timeout
	    serverConfig.socketTimeoutMS = socketTimeoutMS || 0;
	
	    // Return object
	    if(err == null && object.auth){
	      // What db to authenticate against
	      var authentication_db = db;
	      if(object.db_options && object.db_options.authSource) {
	        authentication_db = db.db(object.db_options.authSource);
	      }
	
	      // Build options object
	      var options = {};
	      // Ensure we pass in the correct authentication options
	      if(object.db_options.authMechanism) options.authMechanism = object.db_options.authMechanism;
	      if(object.db_options.gssapiServiceName) options.gssapiServiceName = object.db_options.gssapiServiceName;
	      if(object.db_options.gssapiServiceRealm) options.gssapiServiceRealm = object.db_options.gssapiServiceRealm;
	      if(object.db_options.gssapiCanonicalizeHostName) options.gssapiCanonicalizeHostName = object.db_options.gssapiCanonicalizeHostName;
	
	      // Authenticate
	      authentication_db.authenticate(object.auth.user, object.auth.password, options, function(err, success){
	        if(success){
	          process.nextTick(function() {
	            try {
	              callback(null, db);
	            } catch (err) {
	              if(db) db.close();
	              throw err
	            }
	          });
	        } else {
	          if(db) db.close();
	          process.nextTick(function() {
	            try {
	              callback(err ? err : new Error('Could not authenticate user ' + object.auth[0]), null);
	            } catch (err) {
	              if(db) db.close();
	              throw err
	            }
	          });
	        }
	      });
	    } else {
	      process.nextTick(function() {
	        try {
	          callback(err, db);
	        } catch (err) {
	          if(db) db.close();
	          throw err
	        }
	      })
	    }
	  });
	}
	
	module.exports = MongoClient
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(6)))

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var ReadPreference = __webpack_require__(195),
	  parser = __webpack_require__(32),
	  f = __webpack_require__(77).format;
	
	module.exports = function(url, options) {
	  // Ensure we have a default options object if none set
	  options = options || {};
	  // Variables
	  var connection_part = '';
	  var auth_part = '';
	  var query_string_part = '';
	  var dbName = 'admin';
	
	  // Url parser result
	  var result = parser.parse(url, true);
	
	  if(result.protocol != 'mongodb:') {
	    throw new Error('invalid schema, expected mongodb');
	  }
	
	  if((result.hostname == null || result.hostname == '') && url.indexOf('.sock') == -1) {
	    throw new Error('no hostname or hostnames provided in connection string');
	  }
	
	  if(result.port == '0') {
	    throw new Error('invalid port (zero) with hostname');
	  }
	
	  if(!isNaN(parseInt(result.port, 10)) && parseInt(result.port, 10) > 65535) {
	    throw new Error('invalid port (larger than 65535) with hostname');
	  }
	
	  if(result.path
	    && result.path.length > 0
	    && result.path[0] != '/'
	    && url.indexOf('.sock') == -1) {
	    throw new Error('missing delimiting slash between hosts and options');
	  }
	
	  if(result.query) {
	    for(var name in result.query) {
	      if(name.indexOf('::') != -1) {
	        throw new Error('double colon in host identifier');
	      }
	
	      if(result.query[name] == '') {
	        throw new Error('query parameter ' + name + ' is an incomplete value pair');
	      }
	    }
	  }
	
	  if(result.auth) {
	    var parts = result.auth.split(':');
	    if(url.indexOf(result.auth) != -1 && parts.length > 2) {
	      throw new Error('Username with password containing an unescaped colon');
	    }
	
	    if(url.indexOf(result.auth) != -1 && result.auth.indexOf('@') != -1) {
	      throw new Error('Username containing an unescaped at-sign');
	    }
	  }
	
	  // Remove query
	  var clean = url.split('?').shift();
	
	  // Extract the list of hosts
	  var strings = clean.split(',');
	  var hosts = [];
	
	  for(var i = 0; i < strings.length; i++) {
	    var hostString = strings[i];
	
	    if(hostString.indexOf('mongodb') != -1) {
	      if(hostString.indexOf('@') != -1) {
	        hosts.push(hostString.split('@').pop())
	      } else {
	        hosts.push(hostString.substr('mongodb://'.length));
	      }
	    } else if(hostString.indexOf('/') != -1) {
	      hosts.push(hostString.split('/').shift());
	    } else if(hostString.indexOf('/') == -1) {
	      hosts.push(hostString.trim());
	    }
	  }
	
	  for(var i = 0; i < hosts.length; i++) {
	    var r = parser.parse(f('mongodb://%s', hosts[i].trim()));
	    if(r.path && r.path.indexOf(':') != -1) {
	      throw new Error('double colon in host identifier');
	    }
	  }
	
	  // If we have a ? mark cut the query elements off
	  if(url.indexOf("?") != -1) {
	    query_string_part = url.substr(url.indexOf("?") + 1);
	    connection_part = url.substring("mongodb://".length, url.indexOf("?"))
	  } else {
	    connection_part = url.substring("mongodb://".length);
	  }
	
	  // Check if we have auth params
	  if(connection_part.indexOf("@") != -1) {
	    auth_part = connection_part.split("@")[0];
	    connection_part = connection_part.split("@")[1];
	  }
	
	  // Check if the connection string has a db
	  if(connection_part.indexOf(".sock") != -1) {
	    if(connection_part.indexOf(".sock/") != -1) {
	      dbName = connection_part.split(".sock/")[1];
	      // Check if multiple database names provided, or just an illegal trailing backslash
	      if (dbName.indexOf("/") != -1) {
	        if (dbName.split("/").length == 2 && dbName.split("/")[1].length == 0) {
	          throw new Error('Illegal trailing backslash after database name');
	        }
	        throw new Error('More than 1 database name in URL');
	      }
	      connection_part = connection_part.split("/", connection_part.indexOf(".sock") + ".sock".length);
	    }
	  } else if(connection_part.indexOf("/") != -1) {
	    // Check if multiple database names provided, or just an illegal trailing backslash
	    if (connection_part.split("/").length > 2) {
	      if (connection_part.split("/")[2].length == 0) {
	        throw new Error('Illegal trailing backslash after database name');
	      }
	      throw new Error('More than 1 database name in URL');
	    }
	    dbName = connection_part.split("/")[1];
	    connection_part = connection_part.split("/")[0];
	  }
	
	  // Result object
	  var object = {};
	
	  // Pick apart the authentication part of the string
	  var authPart = auth_part || '';
	  var auth = authPart.split(':', 2);
	
	  // Decode the URI components
	  auth[0] = decodeURIComponent(auth[0]);
	  if(auth[1]){
	    auth[1] = decodeURIComponent(auth[1]);
	  }
	
	  // Add auth to final object if we have 2 elements
	  if(auth.length == 2) object.auth = {user: auth[0], password: auth[1]};
	
	  // Variables used for temporary storage
	  var hostPart;
	  var urlOptions;
	  var servers;
	  var serverOptions = {socketOptions: {}};
	  var dbOptions = {read_preference_tags: []};
	  var replSetServersOptions = {socketOptions: {}};
	  var mongosOptions = {socketOptions: {}};
	  // Add server options to final object
	  object.server_options = serverOptions;
	  object.db_options = dbOptions;
	  object.rs_options = replSetServersOptions;
	  object.mongos_options = mongosOptions;
	
	  // Let's check if we are using a domain socket
	  if(url.match(/\.sock/)) {
	    // Split out the socket part
	    var domainSocket = url.substring(
	        url.indexOf("mongodb://") + "mongodb://".length
	      , url.lastIndexOf(".sock") + ".sock".length);
	    // Clean out any auth stuff if any
	    if(domainSocket.indexOf("@") != -1) domainSocket = domainSocket.split("@")[1];
	    servers = [{domain_socket: domainSocket}];
	  } else {
	    // Split up the db
	    hostPart = connection_part;
	    // Deduplicate servers
	    var deduplicatedServers = {};
	
	    // Parse all server results
	    servers = hostPart.split(',').map(function(h) {
	      var _host, _port, ipv6match;
	      //check if it matches [IPv6]:port, where the port number is optional
	      if ((ipv6match = /\[([^\]]+)\](?:\:(.+))?/.exec(h))) {
	        _host = ipv6match[1];
	        _port = parseInt(ipv6match[2], 10) || 27017;
	      } else {
	        //otherwise assume it's IPv4, or plain hostname
	        var hostPort = h.split(':', 2);
	        _host = hostPort[0] || 'localhost';
	        _port = hostPort[1] != null ? parseInt(hostPort[1], 10) : 27017;
	        // Check for localhost?safe=true style case
	        if(_host.indexOf("?") != -1) _host = _host.split(/\?/)[0];
	      }
	
	      // No entry returned for duplicate servr
	      if(deduplicatedServers[_host + "_" + _port]) return null;
	      deduplicatedServers[_host + "_" + _port] = 1;
	
	      // Return the mapped object
	      return {host: _host, port: _port};
	    }).filter(function(x) {
	      return x != null;
	    });
	  }
	
	  // Get the db name
	  object.dbName = dbName || 'admin';
	  // Split up all the options
	  urlOptions = (query_string_part || '').split(/[&;]/);
	  // Ugh, we have to figure out which options go to which constructor manually.
	  urlOptions.forEach(function(opt) {
	    if(!opt) return;
	    var splitOpt = opt.split('='), name = splitOpt[0], value = splitOpt[1];
	    // Options implementations
	    switch(name) {
	      case 'slaveOk':
	      case 'slave_ok':
	        serverOptions.slave_ok = (value == 'true');
	        dbOptions.slaveOk = (value == 'true');
	        break;
	      case 'maxPoolSize':
	      case 'poolSize':
	        serverOptions.poolSize = parseInt(value, 10);
	        replSetServersOptions.poolSize = parseInt(value, 10);
	        break;
	      case 'autoReconnect':
	      case 'auto_reconnect':
	        serverOptions.auto_reconnect = (value == 'true');
	        break;
	      case 'minPoolSize':
	        throw new Error("minPoolSize not supported");
	      case 'maxIdleTimeMS':
	        throw new Error("maxIdleTimeMS not supported");
	      case 'waitQueueMultiple':
	        throw new Error("waitQueueMultiple not supported");
	      case 'waitQueueTimeoutMS':
	        throw new Error("waitQueueTimeoutMS not supported");
	      case 'uuidRepresentation':
	        throw new Error("uuidRepresentation not supported");
	      case 'ssl':
	        if(value == 'prefer') {
	          serverOptions.ssl = value;
	          replSetServersOptions.ssl = value;
	          mongosOptions.ssl = value;
	          break;
	        }
	        serverOptions.ssl = (value == 'true');
	        replSetServersOptions.ssl = (value == 'true');
	        mongosOptions.ssl = (value == 'true');
	        break;
	      case 'sslValidate':
	        serverOptions.sslValidate = (value == 'true');
	        replSetServersOptions.sslValidate = (value == 'true');
	        mongosOptions.sslValidate = (value == 'true');
	        break;
	      case 'replicaSet':
	      case 'rs_name':
	        replSetServersOptions.rs_name = value;
	        break;
	      case 'reconnectWait':
	        replSetServersOptions.reconnectWait = parseInt(value, 10);
	        break;
	      case 'retries':
	        replSetServersOptions.retries = parseInt(value, 10);
	        break;
	      case 'readSecondary':
	      case 'read_secondary':
	        replSetServersOptions.read_secondary = (value == 'true');
	        break;
	      case 'fsync':
	        dbOptions.fsync = (value == 'true');
	        break;
	      case 'journal':
	        dbOptions.j = (value == 'true');
	        break;
	      case 'safe':
	        dbOptions.safe = (value == 'true');
	        break;
	      case 'nativeParser':
	      case 'native_parser':
	        dbOptions.native_parser = (value == 'true');
	        break;
	      case 'readConcernLevel':
	        dbOptions.readConcern = {level: value};
	        break;
	      case 'connectTimeoutMS':
	        serverOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
	        replSetServersOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
	        mongosOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
	        break;
	      case 'socketTimeoutMS':
	        serverOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
	        replSetServersOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
	        mongosOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
	        break;
	      case 'w':
	        dbOptions.w = parseInt(value, 10);
	        if(isNaN(dbOptions.w)) dbOptions.w = value;
	        break;
	      case 'authSource':
	        dbOptions.authSource = value;
	        break;
	      case 'gssapiServiceName':
	        dbOptions.gssapiServiceName = value;
	        break;
	      case 'authMechanism':
	        if(value == 'GSSAPI') {
	          // If no password provided decode only the principal
	          if(object.auth == null) {
	            var urlDecodeAuthPart = decodeURIComponent(authPart);
	            if(urlDecodeAuthPart.indexOf("@") == -1) throw new Error("GSSAPI requires a provided principal");
	            object.auth = {user: urlDecodeAuthPart, password: null};
	          } else {
	            object.auth.user = decodeURIComponent(object.auth.user);
	          }
	        } else if(value == 'MONGODB-X509') {
	          object.auth = {user: decodeURIComponent(authPart)};
	        }
	
	        // Only support GSSAPI or MONGODB-CR for now
	        if(value != 'GSSAPI'
	          && value != 'MONGODB-X509'
	          && value != 'MONGODB-CR'
	          && value != 'DEFAULT'
	          && value != 'SCRAM-SHA-1'
	          && value != 'PLAIN')
	            throw new Error("only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, SCRAM-SHA-1 or MONGODB-CR is supported by authMechanism");
	
	        // Authentication mechanism
	        dbOptions.authMechanism = value;
	        break;
	      case 'authMechanismProperties':
	        // Split up into key, value pairs
	        var values = value.split(',');
	        var o = {};
	        // For each value split into key, value
	        values.forEach(function(x) {
	          var v = x.split(':');
	          o[v[0]] = v[1];
	        });
	
	        // Set all authMechanismProperties
	        dbOptions.authMechanismProperties = o;
	        // Set the service name value
	        if(typeof o.SERVICE_NAME == 'string') dbOptions.gssapiServiceName = o.SERVICE_NAME;
	        if(typeof o.SERVICE_REALM == 'string') dbOptions.gssapiServiceRealm = o.SERVICE_REALM;
	        if(typeof o.CANONICALIZE_HOST_NAME == 'string') dbOptions.gssapiCanonicalizeHostName = o.CANONICALIZE_HOST_NAME == 'true' ? true : false;
	        break;
	      case 'wtimeoutMS':
	        dbOptions.wtimeout = parseInt(value, 10);
	        break;
	      case 'readPreference':
	        if(!ReadPreference.isValid(value)) throw new Error("readPreference must be either primary/primaryPreferred/secondary/secondaryPreferred/nearest");
	        dbOptions.readPreference = value;
	        break;
	      case 'readPreferenceTags':
	        // Decode the value
	        value = decodeURIComponent(value);
	        // Contains the tag object
	        var tagObject = {};
	        if(value == null || value == '') {
	          dbOptions.read_preference_tags.push(tagObject);
	          break;
	        }
	
	        // Split up the tags
	        var tags = value.split(/\,/);
	        for(var i = 0; i < tags.length; i++) {
	          var parts = tags[i].trim().split(/\:/);
	          tagObject[parts[0]] = parts[1];
	        }
	
	        // Set the preferences tags
	        dbOptions.read_preference_tags.push(tagObject);
	        break;
	      default:
	        break;
	    }
	  });
	
	  // No tags: should be null (not [])
	  if(dbOptions.read_preference_tags.length === 0) {
	    dbOptions.read_preference_tags = null;
	  }
	
	  // Validate if there are an invalid write concern combinations
	  if((dbOptions.w == -1 || dbOptions.w == 0) && (
	      dbOptions.journal == true
	      || dbOptions.fsync == true
	      || dbOptions.safe == true)) throw new Error("w set to -1 or 0 cannot be combined with safe/w/journal/fsync")
	
	  // If no read preference set it to primary
	  if(!dbOptions.readPreference) {
	    dbOptions.readPreference = 'primary';
	  }
	
	  // Add servers to result
	  object.servers = servers;
	  // Returned parsed object
	  return object;
	}


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var Emitter = __webpack_require__(3).EventEmitter;
	var GridFSBucketReadStream = __webpack_require__(217);
	var GridFSBucketWriteStream = __webpack_require__(218);
	var shallowClone = __webpack_require__(194).shallowClone;
	var toError = __webpack_require__(194).toError;
	var util = __webpack_require__(77);
	
	var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
	  bucketName: 'fs',
	  chunkSizeBytes: 255 * 1024
	};
	
	module.exports = GridFSBucket;
	
	/**
	 * Constructor for a streaming GridFS interface
	 * @class
	 * @param {Db} db A db handle
	 * @param {object} [options=null] Optional settings.
	 * @param {string} [options.bucketName="fs"] The 'files' and 'chunks' collections will be prefixed with the bucket name followed by a dot.
	 * @param {number} [options.chunkSizeBytes=255 * 1024] Number of bytes stored in each chunk. Defaults to 255KB
	 * @param {object} [options.writeConcern=null] Optional write concern to be passed to write operations, for instance `{ w: 1 }`
	 * @param {object} [options.readPreference=null] Optional read preference to be passed to read operations
	 * @fires GridFSBucketWriteStream#index
	 * @return {GridFSBucket}
	 */
	
	function GridFSBucket(db, options) {
	  Emitter.apply(this);
	  this.setMaxListeners(0);
	
	  if (options && typeof options === 'object') {
	    options = shallowClone(options);
	    var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);
	    for (var i = 0; i < keys.length; ++i) {
	      if (!options[keys[i]]) {
	        options[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];
	      }
	    }
	  } else {
	    options = DEFAULT_GRIDFS_BUCKET_OPTIONS;
	  }
	
	  this.s = {
	    db: db,
	    options: options,
	    _chunksCollection: db.collection(options.bucketName + '.chunks'),
	    _filesCollection: db.collection(options.bucketName + '.files'),
	    checkedIndexes: false,
	    calledOpenUploadStream: false,
	    promiseLibrary: db.s.promiseLibrary ||
	      (typeof global.Promise == 'function' ? global.Promise : __webpack_require__(198).Promise)
	  };
	};
	
	util.inherits(GridFSBucket, Emitter);
	
	/**
	 * When the first call to openUploadStream is made, the upload stream will
	 * check to see if it needs to create the proper indexes on the chunks and
	 * files collections. This event is fired either when 1) it determines that
	 * no index creation is necessary, 2) when it successfully creates the
	 * necessary indexes.
	 *
	 * @event GridFSBucket#index
	 * @type {Error}
	 */
	
	/**
	 * Returns a writable stream (GridFSBucketWriteStream) for writing
	 * buffers to GridFS. The stream's 'id' property contains the resulting
	 * file's id.
	 * @method
	 * @param {string} filename The value of the 'filename' key in the files doc
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.chunkSizeBytes=null] Optional overwrite this bucket's chunkSizeBytes for this file
	 * @param {object} [options.metadata=null] Optional object to store in the file document's `metadata` field
	 * @param {string} [options.contentType=null] Optional string to store in the file document's `contentType` field
	 * @param {array} [options.aliases=null] Optional array of strings to store in the file document's `aliases` field
	 * @return {GridFSBucketWriteStream}
	 */
	
	GridFSBucket.prototype.openUploadStream = function(filename, options) {
	  if (options) {
	    options = shallowClone(options);
	  } else {
	    options = {};
	  }
	  if (!options.chunkSizeBytes) {
	    options.chunkSizeBytes = this.s.options.chunkSizeBytes;
	  }
	  return new GridFSBucketWriteStream(this, filename, options);
	};
	
	/**
	 * Returns a readable stream (GridFSBucketReadStream) for streaming file
	 * data from GridFS.
	 * @method
	 * @param {ObjectId} id The id of the file doc
	 * @param {Object} [options=null] Optional settings.
	 * @param {Number} [options.start=null] Optional 0-based offset in bytes to start streaming from
	 * @param {Number} [options.end=null] Optional 0-based offset in bytes to stop streaming before
	 * @return {GridFSBucketReadStream}
	 */
	
	GridFSBucket.prototype.openDownloadStream = function(id, options) {
	  var filter = { _id: id };
	  var options = {
	    start: options && options.start,
	    end: options && options.end
	  };
	  return new GridFSBucketReadStream(this.s._chunksCollection,
	    this.s._filesCollection, this.s.options.readPreference, filter, options);
	};
	
	/**
	 * Deletes a file with the given id
	 * @method
	 * @param {ObjectId} id The id of the file doc
	 * @param {GridFSBucket~errorCallback} [callback]
	 */
	
	GridFSBucket.prototype.delete = function(id, callback) {
	  if (typeof callback === 'function') {
	    return _delete(this, id, callback);
	  }
	
	  var _this = this;
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    _delete(_this, id, function(error, res) {
	      if (error) {
	        reject(error);
	      } else {
	        resolve(res);
	      }
	    });
	  });
	};
	
	/**
	 * @ignore
	 */
	
	function _delete(_this, id, callback) {
	  _this.s._filesCollection.deleteOne({ _id: id }, function(error, res) {
	    if (error) {
	      return callback(error);
	    }
	
	    _this.s._chunksCollection.deleteMany({ files_id: id }, function(error) {
	      if (error) {
	        return callback(error);
	      }
	
	      // Delete orphaned chunks before returning FileNotFound
	      if (!res.result.n) {
	        var errmsg = 'FileNotFound: no file with id ' + id + ' found';
	        return callback(new Error(errmsg));
	      }
	
	      callback();
	    });
	  });
	}
	
	/**
	 * Convenience wrapper around find on the files collection
	 * @method
	 * @param {Object} filter
	 * @param {Object} [options=null] Optional settings for cursor
	 * @param {number} [options.batchSize=null] Optional batch size for cursor
	 * @param {number} [options.limit=null] Optional limit for cursor
	 * @param {number} [options.maxTimeMS=null] Optional maxTimeMS for cursor
	 * @param {boolean} [options.noCursorTimeout=null] Optionally set cursor's `noCursorTimeout` flag
	 * @param {number} [options.skip=null] Optional skip for cursor
	 * @param {object} [options.sort=null] Optional sort for cursor
	 * @return {Cursor}
	 */
	
	GridFSBucket.prototype.find = function(filter, options) {
	  filter = filter || {};
	  options = options || {};
	
	  var cursor = this.s._filesCollection.find(filter);
	
	  if (options.batchSize != null) {
	    cursor.batchSize(options.batchSize);
	  }
	  if (options.limit != null) {
	    cursor.limit(options.limit);
	  }
	  if (options.maxTimeMS != null) {
	    cursor.maxTimeMS(options.maxTimeMS);
	  }
	  if (options.noCursorTimeout != null) {
	    cursor.addCursorFlag('noCursorTimeout', options.noCursorTimeout);
	  }
	  if (options.skip != null) {
	    cursor.skip(options.skip);
	  }
	  if (options.sort != null) {
	    cursor.sort(options.sort);
	  }
	
	  return cursor;
	};
	
	/**
	 * Returns a readable stream (GridFSBucketReadStream) for streaming the
	 * file with the given name from GridFS. If there are multiple files with
	 * the same name, this will stream the most recent file with the given name
	 * (as determined by the `uploadDate` field). You can set the `revision`
	 * option to change this behavior.
	 * @method
	 * @param {String} filename The name of the file to stream
	 * @param {Object} [options=null] Optional settings
	 * @param {number} [options.revision=-1] The revision number relative to the oldest file with the given filename. 0 gets you the oldest file, 1 gets you the 2nd oldest, -1 gets you the newest.
	 * @param {Number} [options.start=null] Optional 0-based offset in bytes to start streaming from
	 * @param {Number} [options.end=null] Optional 0-based offset in bytes to stop streaming before
	 * @return {GridFSBucketReadStream}
	 */
	
	GridFSBucket.prototype.openDownloadStreamByName = function(filename, options) {
	  var sort = { uploadDate: -1 };
	  var skip = null;
	  if (options && options.revision != null) {
	    if (options.revision >= 0) {
	      sort = { uploadDate: 1 };
	      skip = options.revision;
	    } else {
	      skip = -options.revision - 1;
	    }
	  }
	
	  var filter = { filename: filename };
	  var options = {
	    sort: sort,
	    skip: skip,
	    start: options && options.start,
	    end: options && options.end
	  };
	  return new GridFSBucketReadStream(this.s._chunksCollection,
	    this.s._filesCollection, this.s.options.readPreference, filter, options);
	};
	
	/**
	 * Renames the file with the given _id to the given string
	 * @method
	 * @param {ObjectId} id the id of the file to rename
	 * @param {String} filename new name for the file
	 * @param {GridFSBucket~errorCallback} [callback]
	 */
	
	GridFSBucket.prototype.rename = function(id, filename, callback) {
	  if (typeof callback === 'function') {
	    return _rename(this, id, filename, callback);
	  }
	
	  var _this = this;
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    _rename(_this, id, filename, function(error, res) {
	      if (error) {
	        reject(error);
	      } else {
	        resolve(res);
	      }
	    });
	  });
	};
	
	/**
	 * @ignore
	 */
	
	function _rename(_this, id, filename, callback) {
	  var filter = { _id: id };
	  var update = { $set: { filename: filename } };
	  _this.s._filesCollection.updateOne(filter, update, function(error, res) {
	    if (error) {
	      return callback(error);
	    }
	    if (!res.result.n) {
	      return callback(toError('File with id ' + id + ' not found'));
	    }
	    callback();
	  });
	}
	
	/**
	 * Removes this bucket's files collection, followed by its chunks collection.
	 * @method
	 * @param {GridFSBucket~errorCallback} [callback]
	 */
	
	GridFSBucket.prototype.drop = function(callback) {
	  if (typeof callback === 'function') {
	    return _drop(this, callback);
	  }
	
	  var _this = this;
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    _drop(_this, function(error, res) {
	      if (error) {
	        reject(error);
	      } else {
	        resolve(res);
	      }
	    });
	  });
	};
	
	/**
	 * @ignore
	 */
	
	function _drop(_this, callback) {
	  _this.s._filesCollection.drop(function(error) {
	    if (error) {
	      return callback(error);
	    }
	    _this.s._chunksCollection.drop(function(error) {
	      if (error) {
	        return callback(error);
	      }
	
	      return callback();
	    });
	  });
	}
	
	/**
	 * Callback format for all GridFSBucket methods that can accept a callback.
	 * @callback GridFSBucket~errorCallback
	 * @param {MongoError} error An error instance representing any errors that occurred
	 */
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var shallowClone = __webpack_require__(194).shallowClone;
	var stream = __webpack_require__(54);
	var util = __webpack_require__(77);
	
	module.exports = GridFSBucketReadStream;
	
	/**
	 * A readable stream that enables you to read buffers from GridFS.
	 *
	 * Do not instantiate this class directly. Use `openDownloadStream()` instead.
	 *
	 * @class
	 * @param {Collection} chunks Handle for chunks collection
	 * @param {Collection} files Handle for files collection
	 * @param {Object} readPreference The read preference to use
	 * @param {Object} filter The query to use to find the file document
	 * @param {Object} [options=null] Optional settings.
	 * @param {Number} [options.sort=null] Optional sort for the file find query
	 * @param {Number} [options.skip=null] Optional skip for the file find query
	 * @param {Number} [options.start=null] Optional 0-based offset in bytes to start streaming from
	 * @param {Number} [options.end=null] Optional 0-based offset in bytes to stop streaming before
	 * @fires GridFSBucketReadStream#error
	 * @fires GridFSBucketReadStream#file
	 * @return {GridFSBucketReadStream} a GridFSBucketReadStream instance.
	 */
	
	function GridFSBucketReadStream(chunks, files, readPreference, filter, options) {
	  var _this = this;
	  this.s = {
	    bytesRead: 0,
	    chunks: chunks,
	    cursor: null,
	    expected: 0,
	    files: files,
	    filter: filter,
	    init: false,
	    expectedEnd: 0,
	    file: null,
	    options: options,
	    readPreference: readPreference
	  };
	
	  stream.Readable.call(this);
	}
	
	util.inherits(GridFSBucketReadStream, stream.Readable);
	
	/**
	 * An error occurred
	 *
	 * @event GridFSBucketReadStream#error
	 * @type {Error}
	 */
	
	/**
	 * Fires when the stream loaded the file document corresponding to the
	 * provided id.
	 *
	 * @event GridFSBucketReadStream#file
	 * @type {object}
	 */
	
	/**
	 * Emitted when a chunk of data is available to be consumed.
	 *
	 * @event GridFSBucketReadStream#data
	 * @type {object}
	 */
	
	/**
	 * Fired when the stream is exhausted (no more data events).
	 *
	 * @event GridFSBucketReadStream#end
	 * @type {object}
	 */
	
	/**
	 * Fired when the stream is exhausted and the underlying cursor is killed
	 *
	 * @event GridFSBucketReadStream#close
	 * @type {object}
	 */
	
	/**
	 * Reads from the cursor and pushes to the stream.
	 * @method
	 */
	
	GridFSBucketReadStream.prototype._read = function() {
	  var _this = this;
	  if (this.destroyed) {
	    return;
	  }
	  waitForFile(_this, function() {
	    doRead(_this);
	  });
	};
	
	/**
	 * Sets the 0-based offset in bytes to start streaming from. Throws
	 * an error if this stream has entered flowing mode
	 * (e.g. if you've already called `on('data')`)
	 * @method
	 * @param {Number} start Offset in bytes to start reading at
	 * @return {GridFSBucketReadStream}
	 */
	
	GridFSBucketReadStream.prototype.start = function(start) {
	  throwIfInitialized(this);
	  this.s.options.start = start;
	  return this;
	};
	
	/**
	 * Sets the 0-based offset in bytes to start streaming from. Throws
	 * an error if this stream has entered flowing mode
	 * (e.g. if you've already called `on('data')`)
	 * @method
	 * @param {Number} end Offset in bytes to stop reading at
	 * @return {GridFSBucketReadStream}
	 */
	
	GridFSBucketReadStream.prototype.end = function(end) {
	  throwIfInitialized(this);
	  this.s.options.end = end;
	  return this;
	};
	
	/**
	 * Marks this stream as aborted (will never push another `data` event)
	 * and kills the underlying cursor. Will emit the 'end' event, and then
	 * the 'close' event once the cursor is successfully killed.
	 *
	 * @method
	 * @param {GridFSBucket~errorCallback} [callback] called when the cursor is successfully closed or an error occurred.
	 * @fires GridFSBucketWriteStream#close
	 * @fires GridFSBucketWriteStream#end
	 */
	
	GridFSBucketReadStream.prototype.abort = function(callback) {
	  var _this = this;
	  this.push(null);
	  this.destroyed = true;
	  if (this.s.cursor) {
	    this.s.cursor.close(function(error) {
	      _this.emit('close');
	      callback && callback(error);
	    });
	  } else {
	    if (!this.s.init) {
	      // If not initialized, fire close event because we will never
	      // get a cursor
	      _this.emit('close');
	    }
	    callback && callback();
	  }
	};
	
	/**
	 * @ignore
	 */
	
	function throwIfInitialized(self) {
	  if (self.s.init) {
	    throw new Error('You cannot change options after the stream has entered' +
	      'flowing mode!');
	  }
	}
	
	/**
	 * @ignore
	 */
	
	function doRead(_this) {
	  if (_this.destroyed) {
	    return;
	  }
	
	  _this.s.cursor.next(function(error, doc) {
	    if (_this.destroyed) {
	      return;
	    }
	    if (error) {
	      return __handleError(_this, error);
	    }
	    if (!doc) {
	      _this.push(null);
	      return _this.s.cursor.close(function(error) {
	        if (error) {
	          return __handleError(_this, error);
	        }
	        _this.emit('close');
	      });
	    }
	
	    var bytesRemaining = _this.s.file.length - _this.s.bytesRead;
	    var expectedN = _this.s.expected++;
	    var expectedLength = Math.min(_this.s.file.chunkSize,
	      bytesRemaining);
	    if (doc.n > expectedN) {
	      var errmsg = 'ChunkIsMissing: Got unexpected n: ' + doc.n +
	        ', expected: ' + expectedN;
	      return __handleError(_this, new Error(errmsg));
	    }
	    if (doc.n < expectedN) {
	      var errmsg = 'ExtraChunk: Got unexpected n: ' + doc.n +
	        ', expected: ' + expectedN;
	      return __handleError(_this, new Error(errmsg));
	    }
	    if (doc.data.length() !== expectedLength) {
	      if (bytesRemaining <= 0) {
	        var errmsg = 'ExtraChunk: Got unexpected n: ' + doc.n;
	        return __handleError(_this, new Error(errmsg));
	      }
	      var errmsg = 'ChunkIsWrongSize: Got unexpected length: ' +
	        doc.data.length() + ', expected: ' + expectedLength;
	      return __handleError(_this, new Error(errmsg));
	    }
	
	    _this.s.bytesRead += doc.data.length();
	
	    if (doc.data.buffer.length === 0) {
	      return _this.push(null);
	    }
	
	    var sliceStart = null;
	    var sliceEnd = null;
	    var buf = doc.data.buffer;
	    if (_this.s.bytesToSkip != null) {
	      sliceStart = _this.s.bytesToSkip;
	      _this.s.bytesToSkip = 0;
	    }
	
	    if (expectedN === _this.s.expectedEnd && _this.s.bytesToTrim != null) {
	      sliceEnd = _this.s.bytesToTrim;
	    }
	
	    if (sliceStart != null || sliceEnd != null) {
	      buf = buf.slice(sliceStart || 0, sliceEnd || buf.length);
	    }
	
	    _this.push(buf);
	  });
	};
	
	/**
	 * @ignore
	 */
	
	function init(self) {
	  var findOneOptions = {};
	  if (self.s.readPreference) {
	    findOneOptions.readPreference = self.s.readPreference;
	  }
	  if (self.s.options && self.s.options.sort) {
	    findOneOptions.sort = self.s.options.sort;
	  }
	  if (self.s.options && self.s.options.skip) {
	    findOneOptions.skip = self.s.options.skip;
	  }
	
	  self.s.files.findOne(self.s.filter, findOneOptions, function(error, doc) {
	    if (error) {
	      return __handleError(self, error);
	    }
	    if (!doc) {
	      var identifier = self.s.filter._id ?
	        self.s.filter._id.toString() : self.s.filter.filename;
	      var errmsg = 'FileNotFound: file ' + identifier + ' was not found';
	      var err = new Error(errmsg);
	      err.code = 'ENOENT';
	      return __handleError(self, err);
	    }
	
	    // If document is empty, kill the stream immediately and don't
	    // execute any reads
	    if (doc.length <= 0) {
	      self.push(null);
	      return;
	    }
	
	    if (self.destroyed) {
	      // If user destroys the stream before we have a cursor, wait
	      // until the query is done to say we're 'closed' because we can't
	      // cancel a query.
	      self.emit('close');
	      return;
	    }
	
	    self.s.cursor = self.s.chunks.find({ files_id: doc._id }).sort({ n: 1 });
	    if (self.s.readPreference) {
	      self.s.cursor.setReadPreference(self.s.readPreference);
	    }
	
	    self.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
	    self.s.file = doc;
	    self.s.bytesToSkip = handleStartOption(self, doc, self.s.cursor,
	      self.s.options);
	    self.s.bytesToTrim = handleEndOption(self, doc, self.s.cursor,
	      self.s.options);
	    self.emit('file', doc);
	  });
	}
	
	/**
	 * @ignore
	 */
	
	function waitForFile(_this, callback) {
	  if (_this.s.file) {
	    return callback();
	  }
	
	  if (!_this.s.init) {
	    init(_this);
	    _this.s.init = true;
	  }
	
	  _this.once('file', function() {
	    callback();
	  });
	};
	
	/**
	 * @ignore
	 */
	
	function handleStartOption(stream, doc, cursor, options) {
	  if (options && options.start != null) {
	    if (options.start > doc.length) {
	      throw new Error('Stream start (' + options.start + ') must not be ' +
	        'more than the length of the file (' + doc.length +')')
	    }
	    if (options.start < 0) {
	      throw new Error('Stream start (' + options.start + ') must not be ' +
	        'negative');
	    }
	    if (options.end != null && options.end < options.start) {
	      throw new Error('Stream start (' + options.start + ') must not be ' +
	        'greater than stream end (' + options.end + ')');
	    }
	
	    cursor.skip(Math.floor(options.start / doc.chunkSize));
	
	    stream.s.bytesRead = Math.floor(options.start / doc.chunkSize) *
	      doc.chunkSize;
	    stream.s.expected = Math.floor(options.start / doc.chunkSize);
	
	    return options.start - stream.s.bytesRead;
	  }
	}
	
	/**
	 * @ignore
	 */
	
	function handleEndOption(stream, doc, cursor, options) {
	  if (options && options.end != null) {
	    if (options.end > doc.length) {
	      throw new Error('Stream end (' + options.end + ') must not be ' +
	        'more than the length of the file (' + doc.length +')')
	    }
	    if (options.start < 0) {
	      throw new Error('Stream end (' + options.end + ') must not be ' +
	        'negative');
	    }
	
	    var start = options.start != null ?
	      Math.floor(options.start / doc.chunkSize) :
	      0;
	
	    cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);
	
	    stream.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);
	
	    return (Math.ceil(options.end / doc.chunkSize) * doc.chunkSize) -
	      options.end;
	  }
	}
	
	/**
	 * @ignore
	 */
	
	function __handleError(_this, error) {
	  _this.emit('error', error);
	}


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var core = __webpack_require__(156);
	var crypto = __webpack_require__(70);
	var shallowClone = __webpack_require__(194).shallowClone;
	var stream = __webpack_require__(54);
	var util = __webpack_require__(77);
	
	var ERROR_NAMESPACE_NOT_FOUND = 26;
	
	module.exports = GridFSBucketWriteStream;
	
	/**
	 * A writable stream that enables you to write buffers to GridFS.
	 *
	 * Do not instantiate this class directly. Use `openUploadStream()` instead.
	 *
	 * @class
	 * @param {GridFSBucket} bucket Handle for this stream's corresponding bucket
	 * @param {string} filename The value of the 'filename' key in the files doc
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.chunkSizeBytes=null] The chunk size to use, in bytes
	 * @param {number} [options.w=null] The write concern
	 * @param {number} [options.wtimeout=null] The write concern timeout
	 * @param {number} [options.j=null] The journal write concern
	 * @fires GridFSBucketWriteStream#error
	 * @fires GridFSBucketWriteStream#finish
	 * @return {GridFSBucketWriteStream} a GridFSBucketWriteStream instance.
	 */
	
	function GridFSBucketWriteStream(bucket, filename, options) {
	  this.bucket = bucket;
	  this.chunks = bucket.s._chunksCollection;
	  this.filename = filename;
	  this.files = bucket.s._filesCollection;
	  this.options = options;
	
	  this.id = core.BSON.ObjectId();
	  this.chunkSizeBytes = this.options.chunkSizeBytes;
	  this.bufToStore = new Buffer(this.chunkSizeBytes);
	  this.length = 0;
	  this.md5 = crypto.createHash('md5');
	  this.n = 0;
	  this.pos = 0;
	  this.state = {
	    streamEnd: false,
	    outstandingRequests: 0,
	    errored: false,
	    aborted: false,
	    promiseLibrary: this.bucket.s.promiseLibrary
	  };
	
	  if (!this.bucket.s.calledOpenUploadStream) {
	    this.bucket.s.calledOpenUploadStream = true;
	
	    var _this = this;
	    checkIndexes(this, function() {
	      _this.bucket.s.checkedIndexes = true;
	      _this.bucket.emit('index');
	    });
	  }
	}
	
	util.inherits(GridFSBucketWriteStream, stream.Writable);
	
	/**
	 * An error occurred
	 *
	 * @event GridFSBucketWriteStream#error
	 * @type {Error}
	 */
	
	/**
	 * `end()` was called and the write stream successfully wrote the file
	 * metadata and all the chunks to MongoDB.
	 *
	 * @event GridFSBucketWriteStream#finish
	 * @type {object}
	 */
	
	/**
	 * Write a buffer to the stream.
	 *
	 * @method
	 * @param {Buffer} chunk Buffer to write
	 * @param {String} encoding Optional encoding for the buffer
	 * @param {Function} callback Function to call when the chunk was added to the buffer, or if the entire chunk was persisted to MongoDB if this chunk caused a flush.
	 * @return {Boolean} False if this write required flushing a chunk to MongoDB. True otherwise.
	 */
	
	GridFSBucketWriteStream.prototype.write = function(chunk, encoding, callback) {
	  var _this = this;
	  return waitForIndexes(this, function() {
	    return doWrite(_this, chunk, encoding, callback);
	  });
	};
	
	/**
	 * Places this write stream into an aborted state (all future writes fail)
	 * and deletes all chunks that have already been written.
	 *
	 * @method
	 * @param {GridFSBucket~errorCallback} callback called when chunks are successfully removed or error occurred
	 * @return {Promise} if no callback specified
	 */
	
	GridFSBucketWriteStream.prototype.abort = function(callback) {
	  if (this.state.streamEnd) {
	    var error = new Error('Cannot abort a stream that has already completed');
	    if (typeof callback == 'function') {
	      return callback(error);
	    }
	    return this.state.promiseLibrary.reject(error);
	  }
	  if (this.state.aborted) {
	    var error = new Error('Cannot call abort() on a stream twice');
	    if (typeof callback == 'function') {
	      return callback(error);
	    }
	    return this.state.promiseLibrary.reject(error);
	  }
	  this.state.aborted = true;
	  this.chunks.deleteMany({ files_id: this.id }, function(error) {
	    if(typeof callback == 'function') callback(error);
	  });
	};
	
	/**
	 * Tells the stream that no more data will be coming in. The stream will
	 * persist the remaining data to MongoDB, write the files document, and
	 * then emit a 'finish' event.
	 *
	 * @method
	 * @param {Buffer} chunk Buffer to write
	 * @param {String} encoding Optional encoding for the buffer
	 * @param {Function} callback Function to call when all files and chunks have been persisted to MongoDB
	 */
	
	GridFSBucketWriteStream.prototype.end = function(chunk, encoding, callback) {
	  if (checkAborted(this, callback)) {
	    return;
	  }
	  var _this = this;
	  this.state.streamEnd = true;
	
	  if (callback) {
	    this.once('finish', callback);
	  }
	
	  if (!chunk) {
	    waitForIndexes(this, function() {
	      writeRemnant(_this);
	    });
	    return;
	  }
	
	  var _this = this;
	  var inputBuf = (Buffer.isBuffer(chunk)) ?
	    chunk : new Buffer(chunk, encoding);
	
	  this.write(chunk, encoding, function() {
	    writeRemnant(_this);
	  });
	};
	
	/**
	 * @ignore
	 */
	
	function __handleError(_this, error, callback) {
	  if (_this.state.errored) {
	    return;
	  }
	  _this.state.errored = true;
	  if (callback) {
	    return callback(error);
	  }
	  _this.emit('error', error);
	}
	
	/**
	 * @ignore
	 */
	
	function createChunkDoc(filesId, n, data) {
	  return {
	    _id: core.BSON.ObjectId(),
	    files_id: filesId,
	    n: n,
	    data: data
	  };
	}
	
	/**
	 * @ignore
	 */
	
	function checkChunksIndex(_this, callback) {
	  _this.chunks.listIndexes().toArray(function(error, indexes) {
	    if (error) {
	      // Collection doesn't exist so create index
	      if (error.code === ERROR_NAMESPACE_NOT_FOUND) {
	        var index = { files_id: 1, n: 1 };
	        _this.chunks.createIndex(index, { background: false }, function(error) {
	          if (error) {
	            return callback(error);
	          }
	
	          callback();
	        });
	        return;
	      }
	      return callback(error);
	    }
	
	    var hasChunksIndex = false;
	    indexes.forEach(function(index) {
	      if (index.key) {
	        var keys = Object.keys(index.key);
	        if (keys.length === 2 && index.key.files_id === 1 &&
	            index.key.n === 1) {
	          hasChunksIndex = true;
	        }
	      }
	    });
	
	    if (hasChunksIndex) {
	      callback();
	    } else {
	      var index = { files_id: 1, n: 1 };
	      var indexOptions = getWriteOptions(_this);
	
	      indexOptions.background = false;
	      indexOptions.unique = true;
	
	      _this.chunks.createIndex(index, indexOptions, function(error) {
	        if (error) {
	          return callback(error);
	        }
	
	        callback();
	      });
	    }
	  });
	}
	
	/**
	 * @ignore
	 */
	
	function checkDone(_this, callback) {
	  if (_this.state.streamEnd &&
	      _this.state.outstandingRequests === 0 &&
	      !_this.state.errored) {
	    var filesDoc = createFilesDoc(_this.id, _this.length, _this.chunkSizeBytes,
	      _this.md5.digest('hex'), _this.filename, _this.options.contentType,
	      _this.options.aliases, _this.options.metadata);
	
	    if (checkAborted(_this, callback)) {
	      return false;
	    }
	
	    _this.files.insert(filesDoc, getWriteOptions(_this), function(error) {
	      if (error) {
	        return __handleError(_this, error, callback);
	      }
	      _this.emit('finish', filesDoc);
	    });
	
	    return true;
	  }
	
	  return false;
	}
	
	/**
	 * @ignore
	 */
	
	function checkIndexes(_this, callback) {
	  _this.files.findOne({}, { _id: 1 }, function(error, doc) {
	    if (error) {
	      return callback(error);
	    }
	    if (doc) {
	      return callback();
	    }
	
	    _this.files.listIndexes().toArray(function(error, indexes) {
	      if (error) {
	        // Collection doesn't exist so create index
	        if (error.code === ERROR_NAMESPACE_NOT_FOUND) {
	          var index = { filename: 1, uploadDate: 1 };
	          _this.files.createIndex(index, { background: false }, function(error) {
	            if (error) {
	              return callback(error);
	            }
	
	            checkChunksIndex(_this, callback);
	          });
	          return;
	        }
	        return callback(error);
	      }
	
	      var hasFileIndex = false;
	      indexes.forEach(function(index) {
	        var keys = Object.keys(index.key);
	        if (keys.length === 2 && index.key.filename === 1 &&
	            index.key.uploadDate === 1) {
	          hasFileIndex = true;
	        }
	      });
	
	      if (hasFileIndex) {
	        checkChunksIndex(_this, callback);
	      } else {
	        var index = { filename: 1, uploadDate: 1 };
	
	        var indexOptions = getWriteOptions(_this);
	
	        indexOptions.background = false;
	
	        _this.files.createIndex(index, indexOptions, function(error) {
	          if (error) {
	            return callback(error);
	          }
	
	          checkChunksIndex(_this, callback);
	        });
	      }
	    });
	  });
	}
	
	/**
	 * @ignore
	 */
	
	function createFilesDoc(_id, length, chunkSize, md5, filename, contentType,
	  aliases, metadata) {
	  var ret = {
	    _id: _id,
	    length: length,
	    chunkSize: chunkSize,
	    uploadDate: new Date(),
	    md5: md5,
	    filename: filename
	  };
	
	  if (contentType) {
	    ret.contentType = contentType;
	  }
	
	  if (aliases) {
	    ret.aliases = aliases;
	  }
	
	  if (metadata) {
	    ret.metadata = metadata;
	  }
	
	  return ret;
	}
	
	/**
	 * @ignore
	 */
	
	function doWrite(_this, chunk, encoding, callback) {
	  if (checkAborted(_this, callback)) {
	    return false;
	  }
	
	  var inputBuf = (Buffer.isBuffer(chunk)) ?
	    chunk : new Buffer(chunk, encoding);
	
	  _this.length += inputBuf.length;
	
	  // Input is small enough to fit in our buffer
	  if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {
	    inputBuf.copy(_this.bufToStore, _this.pos);
	    _this.pos += inputBuf.length;
	
	    callback && callback();
	
	    // Note that we reverse the typical semantics of write's return value
	    // to be compatible with node's `.pipe()` function.
	    // True means client can keep writing.
	    return true;
	  }
	
	  // Otherwise, buffer is too big for current chunk, so we need to flush
	  // to MongoDB.
	  var inputBufRemaining = inputBuf.length;
	  var spaceRemaining = _this.chunkSizeBytes - _this.pos;
	  var numToCopy = Math.min(spaceRemaining, inputBuf.length);
	  var outstandingRequests = 0;
	  while (inputBufRemaining > 0) {
	    var inputBufPos = inputBuf.length - inputBufRemaining;
	    inputBuf.copy(_this.bufToStore, _this.pos,
	      inputBufPos, inputBufPos + numToCopy);
	    _this.pos += numToCopy;
	    spaceRemaining -= numToCopy;
	    if (spaceRemaining === 0) {
	      _this.md5.update(_this.bufToStore);
	      var doc = createChunkDoc(_this.id, _this.n, _this.bufToStore);
	      ++_this.state.outstandingRequests;
	      ++outstandingRequests;
	
	      if (checkAborted(_this, callback)) {
	        return false;
	      }
	
	      _this.chunks.insert(doc, getWriteOptions(_this), function(error) {
	        if (error) {
	          return __handleError(_this, error);
	        }
	        --_this.state.outstandingRequests;
	        --outstandingRequests;
	        if (!outstandingRequests) {
	          _this.emit('drain', doc);
	          callback && callback();
	          checkDone(_this);
	        }
	      });
	
	      spaceRemaining = _this.chunkSizeBytes;
	      _this.pos = 0;
	      ++_this.n;
	    }
	    inputBufRemaining -= numToCopy;
	    numToCopy = Math.min(spaceRemaining, inputBufRemaining);
	  }
	
	  // Note that we reverse the typical semantics of write's return value
	  // to be compatible with node's `.pipe()` function.
	  // False means the client should wait for the 'drain' event.
	  return false;
	}
	
	/**
	 * @ignore
	 */
	
	function getWriteOptions(_this) {
	  var obj = {};
	  if (_this.options.writeConcern) {
	    obj.w = concern.w;
	    obj.wtimeout = concern.wtimeout;
	    obj.j = concern.j;
	  }
	  return obj;
	}
	
	/**
	 * @ignore
	 */
	
	function waitForIndexes(_this, callback) {
	  if (_this.bucket.s.checkedIndexes) {
	    return callback(false);
	  }
	
	  _this.bucket.once('index', function() {
	    callback(true);
	  });
	
	  return true;
	}
	
	/**
	 * @ignore
	 */
	
	function writeRemnant(_this, callback) {
	  // Buffer is empty, so don't bother to insert
	  if (_this.pos === 0) {
	    return checkDone(_this, callback);
	  }
	
	  ++_this.state.outstandingRequests;
	
	  // Create a new buffer to make sure the buffer isn't bigger than it needs
	  // to be.
	  var remnant = new Buffer(_this.pos);
	  _this.bufToStore.copy(remnant, 0, 0, _this.pos);
	  _this.md5.update(remnant);
	  var doc = createChunkDoc(_this.id, _this.n, remnant);
	
	  // If the stream was aborted, do not write remnant
	  if (checkAborted(_this, callback)) {
	    return false;
	  }
	
	  _this.chunks.insert(doc, getWriteOptions(_this), function(error) {
	    if (error) {
	      return __handleError(_this, error);
	    }
	    --_this.state.outstandingRequests;
	    checkDone(_this);
	  });
	}
	
	/**
	 * @ignore
	 */
	
	function checkAborted(_this, callback) {
	  if (_this.state.aborted) {
	    if(typeof callback == 'function') {
	      callback(new Error('this stream has been aborted'));
	    }
	    return true;
	  }
	  return false;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var Binary = __webpack_require__(155).Binary;
	
	module.exports = exports = Binary;


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseCollection = __webpack_require__(221),
	    Collection = __webpack_require__(155).Collection,
	    utils = __webpack_require__(223);
	
	/**
	 * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) collection implementation.
	 *
	 * All methods methods from the [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver are copied and wrapped in queue management.
	 *
	 * @inherits Collection
	 * @api private
	 */
	
	function NativeCollection() {
	  this.collection = null;
	  MongooseCollection.apply(this, arguments);
	}
	
	/*!
	 * Inherit from abstract Collection.
	 */
	
	NativeCollection.prototype.__proto__ = MongooseCollection.prototype;
	
	/**
	 * Called when the connection opens.
	 *
	 * @api private
	 */
	
	NativeCollection.prototype.onOpen = function() {
	  var _this = this;
	
	  // always get a new collection in case the user changed host:port
	  // of parent db instance when re-opening the connection.
	
	  if (!_this.opts.capped.size) {
	    // non-capped
	    return _this.conn.db.collection(_this.name, callback);
	  }
	
	  // capped
	  return _this.conn.db.collection(_this.name, function(err, c) {
	    if (err) return callback(err);
	
	    // discover if this collection exists and if it is capped
	    _this.conn.db.listCollections({name: _this.name}).toArray(function(err, docs) {
	      if (err) {
	        return callback(err);
	      }
	      var doc = docs[0];
	      var exists = !!doc;
	
	      if (exists) {
	        if (doc.options && doc.options.capped) {
	          callback(null, c);
	        } else {
	          var msg = 'A non-capped collection exists with the name: ' + _this.name + '\n\n'
	              + ' To use this collection as a capped collection, please '
	              + 'first convert it.\n'
	              + ' http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-Convertingacollectiontocapped';
	          err = new Error(msg);
	          callback(err);
	        }
	      } else {
	        // create
	        var opts = utils.clone(_this.opts.capped);
	        opts.capped = true;
	        _this.conn.db.createCollection(_this.name, opts, callback);
	      }
	    });
	  });
	
	  function callback(err, collection) {
	    if (err) {
	      // likely a strict mode error
	      _this.conn.emit('error', err);
	    } else {
	      _this.collection = collection;
	      MongooseCollection.prototype.onOpen.call(_this);
	    }
	  }
	};
	
	/**
	 * Called when the connection closes
	 *
	 * @api private
	 */
	
	NativeCollection.prototype.onClose = function() {
	  MongooseCollection.prototype.onClose.call(this);
	};
	
	/*!
	 * Copy the collection methods and make them subject to queues
	 */
	
	function iter(i) {
	  NativeCollection.prototype[i] = function() {
	    if (this.buffer) {
	      this.addQueue(i, arguments);
	      return;
	    }
	
	    var collection = this.collection,
	        args = arguments,
	        _this = this,
	        debug = _this.conn.base.options.debug;
	
	    if (debug) {
	      if (typeof debug === 'function') {
	        debug.apply(debug
	            , [_this.name, i].concat(utils.args(args, 0, args.length - 1)));
	      } else {
	        this.$print(_this.name, i, args);
	      }
	    }
	
	    try {
	      return collection[i].apply(collection, args);
	    } catch (error) {
	      // Collection operation may throw because of max bson size, catch it here
	      // See gh-3906
	      if (args.length > 0 &&
	          typeof args[args.length - 1] === 'function') {
	        args[args.length - 1](error);
	      } else {
	        throw error;
	      }
	    }
	  };
	}
	
	for (var i in Collection.prototype) {
	  // Janky hack to work around gh-3005 until we can get rid of the mongoose
	  // collection abstraction
	  try {
	    if (typeof Collection.prototype[i] !== 'function') {
	      continue;
	    }
	  } catch (e) {
	    continue;
	  }
	
	  iter(i);
	}
	
	/**
	 * Debug print helper
	 *
	 * @api public
	 * @method $print
	 */
	
	NativeCollection.prototype.$print = function(name, i, args) {
	  console.error(
	      '\x1B[0;36mMongoose:\x1B[0m %s.%s(%s) %s %s %s',
	      name,
	      i,
	      this.$format(args[0]),
	      this.$format(args[1]),
	      this.$format(args[2]),
	      this.$format(args[3]));
	};
	
	/**
	 * Formatter for debug print args
	 *
	 * @api public
	 * @method $format
	 */
	
	NativeCollection.prototype.$format = function(arg) {
	  var type = typeof arg;
	  if (type === 'function' || type === 'undefined') return '';
	  return format(arg);
	};
	
	/*!
	 * Debug print helper
	 */
	
	function map(o) {
	  return format(o, true);
	}
	function formatObjectId(x, key) {
	  var representation = 'ObjectId("' + x[key].toHexString() + '")';
	  x[key] = {inspect: function() { return representation; }};
	}
	function formatDate(x, key) {
	  var representation = 'new Date("' + x[key].toUTCString() + '")';
	  x[key] = {inspect: function() { return representation; }};
	}
	function format(obj, sub) {
	  var x = utils.clone(obj, {retainKeyOrder: 1});
	  var representation;
	
	  if (x != null) {
	    if (x.constructor.name === 'Binary') {
	      x = '[object Buffer]';
	    } else if (x.constructor.name === 'ObjectID') {
	      representation = 'ObjectId("' + x.toHexString() + '")';
	      x = {inspect: function() { return representation; }};
	    } else if (x.constructor.name === 'Date') {
	      representation = 'new Date("' + x.toUTCString() + '")';
	      x = {inspect: function() { return representation; }};
	    } else if (x.constructor.name === 'Object') {
	      var keys = Object.keys(x);
	      var numKeys = keys.length;
	      var key;
	      for (var i = 0; i < numKeys; ++i) {
	        key = keys[i];
	        if (x[key]) {
	          if (x[key].constructor.name === 'Binary') {
	            x[key] = '[object Buffer]';
	          } else if (x[key].constructor.name === 'Object') {
	            x[key] = format(x[key], true);
	          } else if (x[key].constructor.name === 'ObjectID') {
	            formatObjectId(x, key);
	          } else if (x[key].constructor.name === 'Date') {
	            formatDate(x, key);
	          } else if (Array.isArray(x[key])) {
	            x[key] = x[key].map(map);
	          }
	        }
	      }
	    }
	    if (sub) return x;
	  }
	
	  return __webpack_require__(77)
	  .inspect(x, false, 10, true)
	  .replace(/\n/g, '')
	  .replace(/\s{2,}/g, ' ');
	}
	
	/**
	 * Retreives information about this collections indexes.
	 *
	 * @param {Function} callback
	 * @method getIndexes
	 * @api public
	 */
	
	NativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;
	
	/*!
	 * Module exports.
	 */
	
	module.exports = NativeCollection;


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*!
	 * Module dependencies.
	 */
	
	var EventEmitter = __webpack_require__(3).EventEmitter;
	var STATES = __webpack_require__(222);
	
	/**
	 * Abstract Collection constructor
	 *
	 * This is the base class that drivers inherit from and implement.
	 *
	 * @param {String} name name of the collection
	 * @param {Connection} conn A MongooseConnection instance
	 * @param {Object} opts optional collection options
	 * @api public
	 */
	
	function Collection(name, conn, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }
	  if (opts.capped === void 0) {
	    opts.capped = {};
	  }
	
	  opts.bufferCommands = undefined === opts.bufferCommands
	      ? true
	      : opts.bufferCommands;
	
	  if (typeof opts.capped === 'number') {
	    opts.capped = {size: opts.capped};
	  }
	
	  this.opts = opts;
	  this.name = name;
	  this.collectionName = name;
	  this.conn = conn;
	  this.queue = [];
	  this.buffer = this.opts.bufferCommands;
	  this.emitter = new EventEmitter();
	
	  if (STATES.connected === this.conn.readyState) {
	    this.onOpen();
	  }
	}
	
	/**
	 * The collection name
	 *
	 * @api public
	 * @property name
	 */
	
	Collection.prototype.name;
	
	/**
	 * The collection name
	 *
	 * @api public
	 * @property collectionName
	 */
	
	Collection.prototype.collectionName;
	
	/**
	 * The Connection instance
	 *
	 * @api public
	 * @property conn
	 */
	
	Collection.prototype.conn;
	
	/**
	 * Called when the database connects
	 *
	 * @api private
	 */
	
	Collection.prototype.onOpen = function() {
	  this.buffer = false;
	  this.doQueue();
	};
	
	/**
	 * Called when the database disconnects
	 *
	 * @api private
	 */
	
	Collection.prototype.onClose = function() {
	  if (this.opts.bufferCommands) {
	    this.buffer = true;
	  }
	};
	
	/**
	 * Queues a method for later execution when its
	 * database connection opens.
	 *
	 * @param {String} name name of the method to queue
	 * @param {Array} args arguments to pass to the method when executed
	 * @api private
	 */
	
	Collection.prototype.addQueue = function(name, args) {
	  this.queue.push([name, args]);
	  return this;
	};
	
	/**
	 * Executes all queued methods and clears the queue.
	 *
	 * @api private
	 */
	
	Collection.prototype.doQueue = function() {
	  for (var i = 0, l = this.queue.length; i < l; i++) {
	    this[this.queue[i][0]].apply(this, this.queue[i][1]);
	  }
	  this.queue = [];
	  var _this = this;
	  process.nextTick(function() {
	    _this.emitter.emit('queue');
	  });
	  return this;
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.ensureIndex = function() {
	  throw new Error('Collection#ensureIndex unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.findAndModify = function() {
	  throw new Error('Collection#findAndModify unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.findOne = function() {
	  throw new Error('Collection#findOne unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.find = function() {
	  throw new Error('Collection#find unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.insert = function() {
	  throw new Error('Collection#insert unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.save = function() {
	  throw new Error('Collection#save unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.update = function() {
	  throw new Error('Collection#update unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.getIndexes = function() {
	  throw new Error('Collection#getIndexes unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.mapReduce = function() {
	  throw new Error('Collection#mapReduce unimplemented by driver');
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = Collection;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 222 */
/***/ function(module, exports) {

	
	/*!
	 * Connection states
	 */
	
	var STATES = module.exports = exports = Object.create(null);
	
	var disconnected = 'disconnected';
	var connected = 'connected';
	var connecting = 'connecting';
	var disconnecting = 'disconnecting';
	var unauthorized = 'unauthorized';
	var uninitialized = 'uninitialized';
	
	STATES[0] = disconnected;
	STATES[1] = connected;
	STATES[2] = connecting;
	STATES[3] = disconnecting;
	STATES[4] = unauthorized;
	STATES[99] = uninitialized;
	
	STATES[disconnected] = 0;
	STATES[connected] = 1;
	STATES[connecting] = 2;
	STATES[disconnecting] = 3;
	STATES[unauthorized] = 4;
	STATES[uninitialized] = 99;


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {/*!
	 * Module dependencies.
	 */
	
	var ObjectId = __webpack_require__(224);
	var cloneRegExp = __webpack_require__(225);
	var sliced = __webpack_require__(226);
	var mpath = __webpack_require__(227);
	var ms = __webpack_require__(15);
	var MongooseBuffer;
	var MongooseArray;
	var Document;
	
	/*!
	 * Produces a collection name from model `name`.
	 *
	 * @param {String} name a model name
	 * @return {String} a collection name
	 * @api private
	 */
	
	exports.toCollectionName = function(name, options) {
	  options = options || {};
	  if (name === 'system.profile') {
	    return name;
	  }
	  if (name === 'system.indexes') {
	    return name;
	  }
	  if (options.pluralization === false) {
	    return name;
	  }
	  return pluralize(name.toLowerCase());
	};
	
	/**
	 * Pluralization rules.
	 *
	 * These rules are applied while processing the argument to `toCollectionName`.
	 *
	 * @deprecated remove in 4.x gh-1350
	 */
	
	exports.pluralization = [
	  [/(m)an$/gi, '$1en'],
	  [/(pe)rson$/gi, '$1ople'],
	  [/(child)$/gi, '$1ren'],
	  [/^(ox)$/gi, '$1en'],
	  [/(ax|test)is$/gi, '$1es'],
	  [/(octop|vir)us$/gi, '$1i'],
	  [/(alias|status)$/gi, '$1es'],
	  [/(bu)s$/gi, '$1ses'],
	  [/(buffal|tomat|potat)o$/gi, '$1oes'],
	  [/([ti])um$/gi, '$1a'],
	  [/sis$/gi, 'ses'],
	  [/(?:([^f])fe|([lr])f)$/gi, '$1$2ves'],
	  [/(hive)$/gi, '$1s'],
	  [/([^aeiouy]|qu)y$/gi, '$1ies'],
	  [/(x|ch|ss|sh)$/gi, '$1es'],
	  [/(matr|vert|ind)ix|ex$/gi, '$1ices'],
	  [/([m|l])ouse$/gi, '$1ice'],
	  [/(kn|w|l)ife$/gi, '$1ives'],
	  [/(quiz)$/gi, '$1zes'],
	  [/s$/gi, 's'],
	  [/([^a-z])$/, '$1'],
	  [/$/gi, 's']
	];
	var rules = exports.pluralization;
	
	/**
	 * Uncountable words.
	 *
	 * These words are applied while processing the argument to `toCollectionName`.
	 * @api public
	 */
	
	exports.uncountables = [
	  'advice',
	  'energy',
	  'excretion',
	  'digestion',
	  'cooperation',
	  'health',
	  'justice',
	  'labour',
	  'machinery',
	  'equipment',
	  'information',
	  'pollution',
	  'sewage',
	  'paper',
	  'money',
	  'species',
	  'series',
	  'rain',
	  'rice',
	  'fish',
	  'sheep',
	  'moose',
	  'deer',
	  'news',
	  'expertise',
	  'status',
	  'media'
	];
	var uncountables = exports.uncountables;
	
	/*!
	 * Pluralize function.
	 *
	 * @author TJ Holowaychuk (extracted from _ext.js_)
	 * @param {String} string to pluralize
	 * @api private
	 */
	
	function pluralize(str) {
	  var found;
	  if (!~uncountables.indexOf(str.toLowerCase())) {
	    found = rules.filter(function(rule) {
	      return str.match(rule[0]);
	    });
	    if (found[0]) {
	      return str.replace(found[0][0], found[0][1]);
	    }
	  }
	  return str;
	}
	
	/*!
	 * Determines if `a` and `b` are deep equal.
	 *
	 * Modified from node/lib/assert.js
	 *
	 * @param {any} a a value to compare to `b`
	 * @param {any} b a value to compare to `a`
	 * @return {Boolean}
	 * @api private
	 */
	
	exports.deepEqual = function deepEqual(a, b) {
	  if (a === b) {
	    return true;
	  }
	
	  if (a instanceof Date && b instanceof Date) {
	    return a.getTime() === b.getTime();
	  }
	
	  if (a instanceof ObjectId && b instanceof ObjectId) {
	    return a.toString() === b.toString();
	  }
	
	  if (a instanceof RegExp && b instanceof RegExp) {
	    return a.source === b.source &&
	        a.ignoreCase === b.ignoreCase &&
	        a.multiline === b.multiline &&
	        a.global === b.global;
	  }
	
	  if (typeof a !== 'object' && typeof b !== 'object') {
	    return a == b;
	  }
	
	  if (a === null || b === null || a === undefined || b === undefined) {
	    return false;
	  }
	
	  if (a.prototype !== b.prototype) {
	    return false;
	  }
	
	  // Handle MongooseNumbers
	  if (a instanceof Number && b instanceof Number) {
	    return a.valueOf() === b.valueOf();
	  }
	
	  if (Buffer.isBuffer(a)) {
	    return exports.buffer.areEqual(a, b);
	  }
	
	  if (isMongooseObject(a)) {
	    a = a.toObject();
	  }
	  if (isMongooseObject(b)) {
	    b = b.toObject();
	  }
	
	  try {
	    var ka = Object.keys(a),
	        kb = Object.keys(b),
	        key, i;
	  } catch (e) {
	    // happens when one is a string literal and the other isn't
	    return false;
	  }
	
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length) {
	    return false;
	  }
	
	  // the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	
	  // ~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i]) {
	      return false;
	    }
	  }
	
	  // equivalent values for every corresponding key, and
	  // ~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key])) {
	      return false;
	    }
	  }
	
	  return true;
	};
	
	/*!
	 * Object clone with Mongoose natives support.
	 *
	 * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.
	 *
	 * Functions are never cloned.
	 *
	 * @param {Object} obj the object to clone
	 * @param {Object} options
	 * @return {Object} the cloned object
	 * @api private
	 */
	
	exports.clone = function clone(obj, options) {
	  if (obj === undefined || obj === null) {
	    return obj;
	  }
	
	  if (Array.isArray(obj)) {
	    return cloneArray(obj, options);
	  }
	
	  if (isMongooseObject(obj)) {
	    if (options && options.json && typeof obj.toJSON === 'function') {
	      return obj.toJSON(options);
	    }
	    return obj.toObject(options);
	  }
	
	  if (obj.constructor) {
	    switch (exports.getFunctionName(obj.constructor)) {
	      case 'Object':
	        return cloneObject(obj, options);
	      case 'Date':
	        return new obj.constructor(+obj);
	      case 'RegExp':
	        return cloneRegExp(obj);
	      default:
	        // ignore
	        break;
	    }
	  }
	
	  if (obj instanceof ObjectId) {
	    return new ObjectId(obj.id);
	  }
	
	  if (!obj.constructor && exports.isObject(obj)) {
	    // object created with Object.create(null)
	    return cloneObject(obj, options);
	  }
	
	  if (obj.valueOf) {
	    return obj.valueOf();
	  }
	};
	var clone = exports.clone;
	
	/*!
	 * ignore
	 */
	
	function cloneObject(obj, options) {
	  var retainKeyOrder = options && options.retainKeyOrder,
	      minimize = options && options.minimize,
	      ret = {},
	      hasKeys,
	      keys,
	      val,
	      k,
	      i;
	
	  if (retainKeyOrder) {
	    for (k in obj) {
	      val = clone(obj[k], options);
	
	      if (!minimize || (typeof val !== 'undefined')) {
	        hasKeys || (hasKeys = true);
	        ret[k] = val;
	      }
	    }
	  } else {
	    // faster
	
	    keys = Object.keys(obj);
	    i = keys.length;
	
	    while (i--) {
	      k = keys[i];
	      val = clone(obj[k], options);
	
	      if (!minimize || (typeof val !== 'undefined')) {
	        if (!hasKeys) {
	          hasKeys = true;
	        }
	        ret[k] = val;
	      }
	    }
	  }
	
	  return minimize
	      ? hasKeys && ret
	      : ret;
	}
	
	function cloneArray(arr, options) {
	  var ret = [];
	  for (var i = 0, l = arr.length; i < l; i++) {
	    ret.push(clone(arr[i], options));
	  }
	  return ret;
	}
	
	/*!
	 * Shallow copies defaults into options.
	 *
	 * @param {Object} defaults
	 * @param {Object} options
	 * @return {Object} the merged object
	 * @api private
	 */
	
	exports.options = function(defaults, options) {
	  var keys = Object.keys(defaults),
	      i = keys.length,
	      k;
	
	  options = options || {};
	
	  while (i--) {
	    k = keys[i];
	    if (!(k in options)) {
	      options[k] = defaults[k];
	    }
	  }
	
	  return options;
	};
	
	/*!
	 * Generates a random string
	 *
	 * @api private
	 */
	
	exports.random = function() {
	  return Math.random().toString().substr(3);
	};
	
	/*!
	 * Merges `from` into `to` without overwriting existing properties.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 * @api private
	 */
	
	exports.merge = function merge(to, from) {
	  var keys = Object.keys(from),
	      i = keys.length,
	      key;
	
	  while (i--) {
	    key = keys[i];
	    if (typeof to[key] === 'undefined') {
	      to[key] = from[key];
	    } else if (exports.isObject(from[key])) {
	      merge(to[key], from[key]);
	    }
	  }
	};
	
	/*!
	 * toString helper
	 */
	
	var toString = Object.prototype.toString;
	
	/*!
	 * Applies toObject recursively.
	 *
	 * @param {Document|Array|Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	exports.toObject = function toObject(obj) {
	  Document || (Document = __webpack_require__(229));
	  var ret;
	
	  if (exports.isNullOrUndefined(obj)) {
	    return obj;
	  }
	
	  if (obj instanceof Document) {
	    return obj.toObject();
	  }
	
	  if (Array.isArray(obj)) {
	    ret = [];
	
	    for (var i = 0, len = obj.length; i < len; ++i) {
	      ret.push(toObject(obj[i]));
	    }
	
	    return ret;
	  }
	
	  if ((obj.constructor && exports.getFunctionName(obj.constructor) === 'Object') ||
	      (!obj.constructor && exports.isObject(obj))) {
	    ret = {};
	
	    for (var k in obj) {
	      ret[k] = toObject(obj[k]);
	    }
	
	    return ret;
	  }
	
	  return obj;
	};
	
	/*!
	 * Determines if `arg` is an object.
	 *
	 * @param {Object|Array|String|Function|RegExp|any} arg
	 * @api private
	 * @return {Boolean}
	 */
	
	exports.isObject = function(arg) {
	  if (Buffer.isBuffer(arg)) {
	    return true;
	  }
	  return toString.call(arg) === '[object Object]';
	};
	
	/*!
	 * A faster Array.prototype.slice.call(arguments) alternative
	 * @api private
	 */
	
	exports.args = sliced;
	
	/*!
	 * process.nextTick helper.
	 *
	 * Wraps `callback` in a try/catch + nextTick.
	 *
	 * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.
	 *
	 * @param {Function} callback
	 * @api private
	 */
	
	exports.tick = function tick(callback) {
	  if (typeof callback !== 'function') {
	    return;
	  }
	  return function() {
	    try {
	      callback.apply(this, arguments);
	    } catch (err) {
	      // only nextTick on err to get out of
	      // the event loop and avoid state corruption.
	      process.nextTick(function() {
	        throw err;
	      });
	    }
	  };
	};
	
	/*!
	 * Returns if `v` is a mongoose object that has a `toObject()` method we can use.
	 *
	 * This is for compatibility with libs like Date.js which do foolish things to Natives.
	 *
	 * @param {any} v
	 * @api private
	 */
	
	exports.isMongooseObject = function(v) {
	  Document || (Document = __webpack_require__(229));
	  MongooseArray || (MongooseArray = __webpack_require__(258).Array);
	  MongooseBuffer || (MongooseBuffer = __webpack_require__(258).Buffer);
	
	  return v instanceof Document ||
	      (v && v.isMongooseArray) ||
	      (v && v.isMongooseBuffer);
	};
	var isMongooseObject = exports.isMongooseObject;
	
	/*!
	 * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.
	 *
	 * @param {Object} object
	 * @api private
	 */
	
	exports.expires = function expires(object) {
	  if (!(object && object.constructor.name === 'Object')) {
	    return;
	  }
	  if (!('expires' in object)) {
	    return;
	  }
	
	  var when;
	  if (typeof object.expires !== 'string') {
	    when = object.expires;
	  } else {
	    when = Math.round(ms(object.expires) / 1000);
	  }
	  object.expireAfterSeconds = when;
	  delete object.expires;
	};
	
	/*!
	 * Populate options constructor
	 */
	
	function PopulateOptions(path, select, match, options, model, subPopulate) {
	  this.path = path;
	  this.match = match;
	  this.select = select;
	  this.options = options;
	  this.model = model;
	  if (typeof subPopulate === 'object') {
	    this.populate = subPopulate;
	  }
	  this._docs = {};
	}
	
	// make it compatible with utils.clone
	PopulateOptions.prototype.constructor = Object;
	
	// expose
	exports.PopulateOptions = PopulateOptions;
	
	/*!
	 * populate helper
	 */
	
	exports.populate = function populate(path, select, model, match, options, subPopulate) {
	  // The order of select/conditions args is opposite Model.find but
	  // necessary to keep backward compatibility (select could be
	  // an array, string, or object literal).
	
	  // might have passed an object specifying all arguments
	  if (arguments.length === 1) {
	    if (path instanceof PopulateOptions) {
	      return [path];
	    }
	
	    if (Array.isArray(path)) {
	      return path.map(function(o) {
	        return exports.populate(o)[0];
	      });
	    }
	
	    if (exports.isObject(path)) {
	      match = path.match;
	      options = path.options;
	      select = path.select;
	      model = path.model;
	      subPopulate = path.populate;
	      path = path.path;
	    }
	  } else if (typeof model !== 'string' && typeof model !== 'function') {
	    options = match;
	    match = model;
	    model = undefined;
	  }
	
	  if (typeof path !== 'string') {
	    throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + typeof path + '`');
	  }
	
	  if (typeof subPopulate === 'object') {
	    subPopulate = exports.populate(subPopulate);
	  }
	
	  var ret = [];
	  var paths = path.split(' ');
	  options = exports.clone(options, { retainKeyOrder: true });
	  for (var i = 0; i < paths.length; ++i) {
	    ret.push(new PopulateOptions(paths[i], select, match, options, model, subPopulate));
	  }
	
	  return ret;
	};
	
	/*!
	 * Return the value of `obj` at the given `path`.
	 *
	 * @param {String} path
	 * @param {Object} obj
	 */
	
	exports.getValue = function(path, obj, map) {
	  return mpath.get(path, obj, '_doc', map);
	};
	
	/*!
	 * Sets the value of `obj` at the given `path`.
	 *
	 * @param {String} path
	 * @param {Anything} val
	 * @param {Object} obj
	 */
	
	exports.setValue = function(path, val, obj, map) {
	  mpath.set(path, val, obj, '_doc', map);
	};
	
	/*!
	 * Returns an array of values from object `o`.
	 *
	 * @param {Object} o
	 * @return {Array}
	 * @private
	 */
	
	exports.object = {};
	exports.object.vals = function vals(o) {
	  var keys = Object.keys(o),
	      i = keys.length,
	      ret = [];
	
	  while (i--) {
	    ret.push(o[keys[i]]);
	  }
	
	  return ret;
	};
	
	/*!
	 * @see exports.options
	 */
	
	exports.object.shallowCopy = exports.options;
	
	/*!
	 * Safer helper for hasOwnProperty checks
	 *
	 * @param {Object} obj
	 * @param {String} prop
	 */
	
	var hop = Object.prototype.hasOwnProperty;
	exports.object.hasOwnProperty = function(obj, prop) {
	  return hop.call(obj, prop);
	};
	
	/*!
	 * Determine if `val` is null or undefined
	 *
	 * @return {Boolean}
	 */
	
	exports.isNullOrUndefined = function(val) {
	  return val === null || val === undefined;
	};
	
	/*!
	 * ignore
	 */
	
	exports.array = {};
	
	/*!
	 * Flattens an array.
	 *
	 * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]
	 *
	 * @param {Array} arr
	 * @param {Function} [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsey value, the item will not be included in the results.
	 * @return {Array}
	 * @private
	 */
	
	exports.array.flatten = function flatten(arr, filter, ret) {
	  ret || (ret = []);
	
	  arr.forEach(function(item) {
	    if (Array.isArray(item)) {
	      flatten(item, filter, ret);
	    } else {
	      if (!filter || filter(item)) {
	        ret.push(item);
	      }
	    }
	  });
	
	  return ret;
	};
	
	/*!
	 * Removes duplicate values from an array
	 *
	 * [1, 2, 3, 3, 5] => [1, 2, 3, 5]
	 * [ ObjectId("550988ba0c19d57f697dc45e"), ObjectId("550988ba0c19d57f697dc45e") ]
	 *    => [ObjectId("550988ba0c19d57f697dc45e")]
	 *
	 * @param {Array} arr
	 * @return {Array}
	 * @private
	 */
	
	exports.array.unique = function(arr) {
	  var primitives = {};
	  var ids = {};
	  var ret = [];
	  var length = arr.length;
	  for (var i = 0; i < length; ++i) {
	    if (typeof arr[i] === 'number' || typeof arr[i] === 'string') {
	      if (primitives[arr[i]]) {
	        continue;
	      }
	      ret.push(arr[i]);
	      primitives[arr[i]] = true;
	    } else if (arr[i] instanceof ObjectId) {
	      if (ids[arr[i].toString()]) {
	        continue;
	      }
	      ret.push(arr[i]);
	      ids[arr[i].toString()] = true;
	    } else {
	      ret.push(arr[i]);
	    }
	  }
	
	  return ret;
	};
	
	/*!
	 * Determines if two buffers are equal.
	 *
	 * @param {Buffer} a
	 * @param {Object} b
	 */
	
	exports.buffer = {};
	exports.buffer.areEqual = function(a, b) {
	  if (!Buffer.isBuffer(a)) {
	    return false;
	  }
	  if (!Buffer.isBuffer(b)) {
	    return false;
	  }
	  if (a.length !== b.length) {
	    return false;
	  }
	  for (var i = 0, len = a.length; i < len; ++i) {
	    if (a[i] !== b[i]) {
	      return false;
	    }
	  }
	  return true;
	};
	
	exports.getFunctionName = function(fn) {
	  if (fn.name) {
	    return fn.name;
	  }
	  return (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
	};
	
	exports.decorate = function(destination, source) {
	  for (var key in source) {
	    destination[key] = source[key];
	  }
	};
	
	/**
	 * merges to with a copy of from
	 *
	 * @param {Object} to
	 * @param {Object} fromObj
	 * @api private
	 */
	
	exports.mergeClone = function(to, fromObj) {
	  var keys = Object.keys(fromObj),
	      i = keys.length,
	      key;
	
	  while (i--) {
	    key = keys[i];
	    if (typeof to[key] === 'undefined') {
	      // make sure to retain key order here because of a bug handling the $each
	      // operator in mongodb 2.4.4
	      to[key] = exports.clone(fromObj[key], {retainKeyOrder: 1});
	    } else {
	      if (exports.isObject(fromObj[key])) {
	        var obj = fromObj[key];
	        if (isMongooseObject(fromObj[key]) && !fromObj[key].isMongooseBuffer) {
	          obj = obj.toObject({ virtuals: false });
	        }
	        exports.mergeClone(to[key], obj);
	      } else {
	        // make sure to retain key order here because of a bug handling the
	        // $each operator in mongodb 2.4.4
	        to[key] = exports.clone(fromObj[key], {retainKeyOrder: 1});
	      }
	    }
	  }
	};
	
	/**
	 * Executes a function on each element of an array (like _.each)
	 *
	 * @param {Array} arr
	 * @param {Function} fn
	 * @api private
	 */
	
	exports.each = function(arr, fn) {
	  for (var i = 0; i < arr.length; ++i) {
	    fn(arr[i]);
	  }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer, __webpack_require__(6)))

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ObjectId type constructor
	 *
	 * ####Example
	 *
	 *     var id = new mongoose.Types.ObjectId;
	 *
	 * @constructor ObjectId
	 */
	
	var ObjectId = __webpack_require__(129).ObjectId;
	
	module.exports = ObjectId;


/***/ },
/* 225 */
/***/ function(module, exports) {

	
	var toString = Object.prototype.toString;
	
	function isRegExp (o) {
	  return 'object' == typeof o
	      && '[object RegExp]' == toString.call(o);
	}
	
	module.exports = exports = function (regexp) {
	  if (!isRegExp(regexp)) {
	    throw new TypeError('Not a RegExp');
	  }
	
	  var flags = [];
	  if (regexp.global) flags.push('g');
	  if (regexp.multiline) flags.push('m');
	  if (regexp.ignoreCase) flags.push('i');
	  return new RegExp(regexp.source, flags.join(''));
	}
	


/***/ },
/* 226 */
/***/ function(module, exports) {

	
	/**
	 * An Array.prototype.slice.call(arguments) alternative
	 *
	 * @param {Object} args something with a length
	 * @param {Number} slice
	 * @param {Number} sliceEnd
	 * @api public
	 */
	
	module.exports = function (args, slice, sliceEnd) {
	  var ret = [];
	  var len = args.length;
	
	  if (0 === len) return ret;
	
	  var start = slice < 0
	    ? Math.max(0, slice + len)
	    : slice || 0;
	
	  if (sliceEnd !== undefined) {
	    len = sliceEnd < 0
	      ? sliceEnd + len
	      : sliceEnd
	  }
	
	  while (len-- > start) {
	    ret[len - start] = args[len];
	  }
	
	  return ret;
	}
	


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = exports = __webpack_require__(228);


/***/ },
/* 228 */
/***/ function(module, exports) {

	/**
	 * Returns the value of object `o` at the given `path`.
	 *
	 * ####Example:
	 *
	 *     var obj = {
	 *         comments: [
	 *             { title: 'exciting!', _doc: { title: 'great!' }}
	 *           , { title: 'number dos' }
	 *         ]
	 *     }
	 *
	 *     mpath.get('comments.0.title', o)         // 'exciting!'
	 *     mpath.get('comments.0.title', o, '_doc') // 'great!'
	 *     mpath.get('comments.title', o)           // ['exciting!', 'number dos']
	 *
	 *     // summary
	 *     mpath.get(path, o)
	 *     mpath.get(path, o, special)
	 *     mpath.get(path, o, map)
	 *     mpath.get(path, o, special, map)
	 *
	 * @param {String} path
	 * @param {Object} o
	 * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.
	 * @param {Function} [map] Optional function which receives each individual found value. The value returned from `map` is used in the original values place.
	 */
	
	exports.get = function (path, o, special, map) {
	  var lookup;
	
	  if ('function' == typeof special) {
	    if (special.length < 2) {
	      map = special;
	      special = undefined;
	    } else {
	      lookup = special;
	      special = undefined;
	    }
	  }
	
	  map || (map = K);
	
	  var parts = 'string' == typeof path
	    ? path.split('.')
	    : path
	
	  if (!Array.isArray(parts)) {
	    throw new TypeError('Invalid `path`. Must be either string or array');
	  }
	
	  var obj = o
	    , part;
	
	  for (var i = 0; i < parts.length; ++i) {
	    part = parts[i];
	
	    if (Array.isArray(obj) && !/^\d+$/.test(part)) {
	      // reading a property from the array items
	      var paths = parts.slice(i);
	
	      return obj.map(function (item) {
	        return item
	          ? exports.get(paths, item, special || lookup, map)
	          : map(undefined);
	      });
	    }
	
	    if (lookup) {
	      obj = lookup(obj, part);
	    } else {
	      obj = special && obj[special]
	        ? obj[special][part]
	        : obj[part];
	    }
	
	    if (!obj) return map(obj);
	  }
	
	  return map(obj);
	}
	
	/**
	 * Sets the `val` at the given `path` of object `o`.
	 *
	 * @param {String} path
	 * @param {Anything} val
	 * @param {Object} o
	 * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.
	 * @param {Function} [map] Optional function which is passed each individual value before setting it. The value returned from `map` is used in the original values place.
	 */
	
	exports.set = function (path, val, o, special, map, _copying) {
	  var lookup;
	
	  if ('function' == typeof special) {
	    if (special.length < 2) {
	      map = special;
	      special = undefined;
	    } else {
	      lookup = special;
	      special = undefined;
	    }
	  }
	
	  map || (map = K);
	
	  var parts = 'string' == typeof path
	    ? path.split('.')
	    : path
	
	  if (!Array.isArray(parts)) {
	    throw new TypeError('Invalid `path`. Must be either string or array');
	  }
	
	  if (null == o) return;
	
	  // the existance of $ in a path tells us if the user desires
	  // the copying of an array instead of setting each value of
	  // the array to the one by one to matching positions of the
	  // current array.
	  var copy = _copying || /\$/.test(path)
	    , obj = o
	    , part
	
	  for (var i = 0, len = parts.length - 1; i < len; ++i) {
	    part = parts[i];
	
	    if ('$' == part) {
	      if (i == len - 1) {
	        break;
	      } else {
	        continue;
	      }
	    }
	
	    if (Array.isArray(obj) && !/^\d+$/.test(part)) {
	      var paths = parts.slice(i);
	      if (!copy && Array.isArray(val)) {
	        for (var j = 0; j < obj.length && j < val.length; ++j) {
	          // assignment of single values of array
	          exports.set(paths, val[j], obj[j], special || lookup, map, copy);
	        }
	      } else {
	        for (var j = 0; j < obj.length; ++j) {
	          // assignment of entire value
	          exports.set(paths, val, obj[j], special || lookup, map, copy);
	        }
	      }
	      return;
	    }
	
	    if (lookup) {
	      obj = lookup(obj, part);
	    } else {
	      obj = special && obj[special]
	        ? obj[special][part]
	        : obj[part];
	    }
	
	    if (!obj) return;
	  }
	
	  // process the last property of the path
	
	  part = parts[len];
	
	  // use the special property if exists
	  if (special && obj[special]) {
	    obj = obj[special];
	  }
	
	  // set the value on the last branch
	  if (Array.isArray(obj) && !/^\d+$/.test(part)) {
	    if (!copy && Array.isArray(val)) {
	      for (var item, j = 0; j < obj.length && j < val.length; ++j) {
	        item = obj[j];
	        if (item) {
	          if (lookup) {
	            lookup(item, part, map(val[j]));
	          } else {
	            if (item[special]) item = item[special];
	            item[part] = map(val[j]);
	          }
	        }
	      }
	    } else {
	      for (var j = 0; j < obj.length; ++j) {
	        item = obj[j];
	        if (item) {
	          if (lookup) {
	            lookup(item, part, map(val));
	          } else {
	            if (item[special]) item = item[special];
	            item[part] = map(val);
	          }
	        }
	      }
	    }
	  } else {
	    if (lookup) {
	      lookup(obj, part, map(val));
	    } else {
	      obj[part] = map(val);
	    }
	  }
	}
	
	/*!
	 * Returns the value passed to it.
	 */
	
	function K (v) {
	  return v;
	}


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {/*!
	 * Module dependencies.
	 */
	
	var EventEmitter = __webpack_require__(3).EventEmitter;
	var MongooseError = __webpack_require__(119);
	var MixedSchema = __webpack_require__(230);
	var Schema = __webpack_require__(128);
	var ObjectExpectedError = __webpack_require__(232);
	var StrictModeError = __webpack_require__(233);
	var ValidatorError = __webpack_require__(231).ValidatorError;
	var VersionError = __webpack_require__(119).VersionError;
	var utils = __webpack_require__(223);
	var clone = utils.clone;
	var isMongooseObject = utils.isMongooseObject;
	var inspect = __webpack_require__(77).inspect;
	var ValidationError = MongooseError.ValidationError;
	var InternalCache = __webpack_require__(234);
	var deepEqual = utils.deepEqual;
	var hooks = __webpack_require__(236);
	var PromiseProvider = __webpack_require__(237);
	var DocumentArray;
	var MongooseArray;
	var Embedded;
	var flatten = __webpack_require__(251).flatten;
	
	/**
	 * Document constructor.
	 *
	 * @param {Object} obj the values to set
	 * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data
	 * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `init`: Emitted on a document after it has was retreived from the db and fully hydrated by Mongoose.
	 * @event `save`: Emitted when the document is successfully saved
	 * @api private
	 */
	
	function Document(obj, fields, skipId) {
	  this.$__ = new InternalCache;
	  this.$__.emitter = new EventEmitter();
	  this.isNew = true;
	  this.errors = undefined;
	
	  var schema = this.schema;
	
	  if (typeof fields === 'boolean') {
	    this.$__.strictMode = fields;
	    fields = undefined;
	  } else {
	    this.$__.strictMode = schema.options && schema.options.strict;
	    this.$__.selected = fields;
	  }
	
	  var required = schema.requiredPaths(true);
	  for (var i = 0; i < required.length; ++i) {
	    this.$__.activePaths.require(required[i]);
	  }
	
	  this.$__.emitter.setMaxListeners(0);
	  this._doc = this.$__buildDoc(obj, fields, skipId);
	
	  if (obj) {
	    if (obj instanceof Document) {
	      this.isNew = obj.isNew;
	    }
	    this.set(obj, undefined, true);
	  }
	
	  if (!schema.options.strict && obj) {
	    var _this = this,
	        keys = Object.keys(this._doc);
	
	    keys.forEach(function(key) {
	      if (!(key in schema.tree)) {
	        defineKey(key, null, _this);
	      }
	    });
	  }
	
	  this.$__registerHooksFromSchema();
	}
	
	/*!
	 * Document exposes the NodeJS event emitter API, so you can use
	 * `on`, `once`, etc.
	 */
	utils.each(
	    ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',
	      'removeAllListeners', 'addListener'],
	    function(emitterFn) {
	      Document.prototype[emitterFn] = function() {
	        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
	      };
	    });
	
	Document.prototype.constructor = Document;
	
	/**
	 * The documents schema.
	 *
	 * @api public
	 * @property schema
	 */
	
	Document.prototype.schema;
	
	/**
	 * Boolean flag specifying if the document is new.
	 *
	 * @api public
	 * @property isNew
	 */
	
	Document.prototype.isNew;
	
	/**
	 * The string version of this documents _id.
	 *
	 * ####Note:
	 *
	 * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.
	 *
	 *     new Schema({ name: String }, { id: false });
	 *
	 * @api public
	 * @see Schema options /docs/guide.html#options
	 * @property id
	 */
	
	Document.prototype.id;
	
	/**
	 * Hash containing current validation errors.
	 *
	 * @api public
	 * @property errors
	 */
	
	Document.prototype.errors;
	
	/**
	 * Builds the default doc structure
	 *
	 * @param {Object} obj
	 * @param {Object} [fields]
	 * @param {Boolean} [skipId]
	 * @return {Object}
	 * @api private
	 * @method $__buildDoc
	 * @memberOf Document
	 */
	
	Document.prototype.$__buildDoc = function(obj, fields, skipId) {
	  var doc = {};
	  var exclude = null;
	  var keys;
	  var ki;
	  var _this = this;
	
	  // determine if this doc is a result of a query with
	  // excluded fields
	
	  if (fields && utils.getFunctionName(fields.constructor) === 'Object') {
	    keys = Object.keys(fields);
	    ki = keys.length;
	
	    if (ki === 1 && keys[0] === '_id') {
	      exclude = !!fields[keys[ki]];
	    } else {
	      while (ki--) {
	        if (keys[ki] !== '_id' &&
	            (!fields[keys[ki]] || typeof fields[keys[ki]] !== 'object')) {
	          exclude = !fields[keys[ki]];
	          break;
	        }
	      }
	    }
	  }
	
	  var paths = Object.keys(this.schema.paths),
	      plen = paths.length,
	      ii = 0;
	
	  for (; ii < plen; ++ii) {
	    var p = paths[ii];
	
	    if (p === '_id') {
	      if (skipId) {
	        continue;
	      }
	      if (obj && '_id' in obj) {
	        continue;
	      }
	    }
	
	    var type = this.schema.paths[p];
	    var path = p.split('.');
	    var len = path.length;
	    var last = len - 1;
	    var curPath = '';
	    var doc_ = doc;
	    var i = 0;
	    var included = false;
	
	    for (; i < len; ++i) {
	      var piece = path[i],
	          def;
	
	      curPath += piece;
	
	      // support excluding intermediary levels
	      if (exclude === true) {
	        if (curPath in fields) {
	          break;
	        }
	      } else if (fields && curPath in fields) {
	        included = true;
	      }
	
	      if (i === last) {
	        if (fields && exclude !== null) {
	          if (exclude === true) {
	            // apply defaults to all non-excluded fields
	            if (p in fields) {
	              continue;
	            }
	
	            def = type.getDefault(_this, true);
	            if (typeof def !== 'undefined') {
	              doc_[piece] = def;
	              _this.$__.activePaths.default(p);
	            }
	          } else if (included) {
	            // selected field
	            def = type.getDefault(_this, true);
	            if (typeof def !== 'undefined') {
	              doc_[piece] = def;
	              _this.$__.activePaths.default(p);
	            }
	          }
	        } else {
	          def = type.getDefault(_this, true);
	          if (typeof def !== 'undefined') {
	            doc_[piece] = def;
	            _this.$__.activePaths.default(p);
	          }
	        }
	      } else {
	        doc_ = doc_[piece] || (doc_[piece] = {});
	        curPath += '.';
	      }
	    }
	  }
	
	  return doc;
	};
	
	/**
	 * Initializes the document without setters or marking anything modified.
	 *
	 * Called internally after a document is returned from mongodb.
	 *
	 * @param {Object} doc document returned by mongo
	 * @param {Function} fn callback
	 * @api public
	 */
	
	Document.prototype.init = function(doc, opts, fn) {
	  // do not prefix this method with $__ since its
	  // used by public hooks
	
	  if (typeof opts === 'function') {
	    fn = opts;
	    opts = null;
	  }
	
	  this.isNew = false;
	
	  // handle docs with populated paths
	  // If doc._id is not null or undefined
	  if (doc._id !== null && doc._id !== undefined &&
	    opts && opts.populated && opts.populated.length) {
	    var id = String(doc._id);
	    for (var i = 0; i < opts.populated.length; ++i) {
	      var item = opts.populated[i];
	      this.populated(item.path, item._docs[id], item);
	    }
	  }
	
	  init(this, doc, this._doc);
	  this.$__storeShard();
	
	  this.emit('init', this);
	  if (fn) {
	    fn(null);
	  }
	  return this;
	};
	
	/*!
	 * Init helper.
	 *
	 * @param {Object} self document instance
	 * @param {Object} obj raw mongodb doc
	 * @param {Object} doc object we are initializing
	 * @api private
	 */
	
	function init(self, obj, doc, prefix) {
	  prefix = prefix || '';
	
	  var keys = Object.keys(obj),
	      len = keys.length,
	      schema,
	      path,
	      i;
	
	  while (len--) {
	    i = keys[len];
	    path = prefix + i;
	    schema = self.schema.path(path);
	
	    if (!schema && utils.isObject(obj[i]) &&
	        (!obj[i].constructor || utils.getFunctionName(obj[i].constructor) === 'Object')) {
	      // assume nested object
	      if (!doc[i]) {
	        doc[i] = {};
	      }
	      init(self, obj[i], doc[i], path + '.');
	    } else {
	      if (obj[i] === null) {
	        doc[i] = null;
	      } else if (obj[i] !== undefined) {
	        if (schema) {
	          try {
	            doc[i] = schema.cast(obj[i], self, true);
	          } catch (e) {
	            self.invalidate(e.path, new ValidatorError({
	              path: e.path,
	              message: e.message,
	              type: 'cast',
	              value: e.value
	            }));
	          }
	        } else {
	          doc[i] = obj[i];
	        }
	      }
	      // mark as hydrated
	      if (!self.isModified(path)) {
	        self.$__.activePaths.init(path);
	      }
	    }
	  }
	}
	
	/**
	 * Stores the current values of the shard keys.
	 *
	 * ####Note:
	 *
	 * _Shard key values do not / are not allowed to change._
	 *
	 * @api private
	 * @method $__storeShard
	 * @memberOf Document
	 */
	
	Document.prototype.$__storeShard = function() {
	  // backwards compat
	  var key = this.schema.options.shardKey || this.schema.options.shardkey;
	  if (!(key && utils.getFunctionName(key.constructor) === 'Object')) {
	    return;
	  }
	
	  var orig = this.$__.shardval = {},
	      paths = Object.keys(key),
	      len = paths.length,
	      val;
	
	  for (var i = 0; i < len; ++i) {
	    val = this.getValue(paths[i]);
	    if (isMongooseObject(val)) {
	      orig[paths[i]] = val.toObject({depopulate: true});
	    } else if (val !== null && val !== undefined && val.valueOf &&
	          // Explicitly don't take value of dates
	        (!val.constructor || utils.getFunctionName(val.constructor) !== 'Date')) {
	      orig[paths[i]] = val.valueOf();
	    } else {
	      orig[paths[i]] = val;
	    }
	  }
	};
	
	/*!
	 * Set up middleware support
	 */
	
	for (var k in hooks) {
	  if (k === 'pre' || k === 'post') {
	    Document.prototype['$' + k] = Document['$' + k] = hooks[k];
	  } else {
	    Document.prototype[k] = Document[k] = hooks[k];
	  }
	}
	
	/**
	 * Sends an update command with this document `_id` as the query selector.
	 *
	 * ####Example:
	 *
	 *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);
	 *
	 * ####Valid options:
	 *
	 *  - same as in [Model.update](#model_Model.update)
	 *
	 * @see Model.update #model_Model.update
	 * @param {Object} doc
	 * @param {Object} options
	 * @param {Function} callback
	 * @return {Query}
	 * @api public
	 */
	
	Document.prototype.update = function update() {
	  var args = utils.args(arguments);
	  args.unshift({_id: this._id});
	  return this.constructor.update.apply(this.constructor, args);
	};
	
	/**
	 * Sets the value of a path, or many paths.
	 *
	 * ####Example:
	 *
	 *     // path, value
	 *     doc.set(path, value)
	 *
	 *     // object
	 *     doc.set({
	 *         path  : value
	 *       , path2 : {
	 *            path  : value
	 *         }
	 *     })
	 *
	 *     // on-the-fly cast to number
	 *     doc.set(path, value, Number)
	 *
	 *     // on-the-fly cast to string
	 *     doc.set(path, value, String)
	 *
	 *     // changing strict mode behavior
	 *     doc.set(path, value, { strict: false });
	 *
	 * @param {String|Object} path path or object of key/vals to set
	 * @param {Any} val the value to set
	 * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for "on-the-fly" attributes
	 * @param {Object} [options] optionally specify options that modify the behavior of the set
	 * @api public
	 */
	
	Document.prototype.set = function(path, val, type, options) {
	  if (type && utils.getFunctionName(type.constructor) === 'Object') {
	    options = type;
	    type = undefined;
	  }
	
	  var merge = options && options.merge,
	      adhoc = type && type !== true,
	      constructing = type === true,
	      adhocs;
	
	  var strict = options && 'strict' in options
	      ? options.strict
	      : this.$__.strictMode;
	
	  if (adhoc) {
	    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
	    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);
	  }
	
	  if (typeof path !== 'string') {
	    // new Document({ key: val })
	
	    if (path === null || path === void 0) {
	      var _ = path;
	      path = val;
	      val = _;
	    } else {
	      var prefix = val
	          ? val + '.'
	          : '';
	
	      if (path instanceof Document) {
	        if (path.$__isNested) {
	          path = path.toObject();
	        } else {
	          path = path._doc;
	        }
	      }
	
	      var keys = Object.keys(path);
	      var i = keys.length;
	      var pathtype;
	      var key;
	
	      if (i === 0 && !this.schema.options.minimize) {
	        if (val) {
	          this.set(val, {});
	        }
	        return this;
	      }
	
	      while (i--) {
	        key = keys[i];
	        var pathName = prefix + key;
	        pathtype = this.schema.pathType(pathName);
	
	        if (path[key] !== null
	            && path[key] !== void 0
	              // need to know if plain object - no Buffer, ObjectId, ref, etc
	            && utils.isObject(path[key])
	            && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === 'Object')
	            && pathtype !== 'virtual'
	            && pathtype !== 'real'
	            && !(this.$__path(pathName) instanceof MixedSchema)
	            && !(this.schema.paths[pathName] &&
	            this.schema.paths[pathName].options &&
	            this.schema.paths[pathName].options.ref)) {
	          this.set(path[key], prefix + key, constructing);
	        } else if (strict) {
	          // Don't overwrite defaults with undefined keys (gh-3981)
	          if (constructing && path[key] === void 0 &&
	              this.get(key) !== void 0) {
	            continue;
	          }
	
	          if (pathtype === 'real' || pathtype === 'virtual') {
	            // Check for setting single embedded schema to document (gh-3535)
	            if (this.schema.paths[pathName] &&
	                this.schema.paths[pathName].$isSingleNested &&
	                path[key] instanceof Document) {
	              path[key] = path[key].toObject({virtuals: false});
	            }
	            this.set(prefix + key, path[key], constructing);
	          } else if (pathtype === 'nested' && path[key] instanceof Document) {
	            this.set(prefix + key,
	                path[key].toObject({virtuals: false}), constructing);
	          } else if (strict === 'throw') {
	            if (pathtype === 'nested') {
	              throw new ObjectExpectedError(key, path[key]);
	            } else {
	              throw new StrictModeError(key);
	            }
	          }
	        } else if (path[key] !== void 0) {
	          this.set(prefix + key, path[key], constructing);
	        }
	      }
	
	      return this;
	    }
	  }
	
	  // ensure _strict is honored for obj props
	  // docschema = new Schema({ path: { nest: 'string' }})
	  // doc.set('path', obj);
	  var pathType = this.schema.pathType(path);
	  if (pathType === 'nested' && val) {
	    if (utils.isObject(val) &&
	        (!val.constructor || utils.getFunctionName(val.constructor) === 'Object')) {
	      if (!merge) {
	        this.setValue(path, null);
	        cleanModifiedSubpaths(this, path);
	      }
	
	      if (Object.keys(val).length === 0) {
	        this.setValue(path, {});
	        this.markModified(path);
	        cleanModifiedSubpaths(this, path);
	      } else {
	        this.set(val, path, constructing);
	      }
	      return this;
	    }
	    this.invalidate(path, new MongooseError.CastError('Object', val, path));
	    return this;
	  }
	
	  var schema;
	  var parts = path.split('.');
	
	  if (pathType === 'adhocOrUndefined' && strict) {
	    // check for roots that are Mixed types
	    var mixed;
	
	    for (i = 0; i < parts.length; ++i) {
	      var subpath = parts.slice(0, i + 1).join('.');
	      schema = this.schema.path(subpath);
	      if (schema instanceof MixedSchema) {
	        // allow changes to sub paths of mixed types
	        mixed = true;
	        break;
	      }
	    }
	
	    if (!mixed) {
	      if (strict === 'throw') {
	        throw new StrictModeError(path);
	      }
	      return this;
	    }
	  } else if (pathType === 'virtual') {
	    schema = this.schema.virtualpath(path);
	    schema.applySetters(val, this);
	    return this;
	  } else {
	    schema = this.$__path(path);
	  }
	
	  var pathToMark;
	
	  // When using the $set operator the path to the field must already exist.
	  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"
	
	  if (parts.length <= 1) {
	    pathToMark = path;
	  } else {
	    for (i = 0; i < parts.length; ++i) {
	      subpath = parts.slice(0, i + 1).join('.');
	      if (this.isDirectModified(subpath) // earlier prefixes that are already
	            // marked as dirty have precedence
	          || this.get(subpath) === null) {
	        pathToMark = subpath;
	        break;
	      }
	    }
	
	    if (!pathToMark) {
	      pathToMark = path;
	    }
	  }
	
	  // if this doc is being constructed we should not trigger getters
	  var priorVal = constructing
	      ? undefined
	      : this.getValue(path);
	
	  if (!schema) {
	    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
	    return this;
	  }
	
	  var shouldSet = true;
	  try {
	    // If the user is trying to set a ref path to a document with
	    // the correct model name, treat it as populated
	    var didPopulate = false;
	    if (schema.options &&
	        schema.options.ref &&
	        val instanceof Document &&
	        schema.options.ref === val.constructor.modelName) {
	      if (this.ownerDocument) {
	        this.ownerDocument().populated(this.$__fullPath(path),
	          val._id, {model: val.constructor});
	      } else {
	        this.populated(path, val._id, {model: val.constructor});
	      }
	      didPopulate = true;
	    }
	
	    var popOpts;
	    if (schema.options &&
	        Array.isArray(schema.options.type) &&
	        schema.options.type.length &&
	        schema.options.type[0].ref &&
	        Array.isArray(val) &&
	        val.length > 0 &&
	        val[0] instanceof Document &&
	        val[0].constructor.modelName &&
	        schema.options.type[0].ref === val[0].constructor.modelName) {
	      if (this.ownerDocument) {
	        popOpts = { model: val[0].constructor };
	        this.ownerDocument().populated(this.$__fullPath(path),
	          val.map(function(v) { return v._id; }), popOpts);
	      } else {
	        popOpts = { model: val[0].constructor };
	        this.populated(path, val.map(function(v) { return v._id; }), popOpts);
	      }
	      didPopulate = true;
	    }
	    val = schema.applySetters(val, this, false, priorVal);
	
	    if (!didPopulate && this.$__.populated) {
	      delete this.$__.populated[path];
	    }
	
	    this.$markValid(path);
	  } catch (e) {
	    this.invalidate(path,
	      new MongooseError.CastError(schema.instance, val, path, e));
	    shouldSet = false;
	  }
	
	  if (schema.$isSingleNested) {
	    cleanModifiedSubpaths(this, path);
	  }
	
	  if (shouldSet) {
	    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
	  }
	
	  return this;
	};
	
	/*!
	 * ignore
	 */
	
	function cleanModifiedSubpaths(doc, path) {
	  var _modifiedPaths = Object.keys(doc.$__.activePaths.states.modify);
	  var _numModifiedPaths = _modifiedPaths.length;
	  for (var j = 0; j < _numModifiedPaths; ++j) {
	    if (_modifiedPaths[j].indexOf(path + '.') === 0) {
	      delete doc.$__.activePaths.states.modify[_modifiedPaths[j]];
	    }
	  }
	}
	
	/**
	 * Determine if we should mark this change as modified.
	 *
	 * @return {Boolean}
	 * @api private
	 * @method $__shouldModify
	 * @memberOf Document
	 */
	
	Document.prototype.$__shouldModify = function(pathToMark, path, constructing, parts, schema, val, priorVal) {
	  if (this.isNew) {
	    return true;
	  }
	
	  if (undefined === val && !this.isSelected(path)) {
	    // when a path is not selected in a query, its initial
	    // value will be undefined.
	    return true;
	  }
	
	  if (undefined === val && path in this.$__.activePaths.states.default) {
	    // we're just unsetting the default value which was never saved
	    return false;
	  }
	
	  // gh-3992: if setting a populated field to a doc, don't mark modified
	  // if they have the same _id
	  if (this.populated(path) &&
	      val instanceof Document &&
	      deepEqual(val._id, priorVal)) {
	    return false;
	  }
	
	  if (!deepEqual(val, priorVal || this.get(path))) {
	    return true;
	  }
	
	  if (!constructing &&
	      val !== null &&
	      val !== undefined &&
	      path in this.$__.activePaths.states.default &&
	      deepEqual(val, schema.getDefault(this, constructing))) {
	    // a path with a default was $unset on the server
	    // and the user is setting it to the same value again
	    return true;
	  }
	  return false;
	};
	
	/**
	 * Handles the actual setting of the value and marking the path modified if appropriate.
	 *
	 * @api private
	 * @method $__set
	 * @memberOf Document
	 */
	
	Document.prototype.$__set = function(pathToMark, path, constructing, parts, schema, val, priorVal) {
	  Embedded = Embedded || __webpack_require__(252);
	
	  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,
	    schema, val, priorVal);
	  var _this = this;
	
	  if (shouldModify) {
	    this.markModified(pathToMark, val);
	
	    // handle directly setting arrays (gh-1126)
	    MongooseArray || (MongooseArray = __webpack_require__(255));
	    if (val && val.isMongooseArray) {
	      val._registerAtomic('$set', val);
	
	      // Small hack for gh-1638: if we're overwriting the entire array, ignore
	      // paths that were modified before the array overwrite
	      this.$__.activePaths.forEach(function(modifiedPath) {
	        if (modifiedPath.indexOf(path + '.') === 0) {
	          _this.$__.activePaths.ignore(modifiedPath);
	        }
	      });
	    }
	  }
	
	  var obj = this._doc,
	      i = 0,
	      l = parts.length;
	
	  for (; i < l; i++) {
	    var next = i + 1,
	        last = next === l;
	
	    if (last) {
	      obj[parts[i]] = val;
	    } else {
	      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === 'Object') {
	        obj = obj[parts[i]];
	      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {
	        obj = obj[parts[i]];
	      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {
	        obj = obj[parts[i]];
	      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {
	        obj = obj[parts[i]];
	      } else {
	        obj = obj[parts[i]] = {};
	      }
	    }
	  }
	};
	
	/**
	 * Gets a raw value from a path (no getters)
	 *
	 * @param {String} path
	 * @api private
	 */
	
	Document.prototype.getValue = function(path) {
	  return utils.getValue(path, this._doc);
	};
	
	/**
	 * Sets a raw value for a path (no casting, setters, transformations)
	 *
	 * @param {String} path
	 * @param {Object} value
	 * @api private
	 */
	
	Document.prototype.setValue = function(path, val) {
	  utils.setValue(path, val, this._doc);
	  return this;
	};
	
	/**
	 * Returns the value of a path.
	 *
	 * ####Example
	 *
	 *     // path
	 *     doc.get('age') // 47
	 *
	 *     // dynamic casting to a string
	 *     doc.get('age', String) // "47"
	 *
	 * @param {String} path
	 * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes
	 * @api public
	 */
	
	Document.prototype.get = function(path, type) {
	  var adhoc;
	  if (type) {
	    adhoc = Schema.interpretAsType(path, type, this.schema.options);
	  }
	
	  var schema = this.$__path(path) || this.schema.virtualpath(path),
	      pieces = path.split('.'),
	      obj = this._doc;
	
	  for (var i = 0, l = pieces.length; i < l; i++) {
	    obj = obj === null || obj === void 0
	        ? undefined
	        : obj[pieces[i]];
	  }
	
	  if (adhoc) {
	    obj = adhoc.cast(obj);
	  }
	
	  // Check if this path is populated - don't apply getters if it is,
	  // because otherwise its a nested object. See gh-3357
	  if (schema && !this.populated(path)) {
	    obj = schema.applyGetters(obj, this);
	  }
	
	  return obj;
	};
	
	/**
	 * Returns the schematype for the given `path`.
	 *
	 * @param {String} path
	 * @api private
	 * @method $__path
	 * @memberOf Document
	 */
	
	Document.prototype.$__path = function(path) {
	  var adhocs = this.$__.adhocPaths,
	      adhocType = adhocs && adhocs[path];
	
	  if (adhocType) {
	    return adhocType;
	  }
	  return this.schema.path(path);
	};
	
	/**
	 * Marks the path as having pending changes to write to the db.
	 *
	 * _Very helpful when using [Mixed](./schematypes.html#mixed) types._
	 *
	 * ####Example:
	 *
	 *     doc.mixed.type = 'changed';
	 *     doc.markModified('mixed.type');
	 *     doc.save() // changes to mixed.type are now persisted
	 *
	 * @param {String} path the path to mark modified
	 * @api public
	 */
	
	Document.prototype.markModified = function(path) {
	  this.$__.activePaths.modify(path);
	};
	
	/**
	 * Clears the modified state on the specified path.
	 *
	 * ####Example:
	 *
	 *     doc.foo = 'bar';
	 *     doc.unmarkModified('foo');
	 *     doc.save() // changes to foo will not be persisted
	 *
	 * @param {String} path the path to unmark modified
	 * @api public
	 */
	
	Document.prototype.unmarkModified = function(path) {
	  this.$__.activePaths.init(path);
	};
	
	/**
	 * Returns the list of paths that have been modified.
	 *
	 * @return {Array}
	 * @api public
	 */
	
	Document.prototype.modifiedPaths = function() {
	  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
	  return directModifiedPaths.reduce(function(list, path) {
	    var parts = path.split('.');
	    return list.concat(parts.reduce(function(chains, part, i) {
	      return chains.concat(parts.slice(0, i).concat(part).join('.'));
	    }, []).filter(function(chain) {
	      return (list.indexOf(chain) === -1);
	    }));
	  }, []);
	};
	
	/**
	 * Returns true if this document was modified, else false.
	 *
	 * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.
	 *
	 * ####Example
	 *
	 *     doc.set('documents.0.title', 'changed');
	 *     doc.isModified()                      // true
	 *     doc.isModified('documents')           // true
	 *     doc.isModified('documents.0.title')   // true
	 *     doc.isModified('documents otherProp') // true
	 *     doc.isDirectModified('documents')     // false
	 *
	 * @param {String} [path] optional
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.isModified = function(paths) {
	  if (paths) {
	    if (!Array.isArray(paths)) {
	      paths = paths.split(' ');
	    }
	    var modified = this.modifiedPaths();
	    return paths.some(function(path) {
	      return !!~modified.indexOf(path);
	    });
	  }
	  return this.$__.activePaths.some('modify');
	};
	
	/**
	 * Checks if a path is set to its default.
	 *
	 * ####Example
	 *
	 *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });
	 *     var m = new MyModel();
	 *     m.$isDefault('name');               // true
	 *
	 * @param {String} [path]
	 * @return {Boolean}
	 * @method $isDefault
	 * @api public
	 */
	
	Document.prototype.$isDefault = function(path) {
	  return (path in this.$__.activePaths.states.default);
	};
	
	/**
	 * Returns true if `path` was directly set and modified, else false.
	 *
	 * ####Example
	 *
	 *     doc.set('documents.0.title', 'changed');
	 *     doc.isDirectModified('documents.0.title') // true
	 *     doc.isDirectModified('documents') // false
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.isDirectModified = function(path) {
	  return (path in this.$__.activePaths.states.modify);
	};
	
	/**
	 * Checks if `path` was initialized.
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.isInit = function(path) {
	  return (path in this.$__.activePaths.states.init);
	};
	
	/**
	 * Checks if `path` was selected in the source query which initialized this document.
	 *
	 * ####Example
	 *
	 *     Thing.findOne().select('name').exec(function (err, doc) {
	 *        doc.isSelected('name') // true
	 *        doc.isSelected('age')  // false
	 *     })
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.isSelected = function isSelected(path) {
	  if (this.$__.selected) {
	    if (path === '_id') {
	      return this.$__.selected._id !== 0;
	    }
	
	    var paths = Object.keys(this.$__.selected),
	        i = paths.length,
	        inclusive = false,
	        cur;
	
	    if (i === 1 && paths[0] === '_id') {
	      // only _id was selected.
	      return this.$__.selected._id === 0;
	    }
	
	    while (i--) {
	      cur = paths[i];
	      if (cur === '_id') {
	        continue;
	      }
	      inclusive = !!this.$__.selected[cur];
	      break;
	    }
	
	    if (path in this.$__.selected) {
	      return inclusive;
	    }
	
	    i = paths.length;
	    var pathDot = path + '.';
	
	    while (i--) {
	      cur = paths[i];
	      if (cur === '_id') {
	        continue;
	      }
	
	      if (cur.indexOf(pathDot) === 0) {
	        return inclusive;
	      }
	
	      if (pathDot.indexOf(cur + '.') === 0) {
	        return inclusive;
	      }
	    }
	
	    return !inclusive;
	  }
	
	  return true;
	};
	
	/**
	 * Executes registered validation rules for this document.
	 *
	 * ####Note:
	 *
	 * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.
	 *
	 * ####Example:
	 *
	 *     doc.validate(function (err) {
	 *       if (err) handleError(err);
	 *       else // validation passed
	 *     });
	 *
	 * @param {Object} optional options internal options
	 * @param {Function} callback optional callback called after validation completes, passing an error if one occurred
	 * @return {Promise} Promise
	 * @api public
	 */
	
	Document.prototype.validate = function(options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = null;
	  }
	
	  this.$__validate(callback);
	};
	
	/*!
	 * ignore
	 */
	
	function _getPathsToValidate(doc) {
	  // only validate required fields when necessary
	  var paths = Object.keys(doc.$__.activePaths.states.require).filter(function(path) {
	    if (!doc.isSelected(path) && !doc.isModified(path)) {
	      return false;
	    }
	    var p = doc.schema.path(path);
	    if (typeof p.originalRequiredValue === 'function') {
	      return p.originalRequiredValue.call(doc);
	    }
	    return true;
	  });
	
	  paths = paths.concat(Object.keys(doc.$__.activePaths.states.init));
	  paths = paths.concat(Object.keys(doc.$__.activePaths.states.modify));
	  paths = paths.concat(Object.keys(doc.$__.activePaths.states.default));
	
	  // gh-661: if a whole array is modified, make sure to run validation on all
	  // the children as well
	  for (var i = 0; i < paths.length; ++i) {
	    var path = paths[i];
	    var val = doc.getValue(path);
	    if (val && val.isMongooseArray && !Buffer.isBuffer(val) && !val.isMongooseDocumentArray) {
	      var numElements = val.length;
	      for (var j = 0; j < numElements; ++j) {
	        paths.push(path + '.' + j);
	      }
	    }
	  }
	
	  var flattenOptions = { skipArrays: true };
	  for (i = 0; i < paths.length; ++i) {
	    var pathToCheck = paths[i];
	    if (doc.schema.nested[pathToCheck]) {
	      var _v = doc.getValue(pathToCheck);
	      if (isMongooseObject(_v)) {
	        _v = _v.toObject({ virtuals: false });
	      }
	      var flat = flatten(_v, '', flattenOptions);
	      var _subpaths = Object.keys(flat).map(function(p) {
	        return pathToCheck + '.' + p;
	      });
	      paths = paths.concat(_subpaths);
	    }
	  }
	
	  return paths;
	}
	
	/*!
	 * ignore
	 */
	
	Document.prototype.$__validate = function(callback) {
	  var _this = this;
	  var _complete = function() {
	    var err = _this.$__.validationError;
	    _this.$__.validationError = undefined;
	    _this.emit('validate', _this);
	    if (err) {
	      for (var key in err.errors) {
	        // Make sure cast errors persist
	        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {
	          _this.invalidate(key, err.errors[key]);
	        }
	      }
	
	      return err;
	    }
	  };
	
	  // only validate required fields when necessary
	  var paths = _getPathsToValidate(this);
	
	  if (paths.length === 0) {
	    process.nextTick(function() {
	      var err = _complete();
	      if (err) {
	        callback(err);
	        return;
	      }
	      callback();
	    });
	  }
	
	  var validating = {},
	      total = 0;
	
	  var complete = function() {
	    var err = _complete();
	    if (err) {
	      callback(err);
	      return;
	    }
	    callback();
	  };
	
	  var validatePath = function(path) {
	    if (validating[path]) {
	      return;
	    }
	
	    validating[path] = true;
	    total++;
	
	    process.nextTick(function() {
	      var p = _this.schema.path(path);
	      if (!p) {
	        return --total || complete();
	      }
	
	      // If user marked as invalid or there was a cast error, don't validate
	      if (!_this.$isValid(path)) {
	        --total || complete();
	        return;
	      }
	
	      var val = _this.getValue(path);
	      p.doValidate(val, function(err) {
	        if (err) {
	          _this.invalidate(path, err, undefined, true);
	        }
	        --total || complete();
	      }, _this);
	    });
	  };
	
	  paths.forEach(validatePath);
	};
	
	/**
	 * Executes registered validation rules (skipping asynchronous validators) for this document.
	 *
	 * ####Note:
	 *
	 * This method is useful if you need synchronous validation.
	 *
	 * ####Example:
	 *
	 *     var err = doc.validateSync();
	 *     if ( err ){
	 *       handleError( err );
	 *     } else {
	 *       // validation passed
	 *     }
	 *
	 * @param {Array|string} pathsToValidate only validate the given paths
	 * @return {MongooseError|undefined} MongooseError if there are errors during validation, or undefined if there is no error.
	 * @api public
	 */
	
	Document.prototype.validateSync = function(pathsToValidate) {
	  var _this = this;
	
	  if (typeof pathsToValidate === 'string') {
	    pathsToValidate = pathsToValidate.split(' ');
	  }
	
	  // only validate required fields when necessary
	  var paths = _getPathsToValidate(this);
	
	  if (pathsToValidate && pathsToValidate.length) {
	    var tmp = [];
	    for (var i = 0; i < paths.length; ++i) {
	      if (pathsToValidate.indexOf(paths[i]) !== -1) {
	        tmp.push(paths[i]);
	      }
	    }
	    paths = tmp;
	  }
	
	  var validating = {};
	
	  paths.forEach(function(path) {
	    if (validating[path]) {
	      return;
	    }
	
	    validating[path] = true;
	
	    var p = _this.schema.path(path);
	    if (!p) {
	      return;
	    }
	    if (!_this.$isValid(path)) {
	      return;
	    }
	
	    var val = _this.getValue(path);
	    var err = p.doValidateSync(val, _this);
	    if (err) {
	      _this.invalidate(path, err, undefined, true);
	    }
	  });
	
	  var err = _this.$__.validationError;
	  _this.$__.validationError = undefined;
	  _this.emit('validate', _this);
	
	  if (err) {
	    for (var key in err.errors) {
	      // Make sure cast errors persist
	      if (err.errors[key] instanceof MongooseError.CastError) {
	        _this.invalidate(key, err.errors[key]);
	      }
	    }
	  }
	
	  return err;
	};
	
	/**
	 * Marks a path as invalid, causing validation to fail.
	 *
	 * The `errorMsg` argument will become the message of the `ValidationError`.
	 *
	 * The `value` argument (if passed) will be available through the `ValidationError.value` property.
	 *
	 *     doc.invalidate('size', 'must be less than 20', 14);
	
	 *     doc.validate(function (err) {
	 *       console.log(err)
	 *       // prints
	 *       { message: 'Validation failed',
	 *         name: 'ValidationError',
	 *         errors:
	 *          { size:
	 *             { message: 'must be less than 20',
	 *               name: 'ValidatorError',
	 *               path: 'size',
	 *               type: 'user defined',
	 *               value: 14 } } }
	 *     })
	 *
	 * @param {String} path the field to invalidate
	 * @param {String|Error} errorMsg the error which states the reason `path` was invalid
	 * @param {Object|String|Number|any} value optional invalid value
	 * @param {String} [kind] optional `kind` property for the error
	 * @return {ValidationError} the current ValidationError, with all currently invalidated paths
	 * @api public
	 */
	
	Document.prototype.invalidate = function(path, err, val, kind) {
	  if (!this.$__.validationError) {
	    this.$__.validationError = new ValidationError(this);
	  }
	
	  if (this.$__.validationError.errors[path]) {
	    return;
	  }
	
	  if (!err || typeof err === 'string') {
	    err = new ValidatorError({
	      path: path,
	      message: err,
	      type: kind || 'user defined',
	      value: val
	    });
	  }
	
	  if (this.$__.validationError === err) {
	    return this.$__.validationError;
	  }
	
	  this.$__.validationError.errors[path] = err;
	  return this.$__.validationError;
	};
	
	/**
	 * Marks a path as valid, removing existing validation errors.
	 *
	 * @param {String} path the field to mark as valid
	 * @api private
	 * @method $markValid
	 * @receiver Document
	 */
	
	Document.prototype.$markValid = function(path) {
	  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {
	    return;
	  }
	
	  delete this.$__.validationError.errors[path];
	  if (Object.keys(this.$__.validationError.errors).length === 0) {
	    this.$__.validationError = null;
	  }
	};
	
	/**
	 * Checks if a path is invalid
	 *
	 * @param {String} path the field to check
	 * @method $isValid
	 * @api private
	 * @receiver Document
	 */
	
	Document.prototype.$isValid = function(path) {
	  return !this.$__.validationError || !this.$__.validationError.errors[path];
	};
	
	/**
	 * Resets the internal modified state of this document.
	 *
	 * @api private
	 * @return {Document}
	 * @method $__reset
	 * @memberOf Document
	 */
	
	Document.prototype.$__reset = function reset() {
	  var _this = this;
	  DocumentArray || (DocumentArray = __webpack_require__(256));
	
	  this.$__.activePaths
	  .map('init', 'modify', function(i) {
	    return _this.getValue(i);
	  })
	  .filter(function(val) {
	    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
	  })
	  .forEach(function(array) {
	    var i = array.length;
	    while (i--) {
	      var doc = array[i];
	      if (!doc) {
	        continue;
	      }
	      doc.$__reset();
	    }
	  });
	
	  // clear atomics
	  this.$__dirty().forEach(function(dirt) {
	    var type = dirt.value;
	    if (type && type._atomics) {
	      type._atomics = {};
	    }
	  });
	
	  // Clear 'dirty' cache
	  this.$__.activePaths.clear('modify');
	  this.$__.activePaths.clear('default');
	  this.$__.validationError = undefined;
	  this.errors = undefined;
	  _this = this;
	  this.schema.requiredPaths().forEach(function(path) {
	    _this.$__.activePaths.require(path);
	  });
	
	  return this;
	};
	
	/**
	 * Returns this documents dirty paths / vals.
	 *
	 * @api private
	 * @method $__dirty
	 * @memberOf Document
	 */
	
	Document.prototype.$__dirty = function() {
	  var _this = this;
	
	  var all = this.$__.activePaths.map('modify', function(path) {
	    return {
	      path: path,
	      value: _this.getValue(path),
	      schema: _this.$__path(path)
	    };
	  });
	
	  // gh-2558: if we had to set a default and the value is not undefined,
	  // we have to save as well
	  all = all.concat(this.$__.activePaths.map('default', function(path) {
	    if (path === '_id' || !_this.getValue(path)) {
	      return;
	    }
	    return {
	      path: path,
	      value: _this.getValue(path),
	      schema: _this.$__path(path)
	    };
	  }));
	
	  // Sort dirty paths in a flat hierarchy.
	  all.sort(function(a, b) {
	    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));
	  });
	
	  // Ignore "foo.a" if "foo" is dirty already.
	  var minimal = [],
	      lastPath,
	      top;
	
	  all.forEach(function(item) {
	    if (!item) {
	      return;
	    }
	    if (item.path.indexOf(lastPath) !== 0) {
	      lastPath = item.path + '.';
	      minimal.push(item);
	      top = item;
	    } else {
	      // special case for top level MongooseArrays
	      if (top.value && top.value._atomics && top.value.hasAtomics()) {
	        // the `top` array itself and a sub path of `top` are being modified.
	        // the only way to honor all of both modifications is through a $set
	        // of entire array.
	        top.value._atomics = {};
	        top.value._atomics.$set = top.value;
	      }
	    }
	  });
	
	  top = lastPath = null;
	  return minimal;
	};
	
	/*!
	 * Compiles schemas.
	 */
	
	function compile(tree, proto, prefix, options) {
	  var keys = Object.keys(tree),
	      i = keys.length,
	      limb,
	      key;
	
	  while (i--) {
	    key = keys[i];
	    limb = tree[key];
	
	    defineKey(key,
	        ((utils.getFunctionName(limb.constructor) === 'Object'
	        && Object.keys(limb).length)
	        && (!limb[options.typeKey] || (options.typeKey === 'type' && limb.type.type))
	            ? limb
	            : null)
	        , proto
	        , prefix
	        , keys
	        , options);
	  }
	}
	
	// gets descriptors for all properties of `object`
	// makes all properties non-enumerable to match previous behavior to #2211
	function getOwnPropertyDescriptors(object) {
	  var result = {};
	
	  Object.getOwnPropertyNames(object).forEach(function(key) {
	    result[key] = Object.getOwnPropertyDescriptor(object, key);
	    result[key].enumerable = true;
	  });
	
	  return result;
	}
	
	/*!
	 * Defines the accessor named prop on the incoming prototype.
	 */
	
	function defineKey(prop, subprops, prototype, prefix, keys, options) {
	  var path = (prefix ? prefix + '.' : '') + prop;
	  prefix = prefix || '';
	
	  if (subprops) {
	    Object.defineProperty(prototype, prop, {
	      enumerable: true,
	      configurable: true,
	      get: function() {
	        var _this = this;
	        if (!this.$__.getters) {
	          this.$__.getters = {};
	        }
	
	        if (!this.$__.getters[path]) {
	          var nested = Object.create(Object.getPrototypeOf(this), getOwnPropertyDescriptors(this));
	
	          // save scope for nested getters/setters
	          if (!prefix) {
	            nested.$__.scope = this;
	          }
	
	          // shadow inherited getters from sub-objects so
	          // thing.nested.nested.nested... doesn't occur (gh-366)
	          var i = 0,
	              len = keys.length;
	
	          for (; i < len; ++i) {
	            // over-write the parents getter without triggering it
	            Object.defineProperty(nested, keys[i], {
	              enumerable: false,    // It doesn't show up.
	              writable: true,       // We can set it later.
	              configurable: true,   // We can Object.defineProperty again.
	              value: undefined      // It shadows its parent.
	            });
	          }
	
	          Object.defineProperty(nested, 'toObject', {
	            enumerable: true,
	            configurable: true,
	            writable: false,
	            value: function() {
	              return _this.get(path);
	            }
	          });
	
	          Object.defineProperty(nested, 'toJSON', {
	            enumerable: true,
	            configurable: true,
	            writable: false,
	            value: function() {
	              return _this.get(path);
	            }
	          });
	
	          Object.defineProperty(nested, '$__isNested', {
	            enumerable: true,
	            configurable: true,
	            writable: false,
	            value: true
	          });
	
	          compile(subprops, nested, path, options);
	          this.$__.getters[path] = nested;
	        }
	
	        return this.$__.getters[path];
	      },
	      set: function(v) {
	        if (v instanceof Document) {
	          v = v.toObject();
	        }
	        return (this.$__.scope || this).set(path, v);
	      }
	    });
	  } else {
	    Object.defineProperty(prototype, prop, {
	      enumerable: true,
	      configurable: true,
	      get: function() {
	        return this.get.call(this.$__.scope || this, path);
	      },
	      set: function(v) {
	        return this.set.call(this.$__.scope || this, path, v);
	      }
	    });
	  }
	}
	
	/**
	 * Assigns/compiles `schema` into this documents prototype.
	 *
	 * @param {Schema} schema
	 * @api private
	 * @method $__setSchema
	 * @memberOf Document
	 */
	
	Document.prototype.$__setSchema = function(schema) {
	  compile(schema.tree, this, undefined, schema.options);
	  this.schema = schema;
	};
	
	
	/**
	 * Get active path that were changed and are arrays
	 *
	 * @api private
	 * @method $__getArrayPathsToValidate
	 * @memberOf Document
	 */
	
	Document.prototype.$__getArrayPathsToValidate = function() {
	  DocumentArray || (DocumentArray = __webpack_require__(256));
	
	  // validate all document arrays.
	  return this.$__.activePaths
	  .map('init', 'modify', function(i) {
	    return this.getValue(i);
	  }.bind(this))
	  .filter(function(val) {
	    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
	  }).reduce(function(seed, array) {
	    return seed.concat(array);
	  }, [])
	  .filter(function(doc) {
	    return doc;
	  });
	};
	
	
	/**
	 * Get all subdocs (by bfs)
	 *
	 * @api private
	 * @method $__getAllSubdocs
	 * @memberOf Document
	 */
	
	Document.prototype.$__getAllSubdocs = function() {
	  DocumentArray || (DocumentArray = __webpack_require__(256));
	  Embedded = Embedded || __webpack_require__(252);
	
	  function docReducer(seed, path) {
	    var val = this[path];
	
	    if (val instanceof Embedded) {
	      seed.push(val);
	    }
	    if (val && val.$isSingleNested) {
	      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);
	      seed.push(val);
	    }
	    if (val && val.isMongooseDocumentArray) {
	      val.forEach(function _docReduce(doc) {
	        if (!doc || !doc._doc) {
	          return;
	        }
	        if (doc instanceof Embedded) {
	          seed.push(doc);
	        }
	        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);
	      });
	    } else if (val instanceof Document && val.$__isNested) {
	      val = val.toObject();
	      if (val) {
	        seed = Object.keys(val).reduce(docReducer.bind(val), seed);
	      }
	    }
	    return seed;
	  }
	
	  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);
	
	  return subDocs;
	};
	
	/**
	 * Executes methods queued from the Schema definition
	 *
	 * @api private
	 * @method $__registerHooksFromSchema
	 * @memberOf Document
	 */
	
	Document.prototype.$__registerHooksFromSchema = function() {
	  Embedded = Embedded || __webpack_require__(252);
	  var Promise = PromiseProvider.get();
	
	  var _this = this;
	  var q = _this.schema && _this.schema.callQueue;
	  if (!q.length) {
	    return _this;
	  }
	
	  // we are only interested in 'pre' hooks, and group by point-cut
	  var toWrap = q.reduce(function(seed, pair) {
	    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {
	      _this[pair[0]].apply(_this, pair[1]);
	      return seed;
	    }
	    var args = [].slice.call(pair[1]);
	    var pointCut = pair[0] === 'on' ? 'post' : args[0];
	    if (!(pointCut in seed)) {
	      seed[pointCut] = {post: [], pre: []};
	    }
	    if (pair[0] === 'post') {
	      seed[pointCut].post.push(args);
	    } else if (pair[0] === 'on') {
	      seed[pointCut].push(args);
	    } else {
	      seed[pointCut].pre.push(args);
	    }
	    return seed;
	  }, {post: []});
	
	  // 'post' hooks are simpler
	  toWrap.post.forEach(function(args) {
	    _this.on.apply(_this, args);
	  });
	  delete toWrap.post;
	
	  // 'init' should be synchronous on subdocuments
	  if (toWrap.init && _this instanceof Embedded) {
	    if (toWrap.init.pre) {
	      toWrap.init.pre.forEach(function(args) {
	        _this.$pre.apply(_this, args);
	      });
	    }
	    if (toWrap.init.post) {
	      toWrap.init.post.forEach(function(args) {
	        _this.$post.apply(_this, args);
	      });
	    }
	    delete toWrap.init;
	  } else if (toWrap.set) {
	    // Set hooks also need to be sync re: gh-3479
	    if (toWrap.set.pre) {
	      toWrap.set.pre.forEach(function(args) {
	        _this.$pre.apply(_this, args);
	      });
	    }
	    if (toWrap.set.post) {
	      toWrap.set.post.forEach(function(args) {
	        _this.$post.apply(_this, args);
	      });
	    }
	    delete toWrap.set;
	  }
	
	  Object.keys(toWrap).forEach(function(pointCut) {
	    // this is so we can wrap everything into a promise;
	    var newName = ('$__original_' + pointCut);
	    if (!_this[pointCut]) {
	      return;
	    }
	    _this[newName] = _this[pointCut];
	    _this[pointCut] = function wrappedPointCut() {
	      var args = [].slice.call(arguments);
	      var lastArg = args.pop();
	      var fn;
	      var originalStack = new Error().stack;
	      var $results;
	      if (lastArg && typeof lastArg !== 'function') {
	        args.push(lastArg);
	      } else {
	        fn = lastArg;
	      }
	
	      var promise = new Promise.ES6(function(resolve, reject) {
	        args.push(function(error) {
	          if (error) {
	            // gh-2633: since VersionError is very generic, take the
	            // stack trace of the original save() function call rather
	            // than the async trace
	            if (error instanceof VersionError) {
	              error.stack = originalStack;
	            }
	            _this.$__handleReject(error);
	            reject(error);
	            return;
	          }
	
	          // There may be multiple results and promise libs other than
	          // mpromise don't support passing multiple values to `resolve()`
	          $results = Array.prototype.slice.call(arguments, 1);
	          resolve.apply(promise, $results);
	        });
	
	        _this[newName].apply(_this, args);
	      });
	      if (fn) {
	        if (_this.constructor.$wrapCallback) {
	          fn = _this.constructor.$wrapCallback(fn);
	        }
	        return promise.then(
	          function() {
	            process.nextTick(function() {
	              fn.apply(null, [null].concat($results));
	            });
	          },
	          function(error) {
	            process.nextTick(function() {
	              fn(error);
	            });
	          });
	      }
	      return promise;
	    };
	
	    toWrap[pointCut].pre.forEach(function(args) {
	      args[0] = newName;
	      _this.$pre.apply(_this, args);
	    });
	    toWrap[pointCut].post.forEach(function(args) {
	      args[0] = newName;
	      _this.$post.apply(_this, args);
	    });
	  });
	  return _this;
	};
	
	Document.prototype.$__handleReject = function handleReject(err) {
	  // emit on the Model if listening
	  if (this.listeners('error').length) {
	    this.emit('error', err);
	  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {
	    this.constructor.emit('error', err);
	  } else if (this.listeners && this.listeners('error').length) {
	    this.emit('error', err);
	  }
	};
	
	/**
	 * Internal helper for toObject() and toJSON() that doesn't manipulate options
	 *
	 * @api private
	 * @method $toObject
	 * @memberOf Document
	 */
	
	Document.prototype.$toObject = function(options, json) {
	  var defaultOptions = {transform: true, json: json};
	
	  if (options && options.depopulate && !options._skipDepopulateTopLevel && this.$__.wasPopulated) {
	    // populated paths that we set to a document
	    return clone(this._id, options);
	  }
	
	  // If we're calling toObject on a populated doc, we may want to skip
	  // depopulated on the top level
	  if (options && options._skipDepopulateTopLevel) {
	    options._skipDepopulateTopLevel = false;
	  }
	
	  // When internally saving this document we always pass options,
	  // bypassing the custom schema options.
	  if (!(options && utils.getFunctionName(options.constructor) === 'Object') ||
	      (options && options._useSchemaOptions)) {
	    if (json) {
	      options = this.schema.options.toJSON ?
	        clone(this.schema.options.toJSON) :
	        {};
	      options.json = true;
	      options._useSchemaOptions = true;
	    } else {
	      options = this.schema.options.toObject ?
	        clone(this.schema.options.toObject) :
	        {};
	      options.json = false;
	      options._useSchemaOptions = true;
	    }
	  }
	
	  for (var key in defaultOptions) {
	    if (options[key] === undefined) {
	      options[key] = defaultOptions[key];
	    }
	  }
	
	  ('minimize' in options) || (options.minimize = this.schema.options.minimize);
	
	  // remember the root transform function
	  // to save it from being overwritten by sub-transform functions
	  var originalTransform = options.transform;
	
	  var ret = clone(this._doc, options) || {};
	
	  if (options.getters) {
	    applyGetters(this, ret, 'paths', options);
	    // applyGetters for paths will add nested empty objects;
	    // if minimize is set, we need to remove them.
	    if (options.minimize) {
	      ret = minimize(ret) || {};
	    }
	  }
	
	  if (options.virtuals || options.getters && options.virtuals !== false) {
	    applyGetters(this, ret, 'virtuals', options);
	  }
	
	  if (options.versionKey === false && this.schema.options.versionKey) {
	    delete ret[this.schema.options.versionKey];
	  }
	
	  var transform = options.transform;
	
	  // In the case where a subdocument has its own transform function, we need to
	  // check and see if the parent has a transform (options.transform) and if the
	  // child schema has a transform (this.schema.options.toObject) In this case,
	  // we need to adjust options.transform to be the child schema's transform and
	  // not the parent schema's
	  if (transform === true ||
	      (this.schema.options.toObject && transform)) {
	    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;
	
	    if (opts) {
	      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);
	    }
	  } else {
	    options.transform = originalTransform;
	  }
	
	  if (typeof transform === 'function') {
	    var xformed = transform(this, ret, options);
	    if (typeof xformed !== 'undefined') {
	      ret = xformed;
	    }
	  }
	
	  return ret;
	};
	
	/**
	 * Converts this document into a plain javascript object, ready for storage in MongoDB.
	 *
	 * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.
	 *
	 * ####Options:
	 *
	 * - `getters` apply all getters (path and virtual getters)
	 * - `virtuals` apply virtual getters (can override `getters` option)
	 * - `minimize` remove empty objects (defaults to true)
	 * - `transform` a transform function to apply to the resulting document before returning
	 * - `depopulate` depopulate any populated paths, replacing them with their original refs (defaults to false)
	 * - `versionKey` whether to include the version key (defaults to true)
	 * - `retainKeyOrder` keep the order of object keys. If this is set to true, `Object.keys(new Doc({ a: 1, b: 2}).toObject())` will always produce `['a', 'b']` (defaults to false)
	 *
	 * ####Getters/Virtuals
	 *
	 * Example of only applying path getters
	 *
	 *     doc.toObject({ getters: true, virtuals: false })
	 *
	 * Example of only applying virtual getters
	 *
	 *     doc.toObject({ virtuals: true })
	 *
	 * Example of applying both path and virtual getters
	 *
	 *     doc.toObject({ getters: true })
	 *
	 * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.
	 *
	 *     schema.set('toObject', { virtuals: true })
	 *
	 * ####Transform
	 *
	 * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.
	 *
	 * Transform functions receive three arguments
	 *
	 *     function (doc, ret, options) {}
	 *
	 * - `doc` The mongoose document which is being converted
	 * - `ret` The plain object representation which has been converted
	 * - `options` The options in use (either schema options or the options passed inline)
	 *
	 * ####Example
	 *
	 *     // specify the transform schema option
	 *     if (!schema.options.toObject) schema.options.toObject = {};
	 *     schema.options.toObject.transform = function (doc, ret, options) {
	 *       // remove the _id of every document before returning the result
	 *       delete ret._id;
	 *       return ret;
	 *     }
	 *
	 *     // without the transformation in the schema
	 *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }
	 *
	 *     // with the transformation
	 *     doc.toObject(); // { name: 'Wreck-it Ralph' }
	 *
	 * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:
	 *
	 *     if (!schema.options.toObject) schema.options.toObject = {};
	 *     schema.options.toObject.transform = function (doc, ret, options) {
	 *       return { movie: ret.name }
	 *     }
	 *
	 *     // without the transformation in the schema
	 *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }
	 *
	 *     // with the transformation
	 *     doc.toObject(); // { movie: 'Wreck-it Ralph' }
	 *
	 * _Note: if a transform function returns `undefined`, the return value will be ignored._
	 *
	 * Transformations may also be applied inline, overridding any transform set in the options:
	 *
	 *     function xform (doc, ret, options) {
	 *       return { inline: ret.name, custom: true }
	 *     }
	 *
	 *     // pass the transform as an inline option
	 *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }
	 *
	 * _Note: if you call `toObject` and pass any options, the transform declared in your schema options will __not__ be applied. To force its application pass `transform: true`_
	 *
	 *     if (!schema.options.toObject) schema.options.toObject = {};
	 *     schema.options.toObject.hide = '_id';
	 *     schema.options.toObject.transform = function (doc, ret, options) {
	 *       if (options.hide) {
	 *         options.hide.split(' ').forEach(function (prop) {
	 *           delete ret[prop];
	 *         });
	 *       }
	 *       return ret;
	 *     }
	 *
	 *     var doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });
	 *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }
	 *     doc.toObject({ hide: 'secret _id' });                  // { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }
	 *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }
	 *
	 * Transforms are applied _only to the document and are not applied to sub-documents_.
	 *
	 * Transforms, like all of these options, are also available for `toJSON`.
	 *
	 * See [schema options](/docs/guide.html#toObject) for some more details.
	 *
	 * _During save, no custom options are applied to the document before being sent to the database._
	 *
	 * @param {Object} [options]
	 * @return {Object} js object
	 * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html
	 * @api public
	 */
	
	Document.prototype.toObject = function(options) {
	  return this.$toObject(options);
	};
	
	/*!
	 * Minimizes an object, removing undefined values and empty objects
	 *
	 * @param {Object} object to minimize
	 * @return {Object}
	 */
	
	function minimize(obj) {
	  var keys = Object.keys(obj),
	      i = keys.length,
	      hasKeys,
	      key,
	      val;
	
	  while (i--) {
	    key = keys[i];
	    val = obj[key];
	
	    if (utils.isObject(val)) {
	      obj[key] = minimize(val);
	    }
	
	    if (undefined === obj[key]) {
	      delete obj[key];
	      continue;
	    }
	
	    hasKeys = true;
	  }
	
	  return hasKeys
	      ? obj
	      : undefined;
	}
	
	/*!
	 * Applies virtuals properties to `json`.
	 *
	 * @param {Document} self
	 * @param {Object} json
	 * @param {String} type either `virtuals` or `paths`
	 * @return {Object} `json`
	 */
	
	function applyGetters(self, json, type, options) {
	  var schema = self.schema,
	      paths = Object.keys(schema[type]),
	      i = paths.length,
	      path;
	
	  while (i--) {
	    path = paths[i];
	
	    var parts = path.split('.'),
	        plen = parts.length,
	        last = plen - 1,
	        branch = json,
	        part;
	
	    for (var ii = 0; ii < plen; ++ii) {
	      part = parts[ii];
	      if (ii === last) {
	        branch[part] = clone(self.get(path), options);
	      } else {
	        branch = branch[part] || (branch[part] = {});
	      }
	    }
	  }
	
	  return json;
	}
	
	/**
	 * The return value of this method is used in calls to JSON.stringify(doc).
	 *
	 * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.
	 *
	 *     schema.set('toJSON', { virtuals: true })
	 *
	 * See [schema options](/docs/guide.html#toJSON) for details.
	 *
	 * @param {Object} options
	 * @return {Object}
	 * @see Document#toObject #document_Document-toObject
	 * @api public
	 */
	
	Document.prototype.toJSON = function(options) {
	  return this.$toObject(options, true);
	};
	
	/**
	 * Helper for console.log
	 *
	 * @api public
	 */
	
	Document.prototype.inspect = function(options) {
	  var isPOJO = options &&
	    utils.getFunctionName(options.constructor) === 'Object';
	  var opts;
	  if (isPOJO) {
	    opts = options;
	    opts.minimize = false;
	    opts.retainKeyOrder = true;
	  }
	  return this.toObject(opts);
	};
	
	/**
	 * Helper for console.log
	 *
	 * @api public
	 * @method toString
	 */
	
	Document.prototype.toString = function() {
	  return inspect(this.inspect());
	};
	
	/**
	 * Returns true if the Document stores the same data as doc.
	 *
	 * Documents are considered equal when they have matching `_id`s, unless neither
	 * document has an `_id`, in which case this function falls back to using
	 * `deepEqual()`.
	 *
	 * @param {Document} doc a document to compare
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.equals = function(doc) {
	  if (!doc) {
	    return false;
	  }
	
	  var tid = this.get('_id');
	  var docid = doc.get ? doc.get('_id') : doc;
	  if (!tid && !docid) {
	    return deepEqual(this, doc);
	  }
	  return tid && tid.equals
	      ? tid.equals(docid)
	      : tid === docid;
	};
	
	/**
	 * Populates document references, executing the `callback` when complete.
	 * If you want to use promises instead, use this function with
	 * [`execPopulate()`](#document_Document-execPopulate)
	 *
	 * ####Example:
	 *
	 *     doc
	 *     .populate('company')
	 *     .populate({
	 *       path: 'notes',
	 *       match: /airline/,
	 *       select: 'text',
	 *       model: 'modelName'
	 *       options: opts
	 *     }, function (err, user) {
	 *       assert(doc._id === user._id) // the document itself is passed
	 *     })
	 *
	 *     // summary
	 *     doc.populate(path)                   // not executed
	 *     doc.populate(options);               // not executed
	 *     doc.populate(path, callback)         // executed
	 *     doc.populate(options, callback);     // executed
	 *     doc.populate(callback);              // executed
	 *     doc.populate(options).execPopulate() // executed, returns promise
	 *
	 *
	 * ####NOTE:
	 *
	 * Population does not occur unless a `callback` is passed *or* you explicitly
	 * call `execPopulate()`.
	 * Passing the same path a second time will overwrite the previous path options.
	 * See [Model.populate()](#model_Model.populate) for explaination of options.
	 *
	 * @see Model.populate #model_Model.populate
	 * @see Document.execPopulate #document_Document-execPopulate
	 * @param {String|Object} [path] The path to populate or an options object
	 * @param {Function} [callback] When passed, population is invoked
	 * @api public
	 * @return {Document} this
	 */
	
	Document.prototype.populate = function populate() {
	  if (arguments.length === 0) {
	    return this;
	  }
	
	  var pop = this.$__.populate || (this.$__.populate = {});
	  var args = utils.args(arguments);
	  var fn;
	
	  if (typeof args[args.length - 1] === 'function') {
	    fn = args.pop();
	  }
	
	  // allow `doc.populate(callback)`
	  if (args.length) {
	    // use hash to remove duplicate paths
	    var res = utils.populate.apply(null, args);
	    for (var i = 0; i < res.length; ++i) {
	      pop[res[i].path] = res[i];
	    }
	  }
	
	  if (fn) {
	    var paths = utils.object.vals(pop);
	    this.$__.populate = undefined;
	    paths.__noPromise = true;
	    this.constructor.populate(this, paths, fn);
	  }
	
	  return this;
	};
	
	/**
	 * Explicitly executes population and returns a promise. Useful for ES2015
	 * integration.
	 *
	 * ####Example:
	 *
	 *     var promise = doc.
	 *       populate('company').
	 *       populate({
	 *         path: 'notes',
	 *         match: /airline/,
	 *         select: 'text',
	 *         model: 'modelName'
	 *         options: opts
	 *       }).
	 *       execPopulate();
	 *
	 *     // summary
	 *     doc.execPopulate().then(resolve, reject);
	 *
	 *
	 * @see Document.populate #document_Document-populate
	 * @api public
	 * @return {Promise} promise that resolves to the document when population is done
	 */
	
	Document.prototype.execPopulate = function() {
	  var Promise = PromiseProvider.get();
	  var _this = this;
	  return new Promise.ES6(function(resolve, reject) {
	    _this.populate(function(error, res) {
	      if (error) {
	        reject(error);
	      } else {
	        resolve(res);
	      }
	    });
	  });
	};
	
	/**
	 * Gets _id(s) used during population of the given `path`.
	 *
	 * ####Example:
	 *
	 *     Model.findOne().populate('author').exec(function (err, doc) {
	 *       console.log(doc.author.name)         // Dr.Seuss
	 *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'
	 *     })
	 *
	 * If the path was not populated, undefined is returned.
	 *
	 * @param {String} path
	 * @return {Array|ObjectId|Number|Buffer|String|undefined}
	 * @api public
	 */
	
	Document.prototype.populated = function(path, val, options) {
	  // val and options are internal
	
	  if (val === null || val === void 0) {
	    if (!this.$__.populated) {
	      return undefined;
	    }
	    var v = this.$__.populated[path];
	    if (v) {
	      return v.value;
	    }
	    return undefined;
	  }
	
	  // internal
	
	  if (val === true) {
	    if (!this.$__.populated) {
	      return undefined;
	    }
	    return this.$__.populated[path];
	  }
	
	  this.$__.populated || (this.$__.populated = {});
	  this.$__.populated[path] = {value: val, options: options};
	  return val;
	};
	
	/**
	 * Takes a populated field and returns it to its unpopulated state.
	 *
	 * ####Example:
	 *
	 *     Model.findOne().populate('author').exec(function (err, doc) {
	 *       console.log(doc.author.name); // Dr.Seuss
	 *       console.log(doc.depopulate('author'));
	 *       console.log(doc.author); // '5144cf8050f071d979c118a7'
	 *     })
	 *
	 * If the path was not populated, this is a no-op.
	 *
	 * @param {String} path
	 * @see Document.populate #document_Document-populate
	 * @api public
	 */
	
	Document.prototype.depopulate = function(path) {
	  var populatedIds = this.populated(path);
	  if (!populatedIds) {
	    return;
	  }
	  delete this.$__.populated[path];
	  this.set(path, populatedIds);
	};
	
	
	/**
	 * Returns the full path to this document.
	 *
	 * @param {String} [path]
	 * @return {String}
	 * @api private
	 * @method $__fullPath
	 * @memberOf Document
	 */
	
	Document.prototype.$__fullPath = function(path) {
	  // overridden in SubDocuments
	  return path || '';
	};
	
	/*!
	 * Module exports.
	 */
	
	Document.ValidationError = ValidationError;
	module.exports = exports = Document;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer, __webpack_require__(6)))

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var SchemaType = __webpack_require__(231);
	var utils = __webpack_require__(223);
	
	/**
	 * Mixed SchemaType constructor.
	 *
	 * @param {String} path
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function Mixed(path, options) {
	  if (options && options.default) {
	    var def = options.default;
	    if (Array.isArray(def) && def.length === 0) {
	      // make sure empty array defaults are handled
	      options.default = Array;
	    } else if (!options.shared && utils.isObject(def) && Object.keys(def).length === 0) {
	      // prevent odd "shared" objects between documents
	      options.default = function() {
	        return {};
	      };
	    }
	  }
	
	  SchemaType.call(this, path, options, 'Mixed');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	Mixed.schemaName = 'Mixed';
	
	/*!
	 * Inherits from SchemaType.
	 */
	Mixed.prototype = Object.create(SchemaType.prototype);
	Mixed.prototype.constructor = Mixed;
	
	/**
	 * Casts `val` for Mixed.
	 *
	 * _this is a no-op_
	 *
	 * @param {Object} value to cast
	 * @api private
	 */
	
	Mixed.prototype.cast = function(val) {
	  return val;
	};
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $cond
	 * @param {any} [val]
	 * @api private
	 */
	
	Mixed.prototype.castForQuery = function($cond, val) {
	  if (arguments.length === 2) {
	    return val;
	  }
	  return $cond;
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = Mixed;


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module dependencies.
	 */
	
	var utils = __webpack_require__(223);
	var MongooseError = __webpack_require__(119);
	var CastError = MongooseError.CastError;
	var ValidatorError = MongooseError.ValidatorError;
	
	/**
	 * SchemaType constructor
	 *
	 * @param {String} path
	 * @param {Object} [options]
	 * @param {String} [instance]
	 * @api public
	 */
	
	function SchemaType(path, options, instance) {
	  this.path = path;
	  this.instance = instance;
	  this.validators = [];
	  this.setters = [];
	  this.getters = [];
	  this.options = options;
	  this._index = null;
	  this.selected;
	
	  for (var i in options) {
	    if (this[i] && typeof this[i] === 'function') {
	      // { unique: true, index: true }
	      if (i === 'index' && this._index) {
	        continue;
	      }
	
	      var opts = Array.isArray(options[i])
	          ? options[i]
	          : [options[i]];
	
	      this[i].apply(this, opts);
	    }
	  }
	}
	
	/**
	 * Sets a default value for this SchemaType.
	 *
	 * ####Example:
	 *
	 *     var schema = new Schema({ n: { type: Number, default: 10 })
	 *     var M = db.model('M', schema)
	 *     var m = new M;
	 *     console.log(m.n) // 10
	 *
	 * Defaults can be either `functions` which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.
	 *
	 * ####Example:
	 *
	 *     // values are cast:
	 *     var schema = new Schema({ aNumber: { type: Number, default: 4.815162342 }})
	 *     var M = db.model('M', schema)
	 *     var m = new M;
	 *     console.log(m.aNumber) // 4.815162342
	 *
	 *     // default unique objects for Mixed types:
	 *     var schema = new Schema({ mixed: Schema.Types.Mixed });
	 *     schema.path('mixed').default(function () {
	 *       return {};
	 *     });
	 *
	 *     // if we don't use a function to return object literals for Mixed defaults,
	 *     // each document will receive a reference to the same object literal creating
	 *     // a "shared" object instance:
	 *     var schema = new Schema({ mixed: Schema.Types.Mixed });
	 *     schema.path('mixed').default({});
	 *     var M = db.model('M', schema);
	 *     var m1 = new M;
	 *     m1.mixed.added = 1;
	 *     console.log(m1.mixed); // { added: 1 }
	 *     var m2 = new M;
	 *     console.log(m2.mixed); // { added: 1 }
	 *
	 * @param {Function|any} val the default value
	 * @return {defaultValue}
	 * @api public
	 */
	
	SchemaType.prototype.default = function(val) {
	  if (arguments.length === 1) {
	    if (val === void 0) {
	      this.defaultValue = void 0;
	      return void 0;
	    }
	    this.defaultValue = typeof val === 'function'
	        ? val
	        : this.cast(val);
	    return this.defaultValue;
	  } else if (arguments.length > 1) {
	    this.defaultValue = utils.args(arguments);
	  }
	  return this.defaultValue;
	};
	
	/**
	 * Declares the index options for this schematype.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ name: { type: String, index: true })
	 *     var s = new Schema({ loc: { type: [Number], index: 'hashed' })
	 *     var s = new Schema({ loc: { type: [Number], index: '2d', sparse: true })
	 *     var s = new Schema({ loc: { type: [Number], index: { type: '2dsphere', sparse: true }})
	 *     var s = new Schema({ date: { type: Date, index: { unique: true, expires: '1d' }})
	 *     Schema.path('my.path').index(true);
	 *     Schema.path('my.date').index({ expires: 60 });
	 *     Schema.path('my.path').index({ unique: true, sparse: true });
	 *
	 * ####NOTE:
	 *
	 * _Indexes are created in the background by default. Specify `background: false` to override._
	 *
	 * [Direction doesn't matter for single key indexes](http://www.mongodb.org/display/DOCS/Indexes#Indexes-CompoundKeysIndexes)
	 *
	 * @param {Object|Boolean|String} options
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.index = function(options) {
	  this._index = options;
	  utils.expires(this._index);
	  return this;
	};
	
	/**
	 * Declares an unique index.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ name: { type: String, unique: true }});
	 *     Schema.path('name').index({ unique: true });
	 *
	 * _NOTE: violating the constraint returns an `E11000` error from MongoDB when saving, not a Mongoose validation error._
	 *
	 * @param {Boolean} bool
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.unique = function(bool) {
	  if (this._index === false) {
	    if (!bool) {
	      return;
	    }
	    throw new Error('Path "' + this.path + '" may not have `index` set to ' +
	      'false and `unique` set to true');
	  }
	  if (this._index == null || this._index === true) {
	    this._index = {};
	  } else if (typeof this._index === 'string') {
	    this._index = {type: this._index};
	  }
	
	  this._index.unique = bool;
	  return this;
	};
	
	/**
	 * Declares a full text index.
	 *
	 * ###Example:
	 *
	 *      var s = new Schema({name : {type: String, text : true })
	 *      Schema.path('name').index({text : true});
	 * @param {Boolean} bool
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.text = function(bool) {
	  if (this._index === null || this._index === undefined ||
	    typeof this._index === 'boolean') {
	    this._index = {};
	  } else if (typeof this._index === 'string') {
	    this._index = {type: this._index};
	  }
	
	  this._index.text = bool;
	  return this;
	};
	
	/**
	 * Declares a sparse index.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ name: { type: String, sparse: true })
	 *     Schema.path('name').index({ sparse: true });
	 *
	 * @param {Boolean} bool
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.sparse = function(bool) {
	  if (this._index === null || this._index === undefined ||
	    typeof this._index === 'boolean') {
	    this._index = {};
	  } else if (typeof this._index === 'string') {
	    this._index = {type: this._index};
	  }
	
	  this._index.sparse = bool;
	  return this;
	};
	
	/**
	 * Adds a setter to this schematype.
	 *
	 * ####Example:
	 *
	 *     function capitalize (val) {
	 *       if (typeof val !== 'string') val = '';
	 *       return val.charAt(0).toUpperCase() + val.substring(1);
	 *     }
	 *
	 *     // defining within the schema
	 *     var s = new Schema({ name: { type: String, set: capitalize }})
	 *
	 *     // or by retreiving its SchemaType
	 *     var s = new Schema({ name: String })
	 *     s.path('name').set(capitalize)
	 *
	 * Setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.
	 *
	 * Suppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, avenue@q.com can be registered for 2 accounts via avenue@q.com and AvEnUe@Q.CoM.
	 *
	 * You can set up email lower case normalization easily via a Mongoose setter.
	 *
	 *     function toLower (v) {
	 *       return v.toLowerCase();
	 *     }
	 *
	 *     var UserSchema = new Schema({
	 *       email: { type: String, set: toLower }
	 *     })
	 *
	 *     var User = db.model('User', UserSchema)
	 *
	 *     var user = new User({email: 'AVENUE@Q.COM'})
	 *     console.log(user.email); // 'avenue@q.com'
	 *
	 *     // or
	 *     var user = new User
	 *     user.email = 'Avenue@Q.com'
	 *     console.log(user.email) // 'avenue@q.com'
	 *
	 * As you can see above, setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.
	 *
	 * _NOTE: we could have also just used the built-in `lowercase: true` SchemaType option instead of defining our own function._
	 *
	 *     new Schema({ email: { type: String, lowercase: true }})
	 *
	 * Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.
	 *
	 *     function inspector (val, schematype) {
	 *       if (schematype.options.required) {
	 *         return schematype.path + ' is required';
	 *       } else {
	 *         return val;
	 *       }
	 *     }
	 *
	 *     var VirusSchema = new Schema({
	 *       name: { type: String, required: true, set: inspector },
	 *       taxonomy: { type: String, set: inspector }
	 *     })
	 *
	 *     var Virus = db.model('Virus', VirusSchema);
	 *     var v = new Virus({ name: 'Parvoviridae', taxonomy: 'Parvovirinae' });
	 *
	 *     console.log(v.name);     // name is required
	 *     console.log(v.taxonomy); // Parvovirinae
	 *
	 * @param {Function} fn
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.set = function(fn) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('A setter must be a function.');
	  }
	  this.setters.push(fn);
	  return this;
	};
	
	/**
	 * Adds a getter to this schematype.
	 *
	 * ####Example:
	 *
	 *     function dob (val) {
	 *       if (!val) return val;
	 *       return (val.getMonth() + 1) + "/" + val.getDate() + "/" + val.getFullYear();
	 *     }
	 *
	 *     // defining within the schema
	 *     var s = new Schema({ born: { type: Date, get: dob })
	 *
	 *     // or by retreiving its SchemaType
	 *     var s = new Schema({ born: Date })
	 *     s.path('born').get(dob)
	 *
	 * Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.
	 *
	 * Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:
	 *
	 *     function obfuscate (cc) {
	 *       return '****-****-****-' + cc.slice(cc.length-4, cc.length);
	 *     }
	 *
	 *     var AccountSchema = new Schema({
	 *       creditCardNumber: { type: String, get: obfuscate }
	 *     });
	 *
	 *     var Account = db.model('Account', AccountSchema);
	 *
	 *     Account.findById(id, function (err, found) {
	 *       console.log(found.creditCardNumber); // '****-****-****-1234'
	 *     });
	 *
	 * Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.
	 *
	 *     function inspector (val, schematype) {
	 *       if (schematype.options.required) {
	 *         return schematype.path + ' is required';
	 *       } else {
	 *         return schematype.path + ' is not';
	 *       }
	 *     }
	 *
	 *     var VirusSchema = new Schema({
	 *       name: { type: String, required: true, get: inspector },
	 *       taxonomy: { type: String, get: inspector }
	 *     })
	 *
	 *     var Virus = db.model('Virus', VirusSchema);
	 *
	 *     Virus.findById(id, function (err, virus) {
	 *       console.log(virus.name);     // name is required
	 *       console.log(virus.taxonomy); // taxonomy is not
	 *     })
	 *
	 * @param {Function} fn
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.get = function(fn) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('A getter must be a function.');
	  }
	  this.getters.push(fn);
	  return this;
	};
	
	/**
	 * Adds validator(s) for this document path.
	 *
	 * Validators always receive the value to validate as their first argument and must return `Boolean`. Returning `false` means validation failed.
	 *
	 * The error message argument is optional. If not passed, the [default generic error message template](#error_messages_MongooseError-messages) will be used.
	 *
	 * ####Examples:
	 *
	 *     // make sure every value is equal to "something"
	 *     function validator (val) {
	 *       return val == 'something';
	 *     }
	 *     new Schema({ name: { type: String, validate: validator }});
	 *
	 *     // with a custom error message
	 *
	 *     var custom = [validator, 'Uh oh, {PATH} does not equal "something".']
	 *     new Schema({ name: { type: String, validate: custom }});
	 *
	 *     // adding many validators at a time
	 *
	 *     var many = [
	 *         { validator: validator, msg: 'uh oh' }
	 *       , { validator: anotherValidator, msg: 'failed' }
	 *     ]
	 *     new Schema({ name: { type: String, validate: many }});
	 *
	 *     // or utilizing SchemaType methods directly:
	 *
	 *     var schema = new Schema({ name: 'string' });
	 *     schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');
	 *
	 * ####Error message templates:
	 *
	 * From the examples above, you may have noticed that error messages support basic templating. There are a few other template keywords besides `{PATH}` and `{VALUE}` too. To find out more, details are available [here](#error_messages_MongooseError-messages)
	 *
	 * ####Asynchronous validation:
	 *
	 * Passing a validator function that receives two arguments tells mongoose that the validator is an asynchronous validator. The first argument passed to the validator function is the value being validated. The second argument is a callback function that must called when you finish validating the value and passed either `true` or `false` to communicate either success or failure respectively.
	 *
	 *     schema.path('name').validate(function (value, respond) {
	 *       doStuff(value, function () {
	 *         ...
	 *         respond(false); // validation failed
	 *       })
	 *     }, '{PATH} failed validation.');
	 *
	 *     // or with dynamic message
	 *
	 *     schema.path('name').validate(function (value, respond) {
	 *       doStuff(value, function () {
	 *         ...
	 *         respond(false, 'this message gets to the validation error');
	 *       });
	 *     }, 'this message does not matter');
	 *
	 * You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.
	 *
	 * Validation occurs `pre('save')` or whenever you manually execute [document#validate](#document_Document-validate).
	 *
	 * If validation fails during `pre('save')` and no callback was passed to receive the error, an `error` event will be emitted on your Models associated db [connection](#connection_Connection), passing the validation error object along.
	 *
	 *     var conn = mongoose.createConnection(..);
	 *     conn.on('error', handleError);
	 *
	 *     var Product = conn.model('Product', yourSchema);
	 *     var dvd = new Product(..);
	 *     dvd.save(); // emits error on the `conn` above
	 *
	 * If you desire handling these errors at the Model level, attach an `error` listener to your Model and the event will instead be emitted there.
	 *
	 *     // registering an error listener on the Model lets us handle errors more locally
	 *     Product.on('error', handleError);
	 *
	 * @param {RegExp|Function|Object} obj validator
	 * @param {String} [errorMsg] optional error message
	 * @param {String} [type] optional validator type
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.validate = function(obj, message, type) {
	  if (typeof obj === 'function' || obj && utils.getFunctionName(obj.constructor) === 'RegExp') {
	    var properties;
	    if (message instanceof Object && !type) {
	      properties = utils.clone(message);
	      if (!properties.message) {
	        properties.message = properties.msg;
	      }
	      properties.validator = obj;
	      properties.type = properties.type || 'user defined';
	    } else {
	      if (!message) {
	        message = MongooseError.messages.general.default;
	      }
	      if (!type) {
	        type = 'user defined';
	      }
	      properties = {message: message, type: type, validator: obj};
	    }
	    this.validators.push(properties);
	    return this;
	  }
	
	  var i,
	      length,
	      arg;
	
	  for (i = 0, length = arguments.length; i < length; i++) {
	    arg = arguments[i];
	    if (!(arg && utils.getFunctionName(arg.constructor) === 'Object')) {
	      var msg = 'Invalid validator. Received (' + typeof arg + ') '
	          + arg
	          + '. See http://mongoosejs.com/docs/api.html#schematype_SchemaType-validate';
	
	      throw new Error(msg);
	    }
	    this.validate(arg.validator, arg);
	  }
	
	  return this;
	};
	
	/**
	 * Adds a required validator to this SchemaType. The validator gets added
	 * to the front of this SchemaType's validators array using `unshift()`.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ born: { type: Date, required: true })
	 *
	 *     // or with custom error message
	 *
	 *     var s = new Schema({ born: { type: Date, required: '{PATH} is required!' })
	 *
	 *     // or through the path API
	 *
	 *     Schema.path('name').required(true);
	 *
	 *     // with custom error messaging
	 *
	 *     Schema.path('name').required(true, 'grrr :( ');
	 *
	 *     // or make a path conditionally required based on a function
	 *     var isOver18 = function() { return this.age >= 18; };
	 *     Schema.path('voterRegistrationId').required(isOver18);
	 *
	 * The required validator uses the SchemaType's `checkRequired` function to
	 * determine whether a given value satisfies the required validator. By default,
	 * a value satisfies the required validator if `val != null` (that is, if
	 * the value is not null nor undefined). However, most built-in mongoose schema
	 * types override the default `checkRequired` function:
	 *
	 * @param {Boolean} required enable/disable the validator
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @see SchemaArray#checkRequired #schema_array_SchemaArray.checkRequired
	 * @see SchemaBoolean#checkRequired #schema_boolean_SchemaBoolean-checkRequired
	 * @see SchemaBuffer#checkRequired #schema_buffer_SchemaBuffer.schemaName
	 * @see SchemaNumber#checkRequired #schema_number_SchemaNumber-min
	 * @see SchemaObjectId#checkRequired #schema_objectid_ObjectId-auto
	 * @see SchemaString#checkRequired #schema_string_SchemaString-checkRequired
	 * @api public
	 */
	
	SchemaType.prototype.required = function(required, message) {
	  if (required === false) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.requiredValidator;
	    }, this);
	
	    this.isRequired = false;
	    return this;
	  }
	
	  var _this = this;
	  this.isRequired = true;
	
	  this.requiredValidator = function(v) {
	    // in here, `this` refers to the validating document.
	    // no validation when this path wasn't selected in the query.
	    if ('isSelected' in this && !this.isSelected(_this.path) && !this.isModified(_this.path)) {
	      return true;
	    }
	
	    return ((typeof required === 'function') && !required.apply(this)) ||
	        _this.checkRequired(v, this);
	  };
	  this.originalRequiredValue = required;
	
	  if (typeof required === 'string') {
	    message = required;
	    required = undefined;
	  }
	
	  var msg = message || MongooseError.messages.general.required;
	  this.validators.unshift({
	    validator: this.requiredValidator,
	    message: msg,
	    type: 'required'
	  });
	
	  return this;
	};
	
	/**
	 * Gets the default value
	 *
	 * @param {Object} scope the scope which callback are executed
	 * @param {Boolean} init
	 * @api private
	 */
	
	SchemaType.prototype.getDefault = function(scope, init) {
	  var ret = typeof this.defaultValue === 'function'
	      ? this.defaultValue.call(scope)
	      : this.defaultValue;
	
	  if (ret !== null && ret !== undefined) {
	    var casted = this.cast(ret, scope, init);
	    if (casted && casted.$isSingleNested) {
	      casted.$parent = scope;
	    }
	    return casted;
	  }
	  return ret;
	};
	
	/**
	 * Applies setters
	 *
	 * @param {Object} value
	 * @param {Object} scope
	 * @param {Boolean} init
	 * @api private
	 */
	
	SchemaType.prototype.applySetters = function(value, scope, init, priorVal, options) {
	  var v = value,
	      setters = this.setters,
	      len = setters.length,
	      caster = this.caster;
	
	  while (len--) {
	    v = setters[len].call(scope, v, this);
	  }
	
	  if (Array.isArray(v) && caster && caster.setters) {
	    var newVal = [];
	    for (var i = 0; i < v.length; i++) {
	      newVal.push(caster.applySetters(v[i], scope, init, priorVal));
	    }
	    v = newVal;
	  }
	
	  if (v === null || v === undefined) {
	    return v;
	  }
	
	  // do not cast until all setters are applied #665
	  v = this.cast(v, scope, init, priorVal, options);
	
	  return v;
	};
	
	/**
	 * Applies getters to a value
	 *
	 * @param {Object} value
	 * @param {Object} scope
	 * @api private
	 */
	
	SchemaType.prototype.applyGetters = function(value, scope) {
	  var v = value,
	      getters = this.getters,
	      len = getters.length;
	
	  if (!len) {
	    return v;
	  }
	
	  while (len--) {
	    v = getters[len].call(scope, v, this);
	  }
	
	  return v;
	};
	
	/**
	 * Sets default `select()` behavior for this path.
	 *
	 * Set to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.
	 *
	 * ####Example:
	 *
	 *     T = db.model('T', new Schema({ x: { type: String, select: true }}));
	 *     T.find(..); // field x will always be selected ..
	 *     // .. unless overridden;
	 *     T.find().select('-x').exec(callback);
	 *
	 * @param {Boolean} val
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.select = function select(val) {
	  this.selected = !!val;
	  return this;
	};
	
	/**
	 * Performs a validation of `value` using the validators declared for this SchemaType.
	 *
	 * @param {any} value
	 * @param {Function} callback
	 * @param {Object} scope
	 * @api private
	 */
	
	SchemaType.prototype.doValidate = function(value, fn, scope) {
	  var err = false,
	      path = this.path,
	      count = this.validators.length;
	
	  if (!count) {
	    return fn(null);
	  }
	
	  var validate = function(ok, validatorProperties) {
	    if (err) {
	      return;
	    }
	    if (ok === undefined || ok) {
	      --count || fn(null);
	    } else {
	      err = new ValidatorError(validatorProperties);
	      fn(err);
	    }
	  };
	
	  var _this = this;
	  this.validators.forEach(function(v) {
	    if (err) {
	      return;
	    }
	
	    var validator = v.validator;
	
	    var validatorProperties = utils.clone(v);
	    validatorProperties.path = path;
	    validatorProperties.value = value;
	
	    if (validator instanceof RegExp) {
	      validate(validator.test(value), validatorProperties);
	    } else if (typeof validator === 'function') {
	      if (value === undefined && !_this.isRequired) {
	        validate(true, validatorProperties);
	        return;
	      }
	      if (validator.length === 2) {
	        var returnVal = validator.call(scope, value, function(ok, customMsg) {
	          if (typeof returnVal === 'boolean') {
	            return;
	          }
	          if (customMsg) {
	            validatorProperties.message = customMsg;
	          }
	          validate(ok, validatorProperties);
	        });
	        if (typeof returnVal === 'boolean') {
	          validate(returnVal, validatorProperties);
	        }
	      } else {
	        validate(validator.call(scope, value), validatorProperties);
	      }
	    }
	  });
	};
	
	/**
	 * Performs a validation of `value` using the validators declared for this SchemaType.
	 *
	 * ####Note:
	 *
	 * This method ignores the asynchronous validators.
	 *
	 * @param {any} value
	 * @param {Object} scope
	 * @return {MongooseError|undefined}
	 * @api private
	 */
	
	SchemaType.prototype.doValidateSync = function(value, scope) {
	  var err = null,
	      path = this.path,
	      count = this.validators.length;
	
	  if (!count) {
	    return null;
	  }
	
	  var validate = function(ok, validatorProperties) {
	    if (err) {
	      return;
	    }
	    if (ok !== undefined && !ok) {
	      err = new ValidatorError(validatorProperties);
	    }
	  };
	
	  var _this = this;
	  if (value === undefined && !_this.isRequired) {
	    return null;
	  }
	
	  this.validators.forEach(function(v) {
	    if (err) {
	      return;
	    }
	
	    var validator = v.validator;
	    var validatorProperties = utils.clone(v);
	    validatorProperties.path = path;
	    validatorProperties.value = value;
	
	    if (validator instanceof RegExp) {
	      validate(validator.test(value), validatorProperties);
	    } else if (typeof validator === 'function') {
	      // if not async validators
	      if (validator.length !== 2) {
	        validate(validator.call(scope, value), validatorProperties);
	      }
	    }
	  });
	
	  return err;
	};
	
	/**
	 * Determines if value is a valid Reference.
	 *
	 * @param {SchemaType} self
	 * @param {Object} value
	 * @param {Document} doc
	 * @param {Boolean} init
	 * @return {Boolean}
	 * @api private
	 */
	
	SchemaType._isRef = function(self, value, doc, init) {
	  // fast path
	  var ref = init && self.options && self.options.ref;
	
	  if (!ref && doc && doc.$__fullPath) {
	    // checks for
	    // - this populated with adhoc model and no ref was set in schema OR
	    // - setting / pushing values after population
	    var path = doc.$__fullPath(self.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    ref = owner.populated(path);
	  }
	
	  if (ref) {
	    if (value == null) {
	      return true;
	    }
	    if (!Buffer.isBuffer(value) &&  // buffers are objects too
	        value._bsontype !== 'Binary' // raw binary value from the db
	        && utils.isObject(value)    // might have deselected _id in population query
	    ) {
	      return true;
	    }
	  }
	
	  return false;
	};
	
	/*!
	 * ignore
	 */
	
	function handleSingle(val) {
	  return this.castForQuery(val);
	}
	
	/*!
	 * ignore
	 */
	
	function handleArray(val) {
	  var _this = this;
	  if (!Array.isArray(val)) {
	    return [this.castForQuery(val)];
	  }
	  return val.map(function(m) {
	    return _this.castForQuery(m);
	  });
	}
	
	/*!
	 * ignore
	 */
	
	SchemaType.prototype.$conditionalHandlers = {
	  $all: handleArray,
	  $eq: handleSingle,
	  $in: handleArray,
	  $ne: handleSingle,
	  $nin: handleArray
	};
	
	/**
	 * Cast the given value with the given optional query operator.
	 *
	 * @param {String} [$conditional] query operator, like `$eq` or `$in`
	 * @param {any} val
	 * @api private
	 */
	
	SchemaType.prototype.castForQuery = function($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler) {
	      throw new Error('Can\'t use ' + $conditional);
	    }
	    return handler.call(this, val);
	  }
	  val = $conditional;
	  return this.cast(val);
	};
	
	/**
	 * Default check for if this path satisfies the `required` validator.
	 *
	 * @param {any} val
	 * @api private
	 */
	
	SchemaType.prototype.checkRequired = function(val) {
	  return val != null;
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = SchemaType;
	
	exports.CastError = CastError;
	
	exports.ValidatorError = ValidatorError;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(119);
	
	/**
	 * Strict mode error constructor
	 *
	 * @param {String} type
	 * @param {String} value
	 * @inherits MongooseError
	 * @api private
	 */
	
	function ObjectExpectedError(path, val) {
	  MongooseError.call(this, 'Tried to set nested object field `' + path +
	    '` to primitive value `' + val + '` and strict mode is set to throw.');
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.name = 'ObjectExpectedError';
	  this.path = path;
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	ObjectExpectedError.prototype = Object.create(MongooseError.prototype);
	ObjectExpectedError.prototype.constructor = MongooseError;
	
	module.exports = ObjectExpectedError;


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(119);
	
	/**
	 * Strict mode error constructor
	 *
	 * @param {String} type
	 * @param {String} value
	 * @inherits MongooseError
	 * @api private
	 */
	
	function StrictModeError(path) {
	  MongooseError.call(this, 'Field `' + path + '` is not in schema and strict ' +
	    'mode is set to throw.');
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.name = 'StrictModeError';
	  this.path = path;
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	StrictModeError.prototype = Object.create(MongooseError.prototype);
	StrictModeError.prototype.constructor = MongooseError;
	
	module.exports = StrictModeError;


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Dependencies
	 */
	
	var StateMachine = __webpack_require__(235);
	var ActiveRoster = StateMachine.ctor('require', 'modify', 'init', 'default', 'ignore');
	
	module.exports = exports = InternalCache;
	
	function InternalCache() {
	  this.strictMode = undefined;
	  this.selected = undefined;
	  this.shardval = undefined;
	  this.saveError = undefined;
	  this.validationError = undefined;
	  this.adhocPaths = undefined;
	  this.removing = undefined;
	  this.inserting = undefined;
	  this.version = undefined;
	  this.getters = {};
	  this._id = undefined;
	  this.populate = undefined; // what we want to populate in this doc
	  this.populated = undefined;// the _ids that have been populated
	  this.wasPopulated = false; // if this doc was the result of a population
	  this.scope = undefined;
	  this.activePaths = new ActiveRoster;
	
	  // embedded docs
	  this.ownerDocument = undefined;
	  this.fullPath = undefined;
	}


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var utils = __webpack_require__(223);
	
	/*!
	 * StateMachine represents a minimal `interface` for the
	 * constructors it builds via StateMachine.ctor(...).
	 *
	 * @api private
	 */
	
	var StateMachine = module.exports = exports = function StateMachine() {
	};
	
	/*!
	 * StateMachine.ctor('state1', 'state2', ...)
	 * A factory method for subclassing StateMachine.
	 * The arguments are a list of states. For each state,
	 * the constructor's prototype gets state transition
	 * methods named after each state. These transition methods
	 * place their path argument into the given state.
	 *
	 * @param {String} state
	 * @param {String} [state]
	 * @return {Function} subclass constructor
	 * @private
	 */
	
	StateMachine.ctor = function() {
	  var states = utils.args(arguments);
	
	  var ctor = function() {
	    StateMachine.apply(this, arguments);
	    this.paths = {};
	    this.states = {};
	    this.stateNames = states;
	
	    var i = states.length,
	        state;
	
	    while (i--) {
	      state = states[i];
	      this.states[state] = {};
	    }
	  };
	
	  ctor.prototype = new StateMachine();
	
	  states.forEach(function(state) {
	    // Changes the `path`'s state to `state`.
	    ctor.prototype[state] = function(path) {
	      this._changeState(path, state);
	    };
	  });
	
	  return ctor;
	};
	
	/*!
	 * This function is wrapped by the state change functions:
	 *
	 * - `require(path)`
	 * - `modify(path)`
	 * - `init(path)`
	 *
	 * @api private
	 */
	
	StateMachine.prototype._changeState = function _changeState(path, nextState) {
	  var prevBucket = this.states[this.paths[path]];
	  if (prevBucket) delete prevBucket[path];
	
	  this.paths[path] = nextState;
	  this.states[nextState][path] = true;
	};
	
	/*!
	 * ignore
	 */
	
	StateMachine.prototype.clear = function clear(state) {
	  var keys = Object.keys(this.states[state]),
	      i = keys.length,
	      path;
	
	  while (i--) {
	    path = keys[i];
	    delete this.states[state][path];
	    delete this.paths[path];
	  }
	};
	
	/*!
	 * Checks to see if at least one path is in the states passed in via `arguments`
	 * e.g., this.some('required', 'inited')
	 *
	 * @param {String} state that we want to check for.
	 * @private
	 */
	
	StateMachine.prototype.some = function some() {
	  var _this = this;
	  var what = arguments.length ? arguments : this.stateNames;
	  return Array.prototype.some.call(what, function(state) {
	    return Object.keys(_this.states[state]).length;
	  });
	};
	
	/*!
	 * This function builds the functions that get assigned to `forEach` and `map`,
	 * since both of those methods share a lot of the same logic.
	 *
	 * @param {String} iterMethod is either 'forEach' or 'map'
	 * @return {Function}
	 * @api private
	 */
	
	StateMachine.prototype._iter = function _iter(iterMethod) {
	  return function() {
	    var numArgs = arguments.length,
	        states = utils.args(arguments, 0, numArgs - 1),
	        callback = arguments[numArgs - 1];
	
	    if (!states.length) states = this.stateNames;
	
	    var _this = this;
	
	    var paths = states.reduce(function(paths, state) {
	      return paths.concat(Object.keys(_this.states[state]));
	    }, []);
	
	    return paths[iterMethod](function(path, i, paths) {
	      return callback(path, i, paths);
	    });
	  };
	};
	
	/*!
	 * Iterates over the paths that belong to one of the parameter states.
	 *
	 * The function profile can look like:
	 * this.forEach(state1, fn);         // iterates over all paths in state1
	 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
	 * this.forEach(fn);                 // iterates over all paths in all states
	 *
	 * @param {String} [state]
	 * @param {String} [state]
	 * @param {Function} callback
	 * @private
	 */
	
	StateMachine.prototype.forEach = function forEach() {
	  this.forEach = this._iter('forEach');
	  return this.forEach.apply(this, arguments);
	};
	
	/*!
	 * Maps over the paths that belong to one of the parameter states.
	 *
	 * The function profile can look like:
	 * this.forEach(state1, fn);         // iterates over all paths in state1
	 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
	 * this.forEach(fn);                 // iterates over all paths in all states
	 *
	 * @param {String} [state]
	 * @param {String} [state]
	 * @param {Function} callback
	 * @return {Array}
	 * @private
	 */
	
	StateMachine.prototype.map = function map() {
	  this.map = this._iter('map');
	  return this.map.apply(this, arguments);
	};


/***/ },
/* 236 */
/***/ function(module, exports) {

	// TODO Add in pre and post skipping options
	module.exports = {
	  /**
	   *  Declares a new hook to which you can add pres and posts
	   *  @param {String} name of the function
	   *  @param {Function} the method
	   *  @param {Function} the error handler callback
	   */
	  hook: function (name, fn, errorCb) {
	    if (arguments.length === 1 && typeof name === 'object') {
	      for (var k in name) { // `name` is a hash of hookName->hookFn
	        this.hook(k, name[k]);
	      }
	      return;
	    }
	
	    var proto = this.prototype || this
	      , pres = proto._pres = proto._pres || {}
	      , posts = proto._posts = proto._posts || {};
	    pres[name] = pres[name] || [];
	    posts[name] = posts[name] || [];
	
	    proto[name] = function () {
	      var self = this
	        , hookArgs // arguments eventually passed to the hook - are mutable
	        , lastArg = arguments[arguments.length-1]
	        , pres = this._pres[name]
	        , posts = this._posts[name]
	        , _total = pres.length
	        , _current = -1
	        , _asyncsLeft = proto[name].numAsyncPres
	        , _asyncsDone = function(err) {
	            if (err) {
	              return handleError(err);
	            }
	            --_asyncsLeft || _done.apply(self, hookArgs);
	          }
	        , handleError = function(err) {
	            if ('function' == typeof lastArg)
	              return lastArg(err);
	            if (errorCb) return errorCb.call(self, err);
	            throw err;
	          }
	        , _next = function () {
	            if (arguments[0] instanceof Error) {
	              return handleError(arguments[0]);
	            }
	            var _args = Array.prototype.slice.call(arguments)
	              , currPre
	              , preArgs;
	            if (_args.length && !(arguments[0] == null && typeof lastArg === 'function'))
	              hookArgs = _args;
	            if (++_current < _total) {
	              currPre = pres[_current]
	              if (currPre.isAsync && currPre.length < 2)
	                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");
	              if (currPre.length < 1)
	                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");
	              preArgs = (currPre.isAsync
	                          ? [once(_next), once(_asyncsDone)]
	                          : [once(_next)]).concat(hookArgs);
	              return currPre.apply(self, preArgs);
	            } else if (!_asyncsLeft) {
	              return _done.apply(self, hookArgs);
	            }
	          }
	        , _done = function () {
	            var args_ = Array.prototype.slice.call(arguments)
	              , ret, total_, current_, next_, done_, postArgs;
	
	            if (_current === _total) {
	              
	              next_ = function () {
	                if (arguments[0] instanceof Error) {
	                  return handleError(arguments[0]);
	                }
	                var args_ = Array.prototype.slice.call(arguments, 1)
	                  , currPost
	                  , postArgs;
	                if (args_.length) hookArgs = args_;
	                if (++current_ < total_) {
	                  currPost = posts[current_]
	                  if (currPost.length < 1)
	                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");
	                  postArgs = [once(next_)].concat(hookArgs);
	                  return currPost.apply(self, postArgs);
	                } else if (typeof lastArg === 'function'){
	                  // All post handlers are done, call original callback function
	                  return lastArg.apply(self, arguments);
	                }
	              };
	
	              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
	              // a callback.  We trap that callback and wait to call it until all post handlers have finished.
	              if(typeof lastArg === 'function'){
	                args_[args_.length - 1] = once(next_);
	              }
	
	              total_ = posts.length;
	              current_ = -1;
	              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward
	
	              if (total_ && typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually
	              return ret;
	            }
	          };
	
	      return _next.apply(this, arguments);
	    };
	    
	    proto[name].numAsyncPres = 0;
	
	    return this;
	  },
	
	  pre: function (name, isAsync, fn, errorCb) {
	    if ('boolean' !== typeof arguments[1]) {
	      errorCb = fn;
	      fn = isAsync;
	      isAsync = false;
	    }
	    var proto = this.prototype || this
	      , pres = proto._pres = proto._pres || {};
	
	    this._lazySetupHooks(proto, name, errorCb);
	
	    if (fn.isAsync = isAsync) {
	      proto[name].numAsyncPres++;
	    }
	
	    (pres[name] = pres[name] || []).push(fn);
	    return this;
	  },
	  post: function (name, isAsync, fn) {
	    if (arguments.length === 2) {
	      fn = isAsync;
	      isAsync = false;
	    }
	    var proto = this.prototype || this
	      , posts = proto._posts = proto._posts || {};
	    
	    this._lazySetupHooks(proto, name);
	    (posts[name] = posts[name] || []).push(fn);
	    return this;
	  },
	  removePre: function (name, fnToRemove) {
	    var proto = this.prototype || this
	      , pres = proto._pres || (proto._pres || {});
	    if (!pres[name]) return this;
	    if (arguments.length === 1) {
	      // Remove all pre callbacks for hook `name`
	      pres[name].length = 0;
	    } else {
	      pres[name] = pres[name].filter( function (currFn) {
	        return currFn !== fnToRemove;
	      });
	    }
	    return this;
	  },
	  removePost: function (name, fnToRemove) {
	    var proto = this.prototype || this
	      , posts = proto._posts || (proto._posts || {});
	    if (!posts[name]) return this;
	    if (arguments.length === 1) {
	      // Remove all post callbacks for hook `name`
	      posts[name].length = 0;
	    } else {
	      posts[name] = posts[name].filter( function (currFn) {
	        return currFn !== fnToRemove;
	      });
	    }
	    return this;
	  },
	  
	  _lazySetupHooks: function (proto, methodName, errorCb) {
	    if ('undefined' === typeof proto[methodName].numAsyncPres) {
	      this.hook(methodName, proto[methodName], errorCb);
	    }
	  }
	};
	
	function once (fn, scope) {
	  return function fnWrapper () {
	    if (fnWrapper.hookCalled) return;
	    fnWrapper.hookCalled = true;
	    fn.apply(scope, arguments);
	  };
	}


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MPromise = __webpack_require__(238);
	
	/**
	 * Helper for multiplexing promise implementations
	 *
	 * @api private
	 */
	
	var Promise = {
	  _promise: MPromise
	};
	
	/**
	 * Get the current promise constructor
	 *
	 * @api private
	 */
	Promise.get = function() {
	  return Promise._promise;
	};
	
	/**
	 * Set the current promise constructor
	 *
	 * @api private
	 */
	
	Promise.set = function(lib) {
	  if (lib === MPromise) {
	    return Promise.reset();
	  }
	  Promise._promise = __webpack_require__(240);
	  Promise._promise.use(lib);
	  __webpack_require__(241).Promise = Promise._promise.ES6;
	};
	
	/**
	 * Resets to using mpromise
	 *
	 * @api private
	 */
	
	Promise.reset = function() {
	  Promise._promise = MPromise;
	};
	
	module.exports = Promise;


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies
	 */
	
	var MPromise = __webpack_require__(239);
	var util = __webpack_require__(77);
	
	/**
	 * Promise constructor.
	 *
	 * Promises are returned from executed queries. Example:
	 *
	 *     var query = Candy.find({ bar: true });
	 *     var promise = query.exec();
	 *
	 * DEPRECATED. Mongoose 5.0 will use native promises by default (or bluebird,
	 * if native promises are not present) but still
	 * support plugging in your own ES6-compatible promises library. Mongoose 5.0
	 * will **not** support mpromise.
	 *
	 * @param {Function} fn a function which will be called when the promise is resolved that accepts `fn(err, ...){}` as signature
	 * @inherits mpromise https://github.com/aheckmann/mpromise
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `err`: Emits when the promise is rejected
	 * @event `complete`: Emits when the promise is fulfilled
	 * @api public
	 * @deprecated
	 */
	
	function Promise(fn) {
	  MPromise.call(this, fn);
	}
	
	/**
	 * ES6-style promise constructor wrapper around mpromise.
	 *
	 * @param {Function} resolver
	 * @return {Promise} new promise
	 * @api public
	 */
	Promise.ES6 = function(resolver) {
	  var promise = new Promise();
	
	  // No try/catch for backwards compatibility
	  resolver(
	    function() {
	      promise.complete.apply(promise, arguments);
	    },
	    function(e) {
	      promise.error(e);
	    });
	
	  return promise;
	};
	
	/*!
	 * Inherit from mpromise
	 */
	
	Promise.prototype = Object.create(MPromise.prototype, {
	  constructor: {
	    value: Promise,
	    enumerable: false,
	    writable: true,
	    configurable: true
	  }
	});
	
	/*!
	 * ignore
	 */
	
	Promise.prototype.then = util.deprecate(Promise.prototype.then,
	  'Mongoose: mpromise (mongoose\'s default promise library) is deprecated, ' +
	  'plug in your own promise library instead: ' +
	  'http://mongoosejs.com/docs/promises.html');
	
	/**
	 * ES6-style `.catch()` shorthand
	 *
	 * @method catch
	 * @memberOf Promise
	 * @param {Function} onReject
	 * @return {Promise}
	 * @api public
	 */
	
	Promise.prototype.catch = function(onReject) {
	  return this.then(null, onReject);
	};
	
	/*!
	 * Override event names for backward compatibility.
	 */
	
	Promise.SUCCESS = 'complete';
	Promise.FAILURE = 'err';
	
	/**
	 * Adds `listener` to the `event`.
	 *
	 * If `event` is either the success or failure event and the event has already been emitted, the`listener` is called immediately and passed the results of the original emitted event.
	 *
	 * @see mpromise#on https://github.com/aheckmann/mpromise#on
	 * @method on
	 * @memberOf Promise
	 * @param {String} event
	 * @param {Function} listener
	 * @return {Promise} this
	 * @api public
	 */
	
	/**
	 * Rejects this promise with `reason`.
	 *
	 * If the promise has already been fulfilled or rejected, not action is taken.
	 *
	 * @see mpromise#reject https://github.com/aheckmann/mpromise#reject
	 * @method reject
	 * @memberOf Promise
	 * @param {Object|String|Error} reason
	 * @return {Promise} this
	 * @api public
	 */
	
	/**
	 * Rejects this promise with `err`.
	 *
	 * If the promise has already been fulfilled or rejected, not action is taken.
	 *
	 * Differs from [#reject](#promise_Promise-reject) by first casting `err` to an `Error` if it is not `instanceof Error`.
	 *
	 * @api public
	 * @param {Error|String} err
	 * @return {Promise} this
	 */
	
	Promise.prototype.error = function(err) {
	  if (!(err instanceof Error)) {
	    if (err instanceof Object) {
	      err = util.inspect(err);
	    }
	    err = new Error(err);
	  }
	  return this.reject(err);
	};
	
	/**
	 * Resolves this promise to a rejected state if `err` is passed or a fulfilled state if no `err` is passed.
	 *
	 * If the promise has already been fulfilled or rejected, not action is taken.
	 *
	 * `err` will be cast to an Error if not already instanceof Error.
	 *
	 * _NOTE: overrides [mpromise#resolve](https://github.com/aheckmann/mpromise#resolve) to provide error casting._
	 *
	 * @param {Error} [err] error or null
	 * @param {Object} [val] value to fulfill the promise with
	 * @api public
	 * @deprecated
	 */
	
	Promise.prototype.resolve = function(err) {
	  if (err) return this.error(err);
	  return this.fulfill.apply(this, Array.prototype.slice.call(arguments, 1));
	};
	
	/**
	 * Adds a single function as a listener to both err and complete.
	 *
	 * It will be executed with traditional node.js argument position when the promise is resolved.
	 *
	 *     promise.addBack(function (err, args...) {
	 *       if (err) return handleError(err);
	 *       console.log('success');
	 *     })
	 *
	 * Alias of [mpromise#onResolve](https://github.com/aheckmann/mpromise#onresolve).
	 *
	 * _Deprecated. Use `onResolve` instead._
	 *
	 * @method addBack
	 * @param {Function} listener
	 * @return {Promise} this
	 * @deprecated
	 */
	
	Promise.prototype.addBack = Promise.prototype.onResolve;
	
	/**
	 * Fulfills this promise with passed arguments.
	 *
	 * @method fulfill
	 * @receiver Promise
	 * @see https://github.com/aheckmann/mpromise#fulfill
	 * @param {any} args
	 * @api public
	 * @deprecated
	 */
	
	/**
	 * Fulfills this promise with passed arguments.
	 *
	 * Alias of [mpromise#fulfill](https://github.com/aheckmann/mpromise#fulfill).
	 *
	 * _Deprecated. Use `fulfill` instead._
	 *
	 * @method complete
	 * @receiver Promise
	 * @param {any} args
	 * @api public
	 * @deprecated
	 */
	
	Promise.prototype.complete = MPromise.prototype.fulfill;
	
	/**
	 * Adds a listener to the `complete` (success) event.
	 *
	 * Alias of [mpromise#onFulfill](https://github.com/aheckmann/mpromise#onfulfill).
	 *
	 * _Deprecated. Use `onFulfill` instead._
	 *
	 * @method addCallback
	 * @param {Function} listener
	 * @return {Promise} this
	 * @api public
	 * @deprecated
	 */
	
	Promise.prototype.addCallback = Promise.prototype.onFulfill;
	
	/**
	 * Adds a listener to the `err` (rejected) event.
	 *
	 * Alias of [mpromise#onReject](https://github.com/aheckmann/mpromise#onreject).
	 *
	 * _Deprecated. Use `onReject` instead._
	 *
	 * @method addErrback
	 * @param {Function} listener
	 * @return {Promise} this
	 * @api public
	 * @deprecated
	 */
	
	Promise.prototype.addErrback = Promise.prototype.onReject;
	
	/**
	 * Creates a new promise and returns it. If `onFulfill` or `onReject` are passed, they are added as SUCCESS/ERROR callbacks to this promise after the nextTick.
	 *
	 * Conforms to [promises/A+](https://github.com/promises-aplus/promises-spec) specification.
	 *
	 * ####Example:
	 *
	 *     var promise = Meetups.find({ tags: 'javascript' }).select('_id').exec();
	 *     promise.then(function (meetups) {
	 *       var ids = meetups.map(function (m) {
	 *         return m._id;
	 *       });
	 *       return People.find({ meetups: { $in: ids }).exec();
	 *     }).then(function (people) {
	 *       if (people.length < 10000) {
	 *         throw new Error('Too few people!!!');
	 *       } else {
	 *         throw new Error('Still need more people!!!');
	 *       }
	 *     }).then(null, function (err) {
	 *       assert.ok(err instanceof Error);
	 *     });
	 *
	 * @see promises-A+ https://github.com/promises-aplus/promises-spec
	 * @see mpromise#then https://github.com/aheckmann/mpromise#then
	 * @method then
	 * @memberOf Promise
	 * @param {Function} onFulFill
	 * @param {Function} onReject
	 * @return {Promise} newPromise
	 * @deprecated
	 */
	
	/**
	 * Signifies that this promise was the last in a chain of `then()s`: if a handler passed to the call to `then` which produced this promise throws, the exception will go uncaught.
	 *
	 * ####Example:
	 *
	 *     var p = new Promise;
	 *     p.then(function(){ throw new Error('shucks') });
	 *     setTimeout(function () {
	 *       p.fulfill();
	 *       // error was caught and swallowed by the promise returned from
	 *       // p.then(). we either have to always register handlers on
	 *       // the returned promises or we can do the following...
	 *     }, 10);
	 *
	 *     // this time we use .end() which prevents catching thrown errors
	 *     var p = new Promise;
	 *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--
	 *     setTimeout(function () {
	 *       p.fulfill(); // throws "shucks"
	 *     }, 10);
	 *
	 * @api public
	 * @see mpromise#end https://github.com/aheckmann/mpromise#end
	 * @method end
	 * @memberOf Promise
	 * @deprecated
	 */
	
	/*!
	 * expose
	 */
	
	module.exports = Promise;


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	var util = __webpack_require__(77);
	var EventEmitter = __webpack_require__(3).EventEmitter;
	function toArray(arr, start, end) {
	  return Array.prototype.slice.call(arr, start, end)
	}
	function strongUnshift(x, arrLike) {
	  var arr = toArray(arrLike);
	  arr.unshift(x);
	  return arr;
	}
	
	
	/**
	 * MPromise constructor.
	 *
	 * _NOTE: The success and failure event names can be overridden by setting `Promise.SUCCESS` and `Promise.FAILURE` respectively._
	 *
	 * @param {Function} back a function that accepts `fn(err, ...){}` as signature
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `reject`: Emits when the promise is rejected (event name may be overridden)
	 * @event `fulfill`: Emits when the promise is fulfilled (event name may be overridden)
	 * @api public
	 */
	function Promise(back) {
	  this.emitter = new EventEmitter();
	  this.emitted = {};
	  this.ended = false;
	  if ('function' == typeof back) {
	    this.ended = true;
	    this.onResolve(back);
	  }
	}
	
	
	/*
	 * Module exports.
	 */
	module.exports = Promise;
	
	
	/*!
	 * event names
	 */
	Promise.SUCCESS = 'fulfill';
	Promise.FAILURE = 'reject';
	
	
	/**
	 * Adds `listener` to the `event`.
	 *
	 * If `event` is either the success or failure event and the event has already been emitted, the`listener` is called immediately and passed the results of the original emitted event.
	 *
	 * @param {String} event
	 * @param {Function} callback
	 * @return {MPromise} this
	 * @api private
	 */
	Promise.prototype.on = function (event, callback) {
	  if (this.emitted[event])
	    callback.apply(undefined, this.emitted[event]);
	  else
	    this.emitter.on(event, callback);
	
	  return this;
	};
	
	
	/**
	 * Keeps track of emitted events to run them on `on`.
	 *
	 * @api private
	 */
	Promise.prototype.safeEmit = function (event) {
	  // ensures a promise can't be fulfill() or reject() more than once
	  if (event == Promise.SUCCESS || event == Promise.FAILURE) {
	    if (this.emitted[Promise.SUCCESS] || this.emitted[Promise.FAILURE]) {
	      return this;
	    }
	    this.emitted[event] = toArray(arguments, 1);
	  }
	
	  this.emitter.emit.apply(this.emitter, arguments);
	  return this;
	};
	
	
	/**
	 * @api private
	 */
	Promise.prototype.hasRejectListeners = function () {
	  return EventEmitter.listenerCount(this.emitter, Promise.FAILURE) > 0;
	};
	
	
	/**
	 * Fulfills this promise with passed arguments.
	 *
	 * If this promise has already been fulfilled or rejected, no action is taken.
	 *
	 * @api public
	 */
	Promise.prototype.fulfill = function () {
	  return this.safeEmit.apply(this, strongUnshift(Promise.SUCCESS, arguments));
	};
	
	
	/**
	 * Rejects this promise with `reason`.
	 *
	 * If this promise has already been fulfilled or rejected, no action is taken.
	 *
	 * @api public
	 * @param {Object|String} reason
	 * @return {MPromise} this
	 */
	Promise.prototype.reject = function (reason) {
	  if (this.ended && !this.hasRejectListeners())
	    throw reason;
	  return this.safeEmit(Promise.FAILURE, reason);
	};
	
	
	/**
	 * Resolves this promise to a rejected state if `err` is passed or
	 * fulfilled state if no `err` is passed.
	 *
	 * @param {Error} [err] error or null
	 * @param {Object} [val] value to fulfill the promise with
	 * @api public
	 */
	Promise.prototype.resolve = function (err, val) {
	  if (err) return this.reject(err);
	  return this.fulfill(val);
	};
	
	
	/**
	 * Adds a listener to the SUCCESS event.
	 *
	 * @return {MPromise} this
	 * @api public
	 */
	Promise.prototype.onFulfill = function (fn) {
	  if (!fn) return this;
	  if ('function' != typeof fn) throw new TypeError("fn should be a function");
	  return this.on(Promise.SUCCESS, fn);
	};
	
	
	/**
	 * Adds a listener to the FAILURE event.
	 *
	 * @return {MPromise} this
	 * @api public
	 */
	Promise.prototype.onReject = function (fn) {
	  if (!fn) return this;
	  if ('function' != typeof fn) throw new TypeError("fn should be a function");
	  return this.on(Promise.FAILURE, fn);
	};
	
	
	/**
	 * Adds a single function as a listener to both SUCCESS and FAILURE.
	 *
	 * It will be executed with traditional node.js argument position:
	 * function (err, args...) {}
	 *
	 * Also marks the promise as `end`ed, since it's the common use-case, and yet has no
	 * side effects unless `fn` is undefined or null.
	 *
	 * @param {Function} fn
	 * @return {MPromise} this
	 */
	Promise.prototype.onResolve = function (fn) {
	  if (!fn) return this;
	  if ('function' != typeof fn) throw new TypeError("fn should be a function");
	  this.on(Promise.FAILURE, function (err) { fn.call(this, err); });
	  this.on(Promise.SUCCESS, function () { fn.apply(this, strongUnshift(null, arguments)); });
	  return this;
	};
	
	
	/**
	 * Creates a new promise and returns it. If `onFulfill` or
	 * `onReject` are passed, they are added as SUCCESS/ERROR callbacks
	 * to this promise after the next tick.
	 *
	 * Conforms to [promises/A+](https://github.com/promises-aplus/promises-spec) specification. Read for more detail how to use this method.
	 *
	 * ####Example:
	 *
	 *     var p = new Promise;
	 *     p.then(function (arg) {
	 *       return arg + 1;
	 *     }).then(function (arg) {
	 *       throw new Error(arg + ' is an error!');
	 *     }).then(null, function (err) {
	 *       assert.ok(err instanceof Error);
	 *       assert.equal('2 is an error', err.message);
	 *     });
	 *     p.complete(1);
	 *
	 * @see promises-A+ https://github.com/promises-aplus/promises-spec
	 * @param {Function} onFulfill
	 * @param {Function} [onReject]
	 * @return {MPromise} newPromise
	 */
	Promise.prototype.then = function (onFulfill, onReject) {
	  var newPromise = new Promise;
	
	  if ('function' == typeof onFulfill) {
	    this.onFulfill(handler(newPromise, onFulfill));
	  } else {
	    this.onFulfill(newPromise.fulfill.bind(newPromise));
	  }
	
	  if ('function' == typeof onReject) {
	    this.onReject(handler(newPromise, onReject));
	  } else {
	    this.onReject(newPromise.reject.bind(newPromise));
	  }
	
	  return newPromise;
	};
	
	
	function handler(promise, fn) {
	  function newTickHandler() {
	    var pDomain = promise.emitter.domain;
	    if (pDomain && pDomain !== process.domain) pDomain.enter();
	    try {
	      var x = fn.apply(undefined, boundHandler.args);
	    } catch (err) {
	      promise.reject(err);
	      return;
	    }
	    resolve(promise, x);
	  }
	  function boundHandler() {
	    boundHandler.args = arguments;
	    process.nextTick(newTickHandler);
	  }
	  return boundHandler;
	}
	
	
	function resolve(promise, x) {
	  function fulfillOnce() {
	    if (done++) return;
	    resolve.apply(undefined, strongUnshift(promise, arguments));
	  }
	  function rejectOnce(reason) {
	    if (done++) return;
	    promise.reject(reason);
	  }
	
	  if (promise === x) {
	    promise.reject(new TypeError("promise and x are the same"));
	    return;
	  }
	  var rest = toArray(arguments, 1);
	  var type = typeof x;
	  if ('undefined' == type || null == x || !('object' == type || 'function' == type)) {
	    promise.fulfill.apply(promise, rest);
	    return;
	  }
	
	  try {
	    var theThen = x.then;
	  } catch (err) {
	    promise.reject(err);
	    return;
	  }
	
	  if ('function' != typeof theThen) {
	    promise.fulfill.apply(promise, rest);
	    return;
	  }
	
	  var done = 0;
	  try {
	    var ret = theThen.call(x, fulfillOnce, rejectOnce);
	    return ret;
	  } catch (err) {
	    if (done++) return;
	    promise.reject(err);
	  }
	}
	
	
	/**
	 * Signifies that this promise was the last in a chain of `then()s`: if a handler passed to the call to `then` which produced this promise throws, the exception will go uncaught.
	 *
	 * ####Example:
	 *
	 *     var p = new Promise;
	 *     p.then(function(){ throw new Error('shucks') });
	 *     setTimeout(function () {
	 *       p.fulfill();
	 *       // error was caught and swallowed by the promise returned from
	 *       // p.then(). we either have to always register handlers on
	 *       // the returned promises or we can do the following...
	 *     }, 10);
	 *
	 *     // this time we use .end() which prevents catching thrown errors
	 *     var p = new Promise;
	 *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--
	 *     setTimeout(function () {
	 *       p.fulfill(); // throws "shucks"
	 *     }, 10);
	 *
	 * @api public
	 * @param {Function} [onReject]
	 * @return {MPromise} this
	 */
	Promise.prototype.end = Promise.prototype['catch'] = function (onReject) {
	  if (!onReject && !this.hasRejectListeners())
	    onReject = function idRejector(e) { throw e; };
	  this.onReject(onReject);
	  this.ended = true;
	  return this;
	};
	
	
	/**
	 * A debug utility function that adds handlers to a promise that will log some output to the `console`
	 *
	 * ####Example:
	 *
	 *     var p = new Promise;
	 *     p.then(function(){ throw new Error('shucks') });
	 *     setTimeout(function () {
	 *       p.fulfill();
	 *       // error was caught and swallowed by the promise returned from
	 *       // p.then(). we either have to always register handlers on
	 *       // the returned promises or we can do the following...
	 *     }, 10);
	 *
	 *     // this time we use .end() which prevents catching thrown errors
	 *     var p = new Promise;
	 *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--
	 *     setTimeout(function () {
	 *       p.fulfill(); // throws "shucks"
	 *     }, 10);
	 *
	 * @api public
	 * @param {MPromise} p
	 * @param {String} name
	 * @return {MPromise} this
	 */
	Promise.trace = function (p, name) {
	  p.then(
	    function () {
	      console.log("%s fulfill %j", name, toArray(arguments));
	    },
	    function () {
	      console.log("%s reject %j", name, toArray(arguments));
	    }
	  )
	};
	
	
	Promise.prototype.chain = function (p2) {
	  var p1 = this;
	  p1.onFulfill(p2.fulfill.bind(p2));
	  p1.onReject(p2.reject.bind(p2));
	  return p2;
	};
	
	
	Promise.prototype.all = function (promiseOfArr) {
	  var pRet = new Promise;
	  this.then(promiseOfArr).then(
	    function (promiseArr) {
	      var count = 0;
	      var ret = [];
	      var errSentinel;
	      if (!promiseArr.length) pRet.resolve();
	      promiseArr.forEach(function (promise, index) {
	        if (errSentinel) return;
	        count++;
	        promise.then(
	          function (val) {
	            if (errSentinel) return;
	            ret[index] = val;
	            --count;
	            if (count == 0) pRet.fulfill(ret);
	          },
	          function (err) {
	            if (errSentinel) return;
	            errSentinel = err;
	            pRet.reject(err);
	          }
	        );
	      });
	      return pRet;
	    }
	    , pRet.reject.bind(pRet)
	  );
	  return pRet;
	};
	
	
	Promise.hook = function (arr) {
	  var p1 = new Promise;
	  var pFinal = new Promise;
	  var signalP = function () {
	    --count;
	    if (count == 0)
	      pFinal.fulfill();
	    return pFinal;
	  };
	  var count = 1;
	  var ps = p1;
	  arr.forEach(function (hook) {
	    ps = ps.then(
	      function () {
	        var p = new Promise;
	        count++;
	        hook(p.resolve.bind(p), signalP);
	        return p;
	      }
	    )
	  });
	  ps = ps.then(signalP);
	  p1.resolve();
	  return ps;
	};
	
	
	/* This is for the A+ tests, but it's very useful as well */
	Promise.fulfilled = function fulfilled() { var p = new Promise; p.fulfill.apply(p, arguments); return p; };
	Promise.rejected = function rejected(reason) { return new Promise().reject(reason); };
	Promise.deferred = function deferred() {
	  var p = new Promise;
	  return {
	    promise: p,
	    reject: p.reject.bind(p),
	    resolve: p.fulfill.bind(p),
	    callback: p.resolve.bind(p)
	  }
	};
	/* End A+ tests adapter bit */
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 240 */
/***/ function(module, exports) {

	/**
	 * ES6 Promise wrapper constructor.
	 *
	 * Promises are returned from executed queries. Example:
	 *
	 *     var query = Candy.find({ bar: true });
	 *     var promise = query.exec();
	 *
	 * DEPRECATED. Mongoose 5.0 will use native promises by default (or bluebird,
	 * if native promises are not present) but still
	 * support plugging in your own ES6-compatible promises library. Mongoose 5.0
	 * will **not** support mpromise.
	 *
	 * @param {Function} fn a function which will be called when the promise is resolved that accepts `fn(err, ...){}` as signature
	 * @api public
	 */
	
	function ES6Promise() {
	  throw new Error('Can\'t use ES6 promise with mpromise style constructor');
	}
	
	ES6Promise.use = function(Promise) {
	  ES6Promise.ES6 = Promise;
	};
	
	module.exports = ES6Promise;


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Dependencies
	 */
	
	var slice = __webpack_require__(242)
	var assert = __webpack_require__(185)
	var util = __webpack_require__(77)
	var utils = __webpack_require__(244)
	var debug = __webpack_require__(13)('mquery');
	
	/**
	 * Query constructor used for building queries.
	 *
	 * ####Example:
	 *
	 *     var query = new Query({ name: 'mquery' });
	 *     query.setOptions({ collection: moduleCollection })
	 *     query.where('age').gte(21).exec(callback);
	 *
	 * @param {Object} [criteria]
	 * @param {Object} [options]
	 * @api public
	 */
	
	function Query (criteria, options) {
	  if (!(this instanceof Query))
	    return new Query(criteria, options);
	
	  var proto = this.constructor.prototype;
	
	  this.op = proto.op || undefined;
	
	  this.options = {};
	  this.setOptions(proto.options);
	
	  this._conditions = proto._conditions
	    ? utils.clone(proto._conditions)
	    : {};
	
	  this._fields = proto._fields
	    ? utils.clone(proto._fields)
	    : undefined;
	
	  this._update = proto._update
	    ? utils.clone(proto._update)
	    : undefined;
	
	  this._path = proto._path || undefined;
	  this._distinct = proto._distinct || undefined;
	  this._collection = proto._collection || undefined;
	  this._traceFunction = proto._traceFunction || undefined;
	
	  if (options) {
	    this.setOptions(options);
	  }
	
	  if (criteria) {
	    if (criteria.find && criteria.remove && criteria.update) {
	      // quack quack!
	      this.collection(criteria);
	    } else {
	      this.find(criteria);
	    }
	  }
	}
	
	/**
	 * This is a parameter that the user can set which determines if mquery
	 * uses $within or $geoWithin for queries. It defaults to true which
	 * means $geoWithin will be used. If using MongoDB < 2.4 you should
	 * set this to false.
	 *
	 * @api public
	 * @property use$geoWithin
	 */
	
	var $withinCmd = '$geoWithin';
	Object.defineProperty(Query, 'use$geoWithin', {
	    get: function ( ) { return $withinCmd == '$geoWithin' }
	  , set: function (v) {
	      if (true === v) {
	        // mongodb >= 2.4
	        $withinCmd = '$geoWithin';
	      } else {
	        $withinCmd = '$within';
	      }
	    }
	});
	
	/**
	 * Converts this query to a constructor function with all arguments and options retained.
	 *
	 * ####Example
	 *
	 *     // Create a query that will read documents with a "video" category from
	 *     // `aCollection` on the primary node in the replica-set unless it is down,
	 *     // in which case we'll read from a secondary node.
	 *     var query = mquery({ category: 'video' })
	 *     query.setOptions({ collection: aCollection, read: 'primaryPreferred' });
	 *
	 *     // create a constructor based off these settings
	 *     var Video = query.toConstructor();
	 *
	 *     // Video is now a subclass of mquery() and works the same way but with the
	 *     // default query parameters and options set.
	 *
	 *     // run a query with the previous settings but filter for movies with names
	 *     // that start with "Life".
	 *     Video().where({ name: /^Life/ }).exec(cb);
	 *
	 * @return {Query} new Query
	 * @api public
	 */
	
	Query.prototype.toConstructor = function toConstructor () {
	  function CustomQuery (criteria, options) {
	    if (!(this instanceof CustomQuery))
	      return new CustomQuery(criteria, options);
	    Query.call(this, criteria, options);
	  }
	
	  utils.inherits(CustomQuery, Query);
	
	  // set inherited defaults
	  var p = CustomQuery.prototype;
	
	  p.options = {};
	  p.setOptions(this.options);
	
	  p.op = this.op;
	  p._conditions = utils.clone(this._conditions);
	  p._fields = utils.clone(this._fields);
	  p._update = utils.clone(this._update);
	  p._path = this._path;
	  p._distinct = this._distinct;
	  p._collection = this._collection;
	  p._traceFunction = this._traceFunction;
	
	  return CustomQuery;
	}
	
	/**
	 * Sets query options.
	 *
	 * ####Options:
	 *
	 * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *
	 * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\)%7D%7D) *
	 * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *
	 * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *
	 * - [maxScan](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan) *
	 * - [maxTime](http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS) *
	 * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *
	 * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *
	 * - [snapshot](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D) *
	 * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *
	 * - [slaveOk](http://docs.mongodb.org/manual/applications/replication/#read-preference) *
	 * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)
	 * - collection the collection to query against
	 *
	 * _* denotes a query helper method is also available_
	 *
	 * @param {Object} options
	 * @api public
	 */
	
	Query.prototype.setOptions = function (options) {
	  if (!(options && utils.isObject(options)))
	    return this;
	
	  // set arbitrary options
	  var methods = utils.keys(options)
	    , method
	
	  for (var i = 0; i < methods.length; ++i) {
	    method = methods[i];
	
	    // use methods if exist (safer option manipulation)
	    if ('function' == typeof this[method]) {
	      var args = utils.isArray(options[method])
	        ? options[method]
	        : [options[method]];
	      this[method].apply(this, args)
	    } else {
	      this.options[method] = options[method];
	    }
	  }
	
	  return this;
	}
	
	/**
	 * Sets this Querys collection.
	 *
	 * @param {Collection} coll
	 * @return {Query} this
	 */
	
	Query.prototype.collection = function collection (coll) {
	  this._collection = new Query.Collection(coll);
	
	  return this;
	}
	
	/**
	 * Specifies a `$where` condition
	 *
	 * Use `$where` when you need to select documents using a JavaScript expression.
	 *
	 * ####Example
	 *
	 *     query.$where('this.comments.length > 10 || this.name.length > 5')
	 *
	 *     query.$where(function () {
	 *       return this.comments.length > 10 || this.name.length > 5;
	 *     })
	 *
	 * @param {String|Function} js javascript string or function
	 * @return {Query} this
	 * @memberOf Query
	 * @method $where
	 * @api public
	 */
	
	Query.prototype.$where = function (js) {
	  this._conditions.$where = js;
	  return this;
	}
	
	/**
	 * Specifies a `path` for use with chaining.
	 *
	 * ####Example
	 *
	 *     // instead of writing:
	 *     User.find({age: {$gte: 21, $lte: 65}}, callback);
	 *
	 *     // we can instead write:
	 *     User.where('age').gte(21).lte(65);
	 *
	 *     // passing query conditions is permitted
	 *     User.find().where({ name: 'vonderful' })
	 *
	 *     // chaining
	 *     User
	 *     .where('age').gte(21).lte(65)
	 *     .where('name', /^vonderful/i)
	 *     .where('friends').slice(10)
	 *     .exec(callback)
	 *
	 * @param {String} [path]
	 * @param {Object} [val]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.where = function () {
	  if (!arguments.length) return this;
	  if (!this.op) this.op = 'find';
	
	  var type = typeof arguments[0];
	
	  if ('string' == type) {
	    this._path = arguments[0];
	
	    if (2 === arguments.length) {
	      this._conditions[this._path] = arguments[1];
	    }
	
	    return this;
	  }
	
	  if ('object' == type && !Array.isArray(arguments[0])) {
	    return this.merge(arguments[0]);
	  }
	
	  throw new TypeError('path must be a string or object');
	}
	
	/**
	 * Specifies the complementary comparison value for paths specified with `where()`
	 *
	 * ####Example
	 *
	 *     User.where('age').equals(49);
	 *
	 *     // is the same as
	 *
	 *     User.where('age', 49);
	 *
	 * @param {Object} val
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.equals = function equals (val) {
	  this._ensurePath('equals');
	  var path = this._path;
	  this._conditions[path] = val;
	  return this;
	}
	
	/**
	 * Specifies the complementary comparison value for paths specified with `where()`
	 * This is alias of `equals`
	 *
	 * ####Example
	 *
	 *     User.where('age').eq(49);
	 *
	 *     // is the same as
	 *
	 *     User.shere('age').equals(49);
	 *
	 *     // is the same as
	 *
	 *     User.where('age', 49);
	 *
	 * @param {Object} val
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.eq = function eq (val) {
	  this._ensurePath('eq');
	  var path = this._path;
	  this._conditions[path] = val;
	  return this;
	}
	
	/**
	 * Specifies arguments for an `$or` condition.
	 *
	 * ####Example
	 *
	 *     query.or([{ color: 'red' }, { status: 'emergency' }])
	 *
	 * @param {Array} array array of conditions
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.or = function or (array) {
	  var or = this._conditions.$or || (this._conditions.$or = []);
	  if (!utils.isArray(array)) array = [array];
	  or.push.apply(or, array);
	  return this;
	}
	
	/**
	 * Specifies arguments for a `$nor` condition.
	 *
	 * ####Example
	 *
	 *     query.nor([{ color: 'green' }, { status: 'ok' }])
	 *
	 * @param {Array} array array of conditions
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.nor = function nor (array) {
	  var nor = this._conditions.$nor || (this._conditions.$nor = []);
	  if (!utils.isArray(array)) array = [array];
	  nor.push.apply(nor, array);
	  return this;
	}
	
	/**
	 * Specifies arguments for a `$and` condition.
	 *
	 * ####Example
	 *
	 *     query.and([{ color: 'green' }, { status: 'ok' }])
	 *
	 * @see $and http://docs.mongodb.org/manual/reference/operator/and/
	 * @param {Array} array array of conditions
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.and = function and (array) {
	  var and = this._conditions.$and || (this._conditions.$and = []);
	  if (!Array.isArray(array)) array = [array];
	  and.push.apply(and, array);
	  return this;
	}
	
	/**
	 * Specifies a $gt query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * ####Example
	 *
	 *     Thing.find().where('age').gt(21)
	 *
	 *     // or
	 *     Thing.find().gt('age', 21)
	 *
	 * @method gt
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $gte query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method gte
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $lt query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method lt
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $lte query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method lte
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $ne query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method ne
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies an $in query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method in
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies an $nin query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method nin
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies an $all query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method all
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $size query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method size
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $regex query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method regex
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $maxDistance query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method maxDistance
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/*!
	 * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance
	 *
	 *     Thing.where('type').nin(array)
	 */
	
	'gt gte lt lte ne in nin all regex size maxDistance minDistance'.split(' ').forEach(function ($conditional) {
	  Query.prototype[$conditional] = function () {
	    var path, val;
	
	    if (1 === arguments.length) {
	      this._ensurePath($conditional);
	      val = arguments[0];
	      path = this._path;
	    } else {
	      val = arguments[1];
	      path = arguments[0];
	    }
	
	    var conds = this._conditions[path] === null || typeof this._conditions[path] === 'object' ?
	      this._conditions[path] : 
	      (this._conditions[path] = {});
	    conds['$' + $conditional] = val;
	    return this;
	  };
	})
	
	/**
	 * Specifies a `$mod` condition
	 *
	 * @param {String} [path]
	 * @param {Number} val
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.mod = function () {
	  var val, path;
	
	  if (1 === arguments.length) {
	    this._ensurePath('mod')
	    val = arguments[0];
	    path = this._path;
	  } else if (2 === arguments.length && !utils.isArray(arguments[1])) {
	    this._ensurePath('mod')
	    val = slice(arguments);
	    path = this._path;
	  } else if (3 === arguments.length) {
	    val = slice(arguments, 1);
	    path = arguments[0];
	  } else {
	    val = arguments[1];
	    path = arguments[0];
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds.$mod = val;
	  return this;
	}
	
	/**
	 * Specifies an `$exists` condition
	 *
	 * ####Example
	 *
	 *     // { name: { $exists: true }}
	 *     Thing.where('name').exists()
	 *     Thing.where('name').exists(true)
	 *     Thing.find().exists('name')
	 *
	 *     // { name: { $exists: false }}
	 *     Thing.where('name').exists(false);
	 *     Thing.find().exists('name', false);
	 *
	 * @param {String} [path]
	 * @param {Number} val
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.exists = function () {
	  var path, val;
	
	  if (0 === arguments.length) {
	    this._ensurePath('exists');
	    path = this._path;
	    val = true;
	  } else if (1 === arguments.length) {
	    if ('boolean' === typeof arguments[0]) {
	      this._ensurePath('exists');
	      path = this._path;
	      val = arguments[0];
	    } else {
	      path = arguments[0];
	      val = true;
	    }
	  } else if (2 === arguments.length) {
	    path = arguments[0];
	    val = arguments[1];
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds.$exists = val;
	  return this;
	}
	
	/**
	 * Specifies an `$elemMatch` condition
	 *
	 * ####Example
	 *
	 *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})
	 *
	 *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})
	 *
	 *     query.elemMatch('comment', function (elem) {
	 *       elem.where('author').equals('autobot');
	 *       elem.where('votes').gte(5);
	 *     })
	 *
	 *     query.where('comment').elemMatch(function (elem) {
	 *       elem.where({ author: 'autobot' });
	 *       elem.where('votes').gte(5);
	 *     })
	 *
	 * @param {String|Object|Function} path
	 * @param {Object|Function} criteria
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.elemMatch = function () {
	  if (null == arguments[0])
	    throw new TypeError("Invalid argument");
	
	  var fn, path, criteria;
	
	  if ('function' === typeof arguments[0]) {
	    this._ensurePath('elemMatch');
	    path = this._path;
	    fn = arguments[0];
	  } else if (utils.isObject(arguments[0])) {
	    this._ensurePath('elemMatch');
	    path = this._path;
	    criteria = arguments[0];
	  } else if ('function' === typeof arguments[1]) {
	    path = arguments[0];
	    fn = arguments[1];
	  } else if (arguments[1] && utils.isObject(arguments[1])) {
	    path = arguments[0];
	    criteria = arguments[1];
	  } else {
	    throw new TypeError("Invalid argument");
	  }
	
	  if (fn) {
	    criteria = new Query;
	    fn(criteria);
	    criteria = criteria._conditions;
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds.$elemMatch = criteria;
	  return this;
	}
	
	// Spatial queries
	
	/**
	 * Sugar for geo-spatial queries.
	 *
	 * ####Example
	 *
	 *     query.within().box()
	 *     query.within().circle()
	 *     query.within().geometry()
	 *
	 *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });
	 *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });
	 *     query.where('loc').within({ polygon: [[],[],[],[]] });
	 *
	 *     query.where('loc').within([], [], []) // polygon
	 *     query.where('loc').within([], []) // box
	 *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry
	 *
	 * ####NOTE:
	 *
	 * Must be used after `where()`.
	 *
	 * @memberOf Query
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.within = function within () {
	  // opinionated, must be used after where
	  this._ensurePath('within');
	  this._geoComparison = $withinCmd;
	
	  if (0 === arguments.length) {
	    return this;
	  }
	
	  if (2 === arguments.length) {
	    return this.box.apply(this, arguments);
	  } else if (2 < arguments.length) {
	    return this.polygon.apply(this, arguments);
	  }
	
	  var area = arguments[0];
	
	  if (!area)
	    throw new TypeError('Invalid argument');
	
	  if (area.center)
	    return this.circle(area);
	
	  if (area.box)
	    return this.box.apply(this, area.box);
	
	  if (area.polygon)
	    return this.polygon.apply(this, area.polygon);
	
	  if (area.type && area.coordinates)
	    return this.geometry(area);
	
	  throw new TypeError('Invalid argument');
	}
	
	/**
	 * Specifies a $box condition
	 *
	 * ####Example
	 *
	 *     var lowerLeft = [40.73083, -73.99756]
	 *     var upperRight= [40.741404,  -73.988135]
	 *
	 *     query.where('loc').within().box(lowerLeft, upperRight)
	 *     query.box('loc', lowerLeft, upperRight )
	 *
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @see Query#within #query_Query-within
	 * @param {String} path
	 * @param {Object} val
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.box = function () {
	  var path, box;
	
	  if (3 === arguments.length) {
	    // box('loc', [], [])
	    path = arguments[0];
	    box = [arguments[1], arguments[2]];
	  } else if (2 === arguments.length) {
	    // box([], [])
	    this._ensurePath('box');
	    path = this._path;
	    box = [arguments[0], arguments[1]];
	  } else {
	    throw new TypeError("Invalid argument");
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds[this._geoComparison || $withinCmd] = { '$box': box  };
	  return this;
	}
	
	/**
	 * Specifies a $polygon condition
	 *
	 * ####Example
	 *
	 *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])
	 *     query.polygon('loc', [10,20], [13, 25], [7,15])
	 *
	 * @param {String|Array} [path]
	 * @param {Array|Object} [val]
	 * @return {Query} this
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	Query.prototype.polygon = function () {
	  var val, path;
	
	  if ('string' == typeof arguments[0]) {
	    // polygon('loc', [],[],[])
	    path = arguments[0];
	    val = slice(arguments, 1);
	  } else {
	    // polygon([],[],[])
	    this._ensurePath('polygon');
	    path = this._path;
	    val = slice(arguments);
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds[this._geoComparison || $withinCmd] = { '$polygon': val };
	  return this;
	}
	
	/**
	 * Specifies a $center or $centerSphere condition.
	 *
	 * ####Example
	 *
	 *     var area = { center: [50, 50], radius: 10, unique: true }
	 *     query.where('loc').within().circle(area)
	 *     query.center('loc', area);
	 *
	 *     // for spherical calculations
	 *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }
	 *     query.where('loc').within().circle(area)
	 *     query.center('loc', area);
	 *
	 * @param {String} [path]
	 * @param {Object} area
	 * @return {Query} this
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	Query.prototype.circle = function () {
	  var path, val;
	
	  if (1 === arguments.length) {
	    this._ensurePath('circle');
	    path = this._path;
	    val = arguments[0];
	  } else if (2 === arguments.length) {
	    path = arguments[0];
	    val = arguments[1];
	  } else {
	    throw new TypeError("Invalid argument");
	  }
	
	  if (!('radius' in val && val.center))
	    throw new Error('center and radius are required');
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	
	  var type = val.spherical
	    ? '$centerSphere'
	    : '$center';
	
	  var wKey = this._geoComparison || $withinCmd;
	  conds[wKey] = {};
	  conds[wKey][type] = [val.center, val.radius];
	
	  if ('unique' in val)
	    conds[wKey].$uniqueDocs = !! val.unique;
	
	  return this;
	}
	
	/**
	 * Specifies a `$near` or `$nearSphere` condition
	 *
	 * These operators return documents sorted by distance.
	 *
	 * ####Example
	 *
	 *     query.where('loc').near({ center: [10, 10] });
	 *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });
	 *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });
	 *     query.near('loc', { center: [10, 10], maxDistance: 5 });
	 *     query.near({ center: { type: 'Point', coordinates: [..] }})
	 *     query.near().geometry({ type: 'Point', coordinates: [..] })
	 *
	 * @param {String} [path]
	 * @param {Object} val
	 * @return {Query} this
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	Query.prototype.near = function near () {
	  var path, val;
	
	  this._geoComparison = '$near';
	
	  if (0 === arguments.length) {
	    return this;
	  } else if (1 === arguments.length) {
	    this._ensurePath('near');
	    path = this._path;
	    val = arguments[0];
	  } else if (2 === arguments.length) {
	    path = arguments[0];
	    val = arguments[1];
	  } else {
	    throw new TypeError("Invalid argument");
	  }
	
	  if (!val.center) {
	    throw new Error('center is required');
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	
	  var type = val.spherical
	    ? '$nearSphere'
	    : '$near';
	
	  // center could be a GeoJSON object or an Array
	  if (Array.isArray(val.center)) {
	    conds[type] = val.center;
	
	    var radius = 'maxDistance' in val
	      ? val.maxDistance
	      : null;
	
	    if (null != radius) {
	      conds.$maxDistance = radius;
	    }
	    if (null != val.minDistance) {
	      conds.$minDistance = val.minDistance;
	    }
	  } else {
	    // GeoJSON?
	    if (val.center.type != 'Point' || !Array.isArray(val.center.coordinates)) {
	      throw new Error(util.format("Invalid GeoJSON specified for %s", type));
	    }
	    conds[type] = { $geometry : val.center };
	
	    // MongoDB 2.6 insists on maxDistance being in $near / $nearSphere
	    if ('maxDistance' in val) {
	      conds[type]['$maxDistance'] = val.maxDistance;
	    }
	    if ('minDistance' in val) {
	      conds[type]['$minDistance'] = val.minDistance;
	    }
	  }
	
	  return this;
	}
	
	/**
	 * Declares an intersects query for `geometry()`.
	 *
	 * ####Example
	 *
	 *     query.where('path').intersects().geometry({
	 *         type: 'LineString'
	 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
	 *     })
	 *
	 *     query.where('path').intersects({
	 *         type: 'LineString'
	 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
	 *     })
	 *
	 * @param {Object} [arg]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.intersects = function intersects () {
	  // opinionated, must be used after where
	  this._ensurePath('intersects');
	
	  this._geoComparison = '$geoIntersects';
	
	  if (0 === arguments.length) {
	    return this;
	  }
	
	  var area = arguments[0];
	
	  if (null != area && area.type && area.coordinates)
	    return this.geometry(area);
	
	  throw new TypeError('Invalid argument');
	}
	
	/**
	 * Specifies a `$geometry` condition
	 *
	 * ####Example
	 *
	 *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]
	 *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })
	 *
	 *     // or
	 *     var polyB = [[ 0, 0 ], [ 1, 1 ]]
	 *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })
	 *
	 *     // or
	 *     var polyC = [ 0, 0 ]
	 *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })
	 *
	 *     // or
	 *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })
	 *
	 * ####NOTE:
	 *
	 * `geometry()` **must** come after either `intersects()` or `within()`.
	 *
	 * The `object` argument must contain `type` and `coordinates` properties.
	 * - type {String}
	 * - coordinates {Array}
	 *
	 * The most recent path passed to `where()` is used.
	 *
	 * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.
	 * @return {Query} this
	 * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/
	 * @api public
	 */
	
	Query.prototype.geometry = function geometry () {
	  if (!('$within' == this._geoComparison ||
	        '$geoWithin' == this._geoComparison ||
	        '$near' == this._geoComparison ||
	        '$geoIntersects' == this._geoComparison)) {
	    throw new Error('geometry() must come after `within()`, `intersects()`, or `near()');
	  }
	
	  var val, path;
	
	  if (1 === arguments.length) {
	    this._ensurePath('geometry');
	    path = this._path;
	    val = arguments[0];
	  } else {
	    throw new TypeError("Invalid argument");
	  }
	
	  if (!(val.type && Array.isArray(val.coordinates))) {
	    throw new TypeError('Invalid argument');
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds[this._geoComparison] = { $geometry: val };
	
	  return this;
	}
	
	// end spatial
	
	/**
	 * Specifies which document fields to include or exclude
	 *
	 * ####String syntax
	 *
	 * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.
	 *
	 * ####Example
	 *
	 *     // include a and b, exclude c
	 *     query.select('a b -c');
	 *
	 *     // or you may use object notation, useful when
	 *     // you have keys already prefixed with a "-"
	 *     query.select({a: 1, b: 1, c: 0});
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @param {Object|String} arg
	 * @return {Query} this
	 * @see SchemaType
	 * @api public
	 */
	
	Query.prototype.select = function select () {
	  var arg = arguments[0];
	  if (!arg) return this;
	
	  if (arguments.length !== 1) {
	    throw new Error("Invalid select: select only takes 1 argument");
	  }
	
	  this._validate('select');
	
	  var fields = this._fields || (this._fields = {});
	  var type = typeof arg;
	
	  if (('string' == type || utils.isArgumentsObject(arg)) &&
	    'number' == typeof arg.length) {
	    if ('string' == type)
	      arg = arg.split(/\s+/);
	
	    for (var i = 0, len = arg.length; i < len; ++i) {
	      var field = arg[i];
	      if (!field) continue;
	      var include = '-' == field[0] ? 0 : 1;
	      if (include === 0) field = field.substring(1);
	      fields[field] = include;
	    }
	
	    return this;
	  }
	
	  if (utils.isObject(arg) && !Array.isArray(arg)) {
	    var keys = utils.keys(arg);
	    for (var i = 0; i < keys.length; ++i) {
	      fields[keys[i]] = arg[keys[i]];
	    }
	    return this;
	  }
	
	  throw new TypeError('Invalid select() argument. Must be string or object.');
	}
	
	/**
	 * Specifies a $slice condition for a `path`
	 *
	 * ####Example
	 *
	 *     query.slice('comments', 5)
	 *     query.slice('comments', -5)
	 *     query.slice('comments', [10, 5])
	 *     query.where('comments').slice(5)
	 *     query.where('comments').slice([-10, 5])
	 *
	 * @param {String} [path]
	 * @param {Number} val number/range of elements to slice
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements
	 * @api public
	 */
	
	Query.prototype.slice = function () {
	  if (0 === arguments.length)
	    return this;
	
	  this._validate('slice');
	
	  var path, val;
	
	  if (1 === arguments.length) {
	    var arg = arguments[0];
	    if (typeof arg === 'object' && !Array.isArray(arg)) {
	      var keys = Object.keys(arg);
	      var numKeys = keys.length;
	      for (var i = 0; i < numKeys; ++i) {
	        this.slice(keys[i], arg[keys[i]]);
	      }
	      return this;
	    }
	    this._ensurePath('slice');
	    path = this._path;
	    val = arguments[0];
	  } else if (2 === arguments.length) {
	    if ('number' === typeof arguments[0]) {
	      this._ensurePath('slice');
	      path = this._path;
	      val = slice(arguments);
	    } else {
	      path = arguments[0];
	      val = arguments[1];
	    }
	  } else if (3 === arguments.length) {
	    path = arguments[0];
	    val = slice(arguments, 1);
	  }
	
	  var myFields = this._fields || (this._fields = {});
	  myFields[path] = { '$slice': val };
	  return this;
	}
	
	/**
	 * Sets the sort order
	 *
	 * If an object is passed, values allowed are 'asc', 'desc', 'ascending', 'descending', 1, and -1.
	 *
	 * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.
	 *
	 * ####Example
	 *
	 *     // these are equivalent
	 *     query.sort({ field: 'asc', test: -1 });
	 *     query.sort('field -test');
	 *     query.sort([['field', 1], ['test', -1]]);
	 *
	 * ####Note
	 *
	 *  - The array syntax `.sort([['field', 1], ['test', -1]])` can only be used with [mongodb driver >= 2.0.46](https://github.com/mongodb/node-mongodb-native/blob/2.1/HISTORY.md#2046-2015-10-15).
	 *  - Cannot be used with `distinct()`
	 *
	 * @param {Object|String|Array} arg
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.sort = function (arg) {
	  if (!arg) return this;
	  var len;
	
	  this._validate('sort');
	
	  var type = typeof arg;
	
	  // .sort([['field', 1], ['test', -1]])
	  if (Array.isArray(arg)) {
	    len = arg.length;
	    for (var i = 0; i < arg.length; ++i) {
	      _pushArr(this.options, arg[i][0], arg[i][1]);
	    }
	    return this;
	  }
	
	  // .sort('field -test')
	  if (1 === arguments.length && 'string' == type) {
	    arg = arg.split(/\s+/);
	    len = arg.length;
	    for (var i = 0; i < len; ++i) {
	      var field = arg[i];
	      if (!field) continue;
	      var ascend = '-' == field[0] ? -1 : 1;
	      if (ascend === -1) field = field.substring(1);
	      push(this.options, field, ascend);
	    }
	
	    return this;
	  }
	
	  // .sort({ field: 1, test: -1 })
	  if (utils.isObject(arg)) {
	    var keys = utils.keys(arg);
	    for (var i = 0; i < keys.length; ++i) {
	      var field = keys[i];
	      push(this.options, field, arg[field]);
	    }
	
	    return this;
	  }
	
	  throw new TypeError('Invalid sort() argument. Must be a string, object, or array.');
	}
	
	/*!
	 * @ignore
	 */
	
	function push (opts, field, value) {
	  if (Array.isArray(opts.sort)) {
	    throw new TypeError("Can't mix sort syntaxes. Use either array or object:" +
	      "\n- `.sort([['field', 1], ['test', -1]])`" +
	      "\n- `.sort({ field: 1, test: -1 })`");
	  }
	
	  if (value && value.$meta) {
	    var s = opts.sort || (opts.sort = {});
	    s[field] = { $meta : value.$meta };
	    return;
	  }
	
	  var val = String(value || 1).toLowerCase();
	  if (!/^(?:ascending|asc|descending|desc|1|-1)$/.test(val)) {
	    if (utils.isArray(value)) value = '['+value+']';
	    throw new TypeError('Invalid sort value: {' + field + ': ' + value + ' }');
	  }
	  // store `sort` in a sane format
	  var s = opts.sort || (opts.sort = {});
	  var valueStr = value.toString()
	                  .replace("asc", "1")
	                  .replace("ascending", "1")
	                  .replace("desc", "-1")
	                  .replace("descending", "-1");
	  s[field] = parseInt(valueStr, 10);
	}
	
	function _pushArr (opts, field, value) {
	  opts.sort = opts.sort || [];
	  if (!Array.isArray(opts.sort)) {
	    throw new TypeError("Can't mix sort syntaxes. Use either array or object:" +
	      "\n- `.sort([['field', 1], ['test', -1]])`" +
	      "\n- `.sort({ field: 1, test: -1 })`");
	  }
	  var valueStr = value.toString()
	    .replace("asc", "1")
	    .replace("ascending", "1")
	    .replace("desc", "-1")
	    .replace("descending", "-1");
	  opts.sort.push([field, value]);
	}
	
	/**
	 * Specifies the limit option.
	 *
	 * ####Example
	 *
	 *     query.limit(20)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method limit
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D
	 * @api public
	 */
	/**
	 * Specifies the skip option.
	 *
	 * ####Example
	 *
	 *     query.skip(100).limit(20)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method skip
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D
	 * @api public
	 */
	/**
	 * Specifies the maxScan option.
	 *
	 * ####Example
	 *
	 *     query.maxScan(100)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method maxScan
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan
	 * @api public
	 */
	/**
	 * Specifies the batchSize option.
	 *
	 * ####Example
	 *
	 *     query.batchSize(100)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method batchSize
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D
	 * @api public
	 */
	/**
	 * Specifies the `comment` option.
	 *
	 * ####Example
	 *
	 *     query.comment('login query')
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method comment
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment
	 * @api public
	 */
	
	/*!
	 * limit, skip, maxScan, batchSize, comment
	 *
	 * Sets these associated options.
	 *
	 *     query.comment('feed query');
	 */
	
	;['limit', 'skip', 'maxScan', 'batchSize', 'comment'].forEach(function (method) {
	  Query.prototype[method] = function (v) {
	    this._validate(method);
	    this.options[method] = v;
	    return this;
	  };
	})
	
	/**
	 * Specifies the maxTimeMS option.
	 *
	 * ####Example
	 *
	 *     query.maxTime(100)
	 *
	 * @method maxTime
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS
	 * @api public
	 */
	
	Query.prototype.maxTime = function (v) {
	  this._validate('maxTime');
	  this.options.maxTimeMS = v;
	  return this;
	};
	
	/**
	 * Specifies this query as a `snapshot` query.
	 *
	 * ####Example
	 *
	 *     mquery().snapshot() // true
	 *     mquery().snapshot(true)
	 *     mquery().snapshot(false)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.snapshot = function () {
	  this._validate('snapshot');
	
	  this.options.snapshot = arguments.length
	    ? !! arguments[0]
	    : true
	
	  return this;
	}
	
	/**
	 * Sets query hints.
	 *
	 * ####Example
	 *
	 *     query.hint({ indexA: 1, indexB: -1})
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @param {Object} val a hint object
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint
	 * @api public
	 */
	
	Query.prototype.hint = function () {
	  if (0 === arguments.length) return this;
	
	  this._validate('hint');
	
	  var arg = arguments[0];
	  if (utils.isObject(arg)) {
	    var hint = this.options.hint || (this.options.hint = {});
	
	    // must keep object keys in order so don't use Object.keys()
	    for (var k in arg) {
	      hint[k] = arg[k];
	    }
	
	    return this;
	  }
	
	  throw new TypeError('Invalid hint. ' + arg);
	}
	
	/**
	 * Sets the slaveOk option. _Deprecated_ in MongoDB 2.2 in favor of read preferences.
	 *
	 * ####Example:
	 *
	 *     query.slaveOk() // true
	 *     query.slaveOk(true)
	 *     query.slaveOk(false)
	 *
	 * @deprecated use read() preferences instead if on mongodb >= 2.2
	 * @param {Boolean} v defaults to true
	 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
	 * @see read()
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.slaveOk = function (v) {
	  this.options.slaveOk = arguments.length ? !!v : true;
	  return this;
	}
	
	/**
	 * Sets the readPreference option for the query.
	 *
	 * ####Example:
	 *
	 *     new Query().read('primary')
	 *     new Query().read('p')  // same as primary
	 *
	 *     new Query().read('primaryPreferred')
	 *     new Query().read('pp') // same as primaryPreferred
	 *
	 *     new Query().read('secondary')
	 *     new Query().read('s')  // same as secondary
	 *
	 *     new Query().read('secondaryPreferred')
	 *     new Query().read('sp') // same as secondaryPreferred
	 *
	 *     new Query().read('nearest')
	 *     new Query().read('n')  // same as nearest
	 *
	 *     // you can also use mongodb.ReadPreference class to also specify tags
	 *     new Query().read(mongodb.ReadPreference('secondary', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }]))
	 *
	 * ####Preferences:
	 *
	 *     primary - (default)  Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.
	 *     secondary            Read from secondary if available, otherwise error.
	 *     primaryPreferred     Read from primary if available, otherwise a secondary.
	 *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.
	 *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.
	 *
	 * Aliases
	 *
	 *     p   primary
	 *     pp  primaryPreferred
	 *     s   secondary
	 *     sp  secondaryPreferred
	 *     n   nearest
	 *
	 * Read more about how to use read preferences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).
	 *
	 * @param {String|ReadPreference} pref one of the listed preference options or their aliases
	 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
	 * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.read = function (pref) {
	  if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {
	    console.error("Deprecation warning: 'tags' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.");
	    Query.prototype.read.deprecationWarningIssued = true;
	  }
	  this.options.readPreference = utils.readPref(pref);
	  return this;
	}
	
	/**
	 * Sets tailable option.
	 *
	 * ####Example
	 *
	 *     query.tailable() <== true
	 *     query.tailable(true)
	 *     query.tailable(false)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @param {Boolean} v defaults to true
	 * @see mongodb http://www.mongodb.org/display/DOCS/Tailable+Cursors
	 * @api public
	 */
	
	Query.prototype.tailable = function () {
	  this._validate('tailable');
	
	  this.options.tailable = arguments.length
	    ? !! arguments[0]
	    : true;
	
	  return this;
	}
	
	/**
	 * Merges another Query or conditions object into this one.
	 *
	 * When a Query is passed, conditions, field selection and options are merged.
	 *
	 * @param {Query|Object} source
	 * @return {Query} this
	 */
	
	Query.prototype.merge = function (source) {
	  if (!source)
	    return this;
	
	  if (!Query.canMerge(source))
	    throw new TypeError('Invalid argument. Expected instanceof mquery or plain object');
	
	  if (source instanceof Query) {
	    // if source has a feature, apply it to ourselves
	
	    if (source._conditions) {
	      utils.merge(this._conditions, source._conditions);
	    }
	
	    if (source._fields) {
	      this._fields || (this._fields = {});
	      utils.merge(this._fields, source._fields);
	    }
	
	    if (source.options) {
	      this.options || (this.options = {});
	      utils.merge(this.options, source.options);
	    }
	
	    if (source._update) {
	      this._update || (this._update = {});
	      utils.mergeClone(this._update, source._update);
	    }
	
	    if (source._distinct) {
	      this._distinct = source._distinct;
	    }
	
	    return this;
	  }
	
	  // plain object
	  utils.merge(this._conditions, source);
	
	  return this;
	}
	
	/**
	 * Finds documents.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * ####Example
	 *
	 *     query.find()
	 *     query.find(callback)
	 *     query.find({ name: 'Burning Lights' }, callback)
	 *
	 * @param {Object} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.find = function (criteria, callback) {
	  this.op = 'find';
	
	  if ('function' === typeof criteria) {
	    callback = criteria;
	    criteria = undefined;
	  } else if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  if (!callback) return this;
	
	  var self = this
	    , conds = this._conditions
	    , options = this._optionsForExec()
	
	  options.fields = this._fieldsForExec()
	
	  debug('find', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('find', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.find(conds, options, utils.tick(callback));
	  return this;
	}
	
	/**
	 * Returns the query cursor
	 *
	 * ####Examples
	 *
	 *     query.find().cursor();
	 *     query.cursor({ name: 'Burning Lights' });
	 *
	 * @param {Object} [criteria] mongodb selector
	 * @return {Object} cursor
	 * @api public
	 */
	
	Query.prototype.cursor = function cursor (criteria) {
	  if (this.op) {
	    if (this.op !== 'find') {
	      throw new TypeError(".cursor only support .find method");
	    }
	  } else {
	    this.find(criteria);
	  }
	
	  var conds = this._conditions
	    , options = this._optionsForExec()
	
	  options.fields = this._fieldsForExec()
	
	  debug('findCursor', this._collection.collectionName, conds, options);
	  return this._collection.findCursor(conds, options);
	}
	
	/**
	 * Executes the query as a findOne() operation.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * ####Example
	 *
	 *     query.findOne().where('name', /^Burning/);
	 *
	 *     query.findOne({ name: /^Burning/ })
	 *
	 *     query.findOne({ name: /^Burning/ }, callback); // executes
	 *
	 *     query.findOne(function (err, doc) {
	 *       if (err) return handleError(err);
	 *       if (doc) {
	 *         // doc may be null if no document matched
	 *
	 *       }
	 *     });
	 *
	 * @param {Object|Query} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.findOne = function (criteria, callback) {
	  this.op = 'findOne';
	
	  if ('function' === typeof criteria) {
	    callback = criteria;
	    criteria = undefined;
	  } else if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  if (!callback) return this;
	
	  var self = this
	    , conds = this._conditions
	    , options = this._optionsForExec()
	
	  options.fields = this._fieldsForExec();
	
	  debug('findOne', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('findOne', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.findOne(conds, options, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Exectues the query as a count() operation.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * ####Example
	 *
	 *     query.count().where('color', 'black').exec(callback);
	 *
	 *     query.count({ color: 'black' }).count(callback)
	 *
	 *     query.count({ color: 'black' }, callback)
	 *
	 *     query.where('color', 'black').count(function (err, count) {
	 *       if (err) return handleError(err);
	 *       console.log('there are %d kittens', count);
	 *     })
	 *
	 * @param {Object} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Count
	 * @api public
	 */
	
	Query.prototype.count = function (criteria, callback) {
	  this.op = 'count';
	  this._validate();
	
	  if ('function' === typeof criteria) {
	    callback = criteria;
	    criteria = undefined;
	  } else if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  if (!callback) return this;
	
	  var conds = this._conditions
	    , options = this._optionsForExec()
	
	  debug('count', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('count', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.count(conds, options, utils.tick(callback));
	  return this;
	}
	
	/**
	 * Declares or executes a distinct() operation.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * ####Example
	 *
	 *     distinct(criteria, field, fn)
	 *     distinct(criteria, field)
	 *     distinct(field, fn)
	 *     distinct(field)
	 *     distinct(fn)
	 *     distinct()
	 *
	 * @param {Object|Query} [criteria]
	 * @param {String} [field]
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Distinct
	 * @api public
	 */
	
	Query.prototype.distinct = function (criteria, field, callback) {
	  this.op = 'distinct';
	  this._validate();
	
	  if (!callback) {
	    switch (typeof field) {
	      case 'function':
	        callback = field;
	        if ('string' == typeof criteria) {
	          field = criteria;
	          criteria = undefined;
	        }
	        break;
	      case 'undefined':
	      case 'string':
	        break;
	      default:
	        throw new TypeError('Invalid `field` argument. Must be string or function')
	        break;
	    }
	
	    switch (typeof criteria) {
	      case 'function':
	        callback = criteria;
	        criteria = field = undefined;
	        break;
	      case 'string':
	        field = criteria;
	        criteria = undefined;
	        break;
	    }
	  }
	
	  if ('string' == typeof field) {
	    this._distinct = field;
	  }
	
	  if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  if (!callback) {
	    return this;
	  }
	
	  if (!this._distinct) {
	    throw new Error('No value for `distinct` has been declared');
	  }
	
	  var conds = this._conditions
	    , options = this._optionsForExec()
	
	  debug('distinct', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('distinct', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.distinct(this._distinct, conds, options, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Declare and/or execute this query as an update() operation.
	 *
	 * _All paths passed that are not $atomic operations will become $set ops._
	 *
	 * ####Example
	 *
	 *     mquery({ _id: id }).update({ title: 'words' }, ...)
	 *
	 * becomes
	 *
	 *     collection.update({ _id: id }, { $set: { title: 'words' }}, ...)
	 *
	 * ####Note
	 *
	 * Passing an empty object `{}` as the doc will result in a no-op unless the `overwrite` option is passed. Without the `overwrite` option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.
	 *
	 * ####Note
	 *
	 * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call update() and then execute it by using the `exec()` method.
	 *
	 *     var q = mquery(collection).where({ _id: id });
	 *     q.update({ $set: { name: 'bob' }}).update(); // not executed
	 *
	 *     var q = mquery(collection).where({ _id: id });
	 *     q.update({ $set: { name: 'bob' }}).exec(); // executed as unsafe
	 *
	 *     // keys that are not $atomic ops become $set.
	 *     // this executes the same command as the previous example.
	 *     q.update({ name: 'bob' }).where({ _id: id }).exec();
	 *
	 *     var q = mquery(collection).update(); // not executed
	 *
	 *     // overwriting with empty docs
	 *     var q.where({ _id: id }).setOptions({ overwrite: true })
	 *     q.update({ }, callback); // executes
	 *
	 *     // multi update with overwrite to empty doc
	 *     var q = mquery(collection).where({ _id: id });
	 *     q.setOptions({ multi: true, overwrite: true })
	 *     q.update({ });
	 *     q.update(callback); // executed
	 *
	 *     // multi updates
	 *     mquery()
	 *       .collection(coll)
	 *       .update({ name: /^match/ }, { $set: { arr: [] }}, { multi: true }, callback)
	 *     // more multi updates
	 *     mquery({ })
	 *       .collection(coll)
	 *       .setOptions({ multi: true })
	 *       .update({ $set: { arr: [] }}, callback)
	 *
	 *     // single update by default
	 *     mquery({ email: 'address@example.com' })
	 *      .collection(coll)
	 *      .update({ $inc: { counter: 1 }}, callback)
	 *
	 *     // summary
	 *     update(criteria, doc, opts, cb) // executes
	 *     update(criteria, doc, opts)
	 *     update(criteria, doc, cb) // executes
	 *     update(criteria, doc)
	 *     update(doc, cb) // executes
	 *     update(doc)
	 *     update(cb) // executes
	 *     update(true) // executes (unsafe write)
	 *     update()
	 *
	 * @param {Object} [criteria]
	 * @param {Object} [doc] the update command
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.update = function update (criteria, doc, options, callback) {
	  this.op = 'update';
	  var force;
	
	  switch (arguments.length) {
	    case 3:
	      if ('function' == typeof options) {
	        callback = options;
	        options = undefined;
	      }
	      break;
	    case 2:
	      if ('function' == typeof doc) {
	        callback = doc;
	        doc = criteria;
	        criteria = undefined;
	      }
	      break;
	    case 1:
	      switch (typeof criteria) {
	        case 'function':
	          callback = criteria;
	          criteria = options = doc = undefined;
	          break;
	        case 'boolean':
	          // execution with no callback (unsafe write)
	          force = criteria;
	          criteria = undefined;
	          break;
	        default:
	          doc = criteria;
	          criteria = options = undefined;
	          break;
	      }
	  }
	
	  if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  if (doc) {
	    this._mergeUpdate(doc);
	  }
	
	  if (utils.isObject(options)) {
	    // { overwrite: true }
	    this.setOptions(options);
	  }
	
	  // we are done if we don't have callback and they are
	  // not forcing an unsafe write.
	  if (!(force || callback))
	    return this;
	
	  if (!this._update ||
	      !this.options.overwrite && 0 === utils.keys(this._update).length) {
	    callback && utils.soon(callback.bind(null, null, 0));
	    return this;
	  }
	
	  options = this._optionsForExec();
	  if (!callback) options.safe = false;
	
	  var criteria = this._conditions;
	  doc = this._updateForExec();
	
	  debug('update', this._collection.collectionName, criteria, doc, options);
	  callback = this._wrapCallback('update', callback, {
	    conditions: criteria
	  , doc: doc
	  , options: options
	  });
	
	  this._collection.update(criteria, doc, options, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Declare and/or execute this query as a remove() operation.
	 *
	 * ####Example
	 *
	 *     mquery(collection).remove({ artist: 'Anne Murray' }, callback)
	 *
	 * ####Note
	 *
	 * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call remove() and then execute it by using the `exec()` method.
	 *
	 *     // not executed
	 *     var query = mquery(collection).remove({ name: 'Anne Murray' })
	 *
	 *     // executed
	 *     mquery(collection).remove({ name: 'Anne Murray' }, callback)
	 *     mquery(collection).remove({ name: 'Anne Murray' }).remove(callback)
	 *
	 *     // executed without a callback (unsafe write)
	 *     query.exec()
	 *
	 *     // summary
	 *     query.remove(conds, fn); // executes
	 *     query.remove(conds)
	 *     query.remove(fn) // executes
	 *     query.remove()
	 *
	 * @param {Object|Query} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.remove = function (criteria, callback) {
	  this.op = 'remove';
	  var force;
	
	  if ('function' === typeof criteria) {
	    callback = criteria;
	    criteria = undefined;
	  } else if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  } else if (true === criteria) {
	    force = criteria;
	    criteria = undefined;
	  }
	
	  if (!(force || callback))
	    return this;
	
	  var options = this._optionsForExec()
	  if (!callback) options.safe = false;
	
	  var conds = this._conditions;
	
	  debug('remove', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('remove', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.remove(conds, options, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.
	 *
	 * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed.
	 *
	 * ####Available options
	 *
	 * - `new`: bool - true to return the modified document rather than the original. defaults to true
	 * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 *
	 * ####Examples
	 *
	 *     query.findOneAndUpdate(conditions, update, options, callback) // executes
	 *     query.findOneAndUpdate(conditions, update, options)  // returns Query
	 *     query.findOneAndUpdate(conditions, update, callback) // executes
	 *     query.findOneAndUpdate(conditions, update)           // returns Query
	 *     query.findOneAndUpdate(update, callback)             // returns Query
	 *     query.findOneAndUpdate(update)                       // returns Query
	 *     query.findOneAndUpdate(callback)                     // executes
	 *     query.findOneAndUpdate()                             // returns Query
	 *
	 * @param {Object|Query} [query]
	 * @param {Object} [doc]
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.findOneAndUpdate = function (criteria, doc, options, callback) {
	  this.op = 'findOneAndUpdate';
	  this._validate();
	
	  switch (arguments.length) {
	    case 3:
	      if ('function' == typeof options) {
	        callback = options;
	        options = {};
	      }
	      break;
	    case 2:
	      if ('function' == typeof doc) {
	        callback = doc;
	        doc = criteria;
	        criteria = undefined;
	      }
	      options = undefined;
	      break;
	    case 1:
	      if ('function' == typeof criteria) {
	        callback = criteria;
	        criteria = options = doc = undefined;
	      } else {
	        doc = criteria;
	        criteria = options = undefined;
	      }
	  }
	
	  if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  // apply doc
	  if (doc) {
	    this._mergeUpdate(doc);
	  }
	
	  options && this.setOptions(options);
	
	  if (!callback) return this;
	  return this._findAndModify('update', callback);
	}
	
	/**
	 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.
	 *
	 * Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if `callback` is passed.
	 *
	 * ####Available options
	 *
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 *
	 * ####Examples
	 *
	 *     A.where().findOneAndRemove(conditions, options, callback) // executes
	 *     A.where().findOneAndRemove(conditions, options)  // return Query
	 *     A.where().findOneAndRemove(conditions, callback) // executes
	 *     A.where().findOneAndRemove(conditions) // returns Query
	 *     A.where().findOneAndRemove(callback)   // executes
	 *     A.where().findOneAndRemove()           // returns Query
	 *
	 * @param {Object} [conditions]
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @api public
	 */
	
	Query.prototype.findOneAndRemove = function (conditions, options, callback) {
	  this.op = 'findOneAndRemove';
	  this._validate();
	
	  if ('function' == typeof options) {
	    callback = options;
	    options = undefined;
	  } else if ('function' == typeof conditions) {
	    callback = conditions;
	    conditions = undefined;
	  }
	
	  // apply conditions
	  if (Query.canMerge(conditions)) {
	    this.merge(conditions);
	  }
	
	  // apply options
	  options && this.setOptions(options);
	
	  if (!callback) return this;
	
	  return this._findAndModify('remove', callback);
	}
	
	/**
	 * _findAndModify
	 *
	 * @param {String} type - either "remove" or "update"
	 * @param {Function} callback
	 * @api private
	 */
	
	Query.prototype._findAndModify = function (type, callback) {
	  assert.equal('function', typeof callback);
	
	  var opts = this._optionsForExec()
	    , self = this
	    , fields
	    , sort
	    , doc
	
	  if ('remove' == type) {
	    opts.remove = true;
	  } else {
	    if (!('new' in opts)) opts.new = true;
	    if (!('upsert' in opts)) opts.upsert = false;
	
	    doc = this._updateForExec()
	    if (!doc) {
	      if (opts.upsert) {
	        // still need to do the upsert to empty doc
	        doc = { $set: {} };
	      } else {
	        return this.findOne(callback);
	      }
	    }
	  }
	
	  var fields = this._fieldsForExec();
	  if (fields) {
	    opts.fields = fields;
	  }
	
	  var conds = this._conditions;
	
	  debug('findAndModify', this._collection.collectionName, conds, doc, opts);
	  callback = this._wrapCallback('findAndModify', callback, {
	    conditions: conds
	  , doc: doc
	  , options: opts
	  });
	
	  this._collection
	  .findAndModify(conds, doc, opts, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Wrap callback to add tracing
	 *
	 * @param {Function} callback
	 * @param {Object} [queryInfo]
	 * @api private
	 */
	Query.prototype._wrapCallback = function (method, callback, queryInfo) {
	  var traceFunction = this._traceFunction || Query.traceFunction;
	
	  if (traceFunction) {
	    queryInfo.collectionName = this._collection.collectionName;
	
	    var traceCallback = traceFunction &&
	      traceFunction.call(null, method, queryInfo, this);
	
	    var startTime = new Date().getTime();
	
	    return function wrapperCallback (err, result) {
	      if (traceCallback) {
	        var millis = new Date().getTime() - startTime;
	        traceCallback.call(null, err, result, millis);
	      }
	
	      if (callback) {
	        callback.apply(null, arguments);
	      }
	    };
	  }
	
	  return callback;
	}
	
	/**
	 * Add trace function that gets called when the query is executed.
	 * The function will be called with (method, queryInfo, query) and
	 * should return a callback function which will be called
	 * with (err, result, millis) when the query is complete.
	 *
	 * queryInfo is an object containing: {
	 *   collectionName: <name of the collection>,
	 *   conditions: <query criteria>,
	 *   options: <comment, fields, readPreference, etc>,
	 *   doc: [document to update, if applicable]
	 * }
	 *
	 * NOTE: Does not trace stream queries.
	 *
	 * @param {Function} traceFunction
	 * @return {Query} this
	 * @api public
	 */
	Query.prototype.setTraceFunction = function (traceFunction) {
	  this._traceFunction = traceFunction;
	  return this;
	}
	
	/**
	 * Executes the query
	 *
	 * ####Examples
	 *
	 *     query.exec();
	 *     query.exec(callback);
	 *     query.exec('update');
	 *     query.exec('find', callback);
	 *
	 * @param {String|Function} [operation]
	 * @param {Function} [callback]
	 * @api public
	 */
	
	Query.prototype.exec = function exec (op, callback) {
	  switch (typeof op) {
	    case 'function':
	      callback = op;
	      op = null;
	      break;
	    case 'string':
	      this.op = op;
	      break;
	  }
	
	  assert.ok(this.op, "Missing query type: (find, update, etc)");
	
	  if ('update' == this.op || 'remove' == this.op) {
	    callback || (callback = true);
	  }
	
	  var self = this;
	
	  if ('function' == typeof callback) {
	    this[this.op](callback);
	  } else {
	    return new Query.Promise(function(success, error) {
	      self[self.op](function(err, val) {
	        if (err) error(err);
	        else success(val);
	        self = success = error = null;
	      });
	    });
	  }
	}
	
	/**
	 * Returns a thunk which when called runs this.exec()
	 *
	 * The thunk receives a callback function which will be
	 * passed to `this.exec()`
	 *
	 * @return {Function}
	 * @api public
	 */
	
	Query.prototype.thunk = function() {
	  var self = this;
	  return function(cb) {
	    self.exec(cb);
	  }
	}
	
	/**
	 * Executes the query returning a `Promise` which will be
	 * resolved with either the doc(s) or rejected with the error.
	 *
	 * @param {Function} [resolve]
	 * @param {Function} [reject]
	 * @return {Promise}
	 * @api public
	 */
	
	Query.prototype.then = function(resolve, reject) {
	  var self = this;
	  var promise = new Query.Promise(function(success, error) {
	    self.exec(function(err, val) {
	      if (err) error(err);
	      else success(val);
	      self = success = error = null;
	    });
	  });
	  return promise.then(resolve, reject);
	}
	
	/**
	 * Returns a stream for the given find query.
	 *
	 * @throws Error if operation is not a find
	 * @returns {Stream} Node 0.8 style
	 */
	
	Query.prototype.stream = function(streamOptions) {
	  if ('find' != this.op)
	    throw new Error('stream() is only available for find');
	
	  var conds = this._conditions;
	
	  var options = this._optionsForExec()
	  options.fields = this._fieldsForExec()
	
	  debug('stream', this._collection.collectionName, conds, options, streamOptions);
	
	  return this._collection.findStream(conds, options, streamOptions);
	}
	
	/**
	 * Determines if field selection has been made.
	 *
	 * @return {Boolean}
	 * @api public
	 */
	
	Query.prototype.selected = function selected () {
	  return !! (this._fields && Object.keys(this._fields).length > 0);
	}
	
	/**
	 * Determines if inclusive field selection has been made.
	 *
	 *     query.selectedInclusively() // false
	 *     query.select('name')
	 *     query.selectedInclusively() // true
	 *     query.selectedExlusively() // false
	 *
	 * @returns {Boolean}
	 */
	
	Query.prototype.selectedInclusively = function selectedInclusively () {
	  if (!this._fields) return false;
	
	  var keys = Object.keys(this._fields);
	  if (0 === keys.length) return false;
	
	  for (var i = 0; i < keys.length; ++i) {
	    var key = keys[i];
	    if (0 === this._fields[key]) return false;
	    if (this._fields[key] &&
	        typeof this._fields[key] === 'object' &&
	        this._fields[key].$meta) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	/**
	 * Determines if exclusive field selection has been made.
	 *
	 *     query.selectedExlusively() // false
	 *     query.select('-name')
	 *     query.selectedExlusively() // true
	 *     query.selectedInclusively() // false
	 *
	 * @returns {Boolean}
	 */
	
	Query.prototype.selectedExclusively = function selectedExclusively () {
	  if (!this._fields) return false;
	
	  var keys = Object.keys(this._fields);
	  if (0 === keys.length) return false;
	
	  for (var i = 0; i < keys.length; ++i) {
	    var key = keys[i];
	    if (0 === this._fields[key]) return true;
	  }
	
	  return false;
	}
	
	/**
	 * Merges `doc` with the current update object.
	 *
	 * @param {Object} doc
	 */
	
	Query.prototype._mergeUpdate = function (doc) {
	  if (!this._update) this._update = {};
	  if (doc instanceof Query) {
	    if (doc._update) {
	      utils.mergeClone(this._update, doc._update);
	    }
	  } else {
	    utils.mergeClone(this._update, doc);
	  }
	}
	
	/**
	 * Returns default options.
	 *
	 * @return {Object}
	 * @api private
	 */
	
	Query.prototype._optionsForExec = function () {
	  var options = utils.clone(this.options, { retainKeyOrder: true });
	  return options;
	}
	
	/**
	 * Returns fields selection for this query.
	 *
	 * @return {Object}
	 * @api private
	 */
	
	Query.prototype._fieldsForExec = function () {
	  return utils.clone(this._fields, { retainKeyOrder: true });
	}
	
	/**
	 * Return an update document with corrected $set operations.
	 *
	 * @api private
	 */
	
	Query.prototype._updateForExec = function () {
	  var update = utils.clone(this._update, { retainKeyOrder: true })
	    , ops = utils.keys(update)
	    , i = ops.length
	    , ret = {}
	    , hasKeys
	    , val
	
	  while (i--) {
	    var op = ops[i];
	
	    if (this.options.overwrite) {
	      ret[op] = update[op];
	      continue;
	    }
	
	    if ('$' !== op[0]) {
	      // fix up $set sugar
	      if (!ret.$set) {
	        if (update.$set) {
	          ret.$set = update.$set;
	        } else {
	          ret.$set = {};
	        }
	      }
	      ret.$set[op] = update[op];
	      ops.splice(i, 1);
	      if (!~ops.indexOf('$set')) ops.push('$set');
	    } else if ('$set' === op) {
	      if (!ret.$set) {
	        ret[op] = update[op];
	      }
	    } else {
	      ret[op] = update[op];
	    }
	  }
	
	  this._compiledUpdate = ret;
	  return ret;
	}
	
	/**
	 * Make sure _path is set.
	 *
	 * @parmam {String} method
	 */
	
	Query.prototype._ensurePath = function (method) {
	  if (!this._path) {
	    var msg = method + '() must be used after where() '
	                     + 'when called with these arguments'
	    throw new Error(msg);
	  }
	}
	
	/*!
	 * Permissions
	 */
	
	Query.permissions = __webpack_require__(245);
	
	Query._isPermitted = function (a, b) {
	  var denied = Query.permissions[b];
	  if (!denied) return true;
	  return true !== denied[a];
	}
	
	Query.prototype._validate = function (action) {
	  var fail;
	  var validator;
	
	  if (undefined === action) {
	
	    validator = Query.permissions[this.op];
	    if ('function' != typeof validator) return true;
	
	    fail = validator(this);
	
	  } else if (!Query._isPermitted(action, this.op)) {
	    fail = action;
	  }
	
	  if (fail) {
	    throw new Error(fail + ' cannot be used with ' + this.op);
	  }
	}
	
	/**
	 * Determines if `conds` can be merged using `mquery().merge()`
	 *
	 * @param {Object} conds
	 * @return {Boolean}
	 */
	
	Query.canMerge = function (conds) {
	  return conds instanceof Query || utils.isObject(conds);
	}
	
	/**
	 * Set a trace function that will get called whenever a
	 * query is executed.
	 *
	 * See `setTraceFunction()` for details.
	 *
	 * @param {Object} conds
	 * @return {Boolean}
	 */
	Query.setGlobalTraceFunction = function (traceFunction) {
	  Query.traceFunction = traceFunction;
	}
	
	/*!
	 * Exports.
	 */
	
	Query.utils = utils;
	Query.env = __webpack_require__(246)
	Query.Collection = __webpack_require__(247);
	Query.BaseCollection = __webpack_require__(249);
	Query.Promise = __webpack_require__(250);
	module.exports = exports = Query;
	
	// TODO
	// test utils


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = exports = __webpack_require__(243);


/***/ },
/* 243 */
/***/ function(module, exports) {

	
	/**
	 * An Array.prototype.slice.call(arguments) alternative
	 *
	 * @param {Object} args something with a length
	 * @param {Number} slice
	 * @param {Number} sliceEnd
	 * @api public
	 */
	
	module.exports = function (args, slice, sliceEnd) {
	  var ret = [];
	  var len = args.length;
	
	  if (0 === len) return ret;
	
	  var start = slice < 0
	    ? Math.max(0, slice + len)
	    : slice || 0;
	
	  if (sliceEnd !== undefined) {
	    len = sliceEnd < 0
	      ? sliceEnd + len
	      : sliceEnd
	  }
	
	  while (len-- > start) {
	    ret[len - start] = args[len];
	  }
	
	  return ret;
	}
	


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, process, Buffer) {'use strict';
	
	/*!
	 * Module dependencies.
	 */
	
	var RegExpClone = __webpack_require__(225)
	
	/**
	 * Clones objects
	 *
	 * @param {Object} obj the object to clone
	 * @param {Object} options
	 * @return {Object} the cloned object
	 * @api private
	 */
	
	var clone = exports.clone = function clone (obj, options) {
	  if (obj === undefined || obj === null)
	    return obj;
	
	  if (Array.isArray(obj))
	    return exports.cloneArray(obj, options);
	
	  if (obj.constructor) {
	    if (/ObjectI[dD]$/.test(obj.constructor.name)) {
	      return 'function' == typeof obj.clone
	        ? obj.clone()
	        : new obj.constructor(obj.id);
	    }
	
	    if ('ReadPreference' === obj._type && obj.isValid && obj.toObject) {
	      return 'function' == typeof obj.clone
	        ? obj.clone()
	        : new obj.constructor(obj.mode, clone(obj.tags, options));
	    }
	
	    if ('Binary' == obj._bsontype && obj.buffer && obj.value) {
	      return 'function' == typeof obj.clone
	        ? obj.clone()
	        : new obj.constructor(obj.value(true), obj.sub_type);
	    }
	
	    if ('Date' === obj.constructor.name || 'Function' === obj.constructor.name)
	      return new obj.constructor(+obj);
	
	    if ('RegExp' === obj.constructor.name)
	      return RegExpClone(obj);
	
	    if ('Buffer' === obj.constructor.name)
	      return exports.cloneBuffer(obj);
	  }
	
	  if (isObject(obj))
	    return exports.cloneObject(obj, options);
	
	  if (obj.valueOf)
	    return obj.valueOf();
	};
	
	/*!
	 * ignore
	 */
	
	var cloneObject = exports.cloneObject = function cloneObject (obj, options) {
	  var retainKeyOrder = options && options.retainKeyOrder
	    , minimize = options && options.minimize
	    , ret = {}
	    , hasKeys
	    , keys
	    , val
	    , k
	    , i
	
	  if (retainKeyOrder) {
	    for (k in obj) {
	      val = clone(obj[k], options);
	
	      if (!minimize || ('undefined' !== typeof val)) {
	        hasKeys || (hasKeys = true);
	        ret[k] = val;
	      }
	    }
	  } else {
	    // faster
	
	    keys = Object.keys(obj);
	    i = keys.length;
	
	    while (i--) {
	      k = keys[i];
	      val = clone(obj[k], options);
	
	      if (!minimize || ('undefined' !== typeof val)) {
	        if (!hasKeys) hasKeys = true;
	        ret[k] = val;
	      }
	    }
	  }
	
	  return minimize
	    ? hasKeys && ret
	    : ret;
	};
	
	var cloneArray = exports.cloneArray = function cloneArray (arr, options) {
	  var ret = [];
	  for (var i = 0, l = arr.length; i < l; i++)
	    ret.push(clone(arr[i], options));
	  return ret;
	};
	
	/**
	 * process.nextTick helper.
	 *
	 * Wraps the given `callback` in a try/catch. If an error is
	 * caught it will be thrown on nextTick.
	 *
	 * node-mongodb-native had a habit of state corruption when
	 * an error was immediately thrown from within a collection
	 * method (find, update, etc) callback.
	 *
	 * @param {Function} [callback]
	 * @api private
	 */
	
	var tick = exports.tick = function tick (callback) {
	  if ('function' !== typeof callback) return;
	  return function () {
	    // callbacks should always be fired on the next
	    // turn of the event loop. A side benefit is
	    // errors thrown from executing the callback
	    // will not cause drivers state to be corrupted
	    // which has historically been a problem.
	    var args = arguments;
	    soon(function(){
	      callback.apply(this, args);
	    });
	  }
	}
	
	/**
	 * Merges `from` into `to` without overwriting existing properties.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 * @api private
	 */
	
	var merge = exports.merge = function merge (to, from) {
	  var keys = Object.keys(from)
	    , i = keys.length
	    , key
	
	  while (i--) {
	    key = keys[i];
	    if ('undefined' === typeof to[key]) {
	      to[key] = from[key];
	    } else {
	      if (exports.isObject(from[key])) {
	        merge(to[key], from[key]);
	      } else {
	        to[key] = from[key];
	      }
	    }
	  }
	}
	
	/**
	 * Same as merge but clones the assigned values.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 * @api private
	 */
	
	var mergeClone = exports.mergeClone = function mergeClone (to, from) {
	  var keys = Object.keys(from)
	    , i = keys.length
	    , key
	
	  while (i--) {
	    key = keys[i];
	    if ('undefined' === typeof to[key]) {
	      // make sure to retain key order here because of a bug handling the $each
	      // operator in mongodb 2.4.4
	      to[key] = clone(from[key], { retainKeyOrder : 1});
	    } else {
	      if (exports.isObject(from[key])) {
	        mergeClone(to[key], from[key]);
	      } else {
	        // make sure to retain key order here because of a bug handling the
	        // $each operator in mongodb 2.4.4
	        to[key] = clone(from[key], { retainKeyOrder : 1});
	      }
	    }
	  }
	}
	
	/**
	 * Read pref helper (mongo 2.2 drivers support this)
	 *
	 * Allows using aliases instead of full preference names:
	 *
	 *     p   primary
	 *     pp  primaryPreferred
	 *     s   secondary
	 *     sp  secondaryPreferred
	 *     n   nearest
	 *
	 * @param {String} pref
	 */
	
	exports.readPref = function readPref (pref) {
	  switch (pref) {
	    case 'p':
	      pref = 'primary';
	      break;
	    case 'pp':
	      pref = 'primaryPreferred';
	      break;
	    case 's':
	      pref = 'secondary';
	      break;
	    case 'sp':
	      pref = 'secondaryPreferred';
	      break;
	    case 'n':
	      pref = 'nearest';
	      break;
	  }
	
	  return pref;
	}
	
	/**
	 * Object.prototype.toString.call helper
	 */
	
	var _toString = Object.prototype.toString;
	var toString = exports.toString = function (arg) {
	  return _toString.call(arg);
	}
	
	/**
	 * Determines if `arg` is an object.
	 *
	 * @param {Object|Array|String|Function|RegExp|any} arg
	 * @return {Boolean}
	 */
	
	var isObject = exports.isObject = function (arg) {
	  return '[object Object]' == exports.toString(arg);
	}
	
	/**
	 * Determines if `arg` is an array.
	 *
	 * @param {Object}
	 * @return {Boolean}
	 * @see nodejs utils
	 */
	
	var isArray = exports.isArray = function (arg) {
	  return Array.isArray(arg) ||
	    'object' == typeof arg && '[object Array]' == exports.toString(arg);
	}
	
	/**
	 * Object.keys helper
	 */
	
	exports.keys = Object.keys || function (obj) {
	  var keys = [];
	  for (var k in obj) if (obj.hasOwnProperty(k)) {
	    keys.push(k);
	  }
	  return keys;
	}
	
	/**
	 * Basic Object.create polyfill.
	 * Only one argument is supported.
	 *
	 * Based on https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create
	 */
	
	exports.create = 'function' == typeof Object.create
	  ? Object.create
	  : create;
	
	function create (proto) {
	  if (arguments.length > 1) {
	    throw new Error("Adding properties is not supported")
	  }
	
	  function F () {}
	  F.prototype = proto;
	  return new F;
	}
	
	/**
	 * inheritance
	 */
	
	exports.inherits = function (ctor, superCtor) {
	  ctor.prototype = exports.create(superCtor.prototype);
	  ctor.prototype.constructor = ctor;
	}
	
	/**
	 * nextTick helper
	 * compat with node 0.10 which behaves differently than previous versions
	 */
	
	var soon = exports.soon = 'function' == typeof setImmediate
	  ? setImmediate
	  : process.nextTick;
	
	/**
	 * Clones the contents of a buffer.
	 *
	 * @param {Buffer} buff
	 * @return {Buffer}
	 */
	
	exports.cloneBuffer = function (buff) {
	  var dupe = new Buffer(buff.length);
	  buff.copy(dupe, 0, 0, buff.length);
	  return dupe;
	};
	
	/**
	 * Check if this object is an arguments object
	 *
	 * @param {Any} v
	 * @return {Boolean}
	 */
	
	exports.isArgumentsObject = function(v) {
	  return Object.prototype.toString.call(v) === '[object Arguments]';
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8).setImmediate, __webpack_require__(6), __webpack_require__(9).Buffer))

/***/ },
/* 245 */
/***/ function(module, exports) {

	'use strict';
	
	var denied = exports;
	
	denied.distinct = function (self) {
	  if (self._fields && Object.keys(self._fields).length > 0) {
	    return 'field selection and slice'
	  }
	
	  var keys = Object.keys(denied.distinct);
	  var err;
	
	  keys.every(function (option) {
	    if (self.options[option]) {
	      err = option;
	      return false;
	    }
	    return true;
	  });
	
	  return err;
	};
	denied.distinct.select =
	denied.distinct.slice =
	denied.distinct.sort =
	denied.distinct.limit =
	denied.distinct.skip =
	denied.distinct.batchSize =
	denied.distinct.comment =
	denied.distinct.maxScan =
	denied.distinct.snapshot =
	denied.distinct.hint =
	denied.distinct.tailable = true;
	
	
	// aggregation integration
	
	
	denied.findOneAndUpdate =
	denied.findOneAndRemove = function (self) {
	  var keys = Object.keys(denied.findOneAndUpdate);
	  var err;
	
	  keys.every(function (option) {
	    if (self.options[option]) {
	      err = option;
	      return false;
	    }
	    return true;
	  });
	
	  return err;
	}
	denied.findOneAndUpdate.limit =
	denied.findOneAndUpdate.skip =
	denied.findOneAndUpdate.batchSize =
	denied.findOneAndUpdate.maxScan =
	denied.findOneAndUpdate.snapshot =
	denied.findOneAndUpdate.hint =
	denied.findOneAndUpdate.tailable =
	denied.findOneAndUpdate.comment = true;
	
	
	denied.count = function (self) {
	  if (self._fields && Object.keys(self._fields).length > 0) {
	    return 'field selection and slice'
	  }
	
	  var keys = Object.keys(denied.count);
	  var err;
	
	  keys.every(function (option) {
	    if (self.options[option]) {
	      err = option;
	      return false;
	    }
	    return true;
	  });
	
	  return err;
	}
	
	denied.count.slice =
	denied.count.batchSize =
	denied.count.comment =
	denied.count.maxScan =
	denied.count.snapshot =
	denied.count.tailable = true;


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global, Buffer) {'use strict';
	
	exports.isNode = 'undefined' != typeof process
	           && 'object' == typeof module
	           && 'object' == typeof global
	           && 'function' == typeof Buffer
	           && process.argv
	
	exports.isMongo = !exports.isNode
	           && 'function' == typeof printjson
	           && 'function' == typeof ObjectId
	           && 'function' == typeof rs
	           && 'function' == typeof sh;
	
	exports.isBrowser = !exports.isNode
	                 && !exports.isMongo
	                 && 'undefined' != typeof window;
	
	exports.type = exports.isNode ? 'node'
	  : exports.isMongo ? 'mongo'
	  : exports.isBrowser ? 'browser'
	  : 'unknown'
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), (function() { return this; }()), __webpack_require__(9).Buffer))

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var env = __webpack_require__(246)
	
	if ('unknown' == env.type) {
	  throw new Error('Unknown environment')
	}
	
	module.exports =
	  env.isNode ? __webpack_require__(248) :
	  env.isMongo ? __webpack_require__(249) :
	  __webpack_require__(249);
	


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Module dependencies
	 */
	
	var Collection = __webpack_require__(249);
	var utils = __webpack_require__(244);
	
	function NodeCollection (col) {
	  this.collection = col;
	  this.collectionName = col.collectionName;
	}
	
	/**
	 * inherit from collection base class
	 */
	
	utils.inherits(NodeCollection, Collection);
	
	/**
	 * find(match, options, function(err, docs))
	 */
	
	NodeCollection.prototype.find = function (match, options, cb) {
	  this.collection.find(match, options, function (err, cursor) {
	    if (err) return cb(err);
	
	    cursor.toArray(cb);
	  });
	}
	
	/**
	 * findOne(match, options, function(err, doc))
	 */
	
	NodeCollection.prototype.findOne = function (match, options, cb) {
	  this.collection.findOne(match, options, cb);
	}
	
	/**
	 * count(match, options, function(err, count))
	 */
	
	NodeCollection.prototype.count = function (match, options, cb) {
	  this.collection.count(match, options, cb);
	}
	
	/**
	 * distinct(prop, match, options, function(err, count))
	 */
	
	NodeCollection.prototype.distinct  = function (prop, match, options, cb) {
	  this.collection.distinct(prop, match, options, cb);
	}
	
	/**
	 * update(match, update, options, function(err[, result]))
	 */
	
	NodeCollection.prototype.update = function (match, update, options, cb) {
	  this.collection.update(match, update, options, cb);
	}
	
	/**
	 * remove(match, options, function(err[, result])
	 */
	
	NodeCollection.prototype.remove = function (match, options, cb) {
	  this.collection.remove(match, options, cb);
	}
	
	/**
	 * findAndModify(match, update, options, function(err, doc))
	 */
	
	NodeCollection.prototype.findAndModify = function (match, update, options, cb) {
	  var sort = Array.isArray(options.sort) ? options.sort : [];
	  this.collection.findAndModify(match, sort, update, options, cb);
	}
	
	/**
	 * var stream = findStream(match, findOptions, streamOptions)
	 */
	
	NodeCollection.prototype.findStream = function(match, findOptions, streamOptions) {
	  return this.collection.find(match, findOptions).stream(streamOptions);
	}
	
	/**
	 * var cursor = findCursor(match, findOptions)
	 */
	
	NodeCollection.prototype.findCursor = function(match, findOptions) {
	  return this.collection.find(match, findOptions);
	}
	
	/**
	 * aggregation(operators..., function(err, doc))
	 * TODO
	 */
	
	/**
	 * Expose
	 */
	
	module.exports = exports = NodeCollection;
	


/***/ },
/* 249 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * methods a collection must implement
	 */
	
	var methods = [
	    'find'
	  , 'findOne'
	  , 'update'
	  , 'remove'
	  , 'count'
	  , 'distinct'
	  , 'findAndModify'
	  , 'aggregate'
	  , 'findStream'
	];
	
	/**
	 * Collection base class from which implementations inherit
	 */
	
	function Collection () {}
	
	for (var i = 0, len = methods.length; i < len; ++i) {
	  var method = methods[i];
	  Collection.prototype[method] = notImplemented(method);
	}
	
	module.exports = exports = Collection;
	Collection.methods = methods;
	
	/**
	 * creates a function which throws an implementation error
	 */
	
	function notImplemented (method) {
	  return function () {
	    throw new Error('collection.' + method + ' not implemented');
	  }
	}
	


/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/* @preserve
	 * The MIT License (MIT)
	 * 
	 * Copyright (c) 2013-2015 Petka Antonov
	 * 
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 * 
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 * 
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 * 
	 */
	/**
	 * bluebird build version 2.10.2
	 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, cancel, using, filter, any, each, timers
	*/
	!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}
	
	Promise.any = function (promises) {
	    return any(promises);
	};
	
	Promise.prototype.any = function () {
	    return any(this);
	};
	
	};
	
	},{}],2:[function(_dereq_,module,exports){
	"use strict";
	var firstLineError;
	try {throw new Error(); } catch (e) {firstLineError = e;}
	var schedule = _dereq_("./schedule.js");
	var Queue = _dereq_("./queue.js");
	var util = _dereq_("./util.js");
	
	function Async() {
	    this._isTickUsed = false;
	    this._lateQueue = new Queue(16);
	    this._normalQueue = new Queue(16);
	    this._trampolineEnabled = true;
	    var self = this;
	    this.drainQueues = function () {
	        self._drainQueues();
	    };
	    this._schedule =
	        schedule.isStatic ? schedule(this.drainQueues) : schedule;
	}
	
	Async.prototype.disableTrampolineIfNecessary = function() {
	    if (util.hasDevTools) {
	        this._trampolineEnabled = false;
	    }
	};
	
	Async.prototype.enableTrampoline = function() {
	    if (!this._trampolineEnabled) {
	        this._trampolineEnabled = true;
	        this._schedule = function(fn) {
	            setTimeout(fn, 0);
	        };
	    }
	};
	
	Async.prototype.haveItemsQueued = function () {
	    return this._normalQueue.length() > 0;
	};
	
	Async.prototype.throwLater = function(fn, arg) {
	    if (arguments.length === 1) {
	        arg = fn;
	        fn = function () { throw arg; };
	    }
	    if (typeof setTimeout !== "undefined") {
	        setTimeout(function() {
	            fn(arg);
	        }, 0);
	    } else try {
	        this._schedule(function() {
	            fn(arg);
	        });
	    } catch (e) {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	    }
	};
	
	function AsyncInvokeLater(fn, receiver, arg) {
	    this._lateQueue.push(fn, receiver, arg);
	    this._queueTick();
	}
	
	function AsyncInvoke(fn, receiver, arg) {
	    this._normalQueue.push(fn, receiver, arg);
	    this._queueTick();
	}
	
	function AsyncSettlePromises(promise) {
	    this._normalQueue._pushOne(promise);
	    this._queueTick();
	}
	
	if (!util.hasDevTools) {
	    Async.prototype.invokeLater = AsyncInvokeLater;
	    Async.prototype.invoke = AsyncInvoke;
	    Async.prototype.settlePromises = AsyncSettlePromises;
	} else {
	    if (schedule.isStatic) {
	        schedule = function(fn) { setTimeout(fn, 0); };
	    }
	    Async.prototype.invokeLater = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvokeLater.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                setTimeout(function() {
	                    fn.call(receiver, arg);
	                }, 100);
	            });
	        }
	    };
	
	    Async.prototype.invoke = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvoke.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                fn.call(receiver, arg);
	            });
	        }
	    };
	
	    Async.prototype.settlePromises = function(promise) {
	        if (this._trampolineEnabled) {
	            AsyncSettlePromises.call(this, promise);
	        } else {
	            this._schedule(function() {
	                promise._settlePromises();
	            });
	        }
	    };
	}
	
	Async.prototype.invokeFirst = function (fn, receiver, arg) {
	    this._normalQueue.unshift(fn, receiver, arg);
	    this._queueTick();
	};
	
	Async.prototype._drainQueue = function(queue) {
	    while (queue.length() > 0) {
	        var fn = queue.shift();
	        if (typeof fn !== "function") {
	            fn._settlePromises();
	            continue;
	        }
	        var receiver = queue.shift();
	        var arg = queue.shift();
	        fn.call(receiver, arg);
	    }
	};
	
	Async.prototype._drainQueues = function () {
	    this._drainQueue(this._normalQueue);
	    this._reset();
	    this._drainQueue(this._lateQueue);
	};
	
	Async.prototype._queueTick = function () {
	    if (!this._isTickUsed) {
	        this._isTickUsed = true;
	        this._schedule(this.drainQueues);
	    }
	};
	
	Async.prototype._reset = function () {
	    this._isTickUsed = false;
	};
	
	module.exports = new Async();
	module.exports.firstLineError = firstLineError;
	
	},{"./queue.js":28,"./schedule.js":31,"./util.js":38}],3:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
	var rejectThis = function(_, e) {
	    this._reject(e);
	};
	
	var targetRejected = function(e, context) {
	    context.promiseRejectionQueued = true;
	    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
	};
	
	var bindingResolved = function(thisArg, context) {
	    if (this._isPending()) {
	        this._resolveCallback(context.target);
	    }
	};
	
	var bindingRejected = function(e, context) {
	    if (!context.promiseRejectionQueued) this._reject(e);
	};
	
	Promise.prototype.bind = function (thisArg) {
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 1);
	    var target = this._target();
	
	    ret._setBoundTo(maybePromise);
	    if (maybePromise instanceof Promise) {
	        var context = {
	            promiseRejectionQueued: false,
	            promise: ret,
	            target: target,
	            bindingPromise: maybePromise
	        };
	        target._then(INTERNAL, targetRejected, ret._progress, ret, context);
	        maybePromise._then(
	            bindingResolved, bindingRejected, ret._progress, ret, context);
	    } else {
	        ret._resolveCallback(target);
	    }
	    return ret;
	};
	
	Promise.prototype._setBoundTo = function (obj) {
	    if (obj !== undefined) {
	        this._bitField = this._bitField | 131072;
	        this._boundTo = obj;
	    } else {
	        this._bitField = this._bitField & (~131072);
	    }
	};
	
	Promise.prototype._isBound = function () {
	    return (this._bitField & 131072) === 131072;
	};
	
	Promise.bind = function (thisArg, value) {
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	
	    ret._setBoundTo(maybePromise);
	    if (maybePromise instanceof Promise) {
	        maybePromise._then(function() {
	            ret._resolveCallback(value);
	        }, ret._reject, ret._progress, ret, null);
	    } else {
	        ret._resolveCallback(value);
	    }
	    return ret;
	};
	};
	
	},{}],4:[function(_dereq_,module,exports){
	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict() {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	var bluebird = _dereq_("./promise.js")();
	bluebird.noConflict = noConflict;
	module.exports = bluebird;
	
	},{"./promise.js":23}],5:[function(_dereq_,module,exports){
	"use strict";
	var cr = Object.create;
	if (cr) {
	    var callerCache = cr(null);
	    var getterCache = cr(null);
	    callerCache[" size"] = getterCache[" size"] = 0;
	}
	
	module.exports = function(Promise) {
	var util = _dereq_("./util.js");
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;
	
	var getMethodCaller;
	var getGetter;
	if (false) {
	var makeMethodCaller = function (methodName) {
	    return new Function("ensureMethod", "                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g, methodName))(ensureMethod);
	};
	
	var makeGetter = function (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	};
	
	var getCompiled = function(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	};
	
	getMethodCaller = function(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	};
	
	getGetter = function(name) {
	    return getCompiled(name, makeGetter, getterCache);
	};
	}
	
	function ensureMethod(obj, methodName) {
	    var fn;
	    if (obj != null) fn = obj[methodName];
	    if (typeof fn !== "function") {
	        var message = "Object " + util.classString(obj) + " has no method '" +
	            util.toString(methodName) + "'";
	        throw new Promise.TypeError(message);
	    }
	    return fn;
	}
	
	function caller(obj) {
	    var methodName = this.pop();
	    var fn = ensureMethod(obj, methodName);
	    return fn.apply(obj, this);
	}
	Promise.prototype.call = function (methodName) {
	    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	    if (false) {
	        if (canEvaluate) {
	            var maybeCaller = getMethodCaller(methodName);
	            if (maybeCaller !== null) {
	                return this._then(
	                    maybeCaller, undefined, undefined, args, undefined);
	            }
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, undefined, undefined, args, undefined);
	};
	
	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    var index = +this;
	    if (index < 0) index = Math.max(0, index + obj.length);
	    return obj[index];
	}
	Promise.prototype.get = function (propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, undefined, undefined, propertyName, undefined);
	};
	};
	
	},{"./util.js":38}],6:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var errors = _dereq_("./errors.js");
	var async = _dereq_("./async.js");
	var CancellationError = errors.CancellationError;
	
	Promise.prototype._cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    var parent;
	    var promiseToReject = this;
	    while ((parent = promiseToReject._cancellationParent) !== undefined &&
	        parent.isCancellable()) {
	        promiseToReject = parent;
	    }
	    this._unsetCancellable();
	    promiseToReject._target()._rejectCallback(reason, false, true);
	};
	
	Promise.prototype.cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    if (reason === undefined) reason = new CancellationError();
	    async.invokeLater(this._cancel, this, reason);
	    return this;
	};
	
	Promise.prototype.cancellable = function () {
	    if (this._cancellable()) return this;
	    async.enableTrampoline();
	    this._setCancellable();
	    this._cancellationParent = undefined;
	    return this;
	};
	
	Promise.prototype.uncancellable = function () {
	    var ret = this.then();
	    ret._unsetCancellable();
	    return ret;
	};
	
	Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
	    var ret = this._then(didFulfill, didReject, didProgress,
	                         undefined, undefined);
	
	    ret._setCancellable();
	    ret._cancellationParent = undefined;
	    return ret;
	};
	};
	
	},{"./async.js":2,"./errors.js":13}],7:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var bluebirdFramePattern =
	    /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
	var stackFramePattern = null;
	var formatStack = null;
	var indentStackFrames = false;
	var warn;
	
	function CapturedTrace(parent) {
	    this._parent = parent;
	    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
	    captureStackTrace(this, CapturedTrace);
	    if (length > 32) this.uncycle();
	}
	util.inherits(CapturedTrace, Error);
	
	CapturedTrace.prototype.uncycle = function() {
	    var length = this._length;
	    if (length < 2) return;
	    var nodes = [];
	    var stackToIndex = {};
	
	    for (var i = 0, node = this; node !== undefined; ++i) {
	        nodes.push(node);
	        node = node._parent;
	    }
	    length = this._length = i;
	    for (var i = length - 1; i >= 0; --i) {
	        var stack = nodes[i].stack;
	        if (stackToIndex[stack] === undefined) {
	            stackToIndex[stack] = i;
	        }
	    }
	    for (var i = 0; i < length; ++i) {
	        var currentStack = nodes[i].stack;
	        var index = stackToIndex[currentStack];
	        if (index !== undefined && index !== i) {
	            if (index > 0) {
	                nodes[index - 1]._parent = undefined;
	                nodes[index - 1]._length = 1;
	            }
	            nodes[i]._parent = undefined;
	            nodes[i]._length = 1;
	            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
	
	            if (index < length - 1) {
	                cycleEdgeNode._parent = nodes[index + 1];
	                cycleEdgeNode._parent.uncycle();
	                cycleEdgeNode._length =
	                    cycleEdgeNode._parent._length + 1;
	            } else {
	                cycleEdgeNode._parent = undefined;
	                cycleEdgeNode._length = 1;
	            }
	            var currentChildLength = cycleEdgeNode._length + 1;
	            for (var j = i - 2; j >= 0; --j) {
	                nodes[j]._length = currentChildLength;
	                currentChildLength++;
	            }
	            return;
	        }
	    }
	};
	
	CapturedTrace.prototype.parent = function() {
	    return this._parent;
	};
	
	CapturedTrace.prototype.hasParent = function() {
	    return this._parent !== undefined;
	};
	
	CapturedTrace.prototype.attachExtraTrace = function(error) {
	    if (error.__stackCleaned__) return;
	    this.uncycle();
	    var parsed = CapturedTrace.parseStackAndMessage(error);
	    var message = parsed.message;
	    var stacks = [parsed.stack];
	
	    var trace = this;
	    while (trace !== undefined) {
	        stacks.push(cleanStack(trace.stack.split("\n")));
	        trace = trace._parent;
	    }
	    removeCommonRoots(stacks);
	    removeDuplicateOrEmptyJumps(stacks);
	    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
	    util.notEnumerableProp(error, "__stackCleaned__", true);
	};
	
	function reconstructStack(message, stacks) {
	    for (var i = 0; i < stacks.length - 1; ++i) {
	        stacks[i].push("From previous event:");
	        stacks[i] = stacks[i].join("\n");
	    }
	    if (i < stacks.length) {
	        stacks[i] = stacks[i].join("\n");
	    }
	    return message + "\n" + stacks.join("\n");
	}
	
	function removeDuplicateOrEmptyJumps(stacks) {
	    for (var i = 0; i < stacks.length; ++i) {
	        if (stacks[i].length === 0 ||
	            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
	            stacks.splice(i, 1);
	            i--;
	        }
	    }
	}
	
	function removeCommonRoots(stacks) {
	    var current = stacks[0];
	    for (var i = 1; i < stacks.length; ++i) {
	        var prev = stacks[i];
	        var currentLastIndex = current.length - 1;
	        var currentLastLine = current[currentLastIndex];
	        var commonRootMeetPoint = -1;
	
	        for (var j = prev.length - 1; j >= 0; --j) {
	            if (prev[j] === currentLastLine) {
	                commonRootMeetPoint = j;
	                break;
	            }
	        }
	
	        for (var j = commonRootMeetPoint; j >= 0; --j) {
	            var line = prev[j];
	            if (current[currentLastIndex] === line) {
	                current.pop();
	                currentLastIndex--;
	            } else {
	                break;
	            }
	        }
	        current = prev;
	    }
	}
	
	function cleanStack(stack) {
	    var ret = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        var isTraceLine = stackFramePattern.test(line) ||
	            "    (No stack trace)" === line;
	        var isInternalFrame = isTraceLine && shouldIgnore(line);
	        if (isTraceLine && !isInternalFrame) {
	            if (indentStackFrames && line.charAt(0) !== " ") {
	                line = "    " + line;
	            }
	            ret.push(line);
	        }
	    }
	    return ret;
	}
	
	function stackFramesAsArray(error) {
	    var stack = error.stack.replace(/\s+$/g, "").split("\n");
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
	            break;
	        }
	    }
	    if (i > 0) {
	        stack = stack.slice(i);
	    }
	    return stack;
	}
	
	CapturedTrace.parseStackAndMessage = function(error) {
	    var stack = error.stack;
	    var message = error.toString();
	    stack = typeof stack === "string" && stack.length > 0
	                ? stackFramesAsArray(error) : ["    (No stack trace)"];
	    return {
	        message: message,
	        stack: cleanStack(stack)
	    };
	};
	
	CapturedTrace.formatAndLogError = function(error, title) {
	    if (typeof console !== "undefined") {
	        var message;
	        if (typeof error === "object" || typeof error === "function") {
	            var stack = error.stack;
	            message = title + formatStack(stack, error);
	        } else {
	            message = title + String(error);
	        }
	        if (typeof warn === "function") {
	            warn(message);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	};
	
	CapturedTrace.unhandledRejection = function (reason) {
	    CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
	};
	
	CapturedTrace.isSupported = function () {
	    return typeof captureStackTrace === "function";
	};
	
	CapturedTrace.fireRejectionEvent =
	function(name, localHandler, reason, promise) {
	    var localEventFired = false;
	    try {
	        if (typeof localHandler === "function") {
	            localEventFired = true;
	            if (name === "rejectionHandled") {
	                localHandler(promise);
	            } else {
	                localHandler(reason, promise);
	            }
	        }
	    } catch (e) {
	        async.throwLater(e);
	    }
	
	    var globalEventFired = false;
	    try {
	        globalEventFired = fireGlobalEvent(name, reason, promise);
	    } catch (e) {
	        globalEventFired = true;
	        async.throwLater(e);
	    }
	
	    var domEventFired = false;
	    if (fireDomEvent) {
	        try {
	            domEventFired = fireDomEvent(name.toLowerCase(), {
	                reason: reason,
	                promise: promise
	            });
	        } catch (e) {
	            domEventFired = true;
	            async.throwLater(e);
	        }
	    }
	
	    if (!globalEventFired && !localEventFired && !domEventFired &&
	        name === "unhandledRejection") {
	        CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
	    }
	};
	
	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj.toString();
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {
	
	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}
	
	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}
	
	var shouldIgnore = function() { return false; };
	var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
	function parseLineInfo(line) {
	    var matches = line.match(parseLineInfoRegex);
	    if (matches) {
	        return {
	            fileName: matches[1],
	            line: parseInt(matches[2], 10)
	        };
	    }
	}
	CapturedTrace.setBounds = function(firstLineError, lastLineError) {
	    if (!CapturedTrace.isSupported()) return;
	    var firstStackLines = firstLineError.stack.split("\n");
	    var lastStackLines = lastLineError.stack.split("\n");
	    var firstIndex = -1;
	    var lastIndex = -1;
	    var firstFileName;
	    var lastFileName;
	    for (var i = 0; i < firstStackLines.length; ++i) {
	        var result = parseLineInfo(firstStackLines[i]);
	        if (result) {
	            firstFileName = result.fileName;
	            firstIndex = result.line;
	            break;
	        }
	    }
	    for (var i = 0; i < lastStackLines.length; ++i) {
	        var result = parseLineInfo(lastStackLines[i]);
	        if (result) {
	            lastFileName = result.fileName;
	            lastIndex = result.line;
	            break;
	        }
	    }
	    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
	        firstFileName !== lastFileName || firstIndex >= lastIndex) {
	        return;
	    }
	
	    shouldIgnore = function(line) {
	        if (bluebirdFramePattern.test(line)) return true;
	        var info = parseLineInfo(line);
	        if (info) {
	            if (info.fileName === firstFileName &&
	                (firstIndex <= info.line && info.line <= lastIndex)) {
	                return true;
	            }
	        }
	        return false;
	    };
	};
	
	var captureStackTrace = (function stackDetection() {
	    var v8stackFramePattern = /^\s*at\s*/;
	    var v8stackFormatter = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if (error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        Error.stackTraceLimit = Error.stackTraceLimit + 6;
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        var captureStackTrace = Error.captureStackTrace;
	
	        shouldIgnore = function(line) {
	            return bluebirdFramePattern.test(line);
	        };
	        return function(receiver, ignoreUntil) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            captureStackTrace(receiver, ignoreUntil);
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }
	    var err = new Error();
	
	    if (typeof err.stack === "string" &&
	        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
	        stackFramePattern = /@/;
	        formatStack = v8stackFormatter;
	        indentStackFrames = true;
	        return function captureStackTrace(o) {
	            o.stack = new Error().stack;
	        };
	    }
	
	    var hasStackAfterThrow;
	    try { throw new Error(); }
	    catch(e) {
	        hasStackAfterThrow = ("stack" in e);
	    }
	    if (!("stack" in err) && hasStackAfterThrow &&
	        typeof Error.stackTraceLimit === "number") {
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        return function captureStackTrace(o) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            try { throw new Error(); }
	            catch(e) { o.stack = e.stack; }
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }
	
	    formatStack = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if ((typeof error === "object" ||
	            typeof error === "function") &&
	            error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    return null;
	
	})([]);
	
	var fireDomEvent;
	var fireGlobalEvent = (function() {
	    if (util.isNode) {
	        return function(name, reason, promise) {
	            if (name === "rejectionHandled") {
	                return process.emit(name, promise);
	            } else {
	                return process.emit(name, reason, promise);
	            }
	        };
	    } else {
	        var customEventWorks = false;
	        var anyEventWorks = true;
	        try {
	            var ev = new self.CustomEvent("test");
	            customEventWorks = ev instanceof CustomEvent;
	        } catch (e) {}
	        if (!customEventWorks) {
	            try {
	                var event = document.createEvent("CustomEvent");
	                event.initCustomEvent("testingtheevent", false, true, {});
	                self.dispatchEvent(event);
	            } catch (e) {
	                anyEventWorks = false;
	            }
	        }
	        if (anyEventWorks) {
	            fireDomEvent = function(type, detail) {
	                var event;
	                if (customEventWorks) {
	                    event = new self.CustomEvent(type, {
	                        detail: detail,
	                        bubbles: false,
	                        cancelable: true
	                    });
	                } else if (self.dispatchEvent) {
	                    event = document.createEvent("CustomEvent");
	                    event.initCustomEvent(type, false, true, detail);
	                }
	
	                return event ? !self.dispatchEvent(event) : false;
	            };
	        }
	
	        var toWindowMethodNameMap = {};
	        toWindowMethodNameMap["unhandledRejection"] = ("on" +
	            "unhandledRejection").toLowerCase();
	        toWindowMethodNameMap["rejectionHandled"] = ("on" +
	            "rejectionHandled").toLowerCase();
	
	        return function(name, reason, promise) {
	            var methodName = toWindowMethodNameMap[name];
	            var method = self[methodName];
	            if (!method) return false;
	            if (name === "rejectionHandled") {
	                method.call(self, promise);
	            } else {
	                method.call(self, reason, promise);
	            }
	            return true;
	        };
	    }
	})();
	
	if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
	    warn = function (message) {
	        console.warn(message);
	    };
	    if (util.isNode && process.stderr.isTTY) {
	        warn = function(message) {
	            process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
	        };
	    } else if (!util.isNode && typeof (new Error().stack) === "string") {
	        warn = function(message) {
	            console.warn("%c" + message, "color: red");
	        };
	    }
	}
	
	return CapturedTrace;
	};
	
	},{"./async.js":2,"./util.js":38}],8:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = _dereq_("./util.js");
	var errors = _dereq_("./errors.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var keys = _dereq_("./es5.js").keys;
	var TypeError = errors.TypeError;
	
	function CatchFilter(instances, callback, promise) {
	    this._instances = instances;
	    this._callback = callback;
	    this._promise = promise;
	}
	
	function safePredicate(predicate, e) {
	    var safeObject = {};
	    var retfilter = tryCatch(predicate).call(safeObject, e);
	
	    if (retfilter === errorObj) return retfilter;
	
	    var safeKeys = keys(safeObject);
	    if (safeKeys.length) {
	        errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
	        return errorObj;
	    }
	    return retfilter;
	}
	
	CatchFilter.prototype.doFilter = function (e) {
	    var cb = this._callback;
	    var promise = this._promise;
	    var boundTo = promise._boundValue();
	    for (var i = 0, len = this._instances.length; i < len; ++i) {
	        var item = this._instances[i];
	        var itemIsErrorType = item === Error ||
	            (item != null && item.prototype instanceof Error);
	
	        if (itemIsErrorType && e instanceof item) {
	            var ret = tryCatch(cb).call(boundTo, e);
	            if (ret === errorObj) {
	                NEXT_FILTER.e = ret.e;
	                return NEXT_FILTER;
	            }
	            return ret;
	        } else if (typeof item === "function" && !itemIsErrorType) {
	            var shouldHandle = safePredicate(item, e);
	            if (shouldHandle === errorObj) {
	                e = errorObj.e;
	                break;
	            } else if (shouldHandle) {
	                var ret = tryCatch(cb).call(boundTo, e);
	                if (ret === errorObj) {
	                    NEXT_FILTER.e = ret.e;
	                    return NEXT_FILTER;
	                }
	                return ret;
	            }
	        }
	    }
	    NEXT_FILTER.e = e;
	    return NEXT_FILTER;
	};
	
	return CatchFilter;
	};
	
	},{"./errors.js":13,"./es5.js":14,"./util.js":38}],9:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, CapturedTrace, isDebugging) {
	var contextStack = [];
	function Context() {
	    this._trace = new CapturedTrace(peekContext());
	}
	Context.prototype._pushContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.push(this._trace);
	    }
	};
	
	Context.prototype._popContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.pop();
	    }
	};
	
	function createContext() {
	    if (isDebugging()) return new Context();
	}
	
	function peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return undefined;
	}
	
	Promise.prototype._peekContext = peekContext;
	Promise.prototype._pushContext = Context.prototype._pushContext;
	Promise.prototype._popContext = Context.prototype._popContext;
	
	return createContext;
	};
	
	},{}],10:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, CapturedTrace) {
	var getDomain = Promise._getDomain;
	var async = _dereq_("./async.js");
	var Warning = _dereq_("./errors.js").Warning;
	var util = _dereq_("./util.js");
	var canAttachTrace = util.canAttachTrace;
	var unhandledRejectionHandled;
	var possiblyUnhandledRejection;
	var debugging = false || (util.isNode &&
	                    (!!process.env["BLUEBIRD_DEBUG"] ||
	                     process.env["NODE_ENV"] === "development"));
	
	if (util.isNode && process.env["BLUEBIRD_DEBUG"] == 0) debugging = false;
	
	if (debugging) {
	    async.disableTrampolineIfNecessary();
	}
	
	Promise.prototype._ignoreRejections = function() {
	    this._unsetRejectionIsUnhandled();
	    this._bitField = this._bitField | 16777216;
	};
	
	Promise.prototype._ensurePossibleRejectionHandled = function () {
	    if ((this._bitField & 16777216) !== 0) return;
	    this._setRejectionIsUnhandled();
	    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
	};
	
	Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
	    CapturedTrace.fireRejectionEvent("rejectionHandled",
	                                  unhandledRejectionHandled, undefined, this);
	};
	
	Promise.prototype._notifyUnhandledRejection = function () {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._getCarriedStackTrace() || this._settledValue;
	        this._setUnhandledRejectionIsNotified();
	        CapturedTrace.fireRejectionEvent("unhandledRejection",
	                                      possiblyUnhandledRejection, reason, this);
	    }
	};
	
	Promise.prototype._setUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField | 524288;
	};
	
	Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField & (~524288);
	};
	
	Promise.prototype._isUnhandledRejectionNotified = function () {
	    return (this._bitField & 524288) > 0;
	};
	
	Promise.prototype._setRejectionIsUnhandled = function () {
	    this._bitField = this._bitField | 2097152;
	};
	
	Promise.prototype._unsetRejectionIsUnhandled = function () {
	    this._bitField = this._bitField & (~2097152);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};
	
	Promise.prototype._isRejectionUnhandled = function () {
	    return (this._bitField & 2097152) > 0;
	};
	
	Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
	    this._bitField = this._bitField | 1048576;
	    this._fulfillmentHandler0 = capturedTrace;
	};
	
	Promise.prototype._isCarryingStackTrace = function () {
	    return (this._bitField & 1048576) > 0;
	};
	
	Promise.prototype._getCarriedStackTrace = function () {
	    return this._isCarryingStackTrace()
	        ? this._fulfillmentHandler0
	        : undefined;
	};
	
	Promise.prototype._captureStackTrace = function () {
	    if (debugging) {
	        this._trace = new CapturedTrace(this._peekContext());
	    }
	    return this;
	};
	
	Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
	    if (debugging && canAttachTrace(error)) {
	        var trace = this._trace;
	        if (trace !== undefined) {
	            if (ignoreSelf) trace = trace._parent;
	        }
	        if (trace !== undefined) {
	            trace.attachExtraTrace(error);
	        } else if (!error.__stackCleaned__) {
	            var parsed = CapturedTrace.parseStackAndMessage(error);
	            util.notEnumerableProp(error, "stack",
	                parsed.message + "\n" + parsed.stack.join("\n"));
	            util.notEnumerableProp(error, "__stackCleaned__", true);
	        }
	    }
	};
	
	Promise.prototype._warn = function(message) {
	    var warning = new Warning(message);
	    var ctx = this._peekContext();
	    if (ctx) {
	        ctx.attachExtraTrace(warning);
	    } else {
	        var parsed = CapturedTrace.parseStackAndMessage(warning);
	        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
	    }
	    CapturedTrace.formatAndLogError(warning, "");
	};
	
	Promise.onPossiblyUnhandledRejection = function (fn) {
	    var domain = getDomain();
	    possiblyUnhandledRejection =
	        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
	                                 : undefined;
	};
	
	Promise.onUnhandledRejectionHandled = function (fn) {
	    var domain = getDomain();
	    unhandledRejectionHandled =
	        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
	                                 : undefined;
	};
	
	Promise.longStackTraces = function () {
	    if (async.haveItemsQueued() &&
	        debugging === false
	   ) {
	        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
	    }
	    debugging = CapturedTrace.isSupported();
	    if (debugging) {
	        async.disableTrampolineIfNecessary();
	    }
	};
	
	Promise.hasLongStackTraces = function () {
	    return debugging && CapturedTrace.isSupported();
	};
	
	if (!CapturedTrace.isSupported()) {
	    Promise.longStackTraces = function(){};
	    debugging = false;
	}
	
	return function() {
	    return debugging;
	};
	};
	
	},{"./async.js":2,"./errors.js":13,"./util.js":38}],11:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util.js");
	var isPrimitive = util.isPrimitive;
	
	module.exports = function(Promise) {
	var returner = function () {
	    return this;
	};
	var thrower = function () {
	    throw this;
	};
	var returnUndefined = function() {};
	var throwUndefined = function() {
	    throw undefined;
	};
	
	var wrapper = function (value, action) {
	    if (action === 1) {
	        return function () {
	            throw value;
	        };
	    } else if (action === 2) {
	        return function () {
	            return value;
	        };
	    }
	};
	
	
	Promise.prototype["return"] =
	Promise.prototype.thenReturn = function (value) {
	    if (value === undefined) return this.then(returnUndefined);
	
	    if (isPrimitive(value)) {
	        return this._then(
	            wrapper(value, 2),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    } else if (value instanceof Promise) {
	        value._ignoreRejections();
	    }
	    return this._then(returner, undefined, undefined, value, undefined);
	};
	
	Promise.prototype["throw"] =
	Promise.prototype.thenThrow = function (reason) {
	    if (reason === undefined) return this.then(throwUndefined);
	
	    if (isPrimitive(reason)) {
	        return this._then(
	            wrapper(reason, 1),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    }
	    return this._then(thrower, undefined, undefined, reason, undefined);
	};
	};
	
	},{"./util.js":38}],12:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;
	
	Promise.prototype.each = function (fn) {
	    return PromiseReduce(this, fn, null, INTERNAL);
	};
	
	Promise.each = function (promises, fn) {
	    return PromiseReduce(promises, fn, null, INTERNAL);
	};
	};
	
	},{}],13:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5.js");
	var Objectfreeze = es5.freeze;
	var util = _dereq_("./util.js");
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;
	
	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        notEnumerableProp(this, "message",
	            typeof message === "string" ? message : defaultMessage);
	        notEnumerableProp(this, "name", nameProperty);
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            Error.call(this);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}
	
	var _TypeError, _RangeError;
	var Warning = subError("Warning", "warning");
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}
	
	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
	
	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}
	
	es5.defineProperty(AggregateError.prototype, "length", {
	    value: 0,
	    configurable: false,
	    writable: true,
	    enumerable: true
	});
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};
	
	function OperationalError(message) {
	    if (!(this instanceof OperationalError))
	        return new OperationalError(message);
	    notEnumerableProp(this, "name", "OperationalError");
	    notEnumerableProp(this, "message", message);
	    this.cause = message;
	    this["isOperational"] = true;
	
	    if (message instanceof Error) {
	        notEnumerableProp(this, "message", message.message);
	        notEnumerableProp(this, "stack", message.stack);
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }
	
	}
	inherits(OperationalError, Error);
	
	var errorTypes = Error["__BluebirdErrorTypes__"];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
	}
	
	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    Warning: Warning
	};
	
	},{"./es5.js":14,"./util.js":38}],14:[function(_dereq_,module,exports){
	var isES5 = (function(){
	    "use strict";
	    return this === undefined;
	})();
	
	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        getDescriptor: Object.getOwnPropertyDescriptor,
	        keys: Object.keys,
	        names: Object.getOwnPropertyNames,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5,
	        propertyIsWritable: function(obj, prop) {
	            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	            return !!(!descriptor || descriptor.writable || descriptor.set);
	        }
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;
	
	    var ObjectKeys = function (o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    };
	
	    var ObjectGetDescriptor = function(o, key) {
	        return {value: o[key]};
	    };
	
	    var ObjectDefineProperty = function (o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    };
	
	    var ObjectFreeze = function (obj) {
	        return obj;
	    };
	
	    var ObjectGetPrototypeOf = function (obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    };
	
	    var ArrayIsArray = function (obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    };
	
	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        names: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        getDescriptor: ObjectGetDescriptor,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5,
	        propertyIsWritable: function() {
	            return true;
	        }
	    };
	}
	
	},{}],15:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;
	
	Promise.prototype.filter = function (fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};
	
	Promise.filter = function (promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};
	
	},{}],16:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
	var util = _dereq_("./util.js");
	var isPrimitive = util.isPrimitive;
	var thrower = util.thrower;
	
	function returnThis() {
	    return this;
	}
	function throwThis() {
	    throw this;
	}
	function return$(r) {
	    return function() {
	        return r;
	    };
	}
	function throw$(r) {
	    return function() {
	        throw r;
	    };
	}
	function promisedFinally(ret, reasonOrValue, isFulfilled) {
	    var then;
	    if (isPrimitive(reasonOrValue)) {
	        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
	    } else {
	        then = isFulfilled ? returnThis : throwThis;
	    }
	    return ret._then(then, thrower, undefined, reasonOrValue, undefined);
	}
	
	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;
	
	    var ret = promise._isBound()
	                    ? handler.call(promise._boundValue())
	                    : handler();
	
	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, reasonOrValue,
	                                    promise.isFulfilled());
	        }
	    }
	
	    if (promise.isRejected()) {
	        NEXT_FILTER.e = reasonOrValue;
	        return NEXT_FILTER;
	    } else {
	        return reasonOrValue;
	    }
	}
	
	function tapHandler(value) {
	    var promise = this.promise;
	    var handler = this.handler;
	
	    var ret = promise._isBound()
	                    ? handler.call(promise._boundValue(), value)
	                    : handler(value);
	
	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, value, true);
	        }
	    }
	    return value;
	}
	
	Promise.prototype._passThroughHandler = function (handler, isFinally) {
	    if (typeof handler !== "function") return this.then();
	
	    var promiseAndHandler = {
	        promise: this,
	        handler: handler
	    };
	
	    return this._then(
	            isFinally ? finallyHandler : tapHandler,
	            isFinally ? finallyHandler : undefined, undefined,
	            promiseAndHandler, undefined);
	};
	
	Promise.prototype.lastly =
	Promise.prototype["finally"] = function (handler) {
	    return this._passThroughHandler(handler, true);
	};
	
	Promise.prototype.tap = function (handler) {
	    return this._passThroughHandler(handler, false);
	};
	};
	
	},{"./util.js":38}],17:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          apiRejection,
	                          INTERNAL,
	                          tryConvertToPromise) {
	var errors = _dereq_("./errors.js");
	var TypeError = errors.TypeError;
	var util = _dereq_("./util.js");
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	var yieldHandlers = [];
	
	function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
	    for (var i = 0; i < yieldHandlers.length; ++i) {
	        traceParent._pushContext();
	        var result = tryCatch(yieldHandlers[i])(value);
	        traceParent._popContext();
	        if (result === errorObj) {
	            traceParent._pushContext();
	            var ret = Promise.reject(errorObj.e);
	            traceParent._popContext();
	            return ret;
	        }
	        var maybePromise = tryConvertToPromise(result, traceParent);
	        if (maybePromise instanceof Promise) return maybePromise;
	    }
	    return null;
	}
	
	function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
	    var promise = this._promise = new Promise(INTERNAL);
	    promise._captureStackTrace();
	    this._stack = stack;
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = undefined;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	}
	
	PromiseSpawn.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseSpawn.prototype._run = function () {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = undefined;
	    this._next(undefined);
	};
	
	PromiseSpawn.prototype._continue = function (result) {
	    if (result === errorObj) {
	        return this._promise._rejectCallback(result.e, false, true);
	    }
	
	    var value = result.value;
	    if (result.done === true) {
	        this._promise._resolveCallback(value);
	    } else {
	        var maybePromise = tryConvertToPromise(value, this._promise);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise,
	                                        this._yieldHandlers,
	                                        this._promise);
	            if (maybePromise === null) {
	                this._throw(
	                    new TypeError(
	                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
	                        "From coroutine:\u000a" +
	                        this._stack.split("\n").slice(1, -7).join("\n")
	                    )
	                );
	                return;
	            }
	        }
	        maybePromise._then(
	            this._next,
	            this._throw,
	            undefined,
	            this,
	            null
	       );
	    }
	};
	
	PromiseSpawn.prototype._throw = function (reason) {
	    this._promise._attachExtraTrace(reason);
	    this._promise._pushContext();
	    var result = tryCatch(this._generator["throw"])
	        .call(this._generator, reason);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._next = function (value) {
	    this._promise._pushContext();
	    var result = tryCatch(this._generator.next).call(this._generator, value);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	Promise.coroutine = function (generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    var stack = new Error().stack;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
	                                      stack);
	        spawn._generator = generator;
	        spawn._next(undefined);
	        return spawn.promise();
	    };
	};
	
	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    yieldHandlers.push(fn);
	};
	
	Promise.spawn = function (generatorFunction) {
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};
	
	},{"./errors.js":13,"./util.js":38}],18:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
	var util = _dereq_("./util.js");
	var canEvaluate = util.canEvaluate;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var reject;
	
	if (false) {
	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };
	
	    var caller = function(count) {
	        var values = [];
	        for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
	        return new Function("holder", "                                      \n\
	            'use strict';                                                    \n\
	            var callback = holder.fn;                                        \n\
	            return callback(values);                                         \n\
	            ".replace(/values/g, values.join(", ")));
	    };
	    var thenCallbacks = [];
	    var callers = [undefined];
	    for (var i = 1; i <= 5; ++i) {
	        thenCallbacks.push(thenCallback(i));
	        callers.push(caller(i));
	    }
	
	    var Holder = function(total, fn) {
	        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
	        this.fn = fn;
	        this.total = total;
	        this.now = 0;
	    };
	
	    Holder.prototype.callers = callers;
	    Holder.prototype.checkFulfillment = function(promise) {
	        var now = this.now;
	        now++;
	        var total = this.total;
	        if (now >= total) {
	            var handler = this.callers[total];
	            promise._pushContext();
	            var ret = tryCatch(handler)(this);
	            promise._popContext();
	            if (ret === errorObj) {
	                promise._rejectCallback(ret.e, false, true);
	            } else {
	                promise._resolveCallback(ret);
	            }
	        } else {
	            this.now = now;
	        }
	    };
	
	    var reject = function (reason) {
	        this._reject(reason);
	    };
	}
	}
	
	Promise.join = function () {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (false) {
	            if (last < 6 && canEvaluate) {
	                var ret = new Promise(INTERNAL);
	                ret._captureStackTrace();
	                var holder = new Holder(last, fn);
	                var callbacks = thenCallbacks;
	                for (var i = 0; i < last; ++i) {
	                    var maybePromise = tryConvertToPromise(arguments[i], ret);
	                    if (maybePromise instanceof Promise) {
	                        maybePromise = maybePromise._target();
	                        if (maybePromise._isPending()) {
	                            maybePromise._then(callbacks[i], reject,
	                                               undefined, ret, holder);
	                        } else if (maybePromise._isFulfilled()) {
	                            callbacks[i].call(ret,
	                                              maybePromise._value(), holder);
	                        } else {
	                            ret._reject(maybePromise._reason());
	                        }
	                    } else {
	                        callbacks[i].call(ret, maybePromise, holder);
	                    }
	                }
	                return ret;
	            }
	        }
	    }
	    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
	    if (fn) args.pop();
	    var ret = new PromiseArray(args).promise();
	    return fn !== undefined ? ret.spread(fn) : ret;
	};
	
	};
	
	},{"./util.js":38}],19:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var getDomain = Promise._getDomain;
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var PENDING = {};
	var EMPTY_ARRAY = [];
	
	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    var domain = getDomain();
	    this._callback = domain === null ? fn : domain.bind(fn);
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
	    async.invoke(init, this, undefined);
	}
	util.inherits(MappingPromiseArray, PromiseArray);
	function init() {this._init$(undefined, -2);}
	
	MappingPromiseArray.prototype._init = function () {};
	
	MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;
	    if (values[index] === PENDING) {
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;
	
	        var callback = this._callback;
	        var receiver = this._promise._boundValue();
	        this._promise._pushContext();
	        var ret = tryCatch(callback).call(receiver, value, index, length);
	        this._promise._popContext();
	        if (ret === errorObj) return this._reject(ret.e);
	
	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = PENDING;
	                return maybePromise._proxyPromiseArray(this, index);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }
	
	    }
	};
	
	MappingPromiseArray.prototype._drainQueue = function () {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        if (this._isResolved()) return;
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};
	
	MappingPromiseArray.prototype._filter = function (booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};
	
	MappingPromiseArray.prototype.preservedValues = function () {
	    return this._preservedValues;
	};
	
	function map(promises, fn, options, _filter) {
	    var limit = typeof options === "object" && options !== null
	        ? options.concurrency
	        : 0;
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter);
	}
	
	Promise.prototype.map = function (fn, options) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	
	    return map(this, fn, options, null).promise();
	};
	
	Promise.map = function (promises, fn, options, _filter) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    return map(promises, fn, options, _filter).promise();
	};
	
	
	};
	
	},{"./async.js":2,"./util.js":38}],20:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	
	Promise.method = function (fn) {
	    if (typeof fn !== "function") {
	        throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    return function () {
	        var ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._pushContext();
	        var value = tryCatch(fn).apply(this, arguments);
	        ret._popContext();
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};
	
	Promise.attempt = Promise["try"] = function (fn, args, ctx) {
	    if (typeof fn !== "function") {
	        return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._pushContext();
	    var value = util.isArray(args)
	        ? tryCatch(fn).apply(ctx, args)
	        : tryCatch(fn).call(ctx, args);
	    ret._popContext();
	    ret._resolveFromSyncValue(value);
	    return ret;
	};
	
	Promise.prototype._resolveFromSyncValue = function (value) {
	    if (value === util.errorObj) {
	        this._rejectCallback(value.e, false, true);
	    } else {
	        this._resolveCallback(value, true);
	    }
	};
	};
	
	},{"./util.js":38}],21:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	function spreadAdapter(val, nodeback) {
	    var promise = this;
	    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
	    var ret =
	        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	function successAdapter(val, nodeback) {
	    var promise = this;
	    var receiver = promise._boundValue();
	    var ret = val === undefined
	        ? tryCatch(nodeback).call(receiver, null)
	        : tryCatch(nodeback).call(receiver, null, val);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	function errorAdapter(reason, nodeback) {
	    var promise = this;
	    if (!reason) {
	        var target = promise._target();
	        var newReason = target._getCarriedStackTrace();
	        newReason.cause = reason;
	        reason = newReason;
	    }
	    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	Promise.prototype.asCallback =
	Promise.prototype.nodeify = function (nodeback, options) {
	    if (typeof nodeback == "function") {
	        var adapter = successAdapter;
	        if (options !== undefined && Object(options).spread) {
	            adapter = spreadAdapter;
	        }
	        this._then(
	            adapter,
	            errorAdapter,
	            undefined,
	            this,
	            nodeback
	        );
	    }
	    return this;
	};
	};
	
	},{"./async.js":2,"./util.js":38}],22:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, PromiseArray) {
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	Promise.prototype.progressed = function (handler) {
	    return this._then(undefined, undefined, handler, undefined, undefined);
	};
	
	Promise.prototype._progress = function (progressValue) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._target()._progressUnchecked(progressValue);
	
	};
	
	Promise.prototype._progressHandlerAt = function (index) {
	    return index === 0
	        ? this._progressHandler0
	        : this[(index << 2) + index - 5 + 2];
	};
	
	Promise.prototype._doProgressWith = function (progression) {
	    var progressValue = progression.value;
	    var handler = progression.handler;
	    var promise = progression.promise;
	    var receiver = progression.receiver;
	
	    var ret = tryCatch(handler).call(receiver, progressValue);
	    if (ret === errorObj) {
	        if (ret.e != null &&
	            ret.e.name !== "StopProgressPropagation") {
	            var trace = util.canAttachTrace(ret.e)
	                ? ret.e : new Error(util.toString(ret.e));
	            promise._attachExtraTrace(trace);
	            promise._progress(ret.e);
	        }
	    } else if (ret instanceof Promise) {
	        ret._then(promise._progress, null, null, promise, undefined);
	    } else {
	        promise._progress(ret);
	    }
	};
	
	
	Promise.prototype._progressUnchecked = function (progressValue) {
	    var len = this._length();
	    var progress = this._progress;
	    for (var i = 0; i < len; i++) {
	        var handler = this._progressHandlerAt(i);
	        var promise = this._promiseAt(i);
	        if (!(promise instanceof Promise)) {
	            var receiver = this._receiverAt(i);
	            if (typeof handler === "function") {
	                handler.call(receiver, progressValue, promise);
	            } else if (receiver instanceof PromiseArray &&
	                       !receiver._isResolved()) {
	                receiver._promiseProgressed(progressValue, promise);
	            }
	            continue;
	        }
	
	        if (typeof handler === "function") {
	            async.invoke(this._doProgressWith, this, {
	                handler: handler,
	                promise: promise,
	                receiver: this._receiverAt(i),
	                value: progressValue
	            });
	        } else {
	            async.invoke(progress, promise, progressValue);
	        }
	    }
	};
	};
	
	},{"./async.js":2,"./util.js":38}],23:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var makeSelfResolutionError = function () {
	    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
	};
	var reflect = function() {
	    return new Promise.PromiseInspection(this._target());
	};
	var apiRejection = function(msg) {
	    return Promise.reject(new TypeError(msg));
	};
	
	var util = _dereq_("./util.js");
	
	var getDomain;
	if (util.isNode) {
	    getDomain = function() {
	        var ret = process.domain;
	        if (ret === undefined) ret = null;
	        return ret;
	    };
	} else {
	    getDomain = function() {
	        return null;
	    };
	}
	util.notEnumerableProp(Promise, "_getDomain", getDomain);
	
	var UNDEFINED_BINDING = {};
	var async = _dereq_("./async.js");
	var errors = _dereq_("./errors.js");
	var TypeError = Promise.TypeError = errors.TypeError;
	Promise.RangeError = errors.RangeError;
	Promise.CancellationError = errors.CancellationError;
	Promise.TimeoutError = errors.TimeoutError;
	Promise.OperationalError = errors.OperationalError;
	Promise.RejectionError = errors.OperationalError;
	Promise.AggregateError = errors.AggregateError;
	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {e: null};
	var tryConvertToPromise = _dereq_("./thenables.js")(Promise, INTERNAL);
	var PromiseArray =
	    _dereq_("./promise_array.js")(Promise, INTERNAL,
	                                    tryConvertToPromise, apiRejection);
	var CapturedTrace = _dereq_("./captured_trace.js")();
	var isDebugging = _dereq_("./debuggability.js")(Promise, CapturedTrace);
	 /*jshint unused:false*/
	var createContext =
	    _dereq_("./context.js")(Promise, CapturedTrace, isDebugging);
	var CatchFilter = _dereq_("./catch_filter.js")(NEXT_FILTER);
	var PromiseResolver = _dereq_("./promise_resolver.js");
	var nodebackForPromise = PromiseResolver._nodebackForPromise;
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	function Promise(resolver) {
	    if (typeof resolver !== "function") {
	        throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
	    }
	    if (this.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
	    }
	    this._bitField = 0;
	    this._fulfillmentHandler0 = undefined;
	    this._rejectionHandler0 = undefined;
	    this._progressHandler0 = undefined;
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._settledValue = undefined;
	    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
	}
	
	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};
	
	Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (typeof item === "function") {
	                catchInstances[j++] = item;
	            } else {
	                return Promise.reject(
	                    new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];
	        var catchFilter = new CatchFilter(catchInstances, fn, this);
	        return this._then(undefined, catchFilter.doFilter, undefined,
	            catchFilter, undefined);
	    }
	    return this._then(undefined, fn, undefined, undefined, undefined);
	};
	
	Promise.prototype.reflect = function () {
	    return this._then(reflect, reflect, undefined, this, undefined);
	};
	
	Promise.prototype.then = function (didFulfill, didReject, didProgress) {
	    if (isDebugging() && arguments.length > 0 &&
	        typeof didFulfill !== "function" &&
	        typeof didReject !== "function") {
	        var msg = ".then() only accepts functions but was passed: " +
	                util.classString(didFulfill);
	        if (arguments.length > 1) {
	            msg += ", " + util.classString(didReject);
	        }
	        this._warn(msg);
	    }
	    return this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	};
	
	Promise.prototype.done = function (didFulfill, didReject, didProgress) {
	    var promise = this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	    promise._setIsFinal();
	};
	
	Promise.prototype.spread = function (didFulfill, didReject) {
	    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
	};
	
	Promise.prototype.isCancellable = function () {
	    return !this.isResolved() &&
	        this._cancellable();
	};
	
	Promise.prototype.toJSON = function () {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: undefined,
	        rejectionReason: undefined
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this.value();
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this.reason();
	        ret.isRejected = true;
	    }
	    return ret;
	};
	
	Promise.prototype.all = function () {
	    return new PromiseArray(this).promise();
	};
	
	Promise.prototype.error = function (fn) {
	    return this.caught(util.originatesFromRejection, fn);
	};
	
	Promise.is = function (val) {
	    return val instanceof Promise;
	};
	
	Promise.fromNode = function(fn) {
	    var ret = new Promise(INTERNAL);
	    var result = tryCatch(fn)(nodebackForPromise(ret));
	    if (result === errorObj) {
	        ret._rejectCallback(result.e, true, true);
	    }
	    return ret;
	};
	
	Promise.all = function (promises) {
	    return new PromiseArray(promises).promise();
	};
	
	Promise.defer = Promise.pending = function () {
	    var promise = new Promise(INTERNAL);
	    return new PromiseResolver(promise);
	};
	
	Promise.cast = function (obj) {
	    var ret = tryConvertToPromise(obj);
	    if (!(ret instanceof Promise)) {
	        var val = ret;
	        ret = new Promise(INTERNAL);
	        ret._fulfillUnchecked(val);
	    }
	    return ret;
	};
	
	Promise.resolve = Promise.fulfilled = Promise.cast;
	
	Promise.reject = Promise.rejected = function (reason) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._rejectCallback(reason, true);
	    return ret;
	};
	
	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var prev = async._schedule;
	    async._schedule = fn;
	    return prev;
	};
	
	Promise.prototype._then = function (
	    didFulfill,
	    didReject,
	    didProgress,
	    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== undefined;
	    var ret = haveInternalData ? internalData : new Promise(INTERNAL);
	
	    if (!haveInternalData) {
	        ret._propagateFrom(this, 4 | 1);
	        ret._captureStackTrace();
	    }
	
	    var target = this._target();
	    if (target !== this) {
	        if (receiver === undefined) receiver = this._boundTo;
	        if (!haveInternalData) ret._setIsMigrated();
	    }
	
	    var callbackIndex = target._addCallbacks(didFulfill,
	                                             didReject,
	                                             didProgress,
	                                             ret,
	                                             receiver,
	                                             getDomain());
	
	    if (target._isResolved() && !target._isSettlePromisesQueued()) {
	        async.invoke(
	            target._settlePromiseAtPostResolution, target, callbackIndex);
	    }
	
	    return ret;
	};
	
	Promise.prototype._settlePromiseAtPostResolution = function (index) {
	    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
	    this._settlePromiseAt(index);
	};
	
	Promise.prototype._length = function () {
	    return this._bitField & 131071;
	};
	
	Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
	    return (this._bitField & 939524096) > 0;
	};
	
	Promise.prototype._isFollowing = function () {
	    return (this._bitField & 536870912) === 536870912;
	};
	
	Promise.prototype._setLength = function (len) {
	    this._bitField = (this._bitField & -131072) |
	        (len & 131071);
	};
	
	Promise.prototype._setFulfilled = function () {
	    this._bitField = this._bitField | 268435456;
	};
	
	Promise.prototype._setRejected = function () {
	    this._bitField = this._bitField | 134217728;
	};
	
	Promise.prototype._setFollowing = function () {
	    this._bitField = this._bitField | 536870912;
	};
	
	Promise.prototype._setIsFinal = function () {
	    this._bitField = this._bitField | 33554432;
	};
	
	Promise.prototype._isFinal = function () {
	    return (this._bitField & 33554432) > 0;
	};
	
	Promise.prototype._cancellable = function () {
	    return (this._bitField & 67108864) > 0;
	};
	
	Promise.prototype._setCancellable = function () {
	    this._bitField = this._bitField | 67108864;
	};
	
	Promise.prototype._unsetCancellable = function () {
	    this._bitField = this._bitField & (~67108864);
	};
	
	Promise.prototype._setIsMigrated = function () {
	    this._bitField = this._bitField | 4194304;
	};
	
	Promise.prototype._unsetIsMigrated = function () {
	    this._bitField = this._bitField & (~4194304);
	};
	
	Promise.prototype._isMigrated = function () {
	    return (this._bitField & 4194304) > 0;
	};
	
	Promise.prototype._receiverAt = function (index) {
	    var ret = index === 0
	        ? this._receiver0
	        : this[
	            index * 5 - 5 + 4];
	    if (ret === UNDEFINED_BINDING) {
	        return undefined;
	    } else if (ret === undefined && this._isBound()) {
	        return this._boundValue();
	    }
	    return ret;
	};
	
	Promise.prototype._promiseAt = function (index) {
	    return index === 0
	        ? this._promise0
	        : this[index * 5 - 5 + 3];
	};
	
	Promise.prototype._fulfillmentHandlerAt = function (index) {
	    return index === 0
	        ? this._fulfillmentHandler0
	        : this[index * 5 - 5 + 0];
	};
	
	Promise.prototype._rejectionHandlerAt = function (index) {
	    return index === 0
	        ? this._rejectionHandler0
	        : this[index * 5 - 5 + 1];
	};
	
	Promise.prototype._boundValue = function() {
	    var ret = this._boundTo;
	    if (ret !== undefined) {
	        if (ret instanceof Promise) {
	            if (ret.isFulfilled()) {
	                return ret.value();
	            } else {
	                return undefined;
	            }
	        }
	    }
	    return ret;
	};
	
	Promise.prototype._migrateCallbacks = function (follower, index) {
	    var fulfill = follower._fulfillmentHandlerAt(index);
	    var reject = follower._rejectionHandlerAt(index);
	    var progress = follower._progressHandlerAt(index);
	    var promise = follower._promiseAt(index);
	    var receiver = follower._receiverAt(index);
	    if (promise instanceof Promise) promise._setIsMigrated();
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, progress, promise, receiver, null);
	};
	
	Promise.prototype._addCallbacks = function (
	    fulfill,
	    reject,
	    progress,
	    promise,
	    receiver,
	    domain
	) {
	    var index = this._length();
	
	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }
	
	    if (index === 0) {
	        this._promise0 = promise;
	        if (receiver !== undefined) this._receiver0 = receiver;
	        if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
	            this._fulfillmentHandler0 =
	                domain === null ? fulfill : domain.bind(fulfill);
	        }
	        if (typeof reject === "function") {
	            this._rejectionHandler0 =
	                domain === null ? reject : domain.bind(reject);
	        }
	        if (typeof progress === "function") {
	            this._progressHandler0 =
	                domain === null ? progress : domain.bind(progress);
	        }
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promise;
	        this[base + 4] = receiver;
	        if (typeof fulfill === "function") {
	            this[base + 0] =
	                domain === null ? fulfill : domain.bind(fulfill);
	        }
	        if (typeof reject === "function") {
	            this[base + 1] =
	                domain === null ? reject : domain.bind(reject);
	        }
	        if (typeof progress === "function") {
	            this[base + 2] =
	                domain === null ? progress : domain.bind(progress);
	        }
	    }
	    this._setLength(index + 1);
	    return index;
	};
	
	Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
	    var index = this._length();
	
	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }
	    if (index === 0) {
	        this._promise0 = promiseSlotValue;
	        this._receiver0 = receiver;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promiseSlotValue;
	        this[base + 4] = receiver;
	    }
	    this._setLength(index + 1);
	};
	
	Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
	    this._setProxyHandlers(promiseArray, index);
	};
	
	Promise.prototype._resolveCallback = function(value, shouldBind) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    if (value === this)
	        return this._rejectCallback(makeSelfResolutionError(), false, true);
	    var maybePromise = tryConvertToPromise(value, this);
	    if (!(maybePromise instanceof Promise)) return this._fulfill(value);
	
	    var propagationFlags = 1 | (shouldBind ? 4 : 0);
	    this._propagateFrom(maybePromise, propagationFlags);
	    var promise = maybePromise._target();
	    if (promise._isPending()) {
	        var len = this._length();
	        for (var i = 0; i < len; ++i) {
	            promise._migrateCallbacks(this, i);
	        }
	        this._setFollowing();
	        this._setLength(0);
	        this._setFollowee(promise);
	    } else if (promise._isFulfilled()) {
	        this._fulfillUnchecked(promise._value());
	    } else {
	        this._rejectUnchecked(promise._reason(),
	            promise._getCarriedStackTrace());
	    }
	};
	
	Promise.prototype._rejectCallback =
	function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
	    if (!shouldNotMarkOriginatingFromRejection) {
	        util.markAsOriginatingFromRejection(reason);
	    }
	    var trace = util.ensureErrorObject(reason);
	    var hasStack = trace === reason;
	    this._attachExtraTrace(trace, synchronous ? hasStack : false);
	    this._reject(reason, hasStack ? undefined : trace);
	};
	
	Promise.prototype._resolveFromResolver = function (resolver) {
	    var promise = this;
	    this._captureStackTrace();
	    this._pushContext();
	    var synchronous = true;
	    var r = tryCatch(resolver)(function(value) {
	        if (promise === null) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }, function (reason) {
	        if (promise === null) return;
	        promise._rejectCallback(reason, synchronous);
	        promise = null;
	    });
	    synchronous = false;
	    this._popContext();
	
	    if (r !== undefined && r === errorObj && promise !== null) {
	        promise._rejectCallback(r.e, true, true);
	        promise = null;
	    }
	};
	
	Promise.prototype._settlePromiseFromHandler = function (
	    handler, receiver, value, promise
	) {
	    if (promise._isRejected()) return;
	    promise._pushContext();
	    var x;
	    if (receiver === APPLY && !this._isRejected()) {
	        x = tryCatch(handler).apply(this._boundValue(), value);
	    } else {
	        x = tryCatch(handler).call(receiver, value);
	    }
	    promise._popContext();
	
	    if (x === errorObj || x === promise || x === NEXT_FILTER) {
	        var err = x === promise ? makeSelfResolutionError() : x.e;
	        promise._rejectCallback(err, false, true);
	    } else {
	        promise._resolveCallback(x);
	    }
	};
	
	Promise.prototype._target = function() {
	    var ret = this;
	    while (ret._isFollowing()) ret = ret._followee();
	    return ret;
	};
	
	Promise.prototype._followee = function() {
	    return this._rejectionHandler0;
	};
	
	Promise.prototype._setFollowee = function(promise) {
	    this._rejectionHandler0 = promise;
	};
	
	Promise.prototype._cleanValues = function () {
	    if (this._cancellable()) {
	        this._cancellationParent = undefined;
	    }
	};
	
	Promise.prototype._propagateFrom = function (parent, flags) {
	    if ((flags & 1) > 0 && parent._cancellable()) {
	        this._setCancellable();
	        this._cancellationParent = parent;
	    }
	    if ((flags & 4) > 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	};
	
	Promise.prototype._fulfill = function (value) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._fulfillUnchecked(value);
	};
	
	Promise.prototype._reject = function (reason, carriedStackTrace) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._rejectUnchecked(reason, carriedStackTrace);
	};
	
	Promise.prototype._settlePromiseAt = function (index) {
	    var promise = this._promiseAt(index);
	    var isPromise = promise instanceof Promise;
	
	    if (isPromise && promise._isMigrated()) {
	        promise._unsetIsMigrated();
	        return async.invoke(this._settlePromiseAt, this, index);
	    }
	    var handler = this._isFulfilled()
	        ? this._fulfillmentHandlerAt(index)
	        : this._rejectionHandlerAt(index);
	
	    var carriedStackTrace =
	        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
	    var value = this._settledValue;
	    var receiver = this._receiverAt(index);
	    this._clearCallbackDataAtIndex(index);
	
	    if (typeof handler === "function") {
	        if (!isPromise) {
	            handler.call(receiver, value, promise);
	        } else {
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (receiver instanceof PromiseArray) {
	        if (!receiver._isResolved()) {
	            if (this._isFulfilled()) {
	                receiver._promiseFulfilled(value, promise);
	            }
	            else {
	                receiver._promiseRejected(value, promise);
	            }
	        }
	    } else if (isPromise) {
	        if (this._isFulfilled()) {
	            promise._fulfill(value);
	        } else {
	            promise._reject(value, carriedStackTrace);
	        }
	    }
	
	    if (index >= 4 && (index & 31) === 4)
	        async.invokeLater(this._setLength, this, 0);
	};
	
	Promise.prototype._clearCallbackDataAtIndex = function(index) {
	    if (index === 0) {
	        if (!this._isCarryingStackTrace()) {
	            this._fulfillmentHandler0 = undefined;
	        }
	        this._rejectionHandler0 =
	        this._progressHandler0 =
	        this._receiver0 =
	        this._promise0 = undefined;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] =
	        this[base + 4] =
	        this[base + 0] =
	        this[base + 1] =
	        this[base + 2] = undefined;
	    }
	};
	
	Promise.prototype._isSettlePromisesQueued = function () {
	    return (this._bitField &
	            -1073741824) === -1073741824;
	};
	
	Promise.prototype._setSettlePromisesQueued = function () {
	    this._bitField = this._bitField | -1073741824;
	};
	
	Promise.prototype._unsetSettlePromisesQueued = function () {
	    this._bitField = this._bitField & (~-1073741824);
	};
	
	Promise.prototype._queueSettlePromises = function() {
	    async.settlePromises(this);
	    this._setSettlePromisesQueued();
	};
	
	Promise.prototype._fulfillUnchecked = function (value) {
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err, undefined);
	    }
	    this._setFulfilled();
	    this._settledValue = value;
	    this._cleanValues();
	
	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    }
	};
	
	Promise.prototype._rejectUncheckedCheckError = function (reason) {
	    var trace = util.ensureErrorObject(reason);
	    this._rejectUnchecked(reason, trace === reason ? undefined : trace);
	};
	
	Promise.prototype._rejectUnchecked = function (reason, trace) {
	    if (reason === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err);
	    }
	    this._setRejected();
	    this._settledValue = reason;
	    this._cleanValues();
	
	    if (this._isFinal()) {
	        async.throwLater(function(e) {
	            if ("stack" in e) {
	                async.invokeFirst(
	                    CapturedTrace.unhandledRejection, undefined, e);
	            }
	            throw e;
	        }, trace === undefined ? reason : trace);
	        return;
	    }
	
	    if (trace !== undefined && trace !== reason) {
	        this._setCarriedStackTrace(trace);
	    }
	
	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};
	
	Promise.prototype._settlePromises = function () {
	    this._unsetSettlePromisesQueued();
	    var len = this._length();
	    for (var i = 0; i < len; i++) {
	        this._settlePromiseAt(i);
	    }
	};
	
	util.notEnumerableProp(Promise,
	                       "_makeSelfResolutionError",
	                       makeSelfResolutionError);
	
	_dereq_("./progress.js")(Promise, PromiseArray);
	_dereq_("./method.js")(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_("./bind.js")(Promise, INTERNAL, tryConvertToPromise);
	_dereq_("./finally.js")(Promise, NEXT_FILTER, tryConvertToPromise);
	_dereq_("./direct_resolve.js")(Promise);
	_dereq_("./synchronous_inspection.js")(Promise);
	_dereq_("./join.js")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
	Promise.Promise = Promise;
	_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	_dereq_('./cancel.js')(Promise);
	_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
	_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
	_dereq_('./nodeify.js')(Promise);
	_dereq_('./call_get.js')(Promise);
	_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
	_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	_dereq_('./settle.js')(Promise, PromiseArray);
	_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
	_dereq_('./promisify.js')(Promise, INTERNAL);
	_dereq_('./any.js')(Promise);
	_dereq_('./each.js')(Promise, INTERNAL);
	_dereq_('./timers.js')(Promise, INTERNAL);
	_dereq_('./filter.js')(Promise, INTERNAL);
	                                                         
	    util.toFastProperties(Promise);                                          
	    util.toFastProperties(Promise.prototype);                                
	    function fillTypes(value) {                                              
	        var p = new Promise(INTERNAL);                                       
	        p._fulfillmentHandler0 = value;                                      
	        p._rejectionHandler0 = value;                                        
	        p._progressHandler0 = value;                                         
	        p._promise0 = value;                                                 
	        p._receiver0 = value;                                                
	        p._settledValue = value;                                             
	    }                                                                        
	    // Complete slack tracking, opt out of field-type tracking and           
	    // stabilize map                                                         
	    fillTypes({a: 1});                                                       
	    fillTypes({b: 2});                                                       
	    fillTypes({c: 3});                                                       
	    fillTypes(1);                                                            
	    fillTypes(function(){});                                                 
	    fillTypes(undefined);                                                    
	    fillTypes(false);                                                        
	    fillTypes(new Promise(INTERNAL));                                        
	    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       
	    return Promise;                                                          
	
	};
	
	},{"./any.js":1,"./async.js":2,"./bind.js":3,"./call_get.js":5,"./cancel.js":6,"./captured_trace.js":7,"./catch_filter.js":8,"./context.js":9,"./debuggability.js":10,"./direct_resolve.js":11,"./each.js":12,"./errors.js":13,"./filter.js":15,"./finally.js":16,"./generators.js":17,"./join.js":18,"./map.js":19,"./method.js":20,"./nodeify.js":21,"./progress.js":22,"./promise_array.js":24,"./promise_resolver.js":25,"./promisify.js":26,"./props.js":27,"./race.js":29,"./reduce.js":30,"./settle.js":32,"./some.js":33,"./synchronous_inspection.js":34,"./thenables.js":35,"./timers.js":36,"./using.js":37,"./util.js":38}],24:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise,
	    apiRejection) {
	var util = _dereq_("./util.js");
	var isArray = util.isArray;
	
	function toResolutionValue(val) {
	    switch(val) {
	    case -2: return [];
	    case -3: return {};
	    }
	}
	
	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    var parent;
	    if (values instanceof Promise) {
	        parent = values;
	        promise._propagateFrom(parent, 1 | 4);
	    }
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(undefined, -2);
	}
	PromiseArray.prototype.length = function () {
	    return this._length;
	};
	
	PromiseArray.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
	    var values = tryConvertToPromise(this._values, this._promise);
	    if (values instanceof Promise) {
	        values = values._target();
	        this._values = values;
	        if (values._isFulfilled()) {
	            values = values._value();
	            if (!isArray(values)) {
	                var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	                this.__hardReject__(err);
	                return;
	            }
	        } else if (values._isPending()) {
	            values._then(
	                init,
	                this._reject,
	                undefined,
	                this,
	                resolveValueIfEmpty
	           );
	            return;
	        } else {
	            this._reject(values._reason());
	            return;
	        }
	    } else if (!isArray(values)) {
	        this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
	        return;
	    }
	
	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    var len = this.getActualLength(values.length);
	    this._length = len;
	    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
	    var promise = this._promise;
	    for (var i = 0; i < len; ++i) {
	        var isResolved = this._isResolved();
	        var maybePromise = tryConvertToPromise(values[i], promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (isResolved) {
	                maybePromise._ignoreRejections();
	            } else if (maybePromise._isPending()) {
	                maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                this._promiseFulfilled(maybePromise._value(), i);
	            } else {
	                this._promiseRejected(maybePromise._reason(), i);
	            }
	        } else if (!isResolved) {
	            this._promiseFulfilled(maybePromise, i);
	        }
	    }
	};
	
	PromiseArray.prototype._isResolved = function () {
	    return this._values === null;
	};
	
	PromiseArray.prototype._resolve = function (value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};
	
	PromiseArray.prototype.__hardReject__ =
	PromiseArray.prototype._reject = function (reason) {
	    this._values = null;
	    this._promise._rejectCallback(reason, false, true);
	};
	
	PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
	    this._promise._progress({
	        index: index,
	        value: progressValue
	    });
	};
	
	
	PromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};
	
	PromiseArray.prototype._promiseRejected = function (reason, index) {
	    this._totalResolved++;
	    this._reject(reason);
	};
	
	PromiseArray.prototype.shouldCopyValues = function () {
	    return true;
	};
	
	PromiseArray.prototype.getActualLength = function (len) {
	    return len;
	};
	
	return PromiseArray;
	};
	
	},{"./util.js":38}],25:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util.js");
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = _dereq_("./errors.js");
	var TimeoutError = errors.TimeoutError;
	var OperationalError = errors.OperationalError;
	var haveGetters = util.haveGetters;
	var es5 = _dereq_("./es5.js");
	
	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}
	
	var rErrorKey = /^(?:name|message|stack|cause)$/;
	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	        ret.name = obj.name;
	        ret.message = obj.message;
	        ret.stack = obj.stack;
	        var keys = es5.keys(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!rErrorKey.test(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    util.markAsOriginatingFromRejection(obj);
	    return obj;
	}
	
	function nodebackForPromise(promise) {
	    return function(err, value) {
	        if (promise === null) return;
	
	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (arguments.length > 2) {
	            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	            promise._fulfill(args);
	        } else {
	            promise._fulfill(value);
	        }
	
	        promise = null;
	    };
	}
	
	
	var PromiseResolver;
	if (!haveGetters) {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	        this.asCallback = nodebackForPromise(promise);
	        this.callback = this.asCallback;
	    };
	}
	else {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	    };
	}
	if (haveGetters) {
	    var prop = {
	        get: function() {
	            return nodebackForPromise(this.promise);
	        }
	    };
	    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
	    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
	}
	
	PromiseResolver._nodebackForPromise = nodebackForPromise;
	
	PromiseResolver.prototype.toString = function () {
	    return "[object PromiseResolver]";
	};
	
	PromiseResolver.prototype.resolve =
	PromiseResolver.prototype.fulfill = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._resolveCallback(value);
	};
	
	PromiseResolver.prototype.reject = function (reason) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._rejectCallback(reason);
	};
	
	PromiseResolver.prototype.progress = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._progress(value);
	};
	
	PromiseResolver.prototype.cancel = function (err) {
	    this.promise.cancel(err);
	};
	
	PromiseResolver.prototype.timeout = function () {
	    this.reject(new TimeoutError("timeout"));
	};
	
	PromiseResolver.prototype.isResolved = function () {
	    return this.promise.isResolved();
	};
	
	PromiseResolver.prototype.toJSON = function () {
	    return this.promise.toJSON();
	};
	
	module.exports = PromiseResolver;
	
	},{"./errors.js":13,"./es5.js":14,"./util.js":38}],26:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = _dereq_("./util.js");
	var nodebackForPromise = _dereq_("./promise_resolver.js")
	    ._nodebackForPromise;
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = _dereq_("./errors").TypeError;
	var defaultSuffix = "Async";
	var defaultPromisified = {__isPromisified__: true};
	var noCopyProps = [
	    "arity",    "length",
	    "name",
	    "arguments",
	    "caller",
	    "callee",
	    "prototype",
	    "__isPromisified__"
	];
	var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
	
	var defaultFilter = function(name) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        name !== "constructor";
	};
	
	function propsFilter(key) {
	    return !noCopyPropsPattern.test(key);
	}
	
	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}
	
	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
	                        .replace("%s", suffix));
	                }
	            }
	        }
	    }
	}
	
	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        var passesDefaultFilter = filter === defaultFilter
	            ? true : defaultFilter(key, value, obj);
	        if (typeof value === "function" &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj, passesDefaultFilter)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}
	
	var escapeIdentRegex = function(str) {
	    return str.replace(/([$])/, "\\$");
	};
	
	var makeNodePromisifiedEval;
	if (false) {
	var switchCaseArgumentOrder = function(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 3);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
	        ret.push(i);
	    }
	    return ret;
	};
	
	var argumentSequence = function(argumentCount) {
	    return util.filledRange(argumentCount, "_arg", "");
	};
	
	var parameterDeclaration = function(parameterCount) {
	    return util.filledRange(
	        Math.max(parameterCount, 3), "_arg", "");
	};
	
	var parameterCount = function(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	};
	
	makeNodePromisifiedEval =
	function(callback, receiver, originalName, fn) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var shouldProxyThis = typeof callback === "string" || receiver === THIS;
	
	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (shouldProxyThis) {
	            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
	        } else {
	            ret = receiver === undefined
	                ? "ret = callback({{args}}, nodeback); break;\n"
	                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
	        }
	        return ret.replace("{{args}}", args).replace(", ", comma);
	    }
	
	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for (var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }
	
	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", (shouldProxyThis
	                                ? "ret = callback.apply(this, args);\n"
	                                : "ret = callback.apply(receiver, args);\n"));
	        return ret;
	    }
	
	    var getFunctionCode = typeof callback === "string"
	                                ? ("this != null ? this['"+callback+"'] : fn")
	                                : "fn";
	
	    return new Function("Promise",
	                        "fn",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "tryCatch",
	                        "errorObj",
	                        "notEnumerableProp",
	                        "INTERNAL","'use strict';                            \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise);                      \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
	        return ret;                                                          \n\
	        "
	        .replace("Parameters", parameterDeclaration(newParameterCount))
	        .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
	        .replace("[GetFunctionCode]", getFunctionCode))(
	            Promise,
	            fn,
	            receiver,
	            withAppended,
	            maybeWrapAsError,
	            nodebackForPromise,
	            util.tryCatch,
	            util.errorObj,
	            util.notEnumerableProp,
	            INTERNAL
	        );
	};
	}
	
	function makeNodePromisifiedClosure(callback, receiver, _, fn) {
	    var defaultThis = (function() {return this;})();
	    var method = callback;
	    if (typeof method === "string") {
	        callback = fn;
	    }
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        var promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	        var cb = typeof method === "string" && this !== defaultThis
	            ? this[method] : callback;
	        var fn = nodebackForPromise(promise);
	        try {
	            cb.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            promise._rejectCallback(maybeWrapAsError(e), true, true);
	        }
	        return promise;
	    }
	    util.notEnumerableProp(promisified, "__isPromisified__", true);
	    return promisified;
	}
	
	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;
	
	function promisifyAll(obj, suffix, filter, promisifier) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);
	
	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        if (promisifier === makeNodePromisified) {
	            obj[promisifiedKey] =
	                makeNodePromisified(key, THIS, key, fn, suffix);
	        } else {
	            var promisified = promisifier(fn, function() {
	                return makeNodePromisified(key, THIS, key, fn, suffix);
	            });
	            util.notEnumerableProp(promisified, "__isPromisified__", true);
	            obj[promisifiedKey] = promisified;
	        }
	    }
	    util.toFastProperties(obj);
	    return obj;
	}
	
	function promisify(callback, receiver) {
	    return makeNodePromisified(callback, receiver, undefined, callback);
	}
	
	Promise.promisify = function (fn, receiver) {
	    if (typeof fn !== "function") {
	        throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
	    util.copyDescriptors(fn, ret, propsFilter);
	    return ret;
	};
	
	Promise.promisifyAll = function (target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
	    }
	    options = Object(options);
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;
	
	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
	    }
	
	    var keys = util.inheritedDataKeys(target);
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier);
	            promisifyAll(value, suffix, filter, promisifier);
	        }
	    }
	
	    return promisifyAll(target, suffix, filter, promisifier);
	};
	};
	
	
	},{"./errors":13,"./promise_resolver.js":25,"./util.js":38}],27:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util.js");
	var isObject = util.isObject;
	var es5 = _dereq_("./es5.js");
	
	function PropertiesPromiseArray(obj) {
	    var keys = es5.keys(obj);
	    var len = keys.length;
	    var values = new Array(len * 2);
	    for (var i = 0; i < len; ++i) {
	        var key = keys[i];
	        values[i] = obj[key];
	        values[i + len] = key;
	    }
	    this.constructor$(values);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);
	
	PropertiesPromiseArray.prototype._init = function () {
	    this._init$(undefined, -3) ;
	};
	
	PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val = {};
	        var keyOffset = this.length();
	        for (var i = 0, len = this.length(); i < len; ++i) {
	            val[this._values[i + keyOffset]] = this._values[i];
	        }
	        this._resolve(val);
	    }
	};
	
	PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
	    this._promise._progress({
	        key: this._values[index + this.length()],
	        value: value
	    });
	};
	
	PropertiesPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};
	
	PropertiesPromiseArray.prototype.getActualLength = function (len) {
	    return len >> 1;
	};
	
	function props(promises) {
	    var ret;
	    var castValue = tryConvertToPromise(promises);
	
	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(
	            Promise.props, undefined, undefined, undefined, undefined);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }
	
	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 4);
	    }
	    return ret;
	}
	
	Promise.prototype.props = function () {
	    return props(this);
	};
	
	Promise.props = function (promises) {
	    return props(promises);
	};
	};
	
	},{"./es5.js":14,"./util.js":38}],28:[function(_dereq_,module,exports){
	"use strict";
	function arrayMove(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	        src[j + srcIndex] = void 0;
	    }
	}
	
	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	}
	
	Queue.prototype._willBeOverCapacity = function (size) {
	    return this._capacity < size;
	};
	
	Queue.prototype._pushOne = function (arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};
	
	Queue.prototype._unshiftOne = function(value) {
	    var capacity = this._capacity;
	    this._checkCapacity(this.length() + 1);
	    var front = this._front;
	    var i = (((( front - 1 ) &
	                    ( capacity - 1) ) ^ capacity ) - capacity );
	    this[i] = value;
	    this._front = i;
	    this._length = this.length() + 1;
	};
	
	Queue.prototype.unshift = function(fn, receiver, arg) {
	    this._unshiftOne(arg);
	    this._unshiftOne(receiver);
	    this._unshiftOne(fn);
	};
	
	Queue.prototype.push = function (fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};
	
	Queue.prototype.shift = function () {
	    var front = this._front,
	        ret = this[front];
	
	    this[front] = undefined;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};
	
	Queue.prototype.length = function () {
	    return this._length;
	};
	
	Queue.prototype._checkCapacity = function (size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 1);
	    }
	};
	
	Queue.prototype._resizeTo = function (capacity) {
	    var oldCapacity = this._capacity;
	    this._capacity = capacity;
	    var front = this._front;
	    var length = this._length;
	    var moveItemsCount = (front + length) & (oldCapacity - 1);
	    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
	};
	
	module.exports = Queue;
	
	},{}],29:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var isArray = _dereq_("./util.js").isArray;
	
	var raceLater = function (promise) {
	    return promise.then(function(array) {
	        return race(array, promise);
	    });
	};
	
	function race(promises, parent) {
	    var maybePromise = tryConvertToPromise(promises);
	
	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else if (!isArray(promises)) {
	        return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	    }
	
	    var ret = new Promise(INTERNAL);
	    if (parent !== undefined) {
	        ret._propagateFrom(parent, 4 | 1);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];
	
	        if (val === undefined && !(i in promises)) {
	            continue;
	        }
	
	        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
	    }
	    return ret;
	}
	
	Promise.race = function (promises) {
	    return race(promises, undefined);
	};
	
	Promise.prototype.race = function () {
	    return race(this, undefined);
	};
	
	};
	
	},{"./util.js":38}],30:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var getDomain = Promise._getDomain;
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	function ReductionPromiseArray(promises, fn, accum, _each) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    this._preservedValues = _each === INTERNAL ? [] : null;
	    this._zerothIsAccum = (accum === undefined);
	    this._gotAccum = false;
	    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
	    this._valuesPhase = undefined;
	    var maybePromise = tryConvertToPromise(accum, this._promise);
	    var rejected = false;
	    var isPromise = maybePromise instanceof Promise;
	    if (isPromise) {
	        maybePromise = maybePromise._target();
	        if (maybePromise._isPending()) {
	            maybePromise._proxyPromiseArray(this, -1);
	        } else if (maybePromise._isFulfilled()) {
	            accum = maybePromise._value();
	            this._gotAccum = true;
	        } else {
	            this._reject(maybePromise._reason());
	            rejected = true;
	        }
	    }
	    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
	    var domain = getDomain();
	    this._callback = domain === null ? fn : domain.bind(fn);
	    this._accum = accum;
	    if (!rejected) async.invoke(init, this, undefined);
	}
	function init() {
	    this._init$(undefined, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);
	
	ReductionPromiseArray.prototype._init = function () {};
	
	ReductionPromiseArray.prototype._resolveEmptyArray = function () {
	    if (this._gotAccum || this._zerothIsAccum) {
	        this._resolve(this._preservedValues !== null
	                        ? [] : this._accum);
	    }
	};
	
	ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    values[index] = value;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var isEach = preservedValues !== null;
	    var gotAccum = this._gotAccum;
	    var valuesPhase = this._valuesPhase;
	    var valuesPhaseIndex;
	    if (!valuesPhase) {
	        valuesPhase = this._valuesPhase = new Array(length);
	        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
	            valuesPhase[valuesPhaseIndex] = 0;
	        }
	    }
	    valuesPhaseIndex = valuesPhase[index];
	
	    if (index === 0 && this._zerothIsAccum) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	        valuesPhase[index] = ((valuesPhaseIndex === 0)
	            ? 1 : 2);
	    } else if (index === -1) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	    } else {
	        if (valuesPhaseIndex === 0) {
	            valuesPhase[index] = 1;
	        } else {
	            valuesPhase[index] = 2;
	            this._accum = value;
	        }
	    }
	    if (!gotAccum) return;
	
	    var callback = this._callback;
	    var receiver = this._promise._boundValue();
	    var ret;
	
	    for (var i = this._reducingIndex; i < length; ++i) {
	        valuesPhaseIndex = valuesPhase[i];
	        if (valuesPhaseIndex === 2) {
	            this._reducingIndex = i + 1;
	            continue;
	        }
	        if (valuesPhaseIndex !== 1) return;
	        value = values[i];
	        this._promise._pushContext();
	        if (isEach) {
	            preservedValues.push(value);
	            ret = tryCatch(callback).call(receiver, value, i, length);
	        }
	        else {
	            ret = tryCatch(callback)
	                .call(receiver, this._accum, value, i, length);
	        }
	        this._promise._popContext();
	
	        if (ret === errorObj) return this._reject(ret.e);
	
	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                valuesPhase[i] = 4;
	                return maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }
	
	        this._reducingIndex = i + 1;
	        this._accum = ret;
	    }
	
	    this._resolve(isEach ? preservedValues : this._accum);
	};
	
	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}
	
	Promise.prototype.reduce = function (fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};
	
	Promise.reduce = function (promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};
	};
	
	},{"./async.js":2,"./util.js":38}],31:[function(_dereq_,module,exports){
	"use strict";
	var schedule;
	var util = _dereq_("./util");
	var noAsyncScheduler = function() {
	    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	};
	if (util.isNode && typeof MutationObserver === "undefined") {
	    var GlobalSetImmediate = global.setImmediate;
	    var ProcessNextTick = process.nextTick;
	    schedule = util.isRecentNode
	                ? function(fn) { GlobalSetImmediate.call(global, fn); }
	                : function(fn) { ProcessNextTick.call(process, fn); };
	} else if ((typeof MutationObserver !== "undefined") &&
	          !(typeof window !== "undefined" &&
	            window.navigator &&
	            window.navigator.standalone)) {
	    schedule = function(fn) {
	        var div = document.createElement("div");
	        var observer = new MutationObserver(fn);
	        observer.observe(div, {attributes: true});
	        return function() { div.classList.toggle("foo"); };
	    };
	    schedule.isStatic = true;
	} else if (typeof setImmediate !== "undefined") {
	    schedule = function (fn) {
	        setImmediate(fn);
	    };
	} else if (typeof setTimeout !== "undefined") {
	    schedule = function (fn) {
	        setTimeout(fn, 0);
	    };
	} else {
	    schedule = noAsyncScheduler;
	}
	module.exports = schedule;
	
	},{"./util":38}],32:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	    function(Promise, PromiseArray) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = _dereq_("./util.js");
	
	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);
	
	SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};
	
	SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 268435456;
	    ret._settledValue = value;
	    this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 134217728;
	    ret._settledValue = reason;
	    this._promiseResolved(index, ret);
	};
	
	Promise.settle = function (promises) {
	    return new SettledPromiseArray(promises).promise();
	};
	
	Promise.prototype.settle = function () {
	    return new SettledPromiseArray(this).promise();
	};
	};
	
	},{"./util.js":38}],33:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = _dereq_("./util.js");
	var RangeError = _dereq_("./errors.js").RangeError;
	var AggregateError = _dereq_("./errors.js").AggregateError;
	var isArray = util.isArray;
	
	
	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);
	
	SomePromiseArray.prototype._init = function () {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(undefined, -5);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        this._reject(this._getRangeError(this.length()));
	    }
	};
	
	SomePromiseArray.prototype.init = function () {
	    this._initialized = true;
	    this._init();
	};
	
	SomePromiseArray.prototype.setUnwrap = function () {
	    this._unwrap = true;
	};
	
	SomePromiseArray.prototype.howMany = function () {
	    return this._howMany;
	};
	
	SomePromiseArray.prototype.setHowMany = function (count) {
	    this._howMany = count;
	};
	
	SomePromiseArray.prototype._promiseFulfilled = function (value) {
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	    }
	
	};
	SomePromiseArray.prototype._promiseRejected = function (reason) {
	    this._addRejected(reason);
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            e.push(this._values[i]);
	        }
	        this._reject(e);
	    }
	};
	
	SomePromiseArray.prototype._fulfilled = function () {
	    return this._totalResolved;
	};
	
	SomePromiseArray.prototype._rejected = function () {
	    return this._values.length - this.length();
	};
	
	SomePromiseArray.prototype._addRejected = function (reason) {
	    this._values.push(reason);
	};
	
	SomePromiseArray.prototype._addFulfilled = function (value) {
	    this._values[this._totalResolved++] = value;
	};
	
	SomePromiseArray.prototype._canPossiblyFulfill = function () {
	    return this.length() - this._rejected();
	};
	
	SomePromiseArray.prototype._getRangeError = function (count) {
	    var message = "Input array must contain at least " +
	            this._howMany + " items but contains only " + count + " items";
	    return new RangeError(message);
	};
	
	SomePromiseArray.prototype._resolveEmptyArray = function () {
	    this._reject(this._getRangeError(0));
	};
	
	function some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}
	
	Promise.some = function (promises, howMany) {
	    return some(promises, howMany);
	};
	
	Promise.prototype.some = function (howMany) {
	    return some(this, howMany);
	};
	
	Promise._SomePromiseArray = SomePromiseArray;
	};
	
	},{"./errors.js":13,"./util.js":38}],34:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== undefined) {
	        promise = promise._target();
	        this._bitField = promise._bitField;
	        this._settledValue = promise._settledValue;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValue = undefined;
	    }
	}
	
	PromiseInspection.prototype.value = function () {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return this._settledValue;
	};
	
	PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason = function () {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    return this._settledValue;
	};
	
	PromiseInspection.prototype.isFulfilled =
	Promise.prototype._isFulfilled = function () {
	    return (this._bitField & 268435456) > 0;
	};
	
	PromiseInspection.prototype.isRejected =
	Promise.prototype._isRejected = function () {
	    return (this._bitField & 134217728) > 0;
	};
	
	PromiseInspection.prototype.isPending =
	Promise.prototype._isPending = function () {
	    return (this._bitField & 402653184) === 0;
	};
	
	PromiseInspection.prototype.isResolved =
	Promise.prototype._isResolved = function () {
	    return (this._bitField & 402653184) > 0;
	};
	
	Promise.prototype.isPending = function() {
	    return this._target()._isPending();
	};
	
	Promise.prototype.isRejected = function() {
	    return this._target()._isRejected();
	};
	
	Promise.prototype.isFulfilled = function() {
	    return this._target()._isFulfilled();
	};
	
	Promise.prototype.isResolved = function() {
	    return this._target()._isResolved();
	};
	
	Promise.prototype._value = function() {
	    return this._settledValue;
	};
	
	Promise.prototype._reason = function() {
	    this._unsetRejectionIsUnhandled();
	    return this._settledValue;
	};
	
	Promise.prototype.value = function() {
	    var target = this._target();
	    if (!target.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return target._settledValue;
	};
	
	Promise.prototype.reason = function() {
	    var target = this._target();
	    if (!target.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    target._unsetRejectionIsUnhandled();
	    return target._settledValue;
	};
	
	
	Promise.PromiseInspection = PromiseInspection;
	};
	
	},{}],35:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util.js");
	var errorObj = util.errorObj;
	var isObject = util.isObject;
	
	function tryConvertToPromise(obj, context) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) {
	            return obj;
	        }
	        else if (isAnyBluebirdPromise(obj)) {
	            var ret = new Promise(INTERNAL);
	            obj._then(
	                ret._fulfillUnchecked,
	                ret._rejectUncheckedCheckError,
	                ret._progressUnchecked,
	                ret,
	                null
	            );
	            return ret;
	        }
	        var then = util.tryCatch(getThen)(obj);
	        if (then === errorObj) {
	            if (context) context._pushContext();
	            var ret = Promise.reject(then.e);
	            if (context) context._popContext();
	            return ret;
	        } else if (typeof then === "function") {
	            return doThenable(obj, then, context);
	        }
	    }
	    return obj;
	}
	
	function getThen(obj) {
	    return obj.then;
	}
	
	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    return hasProp.call(obj, "_promise0");
	}
	
	function doThenable(x, then, context) {
	    var promise = new Promise(INTERNAL);
	    var ret = promise;
	    if (context) context._pushContext();
	    promise._captureStackTrace();
	    if (context) context._popContext();
	    var synchronous = true;
	    var result = util.tryCatch(then).call(x,
	                                        resolveFromThenable,
	                                        rejectFromThenable,
	                                        progressFromThenable);
	    synchronous = false;
	    if (promise && result === errorObj) {
	        promise._rejectCallback(result.e, true, true);
	        promise = null;
	    }
	
	    function resolveFromThenable(value) {
	        if (!promise) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }
	
	    function rejectFromThenable(reason) {
	        if (!promise) return;
	        promise._rejectCallback(reason, synchronous, true);
	        promise = null;
	    }
	
	    function progressFromThenable(value) {
	        if (!promise) return;
	        if (typeof promise._progress === "function") {
	            promise._progress(value);
	        }
	    }
	    return ret;
	}
	
	return tryConvertToPromise;
	};
	
	},{"./util.js":38}],36:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util.js");
	var TimeoutError = Promise.TimeoutError;
	
	var afterTimeout = function (promise, message) {
	    if (!promise.isPending()) return;
	    
	    var err;
	    if(!util.isPrimitive(message) && (message instanceof Error)) {
	        err = message;
	    } else {
	        if (typeof message !== "string") {
	            message = "operation timed out";
	        }
	        err = new TimeoutError(message);
	    }
	    util.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._cancel(err);
	};
	
	var afterValue = function(value) { return delay(+this).thenReturn(value); };
	var delay = Promise.delay = function (value, ms) {
	    if (ms === undefined) {
	        ms = value;
	        value = undefined;
	        var ret = new Promise(INTERNAL);
	        setTimeout(function() { ret._fulfill(); }, ms);
	        return ret;
	    }
	    ms = +ms;
	    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
	};
	
	Promise.prototype.delay = function (ms) {
	    return delay(this, ms);
	};
	
	function successClear(value) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    return value;
	}
	
	function failureClear(reason) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    throw reason;
	}
	
	Promise.prototype.timeout = function (ms, message) {
	    ms = +ms;
	    var ret = this.then().cancellable();
	    ret._cancellationParent = this;
	    var handle = setTimeout(function timeoutTimeout() {
	        afterTimeout(ret, message);
	    }, ms);
	    return ret._then(successClear, failureClear, undefined, handle, undefined);
	};
	
	};
	
	},{"./util.js":38}],37:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function (Promise, apiRejection, tryConvertToPromise,
	    createContext) {
	    var TypeError = _dereq_("./errors.js").TypeError;
	    var inherits = _dereq_("./util.js").inherits;
	    var PromiseInspection = Promise.PromiseInspection;
	
	    function inspectionMapper(inspections) {
	        var len = inspections.length;
	        for (var i = 0; i < len; ++i) {
	            var inspection = inspections[i];
	            if (inspection.isRejected()) {
	                return Promise.reject(inspection.error());
	            }
	            inspections[i] = inspection._settledValue;
	        }
	        return inspections;
	    }
	
	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }
	
	    function castPreservingDisposable(thenable) {
	        var maybePromise = tryConvertToPromise(thenable);
	        if (maybePromise !== thenable &&
	            typeof thenable._isDisposable === "function" &&
	            typeof thenable._getDisposer === "function" &&
	            thenable._isDisposable()) {
	            maybePromise._setDisposable(thenable._getDisposer());
	        }
	        return maybePromise;
	    }
	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = Promise.defer();
	        function iterator() {
	            if (i >= len) return ret.resolve();
	            var maybePromise = castPreservingDisposable(resources[i++]);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = tryConvertToPromise(
	                        maybePromise._getDisposer().tryDispose(inspection),
	                        resources.promise);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret.promise;
	    }
	
	    function disposerSuccess(value) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = value;
	        inspection._bitField = 268435456;
	        return dispose(this, inspection).thenReturn(value);
	    }
	
	    function disposerFail(reason) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = reason;
	        inspection._bitField = 134217728;
	        return dispose(this, inspection).thenThrow(reason);
	    }
	
	    function Disposer(data, promise, context) {
	        this._data = data;
	        this._promise = promise;
	        this._context = context;
	    }
	
	    Disposer.prototype.data = function () {
	        return this._data;
	    };
	
	    Disposer.prototype.promise = function () {
	        return this._promise;
	    };
	
	    Disposer.prototype.resource = function () {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return null;
	    };
	
	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var context = this._context;
	        if (context !== undefined) context._pushContext();
	        var ret = resource !== null
	            ? this.doDispose(resource, inspection) : null;
	        if (context !== undefined) context._popContext();
	        this._promise._unsetDisposable();
	        this._data = null;
	        return ret;
	    };
	
	    Disposer.isDisposer = function (d) {
	        return (d != null &&
	                typeof d.resource === "function" &&
	                typeof d.tryDispose === "function");
	    };
	
	    function FunctionDisposer(fn, promise, context) {
	        this.constructor$(fn, promise, context);
	    }
	    inherits(FunctionDisposer, Disposer);
	
	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };
	
	    function maybeUnwrapDisposer(value) {
	        if (Disposer.isDisposer(value)) {
	            this.resources[this.index]._setDisposable(value);
	            return value.promise();
	        }
	        return value;
	    }
	
	    Promise.using = function () {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	
	        var input;
	        var spreadArgs = true;
	        if (len === 2 && Array.isArray(arguments[0])) {
	            input = arguments[0];
	            len = input.length;
	            spreadArgs = false;
	        } else {
	            input = arguments;
	            len--;
	        }
	        var resources = new Array(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = input[i];
	            if (Disposer.isDisposer(resource)) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            } else {
	                var maybePromise = tryConvertToPromise(resource);
	                if (maybePromise instanceof Promise) {
	                    resource =
	                        maybePromise._then(maybeUnwrapDisposer, null, null, {
	                            resources: resources,
	                            index: i
	                    }, undefined);
	                }
	            }
	            resources[i] = resource;
	        }
	
	        var promise = Promise.settle(resources)
	            .then(inspectionMapper)
	            .then(function(vals) {
	                promise._pushContext();
	                var ret;
	                try {
	                    ret = spreadArgs
	                        ? fn.apply(undefined, vals) : fn.call(undefined,  vals);
	                } finally {
	                    promise._popContext();
	                }
	                return ret;
	            })
	            ._then(
	                disposerSuccess, disposerFail, undefined, resources, undefined);
	        resources.promise = promise;
	        return promise;
	    };
	
	    Promise.prototype._setDisposable = function (disposer) {
	        this._bitField = this._bitField | 262144;
	        this._disposer = disposer;
	    };
	
	    Promise.prototype._isDisposable = function () {
	        return (this._bitField & 262144) > 0;
	    };
	
	    Promise.prototype._getDisposer = function () {
	        return this._disposer;
	    };
	
	    Promise.prototype._unsetDisposable = function () {
	        this._bitField = this._bitField & (~262144);
	        this._disposer = undefined;
	    };
	
	    Promise.prototype.disposer = function (fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this, createContext());
	        }
	        throw new TypeError();
	    };
	
	};
	
	},{"./errors.js":13,"./util.js":38}],38:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5.js");
	var canEvaluate = typeof navigator == "undefined";
	var haveGetters = (function(){
	    try {
	        var o = {};
	        es5.defineProperty(o, "f", {
	            get: function () {
	                return 3;
	            }
	        });
	        return o.f === 3;
	    }
	    catch (e) {
	        return false;
	    }
	
	})();
	
	var errorObj = {e: {}};
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        var target = tryCatchTarget;
	        tryCatchTarget = null;
	        return target.apply(this, arguments);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	
	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;
	
	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};
	
	
	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";
	
	}
	
	function isObject(value) {
	    return !isPrimitive(value);
	}
	
	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;
	
	    return new Error(safeToString(maybeError));
	}
	
	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}
	
	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);
	
	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
	    }
	}
	
	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}
	
	function thrower(r) {
	    throw r;
	}
	
	var inheritedDataKeys = (function() {
	    var excludedPrototypes = [
	        Array.prototype,
	        Object.prototype,
	        Function.prototype
	    ];
	
	    var isExcludedProto = function(val) {
	        for (var i = 0; i < excludedPrototypes.length; ++i) {
	            if (excludedPrototypes[i] === val) {
	                return true;
	            }
	        }
	        return false;
	    };
	
	    if (es5.isES5) {
	        var getKeys = Object.getOwnPropertyNames;
	        return function(obj) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            while (obj != null && !isExcludedProto(obj)) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        var hasProp = {}.hasOwnProperty;
	        return function(obj) {
	            if (isExcludedProto(obj)) return [];
	            var ret = [];
	
	            /*jshint forin:false */
	            enumeration: for (var key in obj) {
	                if (hasProp.call(obj, key)) {
	                    ret.push(key);
	                } else {
	                    for (var i = 0; i < excludedPrototypes.length; ++i) {
	                        if (hasProp.call(excludedPrototypes[i], key)) {
	                            continue enumeration;
	                        }
	                    }
	                    ret.push(key);
	                }
	            }
	            return ret;
	        };
	    }
	
	})();
	
	var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.names(fn.prototype);
	
	            var hasMethods = es5.isES5 && keys.length > 1;
	            var hasMethodsOtherThanConstructor = keys.length > 0 &&
	                !(keys.length === 1 && keys[0] === "constructor");
	            var hasThisAssignmentAndStaticMethods =
	                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
	
	            if (hasMethods || hasMethodsOtherThanConstructor ||
	                hasThisAssignmentAndStaticMethods) {
	                return true;
	            }
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}
	
	function toFastProperties(obj) {
	    /*jshint -W027,-W055,-W031*/
	    function f() {}
	    f.prototype = obj;
	    var l = 8;
	    while (l--) new f();
	    return obj;
	    eval(obj);
	}
	
	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}
	
	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}
	
	function safeToString(obj) {
	    try {
	        return obj + "";
	    } catch (e) {
	        return "[no string representation]";
	    }
	}
	
	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}
	
	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
	        e["isOperational"] === true);
	}
	
	function canAttachTrace(obj) {
	    return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
	}
	
	var ensureErrorObject = (function() {
	    if (!("stack" in new Error())) {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            try {throw new Error(safeToString(value));}
	            catch(err) {return err;}
	        };
	    } else {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            return new Error(safeToString(value));
	        };
	    }
	})();
	
	function classString(obj) {
	    return {}.toString.call(obj);
	}
	
	function copyDescriptors(from, to, filter) {
	    var keys = es5.names(from);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        if (filter(key)) {
	            try {
	                es5.defineProperty(to, key, es5.getDescriptor(from, key));
	            } catch (ignore) {}
	        }
	    }
	}
	
	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    haveGetters: haveGetters,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch: tryCatch,
	    inherits: inherits,
	    withAppended: withAppended,
	    maybeWrapAsError: maybeWrapAsError,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange,
	    toString: safeToString,
	    canAttachTrace: canAttachTrace,
	    ensureErrorObject: ensureErrorObject,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    classString: classString,
	    copyDescriptors: copyDescriptors,
	    hasDevTools: typeof chrome !== "undefined" && chrome &&
	                 typeof chrome.loadTimes === "function",
	    isNode: typeof process !== "undefined" &&
	        classString(process).toLowerCase() === "[object process]"
	};
	ret.isRecentNode = ret.isNode && (function() {
	    var version = process.versions.node.split(".").map(Number);
	    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
	})();
	
	if (ret.isNode) ret.toFastProperties(process);
	
	try {throw new Error(); } catch (e) {ret.lastLineError = e;}
	module.exports = ret;
	
	},{"./es5.js":14}]},{},[4])(4)
	});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), (function() { return this; }()), __webpack_require__(8).setImmediate))

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	
	/*!
	 * Module dependencies.
	 */
	
	var ObjectId = __webpack_require__(224);
	var utils = __webpack_require__(223);
	
	exports.flatten = flatten;
	exports.modifiedPaths = modifiedPaths;
	
	/*!
	 * ignore
	 */
	
	function flatten(update, path, options) {
	  var keys = Object.keys(update || {});
	  var numKeys = keys.length;
	  var result = {};
	  path = path ? path + '.' : '';
	
	  for (var i = 0; i < numKeys; ++i) {
	    var key = keys[i];
	    var val = update[key];
	    if (utils.isMongooseObject(val) && !Buffer.isBuffer(val)) {
	      val = val.toObject({ virtuals: false });
	    }
	    if (shouldFlatten(val)) {
	      if (options && options.skipArrays && Array.isArray(val)) {
	        continue;
	      }
	      var flat = flatten(val, path + key);
	      for (var k in flat) {
	        result[k] = flat[k];
	      }
	      if (Array.isArray(val)) {
	        result[path + key] = val;
	      }
	    } else {
	      result[path + key] = val;
	    }
	  }
	
	  return result;
	}
	
	/*!
	 * ignore
	 */
	
	function modifiedPaths(update, path, result) {
	  var keys = Object.keys(update || {});
	  var numKeys = keys.length;
	  result = result || {};
	  path = path ? path + '.' : '';
	
	  for (var i = 0; i < numKeys; ++i) {
	    var key = keys[i];
	    var val = update[key];
	
	    result[path + key] = true;
	    if (shouldFlatten(val)) {
	      modifiedPaths(val, path + key, result);
	    }
	  }
	
	  return result;
	}
	
	/*!
	 * ignore
	 */
	
	function shouldFlatten(val) {
	  return val &&
	    typeof val === 'object' &&
	    !(val instanceof Date) &&
	    !(val instanceof ObjectId) &&
	    (!Array.isArray(val) || val.length > 0) &&
	    !(val instanceof Buffer);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint no-func-assign: 1 */
	
	/*!
	 * Module dependencies.
	 */
	
	var Document = __webpack_require__(253)();
	var PromiseProvider = __webpack_require__(237);
	
	/**
	 * EmbeddedDocument constructor.
	 *
	 * @param {Object} obj js object returned from the db
	 * @param {MongooseDocumentArray} parentArr the parent array of this document
	 * @param {Boolean} skipId
	 * @inherits Document
	 * @api private
	 */
	
	function EmbeddedDocument(obj, parentArr, skipId, fields, index) {
	  if (parentArr) {
	    this.__parentArray = parentArr;
	    this.__parent = parentArr._parent;
	  } else {
	    this.__parentArray = undefined;
	    this.__parent = undefined;
	  }
	  this.__index = index;
	
	  Document.call(this, obj, fields, skipId);
	
	  var _this = this;
	  this.on('isNew', function(val) {
	    _this.isNew = val;
	  });
	}
	
	/*!
	 * Inherit from Document
	 */
	EmbeddedDocument.prototype = Object.create(Document.prototype);
	EmbeddedDocument.prototype.constructor = EmbeddedDocument;
	
	/**
	 * Marks the embedded doc modified.
	 *
	 * ####Example:
	 *
	 *     var doc = blogpost.comments.id(hexstring);
	 *     doc.mixed.type = 'changed';
	 *     doc.markModified('mixed.type');
	 *
	 * @param {String} path the path which changed
	 * @api public
	 * @receiver EmbeddedDocument
	 */
	
	EmbeddedDocument.prototype.markModified = function(path) {
	  this.$__.activePaths.modify(path);
	  if (!this.__parentArray) {
	    return;
	  }
	
	  if (this.isNew) {
	    // Mark the WHOLE parent array as modified
	    // if this is a new document (i.e., we are initializing
	    // a document),
	    this.__parentArray._markModified();
	  } else {
	    this.__parentArray._markModified(this, path);
	  }
	};
	
	/**
	 * Used as a stub for [hooks.js](https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3)
	 *
	 * ####NOTE:
	 *
	 * _This is a no-op. Does not actually save the doc to the db._
	 *
	 * @param {Function} [fn]
	 * @return {Promise} resolved Promise
	 * @api private
	 */
	
	EmbeddedDocument.prototype.save = function(fn) {
	  var Promise = PromiseProvider.get();
	  return new Promise.ES6(function(resolve) {
	    fn && fn();
	    resolve();
	  });
	};
	
	/*!
	 * Registers remove event listeners for triggering
	 * on subdocuments.
	 *
	 * @param {EmbeddedDocument} sub
	 * @api private
	 */
	
	function registerRemoveListener(sub) {
	  var owner = sub.ownerDocument();
	
	  function emitRemove() {
	    owner.removeListener('save', emitRemove);
	    owner.removeListener('remove', emitRemove);
	    sub.emit('remove', sub);
	    owner = sub = null;
	  }
	
	  owner.on('save', emitRemove);
	  owner.on('remove', emitRemove);
	}
	
	/**
	 * Removes the subdocument from its parent array.
	 *
	 * @param {Object} [options]
	 * @param {Function} [fn]
	 * @api public
	 */
	
	EmbeddedDocument.prototype.remove = function(options, fn) {
	  if ( typeof options === 'function' && !fn ) {
	    fn = options;
	    options = undefined;
	  }
	  if (!this.__parentArray || (options && options.noop)) {
	    fn && fn(null);
	    return this;
	  }
	
	  var _id;
	  if (!this.willRemove) {
	    _id = this._doc._id;
	    if (!_id) {
	      throw new Error('For your own good, Mongoose does not know ' +
	          'how to remove an EmbeddedDocument that has no _id');
	    }
	    this.__parentArray.pull({_id: _id});
	    this.willRemove = true;
	    registerRemoveListener(this);
	  }
	
	  if (fn) {
	    fn(null);
	  }
	
	  return this;
	};
	
	/**
	 * Override #update method of parent documents.
	 * @api private
	 */
	
	EmbeddedDocument.prototype.update = function() {
	  throw new Error('The #update method is not available on EmbeddedDocuments');
	};
	
	/**
	 * Helper for console.log
	 *
	 * @api public
	 */
	
	EmbeddedDocument.prototype.inspect = function() {
	  return this.toObject();
	};
	
	/**
	 * Marks a path as invalid, causing validation to fail.
	 *
	 * @param {String} path the field to invalidate
	 * @param {String|Error} err error which states the reason `path` was invalid
	 * @return {Boolean}
	 * @api public
	 */
	
	EmbeddedDocument.prototype.invalidate = function(path, err, val, first) {
	  if (!this.__parent) {
	    throw err;
	  }
	
	  var index = this.__index;
	  if (typeof index !== 'undefined') {
	    var parentPath = this.__parentArray._path;
	    var fullPath = [parentPath, index, path].join('.');
	    this.__parent.invalidate(fullPath, err, val);
	  }
	
	  if (first) {
	    this.$__.validationError = this.ownerDocument().$__.validationError;
	  }
	
	  return true;
	};
	
	/**
	 * Marks a path as valid, removing existing validation errors.
	 *
	 * @param {String} path the field to mark as valid
	 * @api private
	 * @method $markValid
	 * @receiver EmbeddedDocument
	 */
	
	EmbeddedDocument.prototype.$markValid = function(path) {
	  if (!this.__parent) {
	    return;
	  }
	
	  var index = this.__index;
	  if (typeof index !== 'undefined') {
	    var parentPath = this.__parentArray._path;
	    var fullPath = [parentPath, index, path].join('.');
	    this.__parent.$markValid(fullPath);
	  }
	};
	
	/**
	 * Checks if a path is invalid
	 *
	 * @param {String} path the field to check
	 * @api private
	 * @method $isValid
	 * @receiver EmbeddedDocument
	 */
	
	EmbeddedDocument.prototype.$isValid = function(path) {
	  var index = this.__index;
	  if (typeof index !== 'undefined') {
	    return !this.__parent.$__.validationError ||
	      !this.__parent.$__.validationError.errors[this.$__fullPath(path)];
	  }
	
	  return true;
	};
	
	/**
	 * Returns the top level document of this sub-document.
	 *
	 * @return {Document}
	 */
	
	EmbeddedDocument.prototype.ownerDocument = function() {
	  if (this.$__.ownerDocument) {
	    return this.$__.ownerDocument;
	  }
	
	  var parent = this.__parent;
	  if (!parent) {
	    return this;
	  }
	
	  while (parent.__parent || parent.$parent) {
	    parent = parent.__parent || parent.$parent;
	  }
	
	  this.$__.ownerDocument = parent;
	  return this.$__.ownerDocument;
	};
	
	/**
	 * Returns the full path to this document. If optional `path` is passed, it is appended to the full path.
	 *
	 * @param {String} [path]
	 * @return {String}
	 * @api private
	 * @method $__fullPath
	 * @memberOf EmbeddedDocument
	 */
	
	EmbeddedDocument.prototype.$__fullPath = function(path) {
	  if (!this.$__.fullPath) {
	    var parent = this; // eslint-disable-line consistent-this
	    if (!parent.__parent) {
	      return path;
	    }
	
	    var paths = [];
	    while (parent.__parent || parent.$parent) {
	      if (parent.__parent) {
	        paths.unshift(parent.__parentArray._path);
	      } else {
	        paths.unshift(parent.$basePath);
	      }
	      parent = parent.__parent || parent.$parent;
	    }
	
	    this.$__.fullPath = paths.join('.');
	
	    if (!this.$__.ownerDocument) {
	      // optimization
	      this.$__.ownerDocument = parent;
	    }
	  }
	
	  return path
	      ? this.$__.fullPath + '.' + path
	      : this.$__.fullPath;
	};
	
	/**
	 * Returns this sub-documents parent document.
	 *
	 * @api public
	 */
	
	EmbeddedDocument.prototype.parent = function() {
	  return this.__parent;
	};
	
	/**
	 * Returns this sub-documents parent array.
	 *
	 * @api public
	 */
	
	EmbeddedDocument.prototype.parentArray = function() {
	  return this.__parentArray;
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = EmbeddedDocument;


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/* eslint-env browser */
	
	/*!
	 * Module dependencies.
	 */
	var Document = __webpack_require__(229);
	var BrowserDocument = __webpack_require__(254);
	
	/**
	 * Returns the Document constructor for the current context
	 *
	 * @api private
	 */
	module.exports = function() {
	  if (typeof window !== 'undefined' && typeof document !== 'undefined' && document === window.document) {
	    return BrowserDocument;
	  }
	  return Document;
	};


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var NodeJSDocument = __webpack_require__(229),
	    EventEmitter = __webpack_require__(3).EventEmitter,
	    MongooseError = __webpack_require__(119),
	    Schema = __webpack_require__(128),
	    ObjectId = __webpack_require__(224),
	    utils = __webpack_require__(223),
	    ValidationError = MongooseError.ValidationError,
	    InternalCache = __webpack_require__(234);
	
	/**
	 * Document constructor.
	 *
	 * @param {Object} obj the values to set
	 * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data
	 * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `init`: Emitted on a document after it has was retrieved from the db and fully hydrated by Mongoose.
	 * @event `save`: Emitted when the document is successfully saved
	 * @api private
	 */
	
	function Document(obj, schema, fields, skipId, skipInit) {
	  if (!(this instanceof Document)) {
	    return new Document(obj, schema, fields, skipId, skipInit);
	  }
	
	
	  if (utils.isObject(schema) && !schema.instanceOfSchema) {
	    schema = new Schema(schema);
	  }
	
	  // When creating EmbeddedDocument, it already has the schema and he doesn't need the _id
	  schema = this.schema || schema;
	
	  // Generate ObjectId if it is missing, but it requires a scheme
	  if (!this.schema && schema.options._id) {
	    obj = obj || {};
	
	    if (obj._id === undefined) {
	      obj._id = new ObjectId();
	    }
	  }
	
	  if (!schema) {
	    throw new MongooseError.MissingSchemaError();
	  }
	
	  this.$__setSchema(schema);
	
	  this.$__ = new InternalCache;
	  this.$__.emitter = new EventEmitter();
	  this.isNew = true;
	  this.errors = undefined;
	
	  // var schema = this.schema;
	
	  if (typeof fields === 'boolean') {
	    this.$__.strictMode = fields;
	    fields = undefined;
	  } else {
	    this.$__.strictMode = this.schema.options && this.schema.options.strict;
	    this.$__.selected = fields;
	  }
	
	  var required = this.schema.requiredPaths();
	  for (var i = 0; i < required.length; ++i) {
	    this.$__.activePaths.require(required[i]);
	  }
	
	  this.$__.emitter.setMaxListeners(0);
	  this._doc = this.$__buildDoc(obj, fields, skipId);
	
	  if (!skipInit && obj) {
	    this.init(obj);
	  }
	
	  this.$__registerHooksFromSchema();
	
	  // apply methods
	  for (var m in schema.methods) {
	    this[m] = schema.methods[m];
	  }
	  // apply statics
	  for (var s in schema.statics) {
	    this[s] = schema.statics[s];
	  }
	}
	
	/*!
	 * Inherit from the NodeJS document
	 */
	Document.prototype = Object.create(NodeJSDocument.prototype);
	Document.prototype.constructor = Document;
	
	/*!
	 * Module exports.
	 */
	Document.ValidationError = ValidationError;
	module.exports = exports = Document;


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module dependencies.
	 */
	
	var EmbeddedDocument = __webpack_require__(252);
	var Document = __webpack_require__(229);
	var ObjectId = __webpack_require__(224);
	var utils = __webpack_require__(223);
	var isMongooseObject = utils.isMongooseObject;
	
	/**
	 * Mongoose Array constructor.
	 *
	 * ####NOTE:
	 *
	 * _Values always have to be passed to the constructor to initialize, otherwise `MongooseArray#push` will mark the array as modified._
	 *
	 * @param {Array} values
	 * @param {String} path
	 * @param {Document} doc parent document
	 * @api private
	 * @inherits Array
	 * @see http://bit.ly/f6CnZU
	 */
	
	function MongooseArray(values, path, doc) {
	  var arr = [].concat(values);
	
	  var keysMA = Object.keys(MongooseArray.mixin);
	  var numKeys = keysMA.length;
	  for (var i = 0; i < numKeys; ++i) {
	    arr[keysMA[i]] = MongooseArray.mixin[keysMA[i]];
	  }
	
	  arr._path = path;
	  arr.isMongooseArray = true;
	  arr.validators = [];
	  arr._atomics = {};
	  arr._schema = void 0;
	
	  // Because doc comes from the context of another function, doc === global
	  // can happen if there was a null somewhere up the chain (see #3020)
	  // RB Jun 17, 2015 updated to check for presence of expected paths instead
	  // to make more proof against unusual node environments
	  if (doc && doc instanceof Document) {
	    arr._parent = doc;
	    arr._schema = doc.schema.path(path);
	  }
	
	  return arr;
	}
	
	MongooseArray.mixin = {
	
	  /**
	   * Stores a queue of atomic operations to perform
	   *
	   * @property _atomics
	   * @api private
	   */
	
	  _atomics: undefined,
	
	  /**
	   * Parent owner document
	   *
	   * @property _parent
	   * @api private
	   * @receiver MongooseArray
	   */
	
	  _parent: undefined,
	
	  /**
	   * Casts a member based on this arrays schema.
	   *
	   * @param {any} value
	   * @return value the casted value
	   * @method _cast
	   * @api private
	   * @receiver MongooseArray
	   */
	
	  _cast: function(value) {
	    var owner = this._owner;
	    var populated = false;
	    var Model;
	
	    if (this._parent) {
	      // if a populated array, we must cast to the same model
	      // instance as specified in the original query.
	      if (!owner) {
	        owner = this._owner = this._parent.ownerDocument
	            ? this._parent.ownerDocument()
	            : this._parent;
	      }
	
	      populated = owner.populated(this._path, true);
	    }
	
	    if (populated && value !== null && value !== undefined) {
	      // cast to the populated Models schema
	      Model = populated.options.model;
	
	      // only objects are permitted so we can safely assume that
	      // non-objects are to be interpreted as _id
	      if (Buffer.isBuffer(value) ||
	          value instanceof ObjectId || !utils.isObject(value)) {
	        value = {_id: value};
	      }
	
	      // gh-2399
	      // we should cast model only when it's not a discriminator
	      var isDisc = value.schema && value.schema.discriminatorMapping &&
	          value.schema.discriminatorMapping.key !== undefined;
	      if (!isDisc) {
	        value = new Model(value);
	      }
	      return this._schema.caster.cast(value, this._parent, true);
	    }
	
	    return this._schema.caster.cast(value, this._parent, false);
	  },
	
	  /**
	   * Marks this array as modified.
	   *
	   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)
	   *
	   * @param {EmbeddedDocument} embeddedDoc the embedded doc that invoked this method on the Array
	   * @param {String} embeddedPath the path which changed in the embeddedDoc
	   * @method _markModified
	   * @api private
	   * @receiver MongooseArray
	   */
	
	  _markModified: function(elem, embeddedPath) {
	    var parent = this._parent,
	        dirtyPath;
	
	    if (parent) {
	      dirtyPath = this._path;
	
	      if (arguments.length) {
	        if (embeddedPath != null) {
	          // an embedded doc bubbled up the change
	          dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;
	        } else {
	          // directly set an index
	          dirtyPath = dirtyPath + '.' + elem;
	        }
	      }
	
	      parent.markModified(dirtyPath);
	    }
	
	    return this;
	  },
	
	  /**
	   * Register an atomic operation with the parent.
	   *
	   * @param {Array} op operation
	   * @param {any} val
	   * @method _registerAtomic
	   * @api private
	   * @receiver MongooseArray
	   */
	
	  _registerAtomic: function(op, val) {
	    if (op === '$set') {
	      // $set takes precedence over all other ops.
	      // mark entire array modified.
	      this._atomics = {$set: val};
	      return this;
	    }
	
	    var atomics = this._atomics;
	
	    // reset pop/shift after save
	    if (op === '$pop' && !('$pop' in atomics)) {
	      var _this = this;
	      this._parent.once('save', function() {
	        _this._popped = _this._shifted = null;
	      });
	    }
	
	    // check for impossible $atomic combos (Mongo denies more than one
	    // $atomic op on a single path
	    if (this._atomics.$set ||
	        Object.keys(atomics).length && !(op in atomics)) {
	      // a different op was previously registered.
	      // save the entire thing.
	      this._atomics = {$set: this};
	      return this;
	    }
	
	    var selector;
	
	    if (op === '$pullAll' || op === '$pushAll' || op === '$addToSet') {
	      atomics[op] || (atomics[op] = []);
	      atomics[op] = atomics[op].concat(val);
	    } else if (op === '$pullDocs') {
	      var pullOp = atomics['$pull'] || (atomics['$pull'] = {});
	      if (val[0] instanceof EmbeddedDocument) {
	        selector = pullOp['$or'] || (pullOp['$or'] = []);
	        Array.prototype.push.apply(selector, val.map(function(v) {
	          return v.toObject({virtuals: false});
	        }));
	      } else {
	        selector = pullOp['_id'] || (pullOp['_id'] = {$in: []});
	        selector['$in'] = selector['$in'].concat(val);
	      }
	    } else {
	      atomics[op] = val;
	    }
	
	    return this;
	  },
	
	  /**
	   * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.
	   *
	   * If no atomics exist, we return all array values after conversion.
	   *
	   * @return {Array}
	   * @method $__getAtomics
	   * @memberOf MongooseArray
	   * @api private
	   */
	
	  $__getAtomics: function() {
	    var ret = [];
	    var keys = Object.keys(this._atomics);
	    var i = keys.length;
	
	    if (i === 0) {
	      ret[0] = ['$set', this.toObject({depopulate: 1, transform: false})];
	      return ret;
	    }
	
	    while (i--) {
	      var op = keys[i];
	      var val = this._atomics[op];
	
	      // the atomic values which are arrays are not MongooseArrays. we
	      // need to convert their elements as if they were MongooseArrays
	      // to handle populated arrays versus DocumentArrays properly.
	      if (isMongooseObject(val)) {
	        val = val.toObject({depopulate: 1, transform: false});
	      } else if (Array.isArray(val)) {
	        val = this.toObject.call(val, {depopulate: 1, transform: false});
	      } else if (val.valueOf) {
	        val = val.valueOf();
	      }
	
	      if (op === '$addToSet') {
	        val = {$each: val};
	      }
	
	      ret.push([op, val]);
	    }
	
	    return ret;
	  },
	
	  /**
	   * Returns the number of pending atomic operations to send to the db for this array.
	   *
	   * @api private
	   * @return {Number}
	   * @method hasAtomics
	   * @receiver MongooseArray
	   */
	
	  hasAtomics: function hasAtomics() {
	    if (!(this._atomics && this._atomics.constructor.name === 'Object')) {
	      return 0;
	    }
	
	    return Object.keys(this._atomics).length;
	  },
	
	  /**
	   * Internal helper for .map()
	   *
	   * @api private
	   * @return {Number}
	   * @method _mapCast
	   * @receiver MongooseArray
	   */
	  _mapCast: function(val, index) {
	    return this._cast(val, this.length + index);
	  },
	
	  /**
	   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.
	   *
	   * @param {Object} [args...]
	   * @api public
	   * @method push
	   * @receiver MongooseArray
	   */
	
	  push: function() {
	    var values = [].map.call(arguments, this._mapCast, this);
	    values = this._schema.applySetters(values, this._parent, undefined,
	        undefined, {skipDocumentArrayCast: true});
	    var ret = [].push.apply(this, values);
	
	    // $pushAll might be fibbed (could be $push). But it makes it easier to
	    // handle what could have been $push, $pushAll combos
	    this._registerAtomic('$pushAll', values);
	    this._markModified();
	    return ret;
	  },
	
	  /**
	   * Pushes items to the array non-atomically.
	   *
	   * ####NOTE:
	   *
	   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @param {any} [args...]
	   * @api public
	   * @method nonAtomicPush
	   * @receiver MongooseArray
	   */
	
	  nonAtomicPush: function() {
	    var values = [].map.call(arguments, this._mapCast, this);
	    var ret = [].push.apply(this, values);
	    this._registerAtomic('$set', this);
	    this._markModified();
	    return ret;
	  },
	
	  /**
	   * Pops the array atomically at most one time per document `save()`.
	   *
	   * #### NOTE:
	   *
	   * _Calling this mulitple times on an array before saving sends the same command as calling it once._
	   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._
	   *
	   *      doc.array = [1,2,3];
	   *
	   *      var popped = doc.array.$pop();
	   *      console.log(popped); // 3
	   *      console.log(doc.array); // [1,2]
	   *
	   *      // no affect
	   *      popped = doc.array.$pop();
	   *      console.log(doc.array); // [1,2]
	   *
	   *      doc.save(function (err) {
	   *        if (err) return handleError(err);
	   *
	   *        // we saved, now $pop works again
	   *        popped = doc.array.$pop();
	   *        console.log(popped); // 2
	   *        console.log(doc.array); // [1]
	   *      })
	   *
	   * @api public
	   * @method $pop
	   * @memberOf MongooseArray
	   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop
	   * @method $pop
	   * @receiver MongooseArray
	   */
	
	  $pop: function() {
	    this._registerAtomic('$pop', 1);
	    this._markModified();
	
	    // only allow popping once
	    if (this._popped) {
	      return;
	    }
	    this._popped = true;
	
	    return [].pop.call(this);
	  },
	
	  /**
	   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.
	   *
	   * ####Note:
	   *
	   * _marks the entire array as modified which will pass the entire thing to $set potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @see MongooseArray#$pop #types_array_MongooseArray-%24pop
	   * @api public
	   * @method pop
	   * @receiver MongooseArray
	   */
	
	  pop: function() {
	    var ret = [].pop.call(this);
	    this._registerAtomic('$set', this);
	    this._markModified();
	    return ret;
	  },
	
	  /**
	   * Atomically shifts the array at most one time per document `save()`.
	   *
	   * ####NOTE:
	   *
	   * _Calling this mulitple times on an array before saving sends the same command as calling it once._
	   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._
	   *
	   *      doc.array = [1,2,3];
	   *
	   *      var shifted = doc.array.$shift();
	   *      console.log(shifted); // 1
	   *      console.log(doc.array); // [2,3]
	   *
	   *      // no affect
	   *      shifted = doc.array.$shift();
	   *      console.log(doc.array); // [2,3]
	   *
	   *      doc.save(function (err) {
	   *        if (err) return handleError(err);
	   *
	   *        // we saved, now $shift works again
	   *        shifted = doc.array.$shift();
	   *        console.log(shifted ); // 2
	   *        console.log(doc.array); // [3]
	   *      })
	   *
	   * @api public
	   * @memberOf MongooseArray
	   * @method $shift
	   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop
	   */
	
	  $shift: function $shift() {
	    this._registerAtomic('$pop', -1);
	    this._markModified();
	
	    // only allow shifting once
	    if (this._shifted) {
	      return;
	    }
	    this._shifted = true;
	
	    return [].shift.call(this);
	  },
	
	  /**
	   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
	   *
	   * ####Example:
	   *
	   *     doc.array = [2,3];
	   *     var res = doc.array.shift();
	   *     console.log(res) // 2
	   *     console.log(doc.array) // [3]
	   *
	   * ####Note:
	   *
	   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @api public
	   * @method shift
	   * @receiver MongooseArray
	   */
	
	  shift: function() {
	    var ret = [].shift.call(this);
	    this._registerAtomic('$set', this);
	    this._markModified();
	    return ret;
	  },
	
	  /**
	   * Pulls items from the array atomically. Equality is determined by casting
	   * the provided value to an embedded document and comparing using
	   * [the `Document.equals()` function.](./api.html#document_Document-equals)
	   *
	   * ####Examples:
	   *
	   *     doc.array.pull(ObjectId)
	   *     doc.array.pull({ _id: 'someId' })
	   *     doc.array.pull(36)
	   *     doc.array.pull('tag 1', 'tag 2')
	   *
	   * To remove a document from a subdocument array we may pass an object with a matching `_id`.
	   *
	   *     doc.subdocs.push({ _id: 4815162342 })
	   *     doc.subdocs.pull({ _id: 4815162342 }) // removed
	   *
	   * Or we may passing the _id directly and let mongoose take care of it.
	   *
	   *     doc.subdocs.push({ _id: 4815162342 })
	   *     doc.subdocs.pull(4815162342); // works
	   *
	   * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.
	   *
	   * @param {any} [args...]
	   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull
	   * @api public
	   * @method pull
	   * @receiver MongooseArray
	   */
	
	  pull: function() {
	    var values = [].map.call(arguments, this._cast, this),
	        cur = this._parent.get(this._path),
	        i = cur.length,
	        mem;
	
	    while (i--) {
	      mem = cur[i];
	      if (mem instanceof Document) {
	        var some = values.some(function(v) {
	          return mem.equals(v);
	        });
	        if (some) {
	          [].splice.call(cur, i, 1);
	        }
	      } else if (~cur.indexOf.call(values, mem)) {
	        [].splice.call(cur, i, 1);
	      }
	    }
	
	    if (values[0] instanceof EmbeddedDocument) {
	      this._registerAtomic('$pullDocs', values.map(function(v) {
	        return v._id || v;
	      }));
	    } else {
	      this._registerAtomic('$pullAll', values);
	    }
	
	    this._markModified();
	    return this;
	  },
	
	  /**
	   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.
	   *
	   * ####Note:
	   *
	   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @api public
	   * @method splice
	   * @receiver MongooseArray
	   */
	
	  splice: function splice() {
	    var ret, vals, i;
	
	    if (arguments.length) {
	      vals = [];
	      for (i = 0; i < arguments.length; ++i) {
	        vals[i] = i < 2
	            ? arguments[i]
	            : this._cast(arguments[i], arguments[0] + (i - 2));
	      }
	      ret = [].splice.apply(this, vals);
	      this._registerAtomic('$set', this);
	      this._markModified();
	    }
	
	    return ret;
	  },
	
	  /**
	   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
	   *
	   * ####Note:
	   *
	   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @api public
	   * @method unshift
	   * @receiver MongooseArray
	   */
	
	  unshift: function() {
	    var values = [].map.call(arguments, this._cast, this);
	    values = this._schema.applySetters(values, this._parent);
	    [].unshift.apply(this, values);
	    this._registerAtomic('$set', this);
	    this._markModified();
	    return this.length;
	  },
	
	  /**
	   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.
	   *
	   * ####NOTE:
	   *
	   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @api public
	   * @method sort
	   * @receiver MongooseArray
	   */
	
	  sort: function() {
	    var ret = [].sort.apply(this, arguments);
	    this._registerAtomic('$set', this);
	    this._markModified();
	    return ret;
	  },
	
	  /**
	   * Adds values to the array if not already present.
	   *
	   * ####Example:
	   *
	   *     console.log(doc.array) // [2,3,4]
	   *     var added = doc.array.addToSet(4,5);
	   *     console.log(doc.array) // [2,3,4,5]
	   *     console.log(added)     // [5]
	   *
	   * @param {any} [args...]
	   * @return {Array} the values that were added
	   * @receiver MongooseArray
	   * @api public
	   * @method addToSet
	   */
	
	  addToSet: function addToSet() {
	    var values = [].map.call(arguments, this._mapCast, this);
	    values = this._schema.applySetters(values, this._parent);
	    var added = [];
	    var type = '';
	    if (values[0] instanceof EmbeddedDocument) {
	      type = 'doc';
	    } else if (values[0] instanceof Date) {
	      type = 'date';
	    }
	
	    values.forEach(function(v) {
	      var found;
	      switch (type) {
	        case 'doc':
	          found = this.some(function(doc) {
	            return doc.equals(v);
	          });
	          break;
	        case 'date':
	          var val = +v;
	          found = this.some(function(d) {
	            return +d === val;
	          });
	          break;
	        default:
	          found = ~this.indexOf(v);
	      }
	
	      if (!found) {
	        [].push.call(this, v);
	        this._registerAtomic('$addToSet', v);
	        this._markModified();
	        [].push.call(added, v);
	      }
	    }, this);
	
	    return added;
	  },
	
	  /**
	   * Sets the casted `val` at index `i` and marks the array modified.
	   *
	   * ####Example:
	   *
	   *     // given documents based on the following
	   *     var Doc = mongoose.model('Doc', new Schema({ array: [Number] }));
	   *
	   *     var doc = new Doc({ array: [2,3,4] })
	   *
	   *     console.log(doc.array) // [2,3,4]
	   *
	   *     doc.array.set(1,"5");
	   *     console.log(doc.array); // [2,5,4] // properly cast to number
	   *     doc.save() // the change is saved
	   *
	   *     // VS not using array#set
	   *     doc.array[1] = "5";
	   *     console.log(doc.array); // [2,"5",4] // no casting
	   *     doc.save() // change is not saved
	   *
	   * @return {Array} this
	   * @api public
	   * @method set
	   * @receiver MongooseArray
	   */
	
	  set: function set(i, val) {
	    var value = this._cast(val, i);
	    value = this._schema.caster instanceof EmbeddedDocument ?
	        value :
	        this._schema.caster.applySetters(val, this._parent)
	    ;
	    this[i] = value;
	    this._markModified(i);
	    return this;
	  },
	
	  /**
	   * Returns a native js Array.
	   *
	   * @param {Object} options
	   * @return {Array}
	   * @api public
	   * @method toObject
	   * @receiver MongooseArray
	   */
	
	  toObject: function(options) {
	    if (options && options.depopulate) {
	      return this.map(function(doc) {
	        return doc instanceof Document
	            ? doc.toObject(options)
	            : doc;
	      });
	    }
	
	    return this.slice();
	  },
	
	  /**
	   * Helper for console.log
	   *
	   * @api public
	   * @method inspect
	   * @receiver MongooseArray
	   */
	
	  inspect: function() {
	    return JSON.stringify(this);
	  },
	
	  /**
	   * Return the index of `obj` or `-1` if not found.
	   *
	   * @param {Object} obj the item to look for
	   * @return {Number}
	   * @api public
	   * @method indexOf
	   * @receiver MongooseArray
	   */
	
	  indexOf: function indexOf(obj) {
	    if (obj instanceof ObjectId) {
	      obj = obj.toString();
	    }
	    for (var i = 0, len = this.length; i < len; ++i) {
	      if (obj == this[i]) {
	        return i;
	      }
	    }
	    return -1;
	  }
	};
	
	/**
	 * Alias of [pull](#types_array_MongooseArray-pull)
	 *
	 * @see MongooseArray#pull #types_array_MongooseArray-pull
	 * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull
	 * @api public
	 * @memberOf MongooseArray
	 * @method remove
	 */
	
	MongooseArray.mixin.remove = MongooseArray.mixin.pull;
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = MongooseArray;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module dependencies.
	 */
	
	var MongooseArray = __webpack_require__(255),
	    ObjectId = __webpack_require__(224),
	    ObjectIdSchema = __webpack_require__(257),
	    utils = __webpack_require__(223),
	    Document = __webpack_require__(229);
	
	/**
	 * DocumentArray constructor
	 *
	 * @param {Array} values
	 * @param {String} path the path to this array
	 * @param {Document} doc parent document
	 * @api private
	 * @return {MongooseDocumentArray}
	 * @inherits MongooseArray
	 * @see http://bit.ly/f6CnZU
	 */
	
	function MongooseDocumentArray(values, path, doc) {
	  var arr = [].concat(values);
	  arr._path = path;
	
	  var props = {
	    isMongooseArray: true,
	    isMongooseDocumentArray: true,
	    validators: [],
	    _atomics: {},
	    _schema: void 0,
	    _handlers: void 0
	  };
	
	  // Values always have to be passed to the constructor to initialize, since
	  // otherwise MongooseArray#push will mark the array as modified to the parent.
	  var keysMA = Object.keys(MongooseArray.mixin);
	  var numKeys = keysMA.length;
	  for (var j = 0; j < numKeys; ++j) {
	    arr[keysMA[j]] = MongooseArray.mixin[keysMA[j]];
	  }
	
	  var keysMDA = Object.keys(MongooseDocumentArray.mixin);
	  numKeys = keysMDA.length;
	  for (var i = 0; i < numKeys; ++i) {
	    arr[keysMDA[i]] = MongooseDocumentArray.mixin[keysMDA[i]];
	  }
	
	  var keysP = Object.keys(props);
	  numKeys = keysP.length;
	  for (var k = 0; k < numKeys; ++k) {
	    arr[keysP[k]] = props[keysP[k]];
	  }
	
	  // Because doc comes from the context of another function, doc === global
	  // can happen if there was a null somewhere up the chain (see #3020 && #3034)
	  // RB Jun 17, 2015 updated to check for presence of expected paths instead
	  // to make more proof against unusual node environments
	  if (doc && doc instanceof Document) {
	    arr._parent = doc;
	    arr._schema = doc.schema.path(path);
	    arr._handlers = {
	      isNew: arr.notify('isNew'),
	      save: arr.notify('save')
	    };
	
	    doc.on('save', arr._handlers.save);
	    doc.on('isNew', arr._handlers.isNew);
	  }
	
	  return arr;
	}
	
	/*!
	 * Inherits from MongooseArray
	 */
	// MongooseDocumentArray.mixin = Object.create( MongooseArray.mixin );
	MongooseDocumentArray.mixin = {
	
	  /**
	   * Overrides MongooseArray#cast
	   *
	   * @method _cast
	   * @api private
	   * @receiver MongooseDocumentArray
	   */
	
	  _cast: function(value, index) {
	    if (value instanceof this._schema.casterConstructor) {
	      if (!(value.__parent && value.__parentArray)) {
	        // value may have been created using array.create()
	        value.__parent = this._parent;
	        value.__parentArray = this;
	      }
	      value.__index = index;
	      return value;
	    }
	
	    if (value === undefined || value === null) {
	      return null;
	    }
	
	    // handle cast('string') or cast(ObjectId) etc.
	    // only objects are permitted so we can safely assume that
	    // non-objects are to be interpreted as _id
	    if (Buffer.isBuffer(value) ||
	        value instanceof ObjectId || !utils.isObject(value)) {
	      value = {_id: value};
	    }
	    return new this._schema.casterConstructor(value, this, undefined, undefined, index);
	  },
	
	  /**
	   * Searches array items for the first document with a matching _id.
	   *
	   * ####Example:
	   *
	   *     var embeddedDoc = m.array.id(some_id);
	   *
	   * @return {EmbeddedDocument|null} the subdocument or null if not found.
	   * @param {ObjectId|String|Number|Buffer} id
	   * @TODO cast to the _id based on schema for proper comparison
	   * @method id
	   * @api public
	   * @receiver MongooseDocumentArray
	   */
	
	  id: function(id) {
	    var casted,
	        sid,
	        _id;
	
	    try {
	      var casted_ = ObjectIdSchema.prototype.cast.call({}, id);
	      if (casted_) {
	        casted = String(casted_);
	      }
	    } catch (e) {
	      casted = null;
	    }
	
	    for (var i = 0, l = this.length; i < l; i++) {
	      _id = this[i].get('_id');
	
	      if (_id === null || typeof _id === 'undefined') {
	        continue;
	      } else if (_id instanceof Document) {
	        sid || (sid = String(id));
	        if (sid == _id._id) {
	          return this[i];
	        }
	      } else if (!(id instanceof ObjectId) && !(_id instanceof ObjectId)) {
	        if (utils.deepEqual(id, _id)) {
	          return this[i];
	        }
	      } else if (casted == _id) {
	        return this[i];
	      }
	    }
	
	    return null;
	  },
	
	  /**
	   * Returns a native js Array of plain js objects
	   *
	   * ####NOTE:
	   *
	   * _Each sub-document is converted to a plain object by calling its `#toObject` method._
	   *
	   * @param {Object} [options] optional options to pass to each documents `toObject` method call during conversion
	   * @return {Array}
	   * @method toObject
	   * @api public
	   * @receiver MongooseDocumentArray
	   */
	
	  toObject: function(options) {
	    return this.map(function(doc) {
	      return doc && doc.toObject(options) || null;
	    });
	  },
	
	  /**
	   * Helper for console.log
	   *
	   * @method inspect
	   * @api public
	   * @receiver MongooseDocumentArray
	   */
	
	  inspect: function() {
	    return Array.prototype.slice.call(this);
	  },
	
	  /**
	   * Creates a subdocument casted to this schema.
	   *
	   * This is the same subdocument constructor used for casting.
	   *
	   * @param {Object} obj the value to cast to this arrays SubDocument schema
	   * @method create
	   * @api public
	   * @receiver MongooseDocumentArray
	   */
	
	  create: function(obj) {
	    return new this._schema.casterConstructor(obj);
	  },
	
	  /**
	   * Creates a fn that notifies all child docs of `event`.
	   *
	   * @param {String} event
	   * @return {Function}
	   * @method notify
	   * @api private
	   * @receiver MongooseDocumentArray
	   */
	
	  notify: function notify(event) {
	    var _this = this;
	    return function notify(val) {
	      var i = _this.length;
	      while (i--) {
	        if (!_this[i]) {
	          continue;
	        }
	        switch (event) {
	          // only swap for save event for now, we may change this to all event types later
	          case 'save':
	            val = _this[i];
	            break;
	          default:
	            // NO-OP
	            break;
	        }
	        _this[i].emit(event, val);
	      }
	    };
	  }
	
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = MongooseDocumentArray;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/* eslint no-empty: 1 */
	
	/*!
	 * Module dependencies.
	 */
	
	var SchemaType = __webpack_require__(231),
	    CastError = SchemaType.CastError,
	    oid = __webpack_require__(224),
	    utils = __webpack_require__(223),
	    Document;
	
	/**
	 * ObjectId SchemaType constructor.
	 *
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function ObjectId(key, options) {
	  SchemaType.call(this, key, options, 'ObjectID');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	ObjectId.schemaName = 'ObjectId';
	
	/*!
	 * Inherits from SchemaType.
	 */
	ObjectId.prototype = Object.create(SchemaType.prototype);
	ObjectId.prototype.constructor = ObjectId;
	
	/**
	 * Adds an auto-generated ObjectId default if turnOn is true.
	 * @param {Boolean} turnOn auto generated ObjectId defaults
	 * @api public
	 * @return {SchemaType} this
	 */
	
	ObjectId.prototype.auto = function(turnOn) {
	  if (turnOn) {
	    this.default(defaultId);
	    this.set(resetId);
	  }
	
	  return this;
	};
	
	/**
	 * Check if the given value satisfies a required validator.
	 *
	 * @param {Any} value
	 * @param {Document} doc
	 * @return {Boolean}
	 * @api public
	 */
	
	ObjectId.prototype.checkRequired = function checkRequired(value, doc) {
	  if (SchemaType._isRef(this, value, doc, true)) {
	    return !!value;
	  }
	  return value instanceof oid;
	};
	
	/**
	 * Casts to ObjectId
	 *
	 * @param {Object} value
	 * @param {Object} doc
	 * @param {Boolean} init whether this is an initialization cast
	 * @api private
	 */
	
	ObjectId.prototype.cast = function(value, doc, init) {
	  if (SchemaType._isRef(this, value, doc, init)) {
	    // wait! we may need to cast this to a document
	
	    if (value === null || value === undefined) {
	      return value;
	    }
	
	    // lazy load
	    Document || (Document = __webpack_require__(229));
	
	    if (value instanceof Document) {
	      value.$__.wasPopulated = true;
	      return value;
	    }
	
	    // setting a populated path
	    if (value instanceof oid) {
	      return value;
	    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {
	      throw new CastError('ObjectId', value, this.path);
	    }
	
	    // Handle the case where user directly sets a populated
	    // path to a plain object; cast to the Model used in
	    // the population query.
	    var path = doc.$__fullPath(this.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    var pop = owner.populated(path, true);
	    var ret = value;
	    if (!doc.$__.populated ||
	        !doc.$__.populated[path] ||
	        !doc.$__.populated[path].options ||
	        !doc.$__.populated[path].options.options ||
	        !doc.$__.populated[path].options.options.lean) {
	      ret = new pop.options.model(value);
	      ret.$__.wasPopulated = true;
	    }
	
	    return ret;
	  }
	
	  if (value === null || value === undefined) {
	    return value;
	  }
	
	  if (value instanceof oid) {
	    return value;
	  }
	
	  if (value._id) {
	    if (value._id instanceof oid) {
	      return value._id;
	    }
	    if (value._id.toString instanceof Function) {
	      try {
	        return new oid(value._id.toString());
	      } catch (e) {
	      }
	    }
	  }
	
	  if (value.toString instanceof Function) {
	    try {
	      return new oid(value.toString());
	    } catch (err) {
	      throw new CastError('ObjectId', value, this.path);
	    }
	  }
	
	  throw new CastError('ObjectId', value, this.path);
	};
	
	/*!
	 * ignore
	 */
	
	function handleSingle(val) {
	  return this.cast(val);
	}
	
	ObjectId.prototype.$conditionalHandlers =
	    utils.options(SchemaType.prototype.$conditionalHandlers, {
	      $gt: handleSingle,
	      $gte: handleSingle,
	      $lt: handleSingle,
	      $lte: handleSingle
	    });
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [val]
	 * @api private
	 */
	
	ObjectId.prototype.castForQuery = function($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler) {
	      throw new Error('Can\'t use ' + $conditional + ' with ObjectId.');
	    }
	    return handler.call(this, val);
	  }
	  return this.cast($conditional);
	};
	
	/*!
	 * ignore
	 */
	
	function defaultId() {
	  return new oid();
	}
	
	function resetId(v) {
	  this.$__._id = null;
	  return v;
	}
	
	/*!
	 * Module exports.
	 */
	
	module.exports = ObjectId;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module exports.
	 */
	
	exports.Array = __webpack_require__(255);
	exports.Buffer = __webpack_require__(259);
	
	exports.Document = // @deprecate
	exports.Embedded = __webpack_require__(252);
	
	exports.DocumentArray = __webpack_require__(256);
	exports.ObjectId = __webpack_require__(224);
	
	exports.Subdocument = __webpack_require__(260);


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module dependencies.
	 */
	
	var Binary = __webpack_require__(129).Binary,
	    utils = __webpack_require__(223);
	
	/**
	 * Mongoose Buffer constructor.
	 *
	 * Values always have to be passed to the constructor to initialize.
	 *
	 * @param {Buffer} value
	 * @param {String} encode
	 * @param {Number} offset
	 * @api private
	 * @inherits Buffer
	 * @see http://bit.ly/f6CnZU
	 */
	
	function MongooseBuffer(value, encode, offset) {
	  var length = arguments.length;
	  var val;
	
	  if (length === 0 || arguments[0] === null || arguments[0] === undefined) {
	    val = 0;
	  } else {
	    val = value;
	  }
	
	  var encoding;
	  var path;
	  var doc;
	
	  if (Array.isArray(encode)) {
	    // internal casting
	    path = encode[0];
	    doc = encode[1];
	  } else {
	    encoding = encode;
	  }
	
	  var buf = new Buffer(val, encoding, offset);
	  utils.decorate(buf, MongooseBuffer.mixin);
	  buf.isMongooseBuffer = true;
	
	  // make sure these internal props don't show up in Object.keys()
	  Object.defineProperties(buf, {
	    validators: {value: []},
	    _path: {value: path},
	    _parent: {value: doc}
	  });
	
	  if (doc && typeof path === 'string') {
	    Object.defineProperty(buf, '_schema', {
	      value: doc.schema.path(path)
	    });
	  }
	
	  buf._subtype = 0;
	  return buf;
	}
	
	/*!
	 * Inherit from Buffer.
	 */
	
	// MongooseBuffer.prototype = new Buffer(0);
	
	MongooseBuffer.mixin = {
	
	  /**
	   * Parent owner document
	   *
	   * @api private
	   * @property _parent
	   * @receiver MongooseBuffer
	   */
	
	  _parent: undefined,
	
	  /**
	   * Default subtype for the Binary representing this Buffer
	   *
	   * @api private
	   * @property _subtype
	   * @receiver MongooseBuffer
	   */
	
	  _subtype: undefined,
	
	  /**
	   * Marks this buffer as modified.
	   *
	   * @api private
	   * @method _markModified
	   * @receiver MongooseBuffer
	   */
	
	  _markModified: function() {
	    var parent = this._parent;
	
	    if (parent) {
	      parent.markModified(this._path);
	    }
	    return this;
	  },
	
	  /**
	   * Writes the buffer.
	   *
	   * @api public
	   * @method write
	   * @receiver MongooseBuffer
	   */
	
	  write: function() {
	    var written = Buffer.prototype.write.apply(this, arguments);
	
	    if (written > 0) {
	      this._markModified();
	    }
	
	    return written;
	  },
	
	  /**
	   * Copies the buffer.
	   *
	   * ####Note:
	   *
	   * `Buffer#copy` does not mark `target` as modified so you must copy from a `MongooseBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.
	   *
	   * @return {Number} The number of bytes copied.
	   * @param {Buffer} target
	   * @method copy
	   * @receiver MongooseBuffer
	   */
	
	  copy: function(target) {
	    var ret = Buffer.prototype.copy.apply(this, arguments);
	
	    if (target && target.isMongooseBuffer) {
	      target._markModified();
	    }
	
	    return ret;
	  }
	};
	
	/*!
	 * Compile other Buffer methods marking this buffer as modified.
	 */
	
	(
	// node < 0.5
	    'writeUInt8 writeUInt16 writeUInt32 writeInt8 writeInt16 writeInt32 ' +
	    'writeFloat writeDouble fill ' +
	    'utf8Write binaryWrite asciiWrite set ' +
	
	// node >= 0.5
	    'writeUInt16LE writeUInt16BE writeUInt32LE writeUInt32BE ' +
	    'writeInt16LE writeInt16BE writeInt32LE writeInt32BE ' +
	    'writeFloatLE writeFloatBE writeDoubleLE writeDoubleBE'
	).split(' ').forEach(function(method) {
	  if (!Buffer.prototype[method]) {
	    return;
	  }
	  MongooseBuffer.mixin[method] = function() {
	    var ret = Buffer.prototype[method].apply(this, arguments);
	    this._markModified();
	    return ret;
	  };
	});
	
	/**
	 * Converts this buffer to its Binary type representation.
	 *
	 * ####SubTypes:
	 *
	 *   var bson = require('bson')
	 *   bson.BSON_BINARY_SUBTYPE_DEFAULT
	 *   bson.BSON_BINARY_SUBTYPE_FUNCTION
	 *   bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY
	 *   bson.BSON_BINARY_SUBTYPE_UUID
	 *   bson.BSON_BINARY_SUBTYPE_MD5
	 *   bson.BSON_BINARY_SUBTYPE_USER_DEFINED
	 *
	 *   doc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);
	 *
	 * @see http://bsonspec.org/#/specification
	 * @param {Hex} [subtype]
	 * @return {Binary}
	 * @api public
	 * @method toObject
	 * @receiver MongooseBuffer
	 */
	
	MongooseBuffer.mixin.toObject = function(options) {
	  var subtype = typeof options === 'number'
	      ? options
	      : (this._subtype || 0);
	  return new Binary(this, subtype);
	};
	
	/**
	 * Determines if this buffer is equals to `other` buffer
	 *
	 * @param {Buffer} other
	 * @return {Boolean}
	 * @method equals
	 * @receiver MongooseBuffer
	 */
	
	MongooseBuffer.mixin.equals = function(other) {
	  if (!Buffer.isBuffer(other)) {
	    return false;
	  }
	
	  if (this.length !== other.length) {
	    return false;
	  }
	
	  for (var i = 0; i < this.length; ++i) {
	    if (this[i] !== other[i]) {
	      return false;
	    }
	  }
	
	  return true;
	};
	
	/**
	 * Sets the subtype option and marks the buffer modified.
	 *
	 * ####SubTypes:
	 *
	 *   var bson = require('bson')
	 *   bson.BSON_BINARY_SUBTYPE_DEFAULT
	 *   bson.BSON_BINARY_SUBTYPE_FUNCTION
	 *   bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY
	 *   bson.BSON_BINARY_SUBTYPE_UUID
	 *   bson.BSON_BINARY_SUBTYPE_MD5
	 *   bson.BSON_BINARY_SUBTYPE_USER_DEFINED
	 *
	 *   doc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);
	 *
	 * @see http://bsonspec.org/#/specification
	 * @param {Hex} subtype
	 * @api public
	 * @method subtype
	 * @receiver MongooseBuffer
	 */
	
	MongooseBuffer.mixin.subtype = function(subtype) {
	  if (typeof subtype !== 'number') {
	    throw new TypeError('Invalid subtype. Expected a number');
	  }
	
	  if (this._subtype !== subtype) {
	    this._markModified();
	  }
	
	  this._subtype = subtype;
	};
	
	/*!
	 * Module exports.
	 */
	
	MongooseBuffer.Binary = Binary;
	
	module.exports = MongooseBuffer;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	var Document = __webpack_require__(229);
	var PromiseProvider = __webpack_require__(237);
	
	module.exports = Subdocument;
	
	/**
	 * Subdocument constructor.
	 *
	 * @inherits Document
	 * @api private
	 */
	
	function Subdocument(value, fields) {
	  this.$isSingleNested = true;
	  Document.call(this, value, fields);
	}
	
	Subdocument.prototype = Object.create(Document.prototype);
	
	/**
	 * Used as a stub for [hooks.js](https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3)
	 *
	 * ####NOTE:
	 *
	 * _This is a no-op. Does not actually save the doc to the db._
	 *
	 * @param {Function} [fn]
	 * @return {Promise} resolved Promise
	 * @api private
	 */
	
	Subdocument.prototype.save = function(fn) {
	  var Promise = PromiseProvider.get();
	  return new Promise.ES6(function(resolve) {
	    fn && fn();
	    resolve();
	  });
	};
	
	Subdocument.prototype.$isValid = function(path) {
	  if (this.$parent) {
	    return this.$parent.$isValid([this.$basePath, path].join('.'));
	  }
	};
	
	Subdocument.prototype.markModified = function(path) {
	  Document.prototype.markModified.call(this, path);
	  if (this.$parent) {
	    if (this.$parent.isModified(this.$basePath)) {
	      return;
	    }
	    this.$parent.markModified([this.$basePath, path].join('.'));
	  }
	};
	
	Subdocument.prototype.$markValid = function(path) {
	  if (this.$parent) {
	    this.$parent.$markValid([this.$basePath, path].join('.'));
	  }
	};
	
	Subdocument.prototype.invalidate = function(path, err, val) {
	  if (this.$parent) {
	    this.$parent.invalidate([this.$basePath, path].join('.'), err, val);
	  } else if (err.kind === 'cast' || err.name === 'CastError') {
	    throw err;
	  }
	};
	
	/**
	 * Returns the top level document of this sub-document.
	 *
	 * @return {Document}
	 */
	
	Subdocument.prototype.ownerDocument = function() {
	  if (this.$__.ownerDocument) {
	    return this.$__.ownerDocument;
	  }
	
	  var parent = this.$parent;
	  if (!parent) {
	    return this;
	  }
	
	  while (parent.$parent || parent.__parent) {
	    parent = parent.$parent || parent.__parent;
	  }
	  this.$__.ownerDocument = parent;
	  return this.$__.ownerDocument;
	};
	
	/**
	 * Null-out this subdoc
	 *
	 * @param {Object} [options]
	 * @param {Function} [callback] optional callback for compatibility with Document.prototype.remove
	 */
	
	Subdocument.prototype.remove = function(options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = null;
	  }
	
	  this.$parent.set(this.$basePath, null);
	  registerRemoveListener(this);
	  if (typeof callback === 'function') {
	    callback(null);
	  }
	};
	
	/*!
	 * Registers remove event listeners for triggering
	 * on subdocuments.
	 *
	 * @param {EmbeddedDocument} sub
	 * @api private
	 */
	
	function registerRemoveListener(sub) {
	  var owner = sub.ownerDocument();
	
	  function emitRemove() {
	    owner.removeListener('save', emitRemove);
	    owner.removeListener('remove', emitRemove);
	    sub.emit('remove', sub);
	    owner = sub = null;
	  }
	
	  owner.on('save', emitRemove);
	  owner.on('remove', emitRemove);
	}


/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseConnection = __webpack_require__(262);
	var mongo = __webpack_require__(155);
	var Db = mongo.Db;
	var Server = mongo.Server;
	var Mongos = mongo.Mongos;
	var STATES = __webpack_require__(222);
	var ReplSetServers = mongo.ReplSet;
	var DisconnectedError = __webpack_require__(266);
	
	/**
	 * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.
	 *
	 * @inherits Connection
	 * @api private
	 */
	
	function NativeConnection() {
	  MongooseConnection.apply(this, arguments);
	  this._listening = false;
	}
	
	/**
	 * Expose the possible connection states.
	 * @api public
	 */
	
	NativeConnection.STATES = STATES;
	
	/*!
	 * Inherits from Connection.
	 */
	
	NativeConnection.prototype.__proto__ = MongooseConnection.prototype;
	
	/**
	 * Opens the connection to MongoDB.
	 *
	 * @param {Function} fn
	 * @return {Connection} this
	 * @api private
	 */
	
	NativeConnection.prototype.doOpen = function(fn) {
	  var _this = this;
	  var server = new Server(this.host, this.port, this.options.server);
	
	  if (this.options && this.options.mongos) {
	    var mongos = new Mongos([server], this.options.mongos);
	    this.db = new Db(this.name, mongos, this.options.db);
	  } else {
	    this.db = new Db(this.name, server, this.options.db);
	  }
	
	  this.db.open(function(err) {
	    listen(_this);
	
	    if (!mongos) {
	      server.s.server.on('error', function(error) {
	        if (/after \d+ retries/.test(error.message)) {
	          _this.emit('error', new DisconnectedError(server.s.server.name));
	        }
	      });
	    }
	
	    if (err) return fn(err);
	
	    fn();
	  });
	
	  return this;
	};
	
	/**
	 * Switches to a different database using the same connection pool.
	 *
	 * Returns a new connection object, with the new db.
	 *
	 * @param {String} name The database name
	 * @return {Connection} New Connection Object
	 * @api public
	 */
	
	NativeConnection.prototype.useDb = function(name) {
	  // we have to manually copy all of the attributes...
	  var newConn = new this.constructor();
	  newConn.name = name;
	  newConn.base = this.base;
	  newConn.collections = {};
	  newConn.models = {};
	  newConn.replica = this.replica;
	  newConn.hosts = this.hosts;
	  newConn.host = this.host;
	  newConn.port = this.port;
	  newConn.user = this.user;
	  newConn.pass = this.pass;
	  newConn.options = this.options;
	  newConn._readyState = this._readyState;
	  newConn._closeCalled = this._closeCalled;
	  newConn._hasOpened = this._hasOpened;
	  newConn._listening = false;
	
	  // First, when we create another db object, we are not guaranteed to have a
	  // db object to work with. So, in the case where we have a db object and it
	  // is connected, we can just proceed with setting everything up. However, if
	  // we do not have a db or the state is not connected, then we need to wait on
	  // the 'open' event of the connection before doing the rest of the setup
	  // the 'connected' event is the first time we'll have access to the db object
	
	  var _this = this;
	
	  if (this.db && this._readyState === STATES.connected) {
	    wireup();
	  } else {
	    this.once('connected', wireup);
	  }
	
	  function wireup() {
	    newConn.db = _this.db.db(name);
	    newConn.onOpen();
	    // setup the events appropriately
	    listen(newConn);
	  }
	
	  newConn.name = name;
	
	  // push onto the otherDbs stack, this is used when state changes
	  this.otherDbs.push(newConn);
	  newConn.otherDbs.push(this);
	
	  return newConn;
	};
	
	/*!
	 * Register listeners for important events and bubble appropriately.
	 */
	
	function listen(conn) {
	  if (conn.db._listening) {
	    return;
	  }
	  conn.db._listening = true;
	
	  conn.db.on('close', function() {
	    if (conn._closeCalled) return;
	
	    // the driver never emits an `open` event. auto_reconnect still
	    // emits a `close` event but since we never get another
	    // `open` we can't emit close
	    if (conn.db.serverConfig.autoReconnect) {
	      conn.readyState = STATES.disconnected;
	      conn.emit('close');
	      return;
	    }
	    conn.onClose();
	  });
	  conn.db.on('error', function(err) {
	    conn.emit('error', err);
	  });
	  conn.db.on('reconnect', function() {
	    conn.readyState = STATES.connected;
	    conn.emit('reconnected');
	  });
	  conn.db.on('timeout', function(err) {
	    var error = new Error(err && err.err || 'connection timeout');
	    conn.emit('error', error);
	  });
	  conn.db.on('open', function(err, db) {
	    if (STATES.disconnected === conn.readyState && db && db.databaseName) {
	      conn.readyState = STATES.connected;
	      conn.emit('reconnected');
	    }
	  });
	  conn.db.on('parseError', function(err) {
	    conn.emit('parseError', err);
	  });
	}
	
	/**
	 * Opens a connection to a MongoDB ReplicaSet.
	 *
	 * See description of [doOpen](#NativeConnection-doOpen) for server options. In this case `options.replset` is also passed to ReplSetServers.
	 *
	 * @param {Function} fn
	 * @api private
	 * @return {Connection} this
	 */
	
	NativeConnection.prototype.doOpenSet = function(fn) {
	  var servers = [],
	      _this = this;
	
	  this.hosts.forEach(function(server) {
	    var host = server.host || server.ipc;
	    var port = server.port || 27017;
	    servers.push(new Server(host, port, _this.options.server));
	  });
	
	  var server = this.options.mongos
	    ? new Mongos(servers, this.options.mongos)
	    : new ReplSetServers(servers, this.options.replset || this.options.replSet);
	  this.db = new Db(this.name, server, this.options.db);
	
	  this.db.on('fullsetup', function() {
	    _this.emit('fullsetup');
	  });
	
	  this.db.on('all', function() {
	    _this.emit('all');
	  });
	
	  this.db.open(function(err) {
	    if (err) return fn(err);
	    fn();
	    listen(_this);
	  });
	
	  return this;
	};
	
	/**
	 * Closes the connection
	 *
	 * @param {Function} fn
	 * @return {Connection} this
	 * @api private
	 */
	
	NativeConnection.prototype.doClose = function(fn) {
	  this.db.close(fn);
	  return this;
	};
	
	/**
	 * Prepares default connection options for the node-mongodb-native driver.
	 *
	 * _NOTE: `passed` options take precedence over connection string options._
	 *
	 * @param {Object} passed options that were passed directly during connection
	 * @param {Object} [connStrOptions] options that were passed in the connection string
	 * @api private
	 */
	
	NativeConnection.prototype.parseOptions = function(passed, connStrOpts) {
	  var o = passed || {};
	  o.db || (o.db = {});
	  o.auth || (o.auth = {});
	  o.server || (o.server = {});
	  o.replset || (o.replset = o.replSet) || (o.replset = {});
	  o.server.socketOptions || (o.server.socketOptions = {});
	  o.replset.socketOptions || (o.replset.socketOptions = {});
	  o.mongos || (o.mongos = (connStrOpts && connStrOpts.mongos));
	  (o.mongos === true) && (o.mongos = {});
	
	  var opts = connStrOpts || {};
	  Object.keys(opts).forEach(function(name) {
	    switch (name) {
	      case 'ssl':
	        o.server.ssl = opts.ssl;
	        o.replset.ssl = opts.ssl;
	        o.mongos && (o.mongos.ssl = opts.ssl);
	        break;
	      case 'poolSize':
	        if (typeof o.server[name] === 'undefined') {
	          o.server[name] = o.replset[name] = opts[name];
	        }
	        break;
	      case 'slaveOk':
	        if (typeof o.server.slave_ok === 'undefined') {
	          o.server.slave_ok = opts[name];
	        }
	        break;
	      case 'autoReconnect':
	        if (typeof o.server.auto_reconnect === 'undefined') {
	          o.server.auto_reconnect = opts[name];
	        }
	        break;
	      case 'socketTimeoutMS':
	      case 'connectTimeoutMS':
	        if (typeof o.server.socketOptions[name] === 'undefined') {
	          o.server.socketOptions[name] = o.replset.socketOptions[name] = opts[name];
	        }
	        break;
	      case 'authdb':
	        if (typeof o.auth.authdb === 'undefined') {
	          o.auth.authdb = opts[name];
	        }
	        break;
	      case 'authSource':
	        if (typeof o.auth.authSource === 'undefined') {
	          o.auth.authSource = opts[name];
	        }
	        break;
	      case 'retries':
	      case 'reconnectWait':
	      case 'rs_name':
	        if (typeof o.replset[name] === 'undefined') {
	          o.replset[name] = opts[name];
	        }
	        break;
	      case 'replicaSet':
	        if (typeof o.replset.rs_name === 'undefined') {
	          o.replset.rs_name = opts[name];
	        }
	        break;
	      case 'readSecondary':
	        if (typeof o.replset.read_secondary === 'undefined') {
	          o.replset.read_secondary = opts[name];
	        }
	        break;
	      case 'nativeParser':
	        if (typeof o.db.native_parser === 'undefined') {
	          o.db.native_parser = opts[name];
	        }
	        break;
	      case 'w':
	      case 'safe':
	      case 'fsync':
	      case 'journal':
	      case 'wtimeoutMS':
	        if (typeof o.db[name] === 'undefined') {
	          o.db[name] = opts[name];
	        }
	        break;
	      case 'readPreference':
	        if (typeof o.db.readPreference === 'undefined') {
	          o.db.readPreference = opts[name];
	        }
	        break;
	      case 'readPreferenceTags':
	        if (typeof o.db.read_preference_tags === 'undefined') {
	          o.db.read_preference_tags = opts[name];
	        }
	        break;
	      case 'sslValidate':
	        o.server.sslValidate = opts.sslValidate;
	        o.replset.sslValidate = opts.sslValidate;
	        o.mongos && (o.mongos.sslValidate = opts.sslValidate);
	    }
	  });
	
	  if (!('auto_reconnect' in o.server)) {
	    o.server.auto_reconnect = true;
	  }
	
	  // mongoose creates its own ObjectIds
	  o.db.forceServerObjectId = false;
	
	  // default safe using new nomenclature
	  if (!('journal' in o.db || 'j' in o.db ||
	        'fsync' in o.db || 'safe' in o.db || 'w' in o.db)) {
	    o.db.w = 1;
	  }
	
	  if (o.promiseLibrary) {
	    o.db.promiseLibrary = o.promiseLibrary;
	  }
	
	  validate(o);
	  return o;
	};
	
	/*!
	 * Validates the driver db options.
	 *
	 * @param {Object} o
	 */
	
	function validate(o) {
	  if (o.db.w === -1 || o.db.w === 0) {
	    if (o.db.journal || o.db.fsync || o.db.safe) {
	      throw new Error(
	          'Invalid writeConcern: '
	        + 'w set to -1 or 0 cannot be combined with safe|fsync|journal');
	    }
	  }
	}
	
	/*!
	 * Module exports.
	 */
	
	module.exports = NativeConnection;


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * Module dependencies.
	 */
	
	var utils = __webpack_require__(223);
	var EventEmitter = __webpack_require__(3).EventEmitter;
	var driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native';
	var Schema = __webpack_require__(128);
	var Collection = __webpack_require__(263)(driver + '/collection');
	var STATES = __webpack_require__(222);
	var MongooseError = __webpack_require__(119);
	var muri = __webpack_require__(264);
	var PromiseProvider = __webpack_require__(237);
	
	/*!
	 * Protocol prefix regexp.
	 *
	 * @api private
	 */
	
	var rgxProtocol = /^(?:.)+:\/\//;
	
	/*!
	 * A list of authentication mechanisms that don't require a password for authentication.
	 * This is used by the authMechanismDoesNotRequirePassword method.
	 *
	 * @api private
	 */
	var authMechanismsWhichDontRequirePassword = [
	  'MONGODB-X509'
	];
	
	/**
	 * Connection constructor
	 *
	 * For practical reasons, a Connection equals a Db.
	 *
	 * @param {Mongoose} base a mongoose instance
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `connecting`: Emitted when `connection.{open,openSet}()` is executed on this connection.
	 * @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected` scenarios.
	 * @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connections models.
	 * @event `disconnecting`: Emitted when `connection.close()` was executed.
	 * @event `disconnected`: Emitted after getting disconnected from the db.
	 * @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connections models.
	 * @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successfull connection.
	 * @event `error`: Emitted when an error occurs on this connection.
	 * @event `fullsetup`: Emitted in a replica-set scenario, when primary and at least one seconaries specified in the connection string are connected.
	 * @event `all`: Emitted in a replica-set scenario, when all nodes specified in the connection string are connected.
	 * @api public
	 */
	
	function Connection(base) {
	  this.base = base;
	  this.collections = {};
	  this.models = {};
	  this.config = {autoIndex: true};
	  this.replica = false;
	  this.hosts = null;
	  this.host = null;
	  this.port = null;
	  this.user = null;
	  this.pass = null;
	  this.name = null;
	  this.options = null;
	  this.otherDbs = [];
	  this._readyState = STATES.disconnected;
	  this._closeCalled = false;
	  this._hasOpened = false;
	}
	
	/*!
	 * Inherit from EventEmitter
	 */
	
	Connection.prototype.__proto__ = EventEmitter.prototype;
	
	/**
	 * Connection ready state
	 *
	 * - 0 = disconnected
	 * - 1 = connected
	 * - 2 = connecting
	 * - 3 = disconnecting
	 *
	 * Each state change emits its associated event name.
	 *
	 * ####Example
	 *
	 *     conn.on('connected', callback);
	 *     conn.on('disconnected', callback);
	 *
	 * @property readyState
	 * @api public
	 */
	
	Object.defineProperty(Connection.prototype, 'readyState', {
	  get: function() {
	    return this._readyState;
	  },
	  set: function(val) {
	    if (!(val in STATES)) {
	      throw new Error('Invalid connection state: ' + val);
	    }
	
	    if (this._readyState !== val) {
	      this._readyState = val;
	      // loop over the otherDbs on this connection and change their state
	      for (var i = 0; i < this.otherDbs.length; i++) {
	        this.otherDbs[i].readyState = val;
	      }
	
	      if (STATES.connected === val) {
	        this._hasOpened = true;
	      }
	
	      this.emit(STATES[val]);
	    }
	  }
	});
	
	/**
	 * A hash of the collections associated with this connection
	 *
	 * @property collections
	 */
	
	Connection.prototype.collections;
	
	/**
	 * The mongodb.Db instance, set when the connection is opened
	 *
	 * @property db
	 */
	
	Connection.prototype.db;
	
	/**
	 * A hash of the global options that are associated with this connection
	 *
	 * @property config
	 */
	
	Connection.prototype.config;
	
	/**
	 * Opens the connection to MongoDB.
	 *
	 * `options` is a hash with the following possible properties:
	 *
	 *     config  - passed to the connection config instance
	 *     db      - passed to the connection db instance
	 *     server  - passed to the connection server instance(s)
	 *     replset - passed to the connection ReplSet instance
	 *     user    - username for authentication
	 *     pass    - password for authentication
	 *     auth    - options for authentication (see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate)
	 *
	 * ####Notes:
	 *
	 * Mongoose forces the db option `forceServerObjectId` false and cannot be overridden.
	 * Mongoose defaults the server `auto_reconnect` options to true which can be overridden.
	 * See the node-mongodb-native driver instance for options that it understands.
	 *
	 * _Options passed take precedence over options included in connection strings._
	 *
	 * @param {String} connection_string mongodb://uri or the host to which you are connecting
	 * @param {String} [database] database name
	 * @param {Number} [port] database port
	 * @param {Object} [options] options
	 * @param {Function} [callback]
	 * @see node-mongodb-native https://github.com/mongodb/node-mongodb-native
	 * @see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate
	 * @api public
	 */
	
	Connection.prototype.open = function(host, database, port, options, callback) {
	  var parsed;
	
	  if (typeof database === 'string') {
	    switch (arguments.length) {
	      case 2:
	        port = 27017;
	        break;
	      case 3:
	        switch (typeof port) {
	          case 'function':
	            callback = port;
	            port = 27017;
	            break;
	          case 'object':
	            options = port;
	            port = 27017;
	            break;
	        }
	        break;
	      case 4:
	        if (typeof options === 'function') {
	          callback = options;
	          options = {};
	        }
	    }
	  } else {
	    switch (typeof database) {
	      case 'function':
	        callback = database;
	        database = undefined;
	        break;
	      case 'object':
	        options = database;
	        database = undefined;
	        callback = port;
	        break;
	    }
	
	    if (!rgxProtocol.test(host)) {
	      host = 'mongodb://' + host;
	    }
	
	    try {
	      parsed = muri(host);
	    } catch (err) {
	      this.error(err, callback);
	      return this;
	    }
	
	    database = parsed.db;
	    host = parsed.hosts[0].host || parsed.hosts[0].ipc;
	    port = parsed.hosts[0].port || 27017;
	  }
	
	  this.options = this.parseOptions(options, parsed && parsed.options);
	
	  // make sure we can open
	  if (STATES.disconnected !== this.readyState) {
	    var err = new Error('Trying to open unclosed connection.');
	    err.state = this.readyState;
	    this.error(err, callback);
	    return this;
	  }
	
	  if (!host) {
	    this.error(new Error('Missing hostname.'), callback);
	    return this;
	  }
	
	  if (!database) {
	    this.error(new Error('Missing database name.'), callback);
	    return this;
	  }
	
	  // authentication
	  if (this.optionsProvideAuthenticationData(options)) {
	    this.user = options.user;
	    this.pass = options.pass;
	  } else if (parsed && parsed.auth) {
	    this.user = parsed.auth.user;
	    this.pass = parsed.auth.pass;
	
	    // Check hostname for user/pass
	  } else if (/@/.test(host) && /:/.test(host.split('@')[0])) {
	    host = host.split('@');
	    var auth = host.shift().split(':');
	    host = host.pop();
	    this.user = auth[0];
	    this.pass = auth[1];
	  } else {
	    this.user = this.pass = undefined;
	  }
	
	  // global configuration options
	  if (options && options.config) {
	    this.config.autoIndex = options.config.autoIndex !== false;
	  }
	
	  this.name = database;
	  this.host = host;
	  this.port = port;
	
	  var _this = this;
	  var Promise = PromiseProvider.get();
	  var promise = new Promise.ES6(function(resolve, reject) {
	    _this._open(true, function(error) {
	      callback && callback(error);
	      if (error) {
	        reject(error);
	        if (!callback && !promise.$hasHandler) {
	          _this.emit('error', error);
	        }
	        return;
	      }
	      resolve();
	    });
	  });
	  return promise;
	};
	
	/**
	 * Opens the connection to a replica set.
	 *
	 * ####Example:
	 *
	 *     var db = mongoose.createConnection();
	 *     db.openSet("mongodb://user:pwd@localhost:27020/testing,mongodb://example.com:27020,mongodb://localhost:27019");
	 *
	 * The database name and/or auth need only be included in one URI.
	 * The `options` is a hash which is passed to the internal driver connection object.
	 *
	 * Valid `options`
	 *
	 *     db      - passed to the connection db instance
	 *     server  - passed to the connection server instance(s)
	 *     replset - passed to the connection ReplSetServer instance
	 *     user    - username for authentication
	 *     pass    - password for authentication
	 *     auth    - options for authentication (see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate)
	 *     mongos  - Boolean - if true, enables High Availability support for mongos
	 *
	 * _Options passed take precedence over options included in connection strings._
	 *
	 * ####Notes:
	 *
	 * _If connecting to multiple mongos servers, set the `mongos` option to true._
	 *
	 *     conn.open('mongodb://mongosA:27501,mongosB:27501', { mongos: true }, cb);
	 *
	 * Mongoose forces the db option `forceServerObjectId` false and cannot be overridden.
	 * Mongoose defaults the server `auto_reconnect` options to true which can be overridden.
	 * See the node-mongodb-native driver instance for options that it understands.
	 *
	 * _Options passed take precedence over options included in connection strings._
	 *
	 * @param {String} uris comma-separated mongodb:// `URI`s
	 * @param {String} [database] database name if not included in `uris`
	 * @param {Object} [options] passed to the internal driver
	 * @param {Function} [callback]
	 * @see node-mongodb-native https://github.com/mongodb/node-mongodb-native
	 * @see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate
	 * @api public
	 */
	
	Connection.prototype.openSet = function(uris, database, options, callback) {
	  if (!rgxProtocol.test(uris)) {
	    uris = 'mongodb://' + uris;
	  }
	
	  switch (arguments.length) {
	    case 3:
	      switch (typeof database) {
	        case 'string':
	          this.name = database;
	          break;
	        case 'object':
	          callback = options;
	          options = database;
	          database = null;
	          break;
	      }
	
	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }
	      break;
	    case 2:
	      switch (typeof database) {
	        case 'string':
	          this.name = database;
	          break;
	        case 'function':
	          callback = database;
	          database = null;
	          break;
	        case 'object':
	          options = database;
	          database = null;
	          break;
	      }
	  }
	
	  var parsed;
	  try {
	    parsed = muri(uris);
	  } catch (err) {
	    this.error(err, callback);
	    return this;
	  }
	
	  if (!this.name) {
	    this.name = parsed.db;
	  }
	
	  this.hosts = parsed.hosts;
	  this.options = this.parseOptions(options, parsed && parsed.options);
	  this.replica = true;
	
	  if (!this.name) {
	    this.error(new Error('No database name provided for replica set'), callback);
	    return this;
	  }
	
	  // authentication
	  if (this.optionsProvideAuthenticationData(options)) {
	    this.user = options.user;
	    this.pass = options.pass;
	  } else if (parsed && parsed.auth) {
	    this.user = parsed.auth.user;
	    this.pass = parsed.auth.pass;
	  } else {
	    this.user = this.pass = undefined;
	  }
	
	  // global configuration options
	  if (options && options.config) {
	    this.config.autoIndex = options.config.autoIndex !== false;
	  }
	
	  var _this = this;
	  var Promise = PromiseProvider.get();
	  var promise = new Promise.ES6(function(resolve, reject) {
	    _this._open(true, function(error) {
	      callback && callback(error);
	      if (error) {
	        reject(error);
	        if (!callback && !promise.$hasHandler) {
	          _this.emit('error', error);
	        }
	        return;
	      }
	      resolve();
	    });
	  });
	  return promise;
	};
	
	/**
	 * error
	 *
	 * Graceful error handling, passes error to callback
	 * if available, else emits error on the connection.
	 *
	 * @param {Error} err
	 * @param {Function} callback optional
	 * @api private
	 */
	
	Connection.prototype.error = function(err, callback) {
	  if (callback) {
	    return callback(err);
	  }
	  this.emit('error', err);
	};
	
	/**
	 * Handles opening the connection with the appropriate method based on connection type.
	 *
	 * @param {Function} callback
	 * @api private
	 */
	
	Connection.prototype._open = function(emit, callback) {
	  this.readyState = STATES.connecting;
	  this._closeCalled = false;
	
	  var _this = this;
	
	  var method = this.replica
	      ? 'doOpenSet'
	      : 'doOpen';
	
	  // open connection
	  this[method](function(err) {
	    if (err) {
	      _this.readyState = STATES.disconnected;
	      if (_this._hasOpened) {
	        if (callback) {
	          callback(err);
	        }
	      } else {
	        _this.error(err, emit && callback);
	      }
	      return;
	    }
	
	    _this.onOpen(callback);
	  });
	};
	
	/**
	 * Called when the connection is opened
	 *
	 * @api private
	 */
	
	Connection.prototype.onOpen = function(callback) {
	  var _this = this;
	
	  function open(err, isAuth) {
	    if (err) {
	      _this.readyState = isAuth ? STATES.unauthorized : STATES.disconnected;
	      _this.error(err, callback);
	      return;
	    }
	
	    _this.readyState = STATES.connected;
	
	    // avoid having the collection subscribe to our event emitter
	    // to prevent 0.3 warning
	    for (var i in _this.collections) {
	      if (utils.object.hasOwnProperty(_this.collections, i)) {
	        _this.collections[i].onOpen();
	      }
	    }
	
	    callback && callback();
	    _this.emit('open');
	  }
	
	  // re-authenticate if we're not already connected #3871
	  if (this._readyState !== STATES.connected && this.shouldAuthenticate()) {
	    _this.db.authenticate(_this.user, _this.pass, _this.options.auth, function(err) {
	      open(err, true);
	    });
	  } else {
	    open();
	  }
	};
	
	/**
	 * Closes the connection
	 *
	 * @param {Function} [callback] optional
	 * @return {Connection} self
	 * @api public
	 */
	
	Connection.prototype.close = function(callback) {
	  var _this = this;
	  var Promise = PromiseProvider.get();
	  return new Promise.ES6(function(resolve, reject) {
	    _this._close(function(error) {
	      callback && callback(error);
	      if (error) {
	        reject(error);
	        return;
	      }
	      resolve();
	    });
	  });
	};
	
	/**
	 * Handles closing the connection
	 *
	 * @param {Function} callback
	 * @api private
	 */
	Connection.prototype._close = function(callback) {
	  var _this = this;
	  this._closeCalled = true;
	
	  switch (this.readyState) {
	    case 0: // disconnected
	      callback && callback();
	      break;
	
	    case 1: // connected
	    case 4: // unauthorized
	      this.readyState = STATES.disconnecting;
	      this.doClose(function(err) {
	        if (err) {
	          _this.error(err, callback);
	        } else {
	          _this.onClose();
	          callback && callback();
	        }
	      });
	      break;
	
	    case 2: // connecting
	      this.once('open', function() {
	        _this.close(callback);
	      });
	      break;
	
	    case 3: // disconnecting
	      if (!callback) {
	        break;
	      }
	      this.once('close', function() {
	        callback();
	      });
	      break;
	  }
	
	  return this;
	};
	
	/**
	 * Called when the connection closes
	 *
	 * @api private
	 */
	
	Connection.prototype.onClose = function() {
	  this.readyState = STATES.disconnected;
	
	  // avoid having the collection subscribe to our event emitter
	  // to prevent 0.3 warning
	  for (var i in this.collections) {
	    if (utils.object.hasOwnProperty(this.collections, i)) {
	      this.collections[i].onClose();
	    }
	  }
	
	  this.emit('close');
	};
	
	/**
	 * Retrieves a collection, creating it if not cached.
	 *
	 * Not typically needed by applications. Just talk to your collection through your model.
	 *
	 * @param {String} name of the collection
	 * @param {Object} [options] optional collection options
	 * @return {Collection} collection instance
	 * @api public
	 */
	
	Connection.prototype.collection = function(name, options) {
	  if (!(name in this.collections)) {
	    this.collections[name] = new Collection(name, this, options);
	  }
	  return this.collections[name];
	};
	
	/**
	 * Defines or retrieves a model.
	 *
	 *     var mongoose = require('mongoose');
	 *     var db = mongoose.createConnection(..);
	 *     db.model('Venue', new Schema(..));
	 *     var Ticket = db.model('Ticket', new Schema(..));
	 *     var Venue = db.model('Venue');
	 *
	 * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the [utils.toCollectionName](#utils_exports.toCollectionName) method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._
	 *
	 * ####Example:
	 *
	 *     var schema = new Schema({ name: String }, { collection: 'actor' });
	 *
	 *     // or
	 *
	 *     schema.set('collection', 'actor');
	 *
	 *     // or
	 *
	 *     var collectionName = 'actor'
	 *     var M = conn.model('Actor', schema, collectionName)
	 *
	 * @param {String} name the model name
	 * @param {Schema} [schema] a schema. necessary when defining a model
	 * @param {String} [collection] name of mongodb collection (optional) if not given it will be induced from model name
	 * @see Mongoose#model #index_Mongoose-model
	 * @return {Model} The compiled model
	 * @api public
	 */
	
	Connection.prototype.model = function(name, schema, collection) {
	  // collection name discovery
	  if (typeof schema === 'string') {
	    collection = schema;
	    schema = false;
	  }
	
	  if (utils.isObject(schema) && !schema.instanceOfSchema) {
	    schema = new Schema(schema);
	  }
	
	  if (this.models[name] && !collection) {
	    // model exists but we are not subclassing with custom collection
	    if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {
	      throw new MongooseError.OverwriteModelError(name);
	    }
	    return this.models[name];
	  }
	
	  var opts = {cache: false, connection: this};
	  var model;
	
	  if (schema && schema.instanceOfSchema) {
	    // compile a model
	    model = this.base.model(name, schema, collection, opts);
	
	    // only the first model with this name is cached to allow
	    // for one-offs with custom collection names etc.
	    if (!this.models[name]) {
	      this.models[name] = model;
	    }
	
	    model.init();
	    return model;
	  }
	
	  if (this.models[name] && collection) {
	    // subclassing current model with alternate collection
	    model = this.models[name];
	    schema = model.prototype.schema;
	    var sub = model.__subclass(this, schema, collection);
	    // do not cache the sub model
	    return sub;
	  }
	
	  // lookup model in mongoose module
	  model = this.base.models[name];
	
	  if (!model) {
	    throw new MongooseError.MissingSchemaError(name);
	  }
	
	  if (this === model.prototype.db
	      && (!collection || collection === model.collection.name)) {
	    // model already uses this connection.
	
	    // only the first model with this name is cached to allow
	    // for one-offs with custom collection names etc.
	    if (!this.models[name]) {
	      this.models[name] = model;
	    }
	
	    return model;
	  }
	  this.models[name] = model.__subclass(this, schema, collection);
	  return this.models[name];
	};
	
	/**
	 * Returns an array of model names created on this connection.
	 * @api public
	 * @return {Array}
	 */
	
	Connection.prototype.modelNames = function() {
	  return Object.keys(this.models);
	};
	
	/**
	 * @brief Returns if the connection requires authentication after it is opened. Generally if a
	 * username and password are both provided than authentication is needed, but in some cases a
	 * password is not required.
	 * @api private
	 * @return {Boolean} true if the connection should be authenticated after it is opened, otherwise false.
	 */
	Connection.prototype.shouldAuthenticate = function() {
	  return (this.user !== null && this.user !== void 0) &&
	      ((this.pass !== null || this.pass !== void 0) || this.authMechanismDoesNotRequirePassword());
	};
	
	/**
	 * @brief Returns a boolean value that specifies if the current authentication mechanism needs a
	 * password to authenticate according to the auth objects passed into the open/openSet methods.
	 * @api private
	 * @return {Boolean} true if the authentication mechanism specified in the options object requires
	 *  a password, otherwise false.
	 */
	Connection.prototype.authMechanismDoesNotRequirePassword = function() {
	  if (this.options && this.options.auth) {
	    return authMechanismsWhichDontRequirePassword.indexOf(this.options.auth.authMechanism) >= 0;
	  }
	  return true;
	};
	
	/**
	 * @brief Returns a boolean value that specifies if the provided objects object provides enough
	 * data to authenticate with. Generally this is true if the username and password are both specified
	 * but in some authentication methods, a password is not required for authentication so only a username
	 * is required.
	 * @param {Object} [options] the options object passed into the open/openSet methods.
	 * @api private
	 * @return {Boolean} true if the provided options object provides enough data to authenticate with,
	 *   otherwise false.
	 */
	Connection.prototype.optionsProvideAuthenticationData = function(options) {
	  return (options) &&
	      (options.user) &&
	      ((options.pass) || this.authMechanismDoesNotRequirePassword());
	};
	
	/*!
	 * Module exports.
	 */
	
	Connection.STATES = STATES;
	module.exports = Connection;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./collection": 221,
		"./drivers/node-mongodb-native/collection": 220
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 263;


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = exports = __webpack_require__(265);


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {// muri
	
	/**
	 * MongoDB URI parser as described here:
	 * http://www.mongodb.org/display/DOCS/Connections
	 */
	
	/**
	 * Module dependencies
	 */
	
	var qs = __webpack_require__(35);
	
	/**
	 * Defaults
	 */
	
	var DEFAULT_PORT = 27017;
	var DEFAULT_DB = 'test';
	var ADMIN_DB = 'admin';
	
	/**
	 * Muri
	 */
	
	module.exports = exports = function muri (str) {
	  if (!/^mongodb:\/\//.test(str)) {
	    throw new Error('Invalid mongodb uri. Must begin with "mongodb://"'
	                  + '\n  Received: ' + str);
	  }
	
	  var ret = {
	      hosts: []
	    , db: DEFAULT_DB
	    , options: {}
	  }
	
	  var match = /^mongodb:\/\/([^?]+)(\??.*)$/.exec(str);
	  if (!match || '/' == match[1]) {
	    throw new Error('Invalid mongodb uri. Missing hostname');
	  }
	
	  var uris = match[1];
	  var path = match[2];
	  var db;
	
	  uris.split(',').forEach(function (uri) {
	    var o = parse(uri);
	
	    if (o.host) {
	      ret.hosts.push({
	          host: o.host
	        , port: parseInt(o.port, 10)
	      })
	
	      if (!db && o.db) {
	        db = o.db;
	      }
	    } else if (o.ipc) {
	      ret.hosts.push({ ipc: o.ipc });
	    }
	
	    if (o.auth) {
	      ret.auth = {
	          user: o.auth.user
	        , pass: o.auth.pass
	      }
	    }
	  })
	
	  if (!ret.hosts.length) {
	    throw new Error('Invalid mongodb uri. Missing hostname');
	  }
	
	  var parts = path.split('?');
	
	  if (!db) {
	    if (parts[0]) {
	      db = parts[0].replace(/^\//, '');
	    } else {
	      // deal with ipc formats
	      db = /\/([^\.]+)$/.exec(match[1]);
	      if (db && db[1]) {
	        db = db[1];
	      }
	    }
	  }
	
	  if (db) {
	    ret.db = db;
	  } else if (ret.auth) {
	    ret.db = ADMIN_DB;
	  }
	
	  if (parts[1]) {
	    ret.options = options(parts[1]);
	  }
	
	  return ret;
	}
	
	/**
	 * Parse str into key/val pairs casting values appropriately.
	 */
	
	function options (str) {
	  var sep = /;/.test(str)
	    ? ';'
	    : '&';
	
	  var ret = qs.parse(str, sep);
	
	  Object.keys(ret).forEach(function (key) {
	    var val = ret[key];
	    if ('readPreferenceTags' == key) {
	      val = readPref(val);
	      if (val) {
	        ret[key] = Array.isArray(val)
	          ? val
	          : [val];
	      }
	    } else {
	      ret[key] = format(val);
	    }
	  });
	
	  return ret;
	}
	
	function format (val) {
	  var num;
	
	  if ('true' == val) {
	    return true;
	  } else if ('false' == val) {
	    return false;
	  } else {
	    num = parseInt(val, 10);
	    if (!isNaN(num)) {
	      return num;
	    }
	  }
	
	  return val;
	}
	
	function readPref (val) {
	  var ret;
	
	  if (Array.isArray(val)) {
	    ret = val.map(readPref).filter(Boolean);
	    return ret.length
	      ? ret
	      : undefined
	  }
	
	  var pair = val.split(',');
	  var hasKeys;
	  ret = {};
	
	  pair.forEach(function (kv) {
	    kv = (kv || '').trim();
	    if (!kv) return;
	    hasKeys = true;
	    var split = kv.split(':');
	    ret[split[0]] = format(split[1]);
	  });
	
	  return hasKeys && ret;
	}
	
	var ipcRgx = /\.sock/;
	
	function parse (uriString) {
	  // do not use require('url').parse b/c it can't handle # in username or pwd
	  // mongo uris are strange
	
	  var uri = uriString;
	  var ret = {};
	  var parts;
	  var auth;
	  var ipcs;
	
	  // skip protocol
	  uri = uri.replace(/^mongodb:\/\//, '');
	
	  // auth
	  if (/@/.test(uri)) {
	    parts = uri.split(/@/);
	    auth = parts[0];
	    uri = parts[1];
	
	    parts = auth.split(':');
	    ret.auth = {};
	    ret.auth.user = parts[0];
	    ret.auth.pass = parts[1];
	  }
	
	  // unix domain sockets
	  if (ipcRgx.test(uri)) {
	    ipcs = uri.split(ipcRgx);
	    ret.ipc = ipcs[0] + '.sock';
	
	    // included a database?
	    if (ipcs[1]) {
	      // strip leading / from database name
	      ipcs[1] = ipcs[1].replace(/^\//, '');
	
	      if (ipcs[1]) {
	        ret.db = ipcs[1];
	      }
	    }
	
	    return ret;
	  }
	
	  // database name
	  parts = uri.split('/');
	  if (parts[1]) ret.db = parts[1];
	
	  // ipv6, [ip]:host
	  if (/^\[[^\]]+\]:\d+/.test(parts[0])) {
	    ret.host = parts[0].substring(1, parts[0].indexOf(']:'));
	    ret.port = parts[0].substring(parts[0].indexOf(']:') + ']:'.length);
	  } else {
	    // host:port
	    parts = parts[0].split(':');
	    ret.host = parts[0];
	    ret.port = parts[1] || DEFAULT_PORT;
	  }
	
	  return ret;
	}
	
	/**
	 * Version
	 */
	
	module.exports.version = JSON.parse(
	  __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).readFileSync(__dirname + '/../package.json', 'utf8')
	).version;
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(119);
	
	/**
	 * Casting Error constructor.
	 *
	 * @param {String} type
	 * @param {String} value
	 * @inherits MongooseError
	 * @api private
	 */
	
	function DisconnectedError(connectionString) {
	  MongooseError.call(this, 'Ran out of retries trying to reconnect to "' +
	    connectionString + '". Try setting `server.reconnectTries` and ' +
	    '`server.reconnectInterval` to something higher.');
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.name = 'DisconnectedError';
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	DisconnectedError.prototype = Object.create(MongooseError.prototype);
	DisconnectedError.prototype.constructor = MongooseError;
	
	
	/*!
	 * exports
	 */
	
	module.exports = DisconnectedError;


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module exports.
	 */
	
	exports.Binary = __webpack_require__(219);
	exports.ObjectId = __webpack_require__(268);
	exports.ReadPreference = __webpack_require__(154);


/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) ObjectId
	 * @constructor NodeMongoDbObjectId
	 * @see ObjectId
	 */
	
	var ObjectId = __webpack_require__(155).ObjectId;
	
	/*!
	 * ignore
	 */
	
	module.exports = exports = ObjectId;


/***/ },
/* 269 */
/***/ function(module, exports) {

	
	/**
	 * VirtualType constructor
	 *
	 * This is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.
	 *
	 * ####Example:
	 *
	 *     var fullname = schema.virtual('fullname');
	 *     fullname instanceof mongoose.VirtualType // true
	 *
	 * @parma {Object} options
	 * @api public
	 */
	
	function VirtualType(options, name) {
	  this.path = name;
	  this.getters = [];
	  this.setters = [];
	  this.options = options || {};
	}
	
	/**
	 * Defines a getter.
	 *
	 * ####Example:
	 *
	 *     var virtual = schema.virtual('fullname');
	 *     virtual.get(function () {
	 *       return this.name.first + ' ' + this.name.last;
	 *     });
	 *
	 * @param {Function} fn
	 * @return {VirtualType} this
	 * @api public
	 */
	
	VirtualType.prototype.get = function(fn) {
	  this.getters.push(fn);
	  return this;
	};
	
	/**
	 * Defines a setter.
	 *
	 * ####Example:
	 *
	 *     var virtual = schema.virtual('fullname');
	 *     virtual.set(function (v) {
	 *       var parts = v.split(' ');
	 *       this.name.first = parts[0];
	 *       this.name.last = parts[1];
	 *     });
	 *
	 * @param {Function} fn
	 * @return {VirtualType} this
	 * @api public
	 */
	
	VirtualType.prototype.set = function(fn) {
	  this.setters.push(fn);
	  return this;
	};
	
	/**
	 * Applies getters to `value` using optional `scope`.
	 *
	 * @param {Object} value
	 * @param {Object} scope
	 * @return {any} the value after applying all getters
	 * @api public
	 */
	
	VirtualType.prototype.applyGetters = function(value, scope) {
	  var v = value;
	  for (var l = this.getters.length - 1; l >= 0; l--) {
	    v = this.getters[l].call(scope, v, this);
	  }
	  return v;
	};
	
	/**
	 * Applies setters to `value` using optional `scope`.
	 *
	 * @param {Object} value
	 * @param {Object} scope
	 * @return {any} the value after applying all setters
	 * @api public
	 */
	
	VirtualType.prototype.applySetters = function(value, scope) {
	  var v = value;
	  for (var l = this.setters.length - 1; l >= 0; l--) {
	    v = this.setters[l].call(scope, v, this);
	  }
	  return v;
	};
	
	/*!
	 * exports
	 */
	
	module.exports = VirtualType;


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	function Kareem() {
	  this._pres = {};
	  this._posts = {};
	}
	
	Kareem.prototype.execPre = function(name, context, callback) {
	  var pres = this._pres[name] || [];
	  var numPres = pres.length;
	  var numAsyncPres = pres.numAsync || 0;
	  var currentPre = 0;
	  var asyncPresLeft = numAsyncPres;
	  var done = false;
	
	  if (!numPres) {
	    return process.nextTick(function() {
	      callback(null);
	    });
	  }
	
	  var next = function() {
	    if (currentPre >= numPres) {
	      return;
	    }
	    var pre = pres[currentPre];
	
	    if (pre.isAsync) {
	      pre.fn.call(
	        context,
	        function(error) {
	          if (error) {
	            if (done) {
	              return;
	            }
	            done = true;
	            return callback(error);
	          }
	
	          ++currentPre;
	          next.apply(context, arguments);
	        },
	        function(error) {
	          if (error) {
	            if (done) {
	              return;
	            }
	            done = true;
	            return callback(error);
	          }
	
	          if (--numAsyncPres === 0) {
	            return callback(null);
	          }
	        });
	    } else if (pre.fn.length > 0) {
	      var args = [function(error) {
	        if (error) {
	          if (done) {
	            return;
	          }
	          done = true;
	          return callback(error);
	        }
	
	        if (++currentPre >= numPres) {
	          if (asyncPresLeft > 0) {
	            // Leave parallel hooks to run
	            return;
	          } else {
	            return callback(null);
	          }
	        }
	
	        next.apply(context, arguments);
	      }];
	      if (arguments.length >= 2) {
	        for (var i = 1; i < arguments.length; ++i) {
	          args.push(arguments[i]);
	        }
	      }
	      pre.fn.apply(context, args);
	    } else {
	      pre.fn.call(context);
	      if (++currentPre >= numPres) {
	        if (asyncPresLeft > 0) {
	          // Leave parallel hooks to run
	          return;
	        } else {
	          return process.nextTick(function() {
	            callback(null);
	          });
	        }
	      }
	      next();
	    }
	  };
	
	  next();
	};
	
	Kareem.prototype.execPreSync = function(name, context) {
	  var pres = this._pres[name] || [];
	  var numPres = pres.length;
	
	  for (var i = 0; i < numPres; ++i) {
	    pres[i].fn.call(context);
	  }
	};
	
	Kareem.prototype.execPost = function(name, context, args, options, callback) {
	  if (arguments.length < 5) {
	    callback = options;
	    options = null;
	  }
	  var posts = this._posts[name] || [];
	  var numPosts = posts.length;
	  var currentPost = 0;
	
	  var firstError = null;
	  if (options && options.error) {
	    firstError = options.error;
	  }
	
	  if (!numPosts) {
	    return process.nextTick(function() {
	      callback.apply(null, [firstError].concat(args));
	    });
	  }
	
	  var next = function() {
	    var post = posts[currentPost];
	
	    if (firstError) {
	      if (post.length === args.length + 2) {
	        post.apply(context, [firstError].concat(args).concat(function(error) {
	          if (error) {
	            firstError = error;
	          }
	          if (++currentPost >= numPosts) {
	            return callback.call(null, firstError);
	          }
	          next();
	        }));
	      } else {
	        if (++currentPost >= numPosts) {
	          return callback.call(null, firstError);
	        }
	        next();
	      }
	    } else {
	      if (post.length === args.length + 2) {
	        // Skip error handlers if no error
	        if (++currentPost >= numPosts) {
	          return callback.apply(null, [null].concat(args));
	        }
	        return next();
	      }
	      if (post.length === args.length + 1) {
	        post.apply(context, args.concat(function(error) {
	          if (error) {
	            firstError = error;
	            return next();
	          }
	
	          if (++currentPost >= numPosts) {
	            return callback.apply(null, [null].concat(args));
	          }
	
	          next();
	        }));
	      } else {
	        post.apply(context, args);
	
	        if (++currentPost >= numPosts) {
	          return callback.apply(null, [null].concat(args));
	        }
	
	        next();
	      }
	    }
	  };
	
	  next();
	};
	
	Kareem.prototype.execPostSync = function(name, context) {
	  var posts = this._posts[name] || [];
	  var numPosts = posts.length;
	
	  for (var i = 0; i < numPosts; ++i) {
	    posts[i].call(context);
	  }
	};
	
	function _handleWrapError(instance, error, name, context, args, options, callback) {
	  if (options.useErrorHandlers) {
	    var _options = { error: error };
	    var newArgs = [];
	    // Filter out trailing undefineds
	    for (var i = args.length; i >= 0; --i) {
	      if (newArgs.length > 0 || args[i] !== void 0) {
	        newArgs.unshift(args[i]);
	      }
	    }
	    return instance.execPost(name, context, newArgs, _options, function(error) {
	      return typeof callback === 'function' && callback(error);
	    });
	  } else {
	    return typeof callback === 'function' ?
	      callback(error) :
	      undefined;
	  }
	}
	
	Kareem.prototype.wrap = function(name, fn, context, args, options) {
	  var lastArg = (args.length > 0 ? args[args.length - 1] : null);
	  var argsWithoutCb = typeof lastArg === 'function' ?
	    args.slice(0, args.length - 1) :
	    args;
	  var _this = this;
	
	  var useLegacyPost;
	  if (typeof options === 'object') {
	    useLegacyPost = options && options.useLegacyPost;
	  } else {
	    useLegacyPost = options;
	  }
	  options = options || {};
	
	  this.execPre(name, context, function(error) {
	    if (error) {
	      return _handleWrapError(_this, error, name, context, argsWithoutCb,
	        options, lastArg)
	    }
	
	    var end = (typeof lastArg === 'function' ? args.length - 1 : args.length);
	
	    fn.apply(context, args.slice(0, end).concat(function() {
	      var args = arguments;
	      var argsWithoutError = Array.prototype.slice.call(arguments, 1);
	      if (arguments[0]) {
	        // Assume error
	        return _handleWrapError(_this, arguments[0], name, context,
	          args, options, lastArg);
	      } else {
	        if (useLegacyPost && typeof lastArg === 'function') {
	          lastArg.apply(context, arguments);
	        }
	
	        _this.execPost(name, context, argsWithoutError, function() {
	          if (arguments[0]) {
	            return typeof lastArg === 'function' ?
	              lastArg(arguments[0]) :
	              undefined;
	          }
	
	          return typeof lastArg === 'function' && !useLegacyPost ?
	            lastArg.apply(context, arguments) :
	            undefined;
	        });
	      }
	    }));
	  });
	};
	
	Kareem.prototype.createWrapper = function(name, fn, context, options) {
	  var _this = this;
	  return function() {
	    var args = Array.prototype.slice.call(arguments);
	    _this.wrap(name, fn, context, args, options);
	  };
	};
	
	Kareem.prototype.pre = function(name, isAsync, fn, error) {
	  if (typeof arguments[1] !== 'boolean') {
	    error = fn;
	    fn = isAsync;
	    isAsync = false;
	  }
	
	  this._pres[name] = this._pres[name] || [];
	  var pres = this._pres[name];
	
	  if (isAsync) {
	    pres.numAsync = pres.numAsync || 0;
	    ++pres.numAsync;
	  }
	
	  pres.push({ fn: fn, isAsync: isAsync });
	
	  return this;
	};
	
	Kareem.prototype.post = function(name, fn) {
	  (this._posts[name] = this._posts[name] || []).push(fn);
	  return this;
	};
	
	Kareem.prototype.clone = function() {
	  var n = new Kareem();
	  for (var key in this._pres) {
	    n._pres[key] = this._pres[key].slice();
	  }
	  for (var key in this._posts) {
	    n._posts[key] = this._posts[key].slice();
	  }
	
	  return n;
	};
	
	module.exports = Kareem;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, setImmediate, process) {/*!
	 * async
	 * https://github.com/caolan/async
	 *
	 * Copyright 2010-2014 Caolan McMahon
	 * Released under the MIT license
	 */
	(function () {
	
	    var async = {};
	    function noop() {}
	    function identity(v) {
	        return v;
	    }
	    function toBool(v) {
	        return !!v;
	    }
	    function notId(v) {
	        return !v;
	    }
	
	    // global on the server, window in the browser
	    var previous_async;
	
	    // Establish the root object, `window` (`self`) in the browser, `global`
	    // on the server, or `this` in some virtual machines. We use `self`
	    // instead of `window` for `WebWorker` support.
	    var root = typeof self === 'object' && self.self === self && self ||
	            typeof global === 'object' && global.global === global && global ||
	            this;
	
	    if (root != null) {
	        previous_async = root.async;
	    }
	
	    async.noConflict = function () {
	        root.async = previous_async;
	        return async;
	    };
	
	    function only_once(fn) {
	        return function() {
	            if (fn === null) throw new Error("Callback was already called.");
	            fn.apply(this, arguments);
	            fn = null;
	        };
	    }
	
	    function _once(fn) {
	        return function() {
	            if (fn === null) return;
	            fn.apply(this, arguments);
	            fn = null;
	        };
	    }
	
	    //// cross-browser compatiblity functions ////
	
	    var _toString = Object.prototype.toString;
	
	    var _isArray = Array.isArray || function (obj) {
	        return _toString.call(obj) === '[object Array]';
	    };
	
	    // Ported from underscore.js isObject
	    var _isObject = function(obj) {
	        var type = typeof obj;
	        return type === 'function' || type === 'object' && !!obj;
	    };
	
	    function _isArrayLike(arr) {
	        return _isArray(arr) || (
	            // has a positive integer length property
	            typeof arr.length === "number" &&
	            arr.length >= 0 &&
	            arr.length % 1 === 0
	        );
	    }
	
	    function _arrayEach(arr, iterator) {
	        var index = -1,
	            length = arr.length;
	
	        while (++index < length) {
	            iterator(arr[index], index, arr);
	        }
	    }
	
	    function _map(arr, iterator) {
	        var index = -1,
	            length = arr.length,
	            result = Array(length);
	
	        while (++index < length) {
	            result[index] = iterator(arr[index], index, arr);
	        }
	        return result;
	    }
	
	    function _range(count) {
	        return _map(Array(count), function (v, i) { return i; });
	    }
	
	    function _reduce(arr, iterator, memo) {
	        _arrayEach(arr, function (x, i, a) {
	            memo = iterator(memo, x, i, a);
	        });
	        return memo;
	    }
	
	    function _forEachOf(object, iterator) {
	        _arrayEach(_keys(object), function (key) {
	            iterator(object[key], key);
	        });
	    }
	
	    function _indexOf(arr, item) {
	        for (var i = 0; i < arr.length; i++) {
	            if (arr[i] === item) return i;
	        }
	        return -1;
	    }
	
	    var _keys = Object.keys || function (obj) {
	        var keys = [];
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                keys.push(k);
	            }
	        }
	        return keys;
	    };
	
	    function _keyIterator(coll) {
	        var i = -1;
	        var len;
	        var keys;
	        if (_isArrayLike(coll)) {
	            len = coll.length;
	            return function next() {
	                i++;
	                return i < len ? i : null;
	            };
	        } else {
	            keys = _keys(coll);
	            len = keys.length;
	            return function next() {
	                i++;
	                return i < len ? keys[i] : null;
	            };
	        }
	    }
	
	    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
	    // This accumulates the arguments passed into an array, after a given index.
	    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).
	    function _restParam(func, startIndex) {
	        startIndex = startIndex == null ? func.length - 1 : +startIndex;
	        return function() {
	            var length = Math.max(arguments.length - startIndex, 0);
	            var rest = Array(length);
	            for (var index = 0; index < length; index++) {
	                rest[index] = arguments[index + startIndex];
	            }
	            switch (startIndex) {
	                case 0: return func.call(this, rest);
	                case 1: return func.call(this, arguments[0], rest);
	            }
	            // Currently unused but handle cases outside of the switch statement:
	            // var args = Array(startIndex + 1);
	            // for (index = 0; index < startIndex; index++) {
	            //     args[index] = arguments[index];
	            // }
	            // args[startIndex] = rest;
	            // return func.apply(this, args);
	        };
	    }
	
	    function _withoutIndex(iterator) {
	        return function (value, index, callback) {
	            return iterator(value, callback);
	        };
	    }
	
	    //// exported async module functions ////
	
	    //// nextTick implementation with browser-compatible fallback ////
	
	    // capture the global reference to guard against fakeTimer mocks
	    var _setImmediate = typeof setImmediate === 'function' && setImmediate;
	
	    var _delay = _setImmediate ? function(fn) {
	        // not a direct alias for IE10 compatibility
	        _setImmediate(fn);
	    } : function(fn) {
	        setTimeout(fn, 0);
	    };
	
	    if (typeof process === 'object' && typeof process.nextTick === 'function') {
	        async.nextTick = process.nextTick;
	    } else {
	        async.nextTick = _delay;
	    }
	    async.setImmediate = _setImmediate ? _delay : async.nextTick;
	
	
	    async.forEach =
	    async.each = function (arr, iterator, callback) {
	        return async.eachOf(arr, _withoutIndex(iterator), callback);
	    };
	
	    async.forEachSeries =
	    async.eachSeries = function (arr, iterator, callback) {
	        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
	    };
	
	
	    async.forEachLimit =
	    async.eachLimit = function (arr, limit, iterator, callback) {
	        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
	    };
	
	    async.forEachOf =
	    async.eachOf = function (object, iterator, callback) {
	        callback = _once(callback || noop);
	        object = object || [];
	
	        var iter = _keyIterator(object);
	        var key, completed = 0;
	
	        while ((key = iter()) != null) {
	            completed += 1;
	            iterator(object[key], key, only_once(done));
	        }
	
	        if (completed === 0) callback(null);
	
	        function done(err) {
	            completed--;
	            if (err) {
	                callback(err);
	            }
	            // Check key is null in case iterator isn't exhausted
	            // and done resolved synchronously.
	            else if (key === null && completed <= 0) {
	                callback(null);
	            }
	        }
	    };
	
	    async.forEachOfSeries =
	    async.eachOfSeries = function (obj, iterator, callback) {
	        callback = _once(callback || noop);
	        obj = obj || [];
	        var nextKey = _keyIterator(obj);
	        var key = nextKey();
	        function iterate() {
	            var sync = true;
	            if (key === null) {
	                return callback(null);
	            }
	            iterator(obj[key], key, only_once(function (err) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    key = nextKey();
	                    if (key === null) {
	                        return callback(null);
	                    } else {
	                        if (sync) {
	                            async.setImmediate(iterate);
	                        } else {
	                            iterate();
	                        }
	                    }
	                }
	            }));
	            sync = false;
	        }
	        iterate();
	    };
	
	
	
	    async.forEachOfLimit =
	    async.eachOfLimit = function (obj, limit, iterator, callback) {
	        _eachOfLimit(limit)(obj, iterator, callback);
	    };
	
	    function _eachOfLimit(limit) {
	
	        return function (obj, iterator, callback) {
	            callback = _once(callback || noop);
	            obj = obj || [];
	            var nextKey = _keyIterator(obj);
	            if (limit <= 0) {
	                return callback(null);
	            }
	            var done = false;
	            var running = 0;
	            var errored = false;
	
	            (function replenish () {
	                if (done && running <= 0) {
	                    return callback(null);
	                }
	
	                while (running < limit && !errored) {
	                    var key = nextKey();
	                    if (key === null) {
	                        done = true;
	                        if (running <= 0) {
	                            callback(null);
	                        }
	                        return;
	                    }
	                    running += 1;
	                    iterator(obj[key], key, only_once(function (err) {
	                        running -= 1;
	                        if (err) {
	                            callback(err);
	                            errored = true;
	                        }
	                        else {
	                            replenish();
	                        }
	                    }));
	                }
	            })();
	        };
	    }
	
	
	    function doParallel(fn) {
	        return function (obj, iterator, callback) {
	            return fn(async.eachOf, obj, iterator, callback);
	        };
	    }
	    function doParallelLimit(fn) {
	        return function (obj, limit, iterator, callback) {
	            return fn(_eachOfLimit(limit), obj, iterator, callback);
	        };
	    }
	    function doSeries(fn) {
	        return function (obj, iterator, callback) {
	            return fn(async.eachOfSeries, obj, iterator, callback);
	        };
	    }
	
	    function _asyncMap(eachfn, arr, iterator, callback) {
	        callback = _once(callback || noop);
	        arr = arr || [];
	        var results = _isArrayLike(arr) ? [] : {};
	        eachfn(arr, function (value, index, callback) {
	            iterator(value, function (err, v) {
	                results[index] = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, results);
	        });
	    }
	
	    async.map = doParallel(_asyncMap);
	    async.mapSeries = doSeries(_asyncMap);
	    async.mapLimit = doParallelLimit(_asyncMap);
	
	    // reduce only has a series version, as doing reduce in parallel won't
	    // work in many situations.
	    async.inject =
	    async.foldl =
	    async.reduce = function (arr, memo, iterator, callback) {
	        async.eachOfSeries(arr, function (x, i, callback) {
	            iterator(memo, x, function (err, v) {
	                memo = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, memo);
	        });
	    };
	
	    async.foldr =
	    async.reduceRight = function (arr, memo, iterator, callback) {
	        var reversed = _map(arr, identity).reverse();
	        async.reduce(reversed, memo, iterator, callback);
	    };
	
	    async.transform = function (arr, memo, iterator, callback) {
	        if (arguments.length === 3) {
	            callback = iterator;
	            iterator = memo;
	            memo = _isArray(arr) ? [] : {};
	        }
	
	        async.eachOf(arr, function(v, k, cb) {
	            iterator(memo, v, k, cb);
	        }, function(err) {
	            callback(err, memo);
	        });
	    };
	
	    function _filter(eachfn, arr, iterator, callback) {
	        var results = [];
	        eachfn(arr, function (x, index, callback) {
	            iterator(x, function (v) {
	                if (v) {
	                    results.push({index: index, value: x});
	                }
	                callback();
	            });
	        }, function () {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    }
	
	    async.select =
	    async.filter = doParallel(_filter);
	
	    async.selectLimit =
	    async.filterLimit = doParallelLimit(_filter);
	
	    async.selectSeries =
	    async.filterSeries = doSeries(_filter);
	
	    function _reject(eachfn, arr, iterator, callback) {
	        _filter(eachfn, arr, function(value, cb) {
	            iterator(value, function(v) {
	                cb(!v);
	            });
	        }, callback);
	    }
	    async.reject = doParallel(_reject);
	    async.rejectLimit = doParallelLimit(_reject);
	    async.rejectSeries = doSeries(_reject);
	
	    function _createTester(eachfn, check, getResult) {
	        return function(arr, limit, iterator, cb) {
	            function done() {
	                if (cb) cb(getResult(false, void 0));
	            }
	            function iteratee(x, _, callback) {
	                if (!cb) return callback();
	                iterator(x, function (v) {
	                    if (cb && check(v)) {
	                        cb(getResult(true, x));
	                        cb = iterator = false;
	                    }
	                    callback();
	                });
	            }
	            if (arguments.length > 3) {
	                eachfn(arr, limit, iteratee, done);
	            } else {
	                cb = iterator;
	                iterator = limit;
	                eachfn(arr, iteratee, done);
	            }
	        };
	    }
	
	    async.any =
	    async.some = _createTester(async.eachOf, toBool, identity);
	
	    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);
	
	    async.all =
	    async.every = _createTester(async.eachOf, notId, notId);
	
	    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);
	
	    function _findGetResult(v, x) {
	        return x;
	    }
	    async.detect = _createTester(async.eachOf, identity, _findGetResult);
	    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
	    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);
	
	    async.sortBy = function (arr, iterator, callback) {
	        async.map(arr, function (x, callback) {
	            iterator(x, function (err, criteria) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    callback(null, {value: x, criteria: criteria});
	                }
	            });
	        }, function (err, results) {
	            if (err) {
	                return callback(err);
	            }
	            else {
	                callback(null, _map(results.sort(comparator), function (x) {
	                    return x.value;
	                }));
	            }
	
	        });
	
	        function comparator(left, right) {
	            var a = left.criteria, b = right.criteria;
	            return a < b ? -1 : a > b ? 1 : 0;
	        }
	    };
	
	    async.auto = function (tasks, concurrency, callback) {
	        if (typeof arguments[1] === 'function') {
	            // concurrency is optional, shift the args.
	            callback = concurrency;
	            concurrency = null;
	        }
	        callback = _once(callback || noop);
	        var keys = _keys(tasks);
	        var remainingTasks = keys.length;
	        if (!remainingTasks) {
	            return callback(null);
	        }
	        if (!concurrency) {
	            concurrency = remainingTasks;
	        }
	
	        var results = {};
	        var runningTasks = 0;
	
	        var hasError = false;
	
	        var listeners = [];
	        function addListener(fn) {
	            listeners.unshift(fn);
	        }
	        function removeListener(fn) {
	            var idx = _indexOf(listeners, fn);
	            if (idx >= 0) listeners.splice(idx, 1);
	        }
	        function taskComplete() {
	            remainingTasks--;
	            _arrayEach(listeners.slice(0), function (fn) {
	                fn();
	            });
	        }
	
	        addListener(function () {
	            if (!remainingTasks) {
	                callback(null, results);
	            }
	        });
	
	        _arrayEach(keys, function (k) {
	            if (hasError) return;
	            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
	            var taskCallback = _restParam(function(err, args) {
	                runningTasks--;
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                if (err) {
	                    var safeResults = {};
	                    _forEachOf(results, function(val, rkey) {
	                        safeResults[rkey] = val;
	                    });
	                    safeResults[k] = args;
	                    hasError = true;
	
	                    callback(err, safeResults);
	                }
	                else {
	                    results[k] = args;
	                    async.setImmediate(taskComplete);
	                }
	            });
	            var requires = task.slice(0, task.length - 1);
	            // prevent dead-locks
	            var len = requires.length;
	            var dep;
	            while (len--) {
	                if (!(dep = tasks[requires[len]])) {
	                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));
	                }
	                if (_isArray(dep) && _indexOf(dep, k) >= 0) {
	                    throw new Error('Has cyclic dependencies');
	                }
	            }
	            function ready() {
	                return runningTasks < concurrency && _reduce(requires, function (a, x) {
	                    return (a && results.hasOwnProperty(x));
	                }, true) && !results.hasOwnProperty(k);
	            }
	            if (ready()) {
	                runningTasks++;
	                task[task.length - 1](taskCallback, results);
	            }
	            else {
	                addListener(listener);
	            }
	            function listener() {
	                if (ready()) {
	                    runningTasks++;
	                    removeListener(listener);
	                    task[task.length - 1](taskCallback, results);
	                }
	            }
	        });
	    };
	
	
	
	    async.retry = function(times, task, callback) {
	        var DEFAULT_TIMES = 5;
	        var DEFAULT_INTERVAL = 0;
	
	        var attempts = [];
	
	        var opts = {
	            times: DEFAULT_TIMES,
	            interval: DEFAULT_INTERVAL
	        };
	
	        function parseTimes(acc, t){
	            if(typeof t === 'number'){
	                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
	            } else if(typeof t === 'object'){
	                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
	                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
	            } else {
	                throw new Error('Unsupported argument type for \'times\': ' + typeof t);
	            }
	        }
	
	        var length = arguments.length;
	        if (length < 1 || length > 3) {
	            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
	        } else if (length <= 2 && typeof times === 'function') {
	            callback = task;
	            task = times;
	        }
	        if (typeof times !== 'function') {
	            parseTimes(opts, times);
	        }
	        opts.callback = callback;
	        opts.task = task;
	
	        function wrappedTask(wrappedCallback, wrappedResults) {
	            function retryAttempt(task, finalAttempt) {
	                return function(seriesCallback) {
	                    task(function(err, result){
	                        seriesCallback(!err || finalAttempt, {err: err, result: result});
	                    }, wrappedResults);
	                };
	            }
	
	            function retryInterval(interval){
	                return function(seriesCallback){
	                    setTimeout(function(){
	                        seriesCallback(null);
	                    }, interval);
	                };
	            }
	
	            while (opts.times) {
	
	                var finalAttempt = !(opts.times-=1);
	                attempts.push(retryAttempt(opts.task, finalAttempt));
	                if(!finalAttempt && opts.interval > 0){
	                    attempts.push(retryInterval(opts.interval));
	                }
	            }
	
	            async.series(attempts, function(done, data){
	                data = data[data.length - 1];
	                (wrappedCallback || opts.callback)(data.err, data.result);
	            });
	        }
	
	        // If a callback is passed, run this as a controll flow
	        return opts.callback ? wrappedTask() : wrappedTask;
	    };
	
	    async.waterfall = function (tasks, callback) {
	        callback = _once(callback || noop);
	        if (!_isArray(tasks)) {
	            var err = new Error('First argument to waterfall must be an array of functions');
	            return callback(err);
	        }
	        if (!tasks.length) {
	            return callback();
	        }
	        function wrapIterator(iterator) {
	            return _restParam(function (err, args) {
	                if (err) {
	                    callback.apply(null, [err].concat(args));
	                }
	                else {
	                    var next = iterator.next();
	                    if (next) {
	                        args.push(wrapIterator(next));
	                    }
	                    else {
	                        args.push(callback);
	                    }
	                    ensureAsync(iterator).apply(null, args);
	                }
	            });
	        }
	        wrapIterator(async.iterator(tasks))();
	    };
	
	    function _parallel(eachfn, tasks, callback) {
	        callback = callback || noop;
	        var results = _isArrayLike(tasks) ? [] : {};
	
	        eachfn(tasks, function (task, key, callback) {
	            task(_restParam(function (err, args) {
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                results[key] = args;
	                callback(err);
	            }));
	        }, function (err) {
	            callback(err, results);
	        });
	    }
	
	    async.parallel = function (tasks, callback) {
	        _parallel(async.eachOf, tasks, callback);
	    };
	
	    async.parallelLimit = function(tasks, limit, callback) {
	        _parallel(_eachOfLimit(limit), tasks, callback);
	    };
	
	    async.series = function(tasks, callback) {
	        _parallel(async.eachOfSeries, tasks, callback);
	    };
	
	    async.iterator = function (tasks) {
	        function makeCallback(index) {
	            function fn() {
	                if (tasks.length) {
	                    tasks[index].apply(null, arguments);
	                }
	                return fn.next();
	            }
	            fn.next = function () {
	                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
	            };
	            return fn;
	        }
	        return makeCallback(0);
	    };
	
	    async.apply = _restParam(function (fn, args) {
	        return _restParam(function (callArgs) {
	            return fn.apply(
	                null, args.concat(callArgs)
	            );
	        });
	    });
	
	    function _concat(eachfn, arr, fn, callback) {
	        var result = [];
	        eachfn(arr, function (x, index, cb) {
	            fn(x, function (err, y) {
	                result = result.concat(y || []);
	                cb(err);
	            });
	        }, function (err) {
	            callback(err, result);
	        });
	    }
	    async.concat = doParallel(_concat);
	    async.concatSeries = doSeries(_concat);
	
	    async.whilst = function (test, iterator, callback) {
	        callback = callback || noop;
	        if (test()) {
	            var next = _restParam(function(err, args) {
	                if (err) {
	                    callback(err);
	                } else if (test.apply(this, args)) {
	                    iterator(next);
	                } else {
	                    callback.apply(null, [null].concat(args));
	                }
	            });
	            iterator(next);
	        } else {
	            callback(null);
	        }
	    };
	
	    async.doWhilst = function (iterator, test, callback) {
	        var calls = 0;
	        return async.whilst(function() {
	            return ++calls <= 1 || test.apply(this, arguments);
	        }, iterator, callback);
	    };
	
	    async.until = function (test, iterator, callback) {
	        return async.whilst(function() {
	            return !test.apply(this, arguments);
	        }, iterator, callback);
	    };
	
	    async.doUntil = function (iterator, test, callback) {
	        return async.doWhilst(iterator, function() {
	            return !test.apply(this, arguments);
	        }, callback);
	    };
	
	    async.during = function (test, iterator, callback) {
	        callback = callback || noop;
	
	        var next = _restParam(function(err, args) {
	            if (err) {
	                callback(err);
	            } else {
	                args.push(check);
	                test.apply(this, args);
	            }
	        });
	
	        var check = function(err, truth) {
	            if (err) {
	                callback(err);
	            } else if (truth) {
	                iterator(next);
	            } else {
	                callback(null);
	            }
	        };
	
	        test(check);
	    };
	
	    async.doDuring = function (iterator, test, callback) {
	        var calls = 0;
	        async.during(function(next) {
	            if (calls++ < 1) {
	                next(null, true);
	            } else {
	                test.apply(this, arguments);
	            }
	        }, iterator, callback);
	    };
	
	    function _queue(worker, concurrency, payload) {
	        if (concurrency == null) {
	            concurrency = 1;
	        }
	        else if(concurrency === 0) {
	            throw new Error('Concurrency must not be zero');
	        }
	        function _insert(q, data, pos, callback) {
	            if (callback != null && typeof callback !== "function") {
	                throw new Error("task callback must be a function");
	            }
	            q.started = true;
	            if (!_isArray(data)) {
	                data = [data];
	            }
	            if(data.length === 0 && q.idle()) {
	                // call drain immediately if there are no tasks
	                return async.setImmediate(function() {
	                    q.drain();
	                });
	            }
	            _arrayEach(data, function(task) {
	                var item = {
	                    data: task,
	                    callback: callback || noop
	                };
	
	                if (pos) {
	                    q.tasks.unshift(item);
	                } else {
	                    q.tasks.push(item);
	                }
	
	                if (q.tasks.length === q.concurrency) {
	                    q.saturated();
	                }
	            });
	            async.setImmediate(q.process);
	        }
	        function _next(q, tasks) {
	            return function(){
	                workers -= 1;
	
	                var removed = false;
	                var args = arguments;
	                _arrayEach(tasks, function (task) {
	                    _arrayEach(workersList, function (worker, index) {
	                        if (worker === task && !removed) {
	                            workersList.splice(index, 1);
	                            removed = true;
	                        }
	                    });
	
	                    task.callback.apply(task, args);
	                });
	                if (q.tasks.length + workers === 0) {
	                    q.drain();
	                }
	                q.process();
	            };
	        }
	
	        var workers = 0;
	        var workersList = [];
	        var q = {
	            tasks: [],
	            concurrency: concurrency,
	            payload: payload,
	            saturated: noop,
	            empty: noop,
	            drain: noop,
	            started: false,
	            paused: false,
	            push: function (data, callback) {
	                _insert(q, data, false, callback);
	            },
	            kill: function () {
	                q.drain = noop;
	                q.tasks = [];
	            },
	            unshift: function (data, callback) {
	                _insert(q, data, true, callback);
	            },
	            process: function () {
	                while(!q.paused && workers < q.concurrency && q.tasks.length){
	
	                    var tasks = q.payload ?
	                        q.tasks.splice(0, q.payload) :
	                        q.tasks.splice(0, q.tasks.length);
	
	                    var data = _map(tasks, function (task) {
	                        return task.data;
	                    });
	
	                    if (q.tasks.length === 0) {
	                        q.empty();
	                    }
	                    workers += 1;
	                    workersList.push(tasks[0]);
	                    var cb = only_once(_next(q, tasks));
	                    worker(data, cb);
	                }
	            },
	            length: function () {
	                return q.tasks.length;
	            },
	            running: function () {
	                return workers;
	            },
	            workersList: function () {
	                return workersList;
	            },
	            idle: function() {
	                return q.tasks.length + workers === 0;
	            },
	            pause: function () {
	                q.paused = true;
	            },
	            resume: function () {
	                if (q.paused === false) { return; }
	                q.paused = false;
	                var resumeCount = Math.min(q.concurrency, q.tasks.length);
	                // Need to call q.process once per concurrent
	                // worker to preserve full concurrency after pause
	                for (var w = 1; w <= resumeCount; w++) {
	                    async.setImmediate(q.process);
	                }
	            }
	        };
	        return q;
	    }
	
	    async.queue = function (worker, concurrency) {
	        var q = _queue(function (items, cb) {
	            worker(items[0], cb);
	        }, concurrency, 1);
	
	        return q;
	    };
	
	    async.priorityQueue = function (worker, concurrency) {
	
	        function _compareTasks(a, b){
	            return a.priority - b.priority;
	        }
	
	        function _binarySearch(sequence, item, compare) {
	            var beg = -1,
	                end = sequence.length - 1;
	            while (beg < end) {
	                var mid = beg + ((end - beg + 1) >>> 1);
	                if (compare(item, sequence[mid]) >= 0) {
	                    beg = mid;
	                } else {
	                    end = mid - 1;
	                }
	            }
	            return beg;
	        }
	
	        function _insert(q, data, priority, callback) {
	            if (callback != null && typeof callback !== "function") {
	                throw new Error("task callback must be a function");
	            }
	            q.started = true;
	            if (!_isArray(data)) {
	                data = [data];
	            }
	            if(data.length === 0) {
	                // call drain immediately if there are no tasks
	                return async.setImmediate(function() {
	                    q.drain();
	                });
	            }
	            _arrayEach(data, function(task) {
	                var item = {
	                    data: task,
	                    priority: priority,
	                    callback: typeof callback === 'function' ? callback : noop
	                };
	
	                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
	
	                if (q.tasks.length === q.concurrency) {
	                    q.saturated();
	                }
	                async.setImmediate(q.process);
	            });
	        }
	
	        // Start with a normal queue
	        var q = async.queue(worker, concurrency);
	
	        // Override push to accept second parameter representing priority
	        q.push = function (data, priority, callback) {
	            _insert(q, data, priority, callback);
	        };
	
	        // Remove unshift function
	        delete q.unshift;
	
	        return q;
	    };
	
	    async.cargo = function (worker, payload) {
	        return _queue(worker, 1, payload);
	    };
	
	    function _console_fn(name) {
	        return _restParam(function (fn, args) {
	            fn.apply(null, args.concat([_restParam(function (err, args) {
	                if (typeof console === 'object') {
	                    if (err) {
	                        if (console.error) {
	                            console.error(err);
	                        }
	                    }
	                    else if (console[name]) {
	                        _arrayEach(args, function (x) {
	                            console[name](x);
	                        });
	                    }
	                }
	            })]));
	        });
	    }
	    async.log = _console_fn('log');
	    async.dir = _console_fn('dir');
	    /*async.info = _console_fn('info');
	    async.warn = _console_fn('warn');
	    async.error = _console_fn('error');*/
	
	    async.memoize = function (fn, hasher) {
	        var memo = {};
	        var queues = {};
	        var has = Object.prototype.hasOwnProperty;
	        hasher = hasher || identity;
	        var memoized = _restParam(function memoized(args) {
	            var callback = args.pop();
	            var key = hasher.apply(null, args);
	            if (has.call(memo, key)) {   
	                async.setImmediate(function () {
	                    callback.apply(null, memo[key]);
	                });
	            }
	            else if (has.call(queues, key)) {
	                queues[key].push(callback);
	            }
	            else {
	                queues[key] = [callback];
	                fn.apply(null, args.concat([_restParam(function (args) {
	                    memo[key] = args;
	                    var q = queues[key];
	                    delete queues[key];
	                    for (var i = 0, l = q.length; i < l; i++) {
	                        q[i].apply(null, args);
	                    }
	                })]));
	            }
	        });
	        memoized.memo = memo;
	        memoized.unmemoized = fn;
	        return memoized;
	    };
	
	    async.unmemoize = function (fn) {
	        return function () {
	            return (fn.unmemoized || fn).apply(null, arguments);
	        };
	    };
	
	    function _times(mapper) {
	        return function (count, iterator, callback) {
	            mapper(_range(count), iterator, callback);
	        };
	    }
	
	    async.times = _times(async.map);
	    async.timesSeries = _times(async.mapSeries);
	    async.timesLimit = function (count, limit, iterator, callback) {
	        return async.mapLimit(_range(count), limit, iterator, callback);
	    };
	
	    async.seq = function (/* functions... */) {
	        var fns = arguments;
	        return _restParam(function (args) {
	            var that = this;
	
	            var callback = args[args.length - 1];
	            if (typeof callback == 'function') {
	                args.pop();
	            } else {
	                callback = noop;
	            }
	
	            async.reduce(fns, args, function (newargs, fn, cb) {
	                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {
	                    cb(err, nextargs);
	                })]));
	            },
	            function (err, results) {
	                callback.apply(that, [err].concat(results));
	            });
	        });
	    };
	
	    async.compose = function (/* functions... */) {
	        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
	    };
	
	
	    function _applyEach(eachfn) {
	        return _restParam(function(fns, args) {
	            var go = _restParam(function(args) {
	                var that = this;
	                var callback = args.pop();
	                return eachfn(fns, function (fn, _, cb) {
	                    fn.apply(that, args.concat([cb]));
	                },
	                callback);
	            });
	            if (args.length) {
	                return go.apply(this, args);
	            }
	            else {
	                return go;
	            }
	        });
	    }
	
	    async.applyEach = _applyEach(async.eachOf);
	    async.applyEachSeries = _applyEach(async.eachOfSeries);
	
	
	    async.forever = function (fn, callback) {
	        var done = only_once(callback || noop);
	        var task = ensureAsync(fn);
	        function next(err) {
	            if (err) {
	                return done(err);
	            }
	            task(next);
	        }
	        next();
	    };
	
	    function ensureAsync(fn) {
	        return _restParam(function (args) {
	            var callback = args.pop();
	            args.push(function () {
	                var innerArgs = arguments;
	                if (sync) {
	                    async.setImmediate(function () {
	                        callback.apply(null, innerArgs);
	                    });
	                } else {
	                    callback.apply(null, innerArgs);
	                }
	            });
	            var sync = true;
	            fn.apply(this, args);
	            sync = false;
	        });
	    }
	
	    async.ensureAsync = ensureAsync;
	
	    async.constant = _restParam(function(values) {
	        var args = [null].concat(values);
	        return function (callback) {
	            return callback.apply(this, args);
	        };
	    });
	
	    async.wrapSync =
	    async.asyncify = function asyncify(func) {
	        return _restParam(function (args) {
	            var callback = args.pop();
	            var result;
	            try {
	                result = func.apply(this, args);
	            } catch (e) {
	                return callback(e);
	            }
	            // if result is Promise object
	            if (_isObject(result) && typeof result.then === "function") {
	                result.then(function(value) {
	                    callback(null, value);
	                })["catch"](function(err) {
	                    callback(err.message ? err : new Error(err));
	                });
	            } else {
	                callback(null, result);
	            }
	        });
	    };
	
	    // Node.js
	    if (typeof module === 'object' && module.exports) {
	        module.exports = async;
	    }
	    // AMD / RequireJS
	    else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return async;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    // included directly via <script> tag
	    else {
	        root.async = async;
	    }
	
	}());
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(8).setImmediate, __webpack_require__(6)))

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module exports.
	 */
	
	exports.String = __webpack_require__(273);
	
	exports.Number = __webpack_require__(274);
	
	exports.Boolean = __webpack_require__(276);
	
	exports.DocumentArray = __webpack_require__(277);
	
	exports.Embedded = __webpack_require__(284);
	
	exports.Array = __webpack_require__(278);
	
	exports.Buffer = __webpack_require__(280);
	
	exports.Date = __webpack_require__(279);
	
	exports.ObjectId = __webpack_require__(257);
	
	exports.Mixed = __webpack_require__(230);
	
	// alias
	
	exports.Oid = exports.ObjectId;
	exports.Object = exports.Mixed;
	exports.Bool = exports.Boolean;


/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module dependencies.
	 */
	
	var SchemaType = __webpack_require__(231);
	var CastError = SchemaType.CastError;
	var MongooseError = __webpack_require__(119);
	var utils = __webpack_require__(223);
	var Document;
	
	/**
	 * String SchemaType constructor.
	 *
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function SchemaString(key, options) {
	  this.enumValues = [];
	  this.regExp = null;
	  SchemaType.call(this, key, options, 'String');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	SchemaString.schemaName = 'String';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaString.prototype = Object.create(SchemaType.prototype);
	SchemaString.prototype.constructor = SchemaString;
	
	/**
	 * Adds an enum validator
	 *
	 * ####Example:
	 *
	 *     var states = 'opening open closing closed'.split(' ')
	 *     var s = new Schema({ state: { type: String, enum: states }})
	 *     var M = db.model('M', s)
	 *     var m = new M({ state: 'invalid' })
	 *     m.save(function (err) {
	 *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.
	 *       m.state = 'open'
	 *       m.save(callback) // success
	 *     })
	 *
	 *     // or with custom error messages
	 *     var enu = {
	 *       values: 'opening open closing closed'.split(' '),
	 *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'
	 *     }
	 *     var s = new Schema({ state: { type: String, enum: enu })
	 *     var M = db.model('M', s)
	 *     var m = new M({ state: 'invalid' })
	 *     m.save(function (err) {
	 *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`
	 *       m.state = 'open'
	 *       m.save(callback) // success
	 *     })
	 *
	 * @param {String|Object} [args...] enumeration values
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaString.prototype.enum = function() {
	  if (this.enumValidator) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.enumValidator;
	    }, this);
	    this.enumValidator = false;
	  }
	
	  if (arguments[0] === void 0 || arguments[0] === false) {
	    return this;
	  }
	
	  var values;
	  var errorMessage;
	
	  if (utils.isObject(arguments[0])) {
	    values = arguments[0].values;
	    errorMessage = arguments[0].message;
	  } else {
	    values = arguments;
	    errorMessage = MongooseError.messages.String.enum;
	  }
	
	  for (var i = 0; i < values.length; i++) {
	    if (undefined !== values[i]) {
	      this.enumValues.push(this.cast(values[i]));
	    }
	  }
	
	  var vals = this.enumValues;
	  this.enumValidator = function(v) {
	    return undefined === v || ~vals.indexOf(v);
	  };
	  this.validators.push({
	    validator: this.enumValidator,
	    message: errorMessage,
	    type: 'enum',
	    enumValues: vals
	  });
	
	  return this;
	};
	
	/**
	 * Adds a lowercase setter.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ email: { type: String, lowercase: true }})
	 *     var M = db.model('M', s);
	 *     var m = new M({ email: 'SomeEmail@example.COM' });
	 *     console.log(m.email) // someemail@example.com
	 *
	 * @api public
	 * @return {SchemaType} this
	 */
	
	SchemaString.prototype.lowercase = function() {
	  return this.set(function(v, self) {
	    if (typeof v !== 'string') {
	      v = self.cast(v);
	    }
	    if (v) {
	      return v.toLowerCase();
	    }
	    return v;
	  });
	};
	
	/**
	 * Adds an uppercase setter.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ caps: { type: String, uppercase: true }})
	 *     var M = db.model('M', s);
	 *     var m = new M({ caps: 'an example' });
	 *     console.log(m.caps) // AN EXAMPLE
	 *
	 * @api public
	 * @return {SchemaType} this
	 */
	
	SchemaString.prototype.uppercase = function() {
	  return this.set(function(v, self) {
	    if (typeof v !== 'string') {
	      v = self.cast(v);
	    }
	    if (v) {
	      return v.toUpperCase();
	    }
	    return v;
	  });
	};
	
	/**
	 * Adds a trim setter.
	 *
	 * The string value will be trimmed when set.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ name: { type: String, trim: true }})
	 *     var M = db.model('M', s)
	 *     var string = ' some name '
	 *     console.log(string.length) // 11
	 *     var m = new M({ name: string })
	 *     console.log(m.name.length) // 9
	 *
	 * @api public
	 * @return {SchemaType} this
	 */
	
	SchemaString.prototype.trim = function() {
	  return this.set(function(v, self) {
	    if (typeof v !== 'string') {
	      v = self.cast(v);
	    }
	    if (v && self.options.trim) {
	      return v.trim();
	    }
	    return v;
	  });
	};
	
	/**
	 * Sets a minimum length validator.
	 *
	 * ####Example:
	 *
	 *     var schema = new Schema({ postalCode: { type: String, minlength: 5 })
	 *     var Address = db.model('Address', schema)
	 *     var address = new Address({ postalCode: '9512' })
	 *     address.save(function (err) {
	 *       console.error(err) // validator error
	 *       address.postalCode = '95125';
	 *       address.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MINLENGTH} token which will be replaced with the minimum allowed length
	 *     var minlength = [5, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).'];
	 *     var schema = new Schema({ postalCode: { type: String, minlength: minlength })
	 *     var Address = mongoose.model('Address', schema);
	 *     var address = new Address({ postalCode: '9512' });
	 *     address.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).
	 *     })
	 *
	 * @param {Number} value minimum string length
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaString.prototype.minlength = function(value, message) {
	  if (this.minlengthValidator) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.minlengthValidator;
	    }, this);
	  }
	
	  if (value !== null && value !== undefined) {
	    var msg = message || MongooseError.messages.String.minlength;
	    msg = msg.replace(/{MINLENGTH}/, value);
	    this.validators.push({
	      validator: this.minlengthValidator = function(v) {
	        return v === null || v.length >= value;
	      },
	      message: msg,
	      type: 'minlength',
	      minlength: value
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Sets a maximum length validator.
	 *
	 * ####Example:
	 *
	 *     var schema = new Schema({ postalCode: { type: String, maxlength: 9 })
	 *     var Address = db.model('Address', schema)
	 *     var address = new Address({ postalCode: '9512512345' })
	 *     address.save(function (err) {
	 *       console.error(err) // validator error
	 *       address.postalCode = '95125';
	 *       address.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MAXLENGTH} token which will be replaced with the maximum allowed length
	 *     var maxlength = [9, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];
	 *     var schema = new Schema({ postalCode: { type: String, maxlength: maxlength })
	 *     var Address = mongoose.model('Address', schema);
	 *     var address = new Address({ postalCode: '9512512345' });
	 *     address.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (9).
	 *     })
	 *
	 * @param {Number} value maximum string length
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaString.prototype.maxlength = function(value, message) {
	  if (this.maxlengthValidator) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.maxlengthValidator;
	    }, this);
	  }
	
	  if (value !== null && value !== undefined) {
	    var msg = message || MongooseError.messages.String.maxlength;
	    msg = msg.replace(/{MAXLENGTH}/, value);
	    this.validators.push({
	      validator: this.maxlengthValidator = function(v) {
	        return v === null || v.length <= value;
	      },
	      message: msg,
	      type: 'maxlength',
	      maxlength: value
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Sets a regexp validator.
	 *
	 * Any value that does not pass `regExp`.test(val) will fail validation.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ name: { type: String, match: /^a/ }})
	 *     var M = db.model('M', s)
	 *     var m = new M({ name: 'I am invalid' })
	 *     m.validate(function (err) {
	 *       console.error(String(err)) // "ValidationError: Path `name` is invalid (I am invalid)."
	 *       m.name = 'apples'
	 *       m.validate(function (err) {
	 *         assert.ok(err) // success
	 *       })
	 *     })
	 *
	 *     // using a custom error message
	 *     var match = [ /\.html$/, "That file doesn't end in .html ({VALUE})" ];
	 *     var s = new Schema({ file: { type: String, match: match }})
	 *     var M = db.model('M', s);
	 *     var m = new M({ file: 'invalid' });
	 *     m.validate(function (err) {
	 *       console.log(String(err)) // "ValidationError: That file doesn't end in .html (invalid)"
	 *     })
	 *
	 * Empty strings, `undefined`, and `null` values always pass the match validator. If you require these values, enable the `required` validator also.
	 *
	 *     var s = new Schema({ name: { type: String, match: /^a/, required: true }})
	 *
	 * @param {RegExp} regExp regular expression to test against
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaString.prototype.match = function match(regExp, message) {
	  // yes, we allow multiple match validators
	
	  var msg = message || MongooseError.messages.String.match;
	
	  var matchValidator = function(v) {
	    if (!regExp) {
	      return false;
	    }
	
	    var ret = ((v != null && v !== '')
	        ? regExp.test(v)
	        : true);
	    return ret;
	  };
	
	  this.validators.push({
	    validator: matchValidator,
	    message: msg,
	    type: 'regexp',
	    regexp: regExp
	  });
	  return this;
	};
	
	/**
	 * Check if the given value satisfies a required validator.
	 *
	 * @param {Any} value
	 * @param {Document} doc
	 * @return {Boolean}
	 * @api public
	 */
	
	SchemaString.prototype.checkRequired = function checkRequired(value, doc) {
	  if (SchemaType._isRef(this, value, doc, true)) {
	    return !!value;
	  }
	  return (value instanceof String || typeof value === 'string') && value.length;
	};
	
	/**
	 * Casts to String
	 *
	 * @api private
	 */
	
	SchemaString.prototype.cast = function(value, doc, init) {
	  if (SchemaType._isRef(this, value, doc, init)) {
	    // wait! we may need to cast this to a document
	
	    if (value === null || value === undefined) {
	      return value;
	    }
	
	    // lazy load
	    Document || (Document = __webpack_require__(229));
	
	    if (value instanceof Document) {
	      value.$__.wasPopulated = true;
	      return value;
	    }
	
	    // setting a populated path
	    if (typeof value === 'string') {
	      return value;
	    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {
	      throw new CastError('string', value, this.path);
	    }
	
	    // Handle the case where user directly sets a populated
	    // path to a plain object; cast to the Model used in
	    // the population query.
	    var path = doc.$__fullPath(this.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    var pop = owner.populated(path, true);
	    var ret = new pop.options.model(value);
	    ret.$__.wasPopulated = true;
	    return ret;
	  }
	
	  // If null or undefined
	  if (value === null || value === undefined) {
	    return value;
	  }
	
	  if (typeof value !== 'undefined') {
	    // handle documents being passed
	    if (value._id && typeof value._id === 'string') {
	      return value._id;
	    }
	
	    // Re: gh-647 and gh-3030, we're ok with casting using `toString()`
	    // **unless** its the default Object.toString, because "[object Object]"
	    // doesn't really qualify as useful data
	    if (value.toString && value.toString !== Object.prototype.toString) {
	      return value.toString();
	    }
	  }
	
	  throw new CastError('string', value, this.path);
	};
	
	/*!
	 * ignore
	 */
	
	function handleSingle(val) {
	  return this.castForQuery(val);
	}
	
	function handleArray(val) {
	  var _this = this;
	  if (!Array.isArray(val)) {
	    return [this.castForQuery(val)];
	  }
	  return val.map(function(m) {
	    return _this.castForQuery(m);
	  });
	}
	
	SchemaString.prototype.$conditionalHandlers =
	    utils.options(SchemaType.prototype.$conditionalHandlers, {
	      $all: handleArray,
	      $gt: handleSingle,
	      $gte: handleSingle,
	      $lt: handleSingle,
	      $lte: handleSingle,
	      $options: handleSingle,
	      $regex: handleSingle
	    });
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [val]
	 * @api private
	 */
	
	SchemaString.prototype.castForQuery = function($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler) {
	      throw new Error('Can\'t use ' + $conditional + ' with String.');
	    }
	    return handler.call(this, val);
	  }
	  val = $conditional;
	  if (Object.prototype.toString.call(val) === '[object RegExp]') {
	    return val;
	  }
	  return this.cast(val);
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaString;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module requirements.
	 */
	
	var SchemaType = __webpack_require__(231);
	var CastError = SchemaType.CastError;
	var handleBitwiseOperator = __webpack_require__(275);
	var MongooseError = __webpack_require__(119);
	var utils = __webpack_require__(223);
	var Document;
	
	/**
	 * Number SchemaType constructor.
	 *
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function SchemaNumber(key, options) {
	  SchemaType.call(this, key, options, 'Number');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	SchemaNumber.schemaName = 'Number';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaNumber.prototype = Object.create(SchemaType.prototype);
	SchemaNumber.prototype.constructor = SchemaNumber;
	
	/**
	 * Check if the given value satisfies a required validator.
	 *
	 * @param {Any} value
	 * @param {Document} doc
	 * @return {Boolean}
	 * @api public
	 */
	
	SchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {
	  if (SchemaType._isRef(this, value, doc, true)) {
	    return !!value;
	  }
	  return typeof value === 'number' || value instanceof Number;
	};
	
	/**
	 * Sets a minimum number validator.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ n: { type: Number, min: 10 })
	 *     var M = db.model('M', s)
	 *     var m = new M({ n: 9 })
	 *     m.save(function (err) {
	 *       console.error(err) // validator error
	 *       m.n = 10;
	 *       m.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MIN} token which will be replaced with the invalid value
	 *     var min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];
	 *     var schema = new Schema({ n: { type: Number, min: min })
	 *     var M = mongoose.model('Measurement', schema);
	 *     var s= new M({ n: 4 });
	 *     s.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).
	 *     })
	 *
	 * @param {Number} value minimum number
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaNumber.prototype.min = function(value, message) {
	  if (this.minValidator) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.minValidator;
	    }, this);
	  }
	
	  if (value !== null && value !== undefined) {
	    var msg = message || MongooseError.messages.Number.min;
	    msg = msg.replace(/{MIN}/, value);
	    this.validators.push({
	      validator: this.minValidator = function(v) {
	        return v == null || v >= value;
	      },
	      message: msg,
	      type: 'min',
	      min: value
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Sets a maximum number validator.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ n: { type: Number, max: 10 })
	 *     var M = db.model('M', s)
	 *     var m = new M({ n: 11 })
	 *     m.save(function (err) {
	 *       console.error(err) // validator error
	 *       m.n = 10;
	 *       m.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MAX} token which will be replaced with the invalid value
	 *     var max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];
	 *     var schema = new Schema({ n: { type: Number, max: max })
	 *     var M = mongoose.model('Measurement', schema);
	 *     var s= new M({ n: 4 });
	 *     s.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).
	 *     })
	 *
	 * @param {Number} maximum number
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaNumber.prototype.max = function(value, message) {
	  if (this.maxValidator) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.maxValidator;
	    }, this);
	  }
	
	  if (value !== null && value !== undefined) {
	    var msg = message || MongooseError.messages.Number.max;
	    msg = msg.replace(/{MAX}/, value);
	    this.validators.push({
	      validator: this.maxValidator = function(v) {
	        return v == null || v <= value;
	      },
	      message: msg,
	      type: 'max',
	      max: value
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Casts to number
	 *
	 * @param {Object} value value to cast
	 * @param {Document} doc document that triggers the casting
	 * @param {Boolean} init
	 * @api private
	 */
	
	SchemaNumber.prototype.cast = function(value, doc, init) {
	  if (SchemaType._isRef(this, value, doc, init)) {
	    // wait! we may need to cast this to a document
	
	    if (value === null || value === undefined) {
	      return value;
	    }
	
	    // lazy load
	    Document || (Document = __webpack_require__(229));
	
	    if (value instanceof Document) {
	      value.$__.wasPopulated = true;
	      return value;
	    }
	
	    // setting a populated path
	    if (typeof value === 'number') {
	      return value;
	    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {
	      throw new CastError('number', value, this.path);
	    }
	
	    // Handle the case where user directly sets a populated
	    // path to a plain object; cast to the Model used in
	    // the population query.
	    var path = doc.$__fullPath(this.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    var pop = owner.populated(path, true);
	    var ret = new pop.options.model(value);
	    ret.$__.wasPopulated = true;
	    return ret;
	  }
	
	  var val = value && value._id
	      ? value._id // documents
	      : value;
	
	  if (!isNaN(val)) {
	    if (val === null) {
	      return val;
	    }
	    if (val === '') {
	      return null;
	    }
	    if (typeof val === 'string' || typeof val === 'boolean') {
	      val = Number(val);
	    }
	    if (val instanceof Number) {
	      return val;
	    }
	    if (typeof val === 'number') {
	      return val;
	    }
	    if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {
	      return new Number(val);
	    }
	  }
	
	  throw new CastError('number', value, this.path);
	};
	
	/*!
	 * ignore
	 */
	
	function handleSingle(val) {
	  return this.cast(val);
	}
	
	function handleArray(val) {
	  var _this = this;
	  if (!Array.isArray(val)) {
	    return [this.cast(val)];
	  }
	  return val.map(function(m) {
	    return _this.cast(m);
	  });
	}
	
	SchemaNumber.prototype.$conditionalHandlers =
	    utils.options(SchemaType.prototype.$conditionalHandlers, {
	      $bitsAllClear: handleBitwiseOperator,
	      $bitsAnyClear: handleBitwiseOperator,
	      $bitsAllSet: handleBitwiseOperator,
	      $bitsAnySet: handleBitwiseOperator,
	      $gt: handleSingle,
	      $gte: handleSingle,
	      $lt: handleSingle,
	      $lte: handleSingle,
	      $mod: handleArray
	    });
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [value]
	 * @api private
	 */
	
	SchemaNumber.prototype.castForQuery = function($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler) {
	      throw new Error('Can\'t use ' + $conditional + ' with Number.');
	    }
	    return handler.call(this, val);
	  }
	  val = this.cast($conditional);
	  return val;
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaNumber;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module requirements.
	 */
	
	var CastError = __webpack_require__(121);
	
	/*!
	 * ignore
	 */
	
	function handleBitwiseOperator(val) {
	  var _this = this;
	  if (Array.isArray(val)) {
	    return val.map(function(v) {
	      return _castNumber(_this.path, v);
	    });
	  } else if (Buffer.isBuffer(val)) {
	    return val;
	  }
	  // Assume trying to cast to number
	  return _castNumber(_this.path, val);
	}
	
	/*!
	 * ignore
	 */
	
	function _castNumber(path, num) {
	  var v = Number(num);
	  if (isNaN(v)) {
	    throw new CastError('number', num, path);
	  }
	  return v;
	}
	
	module.exports = handleBitwiseOperator;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var utils = __webpack_require__(223);
	
	var SchemaType = __webpack_require__(231);
	
	/**
	 * Boolean SchemaType constructor.
	 *
	 * @param {String} path
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function SchemaBoolean(path, options) {
	  SchemaType.call(this, path, options, 'Boolean');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	SchemaBoolean.schemaName = 'Boolean';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaBoolean.prototype = Object.create(SchemaType.prototype);
	SchemaBoolean.prototype.constructor = SchemaBoolean;
	
	/**
	 * Check if the given value satisfies a required validator. For a boolean
	 * to satisfy a required validator, it must be strictly equal to true or to
	 * false.
	 *
	 * @param {Any} value
	 * @return {Boolean}
	 * @api public
	 */
	
	SchemaBoolean.prototype.checkRequired = function(value) {
	  return value === true || value === false;
	};
	
	/**
	 * Casts to boolean
	 *
	 * @param {Object} value
	 * @api private
	 */
	
	SchemaBoolean.prototype.cast = function(value) {
	  if (value === null) {
	    return value;
	  }
	  if (value === '0') {
	    return false;
	  }
	  if (value === 'true') {
	    return true;
	  }
	  if (value === 'false') {
	    return false;
	  }
	  return !!value;
	};
	
	SchemaBoolean.$conditionalHandlers =
	    utils.options(SchemaType.prototype.$conditionalHandlers, {});
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} val
	 * @api private
	 */
	
	SchemaBoolean.prototype.castForQuery = function($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = SchemaBoolean.$conditionalHandlers[$conditional];
	
	    if (handler) {
	      return handler.call(this, val);
	    }
	
	    return this.cast(val);
	  }
	
	  return this.cast($conditional);
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaBoolean;


/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint no-empty: 1 */
	
	/*!
	 * Module dependencies.
	 */
	
	var ArrayType = __webpack_require__(278);
	var CastError = __webpack_require__(121);
	var MongooseDocumentArray = __webpack_require__(256);
	var SchemaType = __webpack_require__(231);
	var Subdocument = __webpack_require__(252);
	var util = __webpack_require__(77);
	
	/**
	 * SubdocsArray SchemaType constructor
	 *
	 * @param {String} key
	 * @param {Schema} schema
	 * @param {Object} options
	 * @inherits SchemaArray
	 * @api public
	 */
	
	function DocumentArray(key, schema, options) {
	  // compile an embedded document for this schema
	  function EmbeddedDocument() {
	    Subdocument.apply(this, arguments);
	  }
	
	  EmbeddedDocument.prototype = Object.create(Subdocument.prototype);
	  EmbeddedDocument.prototype.$__setSchema(schema);
	  EmbeddedDocument.schema = schema;
	
	  // apply methods
	  for (var i in schema.methods) {
	    EmbeddedDocument.prototype[i] = schema.methods[i];
	  }
	
	  // apply statics
	  for (i in schema.statics) {
	    EmbeddedDocument[i] = schema.statics[i];
	  }
	
	  EmbeddedDocument.options = options;
	
	  ArrayType.call(this, key, EmbeddedDocument, options);
	
	  this.schema = schema;
	  this.$isMongooseDocumentArray = true;
	  var path = this.path;
	  var fn = this.defaultValue;
	
	  if (!('defaultValue' in this) || fn !== void 0) {
	    this.default(function() {
	      var arr = fn.call(this);
	      if (!Array.isArray(arr)) {
	        arr = [arr];
	      }
	      return new MongooseDocumentArray(arr, path, this);
	    });
	  }
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	DocumentArray.schemaName = 'DocumentArray';
	
	/*!
	 * Inherits from ArrayType.
	 */
	DocumentArray.prototype = Object.create(ArrayType.prototype);
	DocumentArray.prototype.constructor = DocumentArray;
	
	/**
	 * Performs local validations first, then validations on each embedded doc
	 *
	 * @api private
	 */
	
	DocumentArray.prototype.doValidate = function(array, fn, scope, options) {
	  var _this = this;
	  SchemaType.prototype.doValidate.call(this, array, function(err) {
	    if (err) {
	      return fn(err);
	    }
	
	    var count = array && array.length;
	    var error;
	
	    if (!count) {
	      return fn();
	    }
	    if (options && options.updateValidator) {
	      return fn();
	    }
	
	    // handle sparse arrays, do not use array.forEach which does not
	    // iterate over sparse elements yet reports array.length including
	    // them :(
	
	    function callback(err) {
	      if (err) {
	        error = err;
	      }
	      --count || fn(error);
	    }
	
	    for (var i = 0, len = count; i < len; ++i) {
	      // sidestep sparse entries
	      var doc = array[i];
	      if (!doc) {
	        --count || fn(error);
	        continue;
	      }
	
	      // If you set the array index directly, the doc might not yet be
	      // a full fledged mongoose subdoc, so make it into one.
	      if (!(doc instanceof Subdocument)) {
	        doc = array[i] = new _this.casterConstructor(doc, array, undefined,
	            undefined, i);
	      }
	
	      // HACK: use $__original_validate to avoid promises so bluebird doesn't
	      // complain
	      if (doc.$__original_validate) {
	        doc.$__original_validate({__noPromise: true}, callback);
	      } else {
	        doc.validate({__noPromise: true}, callback);
	      }
	    }
	  }, scope);
	};
	
	/**
	 * Performs local validations first, then validations on each embedded doc.
	 *
	 * ####Note:
	 *
	 * This method ignores the asynchronous validators.
	 *
	 * @return {MongooseError|undefined}
	 * @api private
	 */
	
	DocumentArray.prototype.doValidateSync = function(array, scope) {
	  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
	  if (schemaTypeError) {
	    return schemaTypeError;
	  }
	
	  var count = array && array.length,
	      resultError = null;
	
	  if (!count) {
	    return;
	  }
	
	  // handle sparse arrays, do not use array.forEach which does not
	  // iterate over sparse elements yet reports array.length including
	  // them :(
	
	  for (var i = 0, len = count; i < len; ++i) {
	    // only first error
	    if (resultError) {
	      break;
	    }
	    // sidestep sparse entries
	    var doc = array[i];
	    if (!doc) {
	      continue;
	    }
	
	    var subdocValidateError = doc.validateSync();
	
	    if (subdocValidateError) {
	      resultError = subdocValidateError;
	    }
	  }
	
	  return resultError;
	};
	
	/**
	 * Casts contents
	 *
	 * @param {Object} value
	 * @param {Document} document that triggers the casting
	 * @api private
	 */
	
	DocumentArray.prototype.cast = function(value, doc, init, prev, options) {
	  var selected,
	      subdoc,
	      i;
	
	  if (!Array.isArray(value)) {
	    // gh-2442 mark whole array as modified if we're initializing a doc from
	    // the db and the path isn't an array in the document
	    if (!!doc && init) {
	      doc.markModified(this.path);
	    }
	    return this.cast([value], doc, init, prev);
	  }
	
	  if (!(value && value.isMongooseDocumentArray) &&
	      (!options || !options.skipDocumentArrayCast)) {
	    value = new MongooseDocumentArray(value, this.path, doc);
	    if (prev && prev._handlers) {
	      for (var key in prev._handlers) {
	        doc.removeListener(key, prev._handlers[key]);
	      }
	    }
	  }
	
	  i = value.length;
	
	  while (i--) {
	    if (!value[i]) {
	      continue;
	    }
	    // Check if the document has a different schema (re gh-3701)
	    if ((value[i] instanceof Subdocument) &&
	        value[i].schema !== this.casterConstructor.schema) {
	      value[i] = value[i].toObject({virtuals: false});
	    }
	    if (!(value[i] instanceof Subdocument) && value[i]) {
	      if (init) {
	        selected || (selected = scopePaths(this, doc.$__.selected, init));
	        subdoc = new this.casterConstructor(null, value, true, selected, i);
	        value[i] = subdoc.init(value[i]);
	      } else {
	        try {
	          subdoc = prev.id(value[i]._id);
	        } catch (e) {
	        }
	
	        if (prev && subdoc) {
	          // handle resetting doc with existing id but differing data
	          // doc.array = [{ doc: 'val' }]
	          subdoc.set(value[i]);
	          // if set() is hooked it will have no return value
	          // see gh-746
	          value[i] = subdoc;
	        } else {
	          try {
	            subdoc = new this.casterConstructor(value[i], value, undefined,
	                undefined, i);
	            // if set() is hooked it will have no return value
	            // see gh-746
	            value[i] = subdoc;
	          } catch (error) {
	            var valueInErrorMessage = util.inspect(value[i]);
	            throw new CastError('embedded', valueInErrorMessage,
	              value._path, error);
	          }
	        }
	      }
	    }
	  }
	
	  return value;
	};
	
	/*!
	 * Scopes paths selected in a query to this array.
	 * Necessary for proper default application of subdocument values.
	 *
	 * @param {DocumentArray} array - the array to scope `fields` paths
	 * @param {Object|undefined} fields - the root fields selected in the query
	 * @param {Boolean|undefined} init - if we are being created part of a query result
	 */
	
	function scopePaths(array, fields, init) {
	  if (!(init && fields)) {
	    return undefined;
	  }
	
	  var path = array.path + '.',
	      keys = Object.keys(fields),
	      i = keys.length,
	      selected = {},
	      hasKeys,
	      key;
	
	  while (i--) {
	    key = keys[i];
	    if (key.indexOf(path) === 0) {
	      hasKeys || (hasKeys = true);
	      selected[key.substring(path.length)] = fields[key];
	    }
	  }
	
	  return hasKeys && selected || undefined;
	}
	
	/*!
	 * Module exports.
	 */
	
	module.exports = DocumentArray;


/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var SchemaType = __webpack_require__(231);
	var CastError = SchemaType.CastError;
	var Types = {
	  Boolean: __webpack_require__(276),
	  Date: __webpack_require__(279),
	  Number: __webpack_require__(274),
	  String: __webpack_require__(273),
	  ObjectId: __webpack_require__(257),
	  Buffer: __webpack_require__(280)
	};
	var MongooseArray = __webpack_require__(258).Array;
	var EmbeddedDoc = __webpack_require__(258).Embedded;
	var Mixed = __webpack_require__(230);
	var cast = __webpack_require__(281);
	var util = __webpack_require__(77);
	var utils = __webpack_require__(223);
	var isMongooseObject = utils.isMongooseObject;
	var castToNumber = __webpack_require__(282).castToNumber;
	var geospatial = __webpack_require__(283);
	
	/**
	 * Array SchemaType constructor
	 *
	 * @param {String} key
	 * @param {SchemaType} cast
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function SchemaArray(key, cast, options) {
	  if (cast) {
	    var castOptions = {};
	
	    if (utils.getFunctionName(cast.constructor) === 'Object') {
	      if (cast.type) {
	        // support { type: Woot }
	        castOptions = utils.clone(cast); // do not alter user arguments
	        delete castOptions.type;
	        cast = cast.type;
	      } else {
	        cast = Mixed;
	      }
	    }
	
	    // support { type: 'String' }
	    var name = typeof cast === 'string'
	        ? cast
	        : utils.getFunctionName(cast);
	
	    var caster = name in Types
	        ? Types[name]
	        : cast;
	
	    this.casterConstructor = caster;
	    if (typeof caster === 'function') {
	      this.caster = new caster(null, castOptions);
	    } else {
	      this.caster = caster;
	    }
	
	    if (!(this.caster instanceof EmbeddedDoc)) {
	      this.caster.path = key;
	    }
	  }
	
	  SchemaType.call(this, key, options, 'Array');
	
	  var _this = this;
	  var defaultArr;
	  var fn;
	
	  if (this.defaultValue) {
	    defaultArr = this.defaultValue;
	    fn = typeof defaultArr === 'function';
	  }
	
	  if (!('defaultValue' in this) || this.defaultValue !== void 0) {
	    this.default(function() {
	      var arr = fn ? defaultArr() : defaultArr || [];
	      return new MongooseArray(arr, _this.path, this);
	    });
	  }
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	SchemaArray.schemaName = 'Array';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaArray.prototype = Object.create(SchemaType.prototype);
	SchemaArray.prototype.constructor = SchemaArray;
	
	/**
	 * Check if the given value satisfies a required validator. The given value
	 * must be not null nor undefined, and have a non-zero length.
	 *
	 * @param {Any} value
	 * @return {Boolean}
	 * @api public
	 */
	
	SchemaArray.prototype.checkRequired = function(value) {
	  return !!(value && value.length);
	};
	
	/**
	 * Overrides the getters application for the population special-case
	 *
	 * @param {Object} value
	 * @param {Object} scope
	 * @api private
	 */
	
	SchemaArray.prototype.applyGetters = function(value, scope) {
	  if (this.caster.options && this.caster.options.ref) {
	    // means the object id was populated
	    return value;
	  }
	
	  return SchemaType.prototype.applyGetters.call(this, value, scope);
	};
	
	/**
	 * Casts values for set().
	 *
	 * @param {Object} value
	 * @param {Document} doc document that triggers the casting
	 * @param {Boolean} init whether this is an initialization cast
	 * @api private
	 */
	
	SchemaArray.prototype.cast = function(value, doc, init) {
	  if (Array.isArray(value)) {
	    if (!value.length && doc) {
	      var indexes = doc.schema.indexedPaths();
	
	      for (var i = 0, l = indexes.length; i < l; ++i) {
	        var pathIndex = indexes[i][0][this.path];
	        if (pathIndex === '2dsphere' || pathIndex === '2d') {
	          return;
	        }
	      }
	    }
	
	    if (!(value && value.isMongooseArray)) {
	      value = new MongooseArray(value, this.path, doc);
	    }
	
	    if (this.caster) {
	      try {
	        for (i = 0, l = value.length; i < l; i++) {
	          value[i] = this.caster.cast(value[i], doc, init);
	        }
	      } catch (e) {
	        // rethrow
	        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e);
	      }
	    }
	
	    return value;
	  }
	  // gh-2442: if we're loading this from the db and its not an array, mark
	  // the whole array as modified.
	  if (!!doc && !!init) {
	    doc.markModified(this.path);
	  }
	  return this.cast([value], doc, init);
	};
	
	/**
	 * Casts values for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [value]
	 * @api private
	 */
	
	SchemaArray.prototype.castForQuery = function($conditional, value) {
	  var handler,
	      val;
	
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	
	    if (!handler) {
	      throw new Error('Can\'t use ' + $conditional + ' with Array.');
	    }
	
	    val = handler.call(this, value);
	  } else {
	    val = $conditional;
	    var proto = this.casterConstructor.prototype;
	    var method = proto.castForQuery || proto.cast;
	    var caster = this.caster;
	
	    if (Array.isArray(val)) {
	      val = val.map(function(v) {
	        if (utils.isObject(v) && v.$elemMatch) {
	          return v;
	        }
	        if (method) {
	          v = method.call(caster, v);
	        }
	        return isMongooseObject(v) ?
	            v.toObject({virtuals: false}) :
	            v;
	      });
	    } else if (method) {
	      val = method.call(caster, val);
	    }
	  }
	
	  return val && isMongooseObject(val) ?
	      val.toObject({virtuals: false}) :
	      val;
	};
	
	function cast$all(val) {
	  if (!Array.isArray(val)) {
	    val = [val];
	  }
	
	  val = val.map(function(v) {
	    if (utils.isObject(v)) {
	      var o = {};
	      o[this.path] = v;
	      return cast(this.casterConstructor.schema, o)[this.path];
	    }
	    return v;
	  }, this);
	
	  return this.castForQuery(val);
	}
	
	function cast$elemMatch(val) {
	  var keys = Object.keys(val);
	  var numKeys = keys.length;
	  var key;
	  var value;
	  for (var i = 0; i < numKeys; ++i) {
	    key = keys[i];
	    value = val[key];
	    if (key.indexOf('$') === 0 && value) {
	      val[key] = this.castForQuery(key, value);
	    }
	  }
	
	  return cast(this.casterConstructor.schema, val);
	}
	
	var handle = SchemaArray.prototype.$conditionalHandlers = {};
	
	handle.$all = cast$all;
	handle.$options = String;
	handle.$elemMatch = cast$elemMatch;
	handle.$geoIntersects = geospatial.cast$geoIntersects;
	handle.$or = handle.$and = function(val) {
	  if (!Array.isArray(val)) {
	    throw new TypeError('conditional $or/$and require array');
	  }
	
	  var ret = [];
	  for (var i = 0; i < val.length; ++i) {
	    ret.push(cast(this.casterConstructor.schema, val[i]));
	  }
	
	  return ret;
	};
	
	handle.$near =
	handle.$nearSphere = geospatial.cast$near;
	
	handle.$within =
	handle.$geoWithin = geospatial.cast$within;
	
	handle.$size =
	handle.$minDistance =
	handle.$maxDistance = castToNumber;
	
	handle.$eq =
	handle.$gt =
	handle.$gte =
	handle.$in =
	handle.$lt =
	handle.$lte =
	handle.$ne =
	handle.$nin =
	handle.$regex = SchemaArray.prototype.castForQuery;
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaArray;


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module requirements.
	 */
	
	var MongooseError = __webpack_require__(119);
	var utils = __webpack_require__(223);
	
	var SchemaType = __webpack_require__(231);
	
	var CastError = SchemaType.CastError;
	
	/**
	 * Date SchemaType constructor.
	 *
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function SchemaDate(key, options) {
	  SchemaType.call(this, key, options, 'Date');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	SchemaDate.schemaName = 'Date';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaDate.prototype = Object.create(SchemaType.prototype);
	SchemaDate.prototype.constructor = SchemaDate;
	
	/**
	 * Declares a TTL index (rounded to the nearest second) for _Date_ types only.
	 *
	 * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.
	 * This index type is only compatible with Date types.
	 *
	 * ####Example:
	 *
	 *     // expire in 24 hours
	 *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});
	 *
	 * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:
	 *
	 * ####Example:
	 *
	 *     // expire in 24 hours
	 *     new Schema({ createdAt: { type: Date, expires: '24h' }});
	 *
	 *     // expire in 1.5 hours
	 *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});
	 *
	 *     // expire in 7 days
	 *     var schema = new Schema({ createdAt: Date });
	 *     schema.path('createdAt').expires('7d');
	 *
	 * @param {Number|String} when
	 * @added 3.0.0
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaDate.prototype.expires = function(when) {
	  if (!this._index || this._index.constructor.name !== 'Object') {
	    this._index = {};
	  }
	
	  this._index.expires = when;
	  utils.expires(this._index);
	  return this;
	};
	
	/**
	 * Check if the given value satisfies a required validator. To satisfy
	 * a required validator, the given value must be an instance of `Date`.
	 *
	 * @param {Any} value
	 * @param {Document} doc
	 * @return {Boolean}
	 * @api public
	 */
	
	SchemaDate.prototype.checkRequired = function(value) {
	  return value instanceof Date;
	};
	
	/**
	 * Sets a minimum date validator.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ d: { type: Date, min: Date('1970-01-01') })
	 *     var M = db.model('M', s)
	 *     var m = new M({ d: Date('1969-12-31') })
	 *     m.save(function (err) {
	 *       console.error(err) // validator error
	 *       m.d = Date('2014-12-08');
	 *       m.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MIN} token which will be replaced with the invalid value
	 *     var min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];
	 *     var schema = new Schema({ d: { type: Date, min: min })
	 *     var M = mongoose.model('M', schema);
	 *     var s= new M({ d: Date('1969-12-31') });
	 *     s.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).
	 *     })
	 *
	 * @param {Date} value minimum date
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaDate.prototype.min = function(value, message) {
	  if (this.minValidator) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.minValidator;
	    }, this);
	  }
	
	  if (value) {
	    var msg = message || MongooseError.messages.Date.min;
	    msg = msg.replace(/{MIN}/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));
	    var _this = this;
	    this.validators.push({
	      validator: this.minValidator = function(val) {
	        var min = (value === Date.now ? value() : _this.cast(value));
	        return val === null || val.valueOf() >= min.valueOf();
	      },
	      message: msg,
	      type: 'min',
	      min: value
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Sets a maximum date validator.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ d: { type: Date, max: Date('2014-01-01') })
	 *     var M = db.model('M', s)
	 *     var m = new M({ d: Date('2014-12-08') })
	 *     m.save(function (err) {
	 *       console.error(err) // validator error
	 *       m.d = Date('2013-12-31');
	 *       m.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MAX} token which will be replaced with the invalid value
	 *     var max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];
	 *     var schema = new Schema({ d: { type: Date, max: max })
	 *     var M = mongoose.model('M', schema);
	 *     var s= new M({ d: Date('2014-12-08') });
	 *     s.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).
	 *     })
	 *
	 * @param {Date} maximum date
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaDate.prototype.max = function(value, message) {
	  if (this.maxValidator) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.maxValidator;
	    }, this);
	  }
	
	  if (value) {
	    var msg = message || MongooseError.messages.Date.max;
	    msg = msg.replace(/{MAX}/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));
	    var _this = this;
	    this.validators.push({
	      validator: this.maxValidator = function(val) {
	        var max = (value === Date.now ? value() : _this.cast(value));
	        return val === null || val.valueOf() <= max.valueOf();
	      },
	      message: msg,
	      type: 'max',
	      max: value
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Casts to date
	 *
	 * @param {Object} value to cast
	 * @api private
	 */
	
	SchemaDate.prototype.cast = function(value) {
	  // If null or undefined
	  if (value === null || value === void 0 || value === '') {
	    return null;
	  }
	
	  if (value instanceof Date) {
	    return value;
	  }
	
	  var date;
	
	  if (typeof value === 'boolean') {
	    throw new CastError('date', value, this.path);
	  }
	
	  if (value instanceof Number || typeof value === 'number'
	      || String(value) == Number(value)) {
	    // support for timestamps
	    date = new Date(Number(value));
	  } else if (value.valueOf) {
	    // support for moment.js
	    date = new Date(value.valueOf());
	  }
	
	  if (!isNaN(date.valueOf())) {
	    return date;
	  }
	
	  throw new CastError('date', value, this.path);
	};
	
	/*!
	 * Date Query casting.
	 *
	 * @api private
	 */
	
	function handleSingle(val) {
	  return this.cast(val);
	}
	
	SchemaDate.prototype.$conditionalHandlers =
	    utils.options(SchemaType.prototype.$conditionalHandlers, {
	      $gt: handleSingle,
	      $gte: handleSingle,
	      $lt: handleSingle,
	      $lte: handleSingle
	    });
	
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [value]
	 * @api private
	 */
	
	SchemaDate.prototype.castForQuery = function($conditional, val) {
	  var handler;
	
	  if (arguments.length !== 2) {
	    return this.cast($conditional);
	  }
	
	  handler = this.$conditionalHandlers[$conditional];
	
	  if (!handler) {
	    throw new Error('Can\'t use ' + $conditional + ' with Date.');
	  }
	
	  return handler.call(this, val);
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaDate;


/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module dependencies.
	 */
	
	var handleBitwiseOperator = __webpack_require__(275);
	var utils = __webpack_require__(223);
	
	var MongooseBuffer = __webpack_require__(258).Buffer;
	var SchemaType = __webpack_require__(231);
	
	var Binary = MongooseBuffer.Binary;
	var CastError = SchemaType.CastError;
	var Document;
	
	/**
	 * Buffer SchemaType constructor
	 *
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function SchemaBuffer(key, options) {
	  SchemaType.call(this, key, options, 'Buffer');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	SchemaBuffer.schemaName = 'Buffer';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaBuffer.prototype = Object.create(SchemaType.prototype);
	SchemaBuffer.prototype.constructor = SchemaBuffer;
	
	/**
	 * Check if the given value satisfies a required validator. To satisfy a
	 * required validator, a buffer must not be null or undefined and have
	 * non-zero length.
	 *
	 * @param {Any} value
	 * @param {Document} doc
	 * @return {Boolean}
	 * @api public
	 */
	
	SchemaBuffer.prototype.checkRequired = function(value, doc) {
	  if (SchemaType._isRef(this, value, doc, true)) {
	    return !!value;
	  }
	  return !!(value && value.length);
	};
	
	/**
	 * Casts contents
	 *
	 * @param {Object} value
	 * @param {Document} doc document that triggers the casting
	 * @param {Boolean} init
	 * @api private
	 */
	
	SchemaBuffer.prototype.cast = function(value, doc, init) {
	  var ret;
	  if (SchemaType._isRef(this, value, doc, init)) {
	    // wait! we may need to cast this to a document
	
	    if (value === null || value === undefined) {
	      return value;
	    }
	
	    // lazy load
	    Document || (Document = __webpack_require__(229));
	
	    if (value instanceof Document) {
	      value.$__.wasPopulated = true;
	      return value;
	    }
	
	    // setting a populated path
	    if (Buffer.isBuffer(value)) {
	      return value;
	    } else if (!utils.isObject(value)) {
	      throw new CastError('buffer', value, this.path);
	    }
	
	    // Handle the case where user directly sets a populated
	    // path to a plain object; cast to the Model used in
	    // the population query.
	    var path = doc.$__fullPath(this.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    var pop = owner.populated(path, true);
	    ret = new pop.options.model(value);
	    ret.$__.wasPopulated = true;
	    return ret;
	  }
	
	  // documents
	  if (value && value._id) {
	    value = value._id;
	  }
	
	  if (value && value.isMongooseBuffer) {
	    return value;
	  }
	
	  if (Buffer.isBuffer(value)) {
	    if (!value || !value.isMongooseBuffer) {
	      value = new MongooseBuffer(value, [this.path, doc]);
	    }
	
	    return value;
	  } else if (value instanceof Binary) {
	    ret = new MongooseBuffer(value.value(true), [this.path, doc]);
	    if (typeof value.sub_type !== 'number') {
	      throw new CastError('buffer', value, this.path);
	    }
	    ret._subtype = value.sub_type;
	    return ret;
	  }
	
	  if (value === null) {
	    return value;
	  }
	
	  var type = typeof value;
	  if (type === 'string' || type === 'number' || Array.isArray(value)) {
	    if (type === 'number') {
	      value = [value];
	    }
	    ret = new MongooseBuffer(value, [this.path, doc]);
	    return ret;
	  }
	
	  throw new CastError('buffer', value, this.path);
	};
	
	/*!
	 * ignore
	 */
	function handleSingle(val) {
	  return this.castForQuery(val);
	}
	
	SchemaBuffer.prototype.$conditionalHandlers =
	    utils.options(SchemaType.prototype.$conditionalHandlers, {
	      $bitsAllClear: handleBitwiseOperator,
	      $bitsAnyClear: handleBitwiseOperator,
	      $bitsAllSet: handleBitwiseOperator,
	      $bitsAnySet: handleBitwiseOperator,
	      $gt: handleSingle,
	      $gte: handleSingle,
	      $lt: handleSingle,
	      $lte: handleSingle
	    });
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [value]
	 * @api private
	 */
	
	SchemaBuffer.prototype.castForQuery = function($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler) {
	      throw new Error('Can\'t use ' + $conditional + ' with Buffer.');
	    }
	    return handler.call(this, val);
	  }
	  val = $conditional;
	  return this.cast(val).toObject();
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaBuffer;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var utils = __webpack_require__(223);
	var Types = __webpack_require__(272);
	
	/**
	 * Handles internal casting for queries
	 *
	 * @param {Schema} schema
	 * @param {Object} obj Object to cast
	 * @api private
	 */
	module.exports = function cast(schema, obj) {
	  var paths = Object.keys(obj),
	      i = paths.length,
	      any$conditionals,
	      schematype,
	      nested,
	      path,
	      type,
	      val;
	
	  while (i--) {
	    path = paths[i];
	    val = obj[path];
	
	    if (path === '$or' || path === '$nor' || path === '$and') {
	      var k = val.length;
	
	      while (k--) {
	        val[k] = cast(schema, val[k]);
	      }
	    } else if (path === '$where') {
	      type = typeof val;
	
	      if (type !== 'string' && type !== 'function') {
	        throw new Error('Must have a string or function for $where');
	      }
	
	      if (type === 'function') {
	        obj[path] = val.toString();
	      }
	
	      continue;
	    } else if (path === '$elemMatch') {
	      val = cast(schema, val);
	    } else {
	      if (!schema) {
	        // no casting for Mixed types
	        continue;
	      }
	
	      schematype = schema.path(path);
	
	      if (!schematype) {
	        // Handle potential embedded array queries
	        var split = path.split('.'),
	            j = split.length,
	            pathFirstHalf,
	            pathLastHalf,
	            remainingConds;
	
	        // Find the part of the var path that is a path of the Schema
	        while (j--) {
	          pathFirstHalf = split.slice(0, j).join('.');
	          schematype = schema.path(pathFirstHalf);
	          if (schematype) {
	            break;
	          }
	        }
	
	        // If a substring of the input path resolves to an actual real path...
	        if (schematype) {
	          // Apply the casting; similar code for $elemMatch in schema/array.js
	          if (schematype.caster && schematype.caster.schema) {
	            remainingConds = {};
	            pathLastHalf = split.slice(j).join('.');
	            remainingConds[pathLastHalf] = val;
	            obj[path] = cast(schematype.caster.schema, remainingConds)[pathLastHalf];
	          } else {
	            obj[path] = val;
	          }
	          continue;
	        }
	
	        if (utils.isObject(val)) {
	          // handle geo schemas that use object notation
	          // { loc: { long: Number, lat: Number }
	
	          var geo = val.$near ? '$near' :
	                    val.$nearSphere ? '$nearSphere' :
	                    val.$within ? '$within' :
	                    val.$geoIntersects ? '$geoIntersects' : '';
	
	          if (!geo) {
	            continue;
	          }
	
	          var numbertype = new Types.Number('__QueryCasting__');
	          var value = val[geo];
	
	          if (val.$maxDistance != null) {
	            val.$maxDistance = numbertype.castForQuery(val.$maxDistance);
	          }
	          if (val.$minDistance != null) {
	            val.$minDistance = numbertype.castForQuery(val.$minDistance);
	          }
	
	          if (geo === '$within') {
	            var withinType = value.$center
	                || value.$centerSphere
	                || value.$box
	                || value.$polygon;
	
	            if (!withinType) {
	              throw new Error('Bad $within paramater: ' + JSON.stringify(val));
	            }
	
	            value = withinType;
	          } else if (geo === '$near' &&
	              typeof value.type === 'string' && Array.isArray(value.coordinates)) {
	            // geojson; cast the coordinates
	            value = value.coordinates;
	          } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&
	              value.$geometry && typeof value.$geometry.type === 'string' &&
	              Array.isArray(value.$geometry.coordinates)) {
	            if (value.$maxDistance != null) {
	              value.$maxDistance = numbertype.castForQuery(value.$maxDistance);
	            }
	            if (value.$minDistance != null) {
	              value.$minDistance = numbertype.castForQuery(value.$minDistance);
	            }
	            value = value.$geometry.coordinates;
	          }
	
	          _cast(value, numbertype);
	        }
	      } else if (val === null || val === undefined) {
	        obj[path] = null;
	        continue;
	      } else if (val.constructor.name === 'Object') {
	        any$conditionals = Object.keys(val).some(function(k) {
	          return k.charAt(0) === '$' && k !== '$id' && k !== '$ref';
	        });
	
	        if (!any$conditionals) {
	          obj[path] = schematype.castForQuery(val);
	        } else {
	          var ks = Object.keys(val),
	              $cond;
	
	          k = ks.length;
	
	          while (k--) {
	            $cond = ks[k];
	            nested = val[$cond];
	
	            if ($cond === '$exists') {
	              if (typeof nested !== 'boolean') {
	                throw new Error('$exists parameter must be Boolean');
	              }
	              continue;
	            }
	
	            if ($cond === '$type') {
	              if (typeof nested !== 'number' && typeof nested !== 'string') {
	                throw new Error('$type parameter must be number or string');
	              }
	              continue;
	            }
	
	            if ($cond === '$not') {
	              cast(schema, nested);
	            } else {
	              val[$cond] = schematype.castForQuery($cond, nested);
	            }
	          }
	        }
	      } else {
	        obj[path] = schematype.castForQuery(val);
	      }
	    }
	  }
	
	  return obj;
	};
	
	function _cast(val, numbertype) {
	  if (Array.isArray(val)) {
	    val.forEach(function(item, i) {
	      if (Array.isArray(item) || utils.isObject(item)) {
	        return _cast(item, numbertype);
	      }
	      val[i] = numbertype.castForQuery(item);
	    });
	  } else {
	    var nearKeys = Object.keys(val);
	    var nearLen = nearKeys.length;
	    while (nearLen--) {
	      var nkey = nearKeys[nearLen];
	      var item = val[nkey];
	      if (Array.isArray(item) || utils.isObject(item)) {
	        _cast(item, numbertype);
	        val[nkey] = item;
	      } else {
	        val[nkey] = numbertype.castForQuery(item);
	      }
	    }
	  }
	}


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/*!
	 * Module requirements.
	 */
	
	var Types = {
	  Number: __webpack_require__(274)
	};
	
	/*!
	 * @ignore
	 */
	
	exports.castToNumber = castToNumber;
	exports.castArraysOfNumbers = castArraysOfNumbers;
	
	/*!
	 * @ignore
	 */
	
	function castToNumber(val) {
	  return Types.Number.prototype.cast.call(this, val);
	}
	
	function castArraysOfNumbers(arr, self) {
	  arr.forEach(function(v, i) {
	    if (Array.isArray(v)) {
	      castArraysOfNumbers(v, self);
	    } else {
	      arr[i] = castToNumber.call(self, v);
	    }
	  });
	}


/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module requirements.
	 */
	
	var castArraysOfNumbers = __webpack_require__(282).castArraysOfNumbers;
	var castToNumber = __webpack_require__(282).castToNumber;
	
	/*!
	 * ignore
	 */
	
	exports.cast$geoIntersects = cast$geoIntersects;
	exports.cast$near = cast$near;
	exports.cast$within = cast$within;
	
	function cast$near(val) {
	  var SchemaArray = __webpack_require__(278);
	
	  if (Array.isArray(val)) {
	    castArraysOfNumbers(val, this);
	    return val;
	  }
	
	  _castMinMaxDistance(this, val);
	
	  if (val && val.$geometry) {
	    return cast$geometry(val, this);
	  }
	
	  return SchemaArray.prototype.castForQuery.call(this, val);
	}
	
	function cast$geometry(val, self) {
	  switch (val.$geometry.type) {
	    case 'Polygon':
	    case 'LineString':
	    case 'Point':
	      castArraysOfNumbers(val.$geometry.coordinates, self);
	      break;
	    default:
	      // ignore unknowns
	      break;
	  }
	
	  _castMinMaxDistance(this, val);
	
	  return val;
	}
	
	function cast$within(val) {
	  _castMinMaxDistance(this, val);
	
	  if (val.$box || val.$polygon) {
	    var type = val.$box ? '$box' : '$polygon';
	    val[type].forEach(function(arr) {
	      if (!Array.isArray(arr)) {
	        var msg = 'Invalid $within $box argument. '
	            + 'Expected an array, received ' + arr;
	        throw new TypeError(msg);
	      }
	      arr.forEach(function(v, i) {
	        arr[i] = castToNumber.call(this, v);
	      });
	    });
	  } else if (val.$center || val.$centerSphere) {
	    type = val.$center ? '$center' : '$centerSphere';
	    val[type].forEach(function(item, i) {
	      if (Array.isArray(item)) {
	        item.forEach(function(v, j) {
	          item[j] = castToNumber.call(this, v);
	        });
	      } else {
	        val[type][i] = castToNumber.call(this, item);
	      }
	    });
	  } else if (val.$geometry) {
	    cast$geometry(val, this);
	  }
	
	  return val;
	}
	
	function cast$geoIntersects(val) {
	  var geo = val.$geometry;
	  if (!geo) {
	    return;
	  }
	
	  cast$geometry(val, this);
	  return val;
	}
	
	function _castMinMaxDistance(self, val) {
	  if (val.$maxDistance) {
	    val.$maxDistance = castToNumber.call(self, val.$maxDistance);
	  }
	  if (val.$minDistance) {
	    val.$minDistance = castToNumber.call(self, val.$minDistance);
	  }
	}


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/*!
	 * Module dependencies.
	 */
	
	var SchemaType = __webpack_require__(231);
	var Subdocument = __webpack_require__(260);
	var castToNumber = __webpack_require__(282).castToNumber;
	var geospatial = __webpack_require__(283);
	
	module.exports = Embedded;
	
	/**
	 * Sub-schema schematype constructor
	 *
	 * @param {Schema} schema
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function Embedded(schema, path, options) {
	  var _embedded = function(value, path, parent) {
	    var _this = this;
	    Subdocument.apply(this, arguments);
	    this.$parent = parent;
	    if (parent) {
	      parent.on('save', function() {
	        _this.emit('save', _this);
	      });
	    }
	  };
	  _embedded.prototype = Object.create(Subdocument.prototype);
	  _embedded.prototype.$__setSchema(schema);
	  _embedded.schema = schema;
	  _embedded.$isSingleNested = true;
	  _embedded.prototype.$basePath = path;
	
	  // apply methods
	  for (var i in schema.methods) {
	    _embedded.prototype[i] = schema.methods[i];
	  }
	
	  // apply statics
	  for (i in schema.statics) {
	    _embedded[i] = schema.statics[i];
	  }
	
	  this.caster = _embedded;
	  this.schema = schema;
	  this.$isSingleNested = true;
	  SchemaType.call(this, path, options, 'Embedded');
	}
	
	Embedded.prototype = Object.create(SchemaType.prototype);
	
	/**
	 * Special case for when users use a common location schema to represent
	 * locations for use with $geoWithin.
	 * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/
	 *
	 * @param {Object} val
	 * @api private
	 */
	
	Embedded.prototype.$conditionalHandlers.$geoWithin = function(val) {
	  return { $geometry: this.castForQuery(val.$geometry) };
	};
	
	/*!
	 * ignore
	 */
	
	Embedded.prototype.$conditionalHandlers.$near =
	Embedded.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;
	
	Embedded.prototype.$conditionalHandlers.$within =
	Embedded.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;
	
	Embedded.prototype.$conditionalHandlers.$geoIntersects =
	  geospatial.cast$geoIntersects;
	
	Embedded.prototype.$conditionalHandlers.$minDistance = castToNumber;
	Embedded.prototype.$conditionalHandlers.$maxDistance = castToNumber;
	
	/**
	 * Casts contents
	 *
	 * @param {Object} value
	 * @api private
	 */
	
	Embedded.prototype.cast = function(val, doc, init) {
	  if (val && val.$isSingleNested) {
	    return val;
	  }
	  var subdoc = new this.caster(void 0, doc ? doc.$__.selected : void 0, doc);
	  if (init) {
	    subdoc.init(val);
	  } else {
	    subdoc.set(val, undefined, true);
	  }
	  return subdoc;
	};
	
	/**
	 * Casts contents for query
	 *
	 * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)
	 * @param {any} value
	 * @api private
	 */
	
	Embedded.prototype.castForQuery = function($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler) {
	      throw new Error('Can\'t use ' + $conditional);
	    }
	    return handler.call(this, val);
	  }
	  val = $conditional;
	  if (val == null) {
	    return val;
	  }
	  return new this.caster(val).toObject({virtuals: false});
	};
	
	/**
	 * Async validation on this single nested doc.
	 *
	 * @api private
	 */
	
	Embedded.prototype.doValidate = function(value, fn) {
	  SchemaType.prototype.doValidate.call(this, value, function(error) {
	    if (error) {
	      return fn(error);
	    }
	    if (!value) {
	      return fn(null);
	    }
	    value.validate(fn, {__noPromise: true});
	  });
	};
	
	/**
	 * Synchronously validate this single nested doc
	 *
	 * @api private
	 */
	
	Embedded.prototype.doValidateSync = function(value) {
	  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value);
	  if (schemaTypeError) {
	    return schemaTypeError;
	  }
	  if (!value) {
	    return;
	  }
	  return value.validateSync();
	};


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	var express = __webpack_require__(1);
	var bodyParser = __webpack_require__(286);
	
	module.exports = function(app) {
	  app.use(express.static('public'));
	  app.use(bodyParser.json());
	  app.use(bodyParser.urlencoded({
	    extended: false
	  }));
	};


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * body-parser
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var deprecate = __webpack_require__(30)('body-parser')
	
	/**
	 * Cache of loaded parsers.
	 * @private
	 */
	
	var parsers = Object.create(null)
	
	/**
	 * @typedef Parsers
	 * @type {function}
	 * @property {function} json
	 * @property {function} raw
	 * @property {function} text
	 * @property {function} urlencoded
	 */
	
	/**
	 * Module exports.
	 * @type {Parsers}
	 */
	
	exports = module.exports = deprecate.function(bodyParser,
	  'bodyParser: use individual json/urlencoded middlewares')
	
	/**
	 * JSON parser.
	 * @public
	 */
	
	Object.defineProperty(exports, 'json', {
	  configurable: true,
	  enumerable: true,
	  get: createParserGetter('json')
	})
	
	/**
	 * Raw parser.
	 * @public
	 */
	
	Object.defineProperty(exports, 'raw', {
	  configurable: true,
	  enumerable: true,
	  get: createParserGetter('raw')
	})
	
	/**
	 * Text parser.
	 * @public
	 */
	
	Object.defineProperty(exports, 'text', {
	  configurable: true,
	  enumerable: true,
	  get: createParserGetter('text')
	})
	
	/**
	 * URL-encoded parser.
	 * @public
	 */
	
	Object.defineProperty(exports, 'urlencoded', {
	  configurable: true,
	  enumerable: true,
	  get: createParserGetter('urlencoded')
	})
	
	/**
	 * Create a middleware to parse json and urlencoded bodies.
	 *
	 * @param {object} [options]
	 * @return {function}
	 * @deprecated
	 * @public
	 */
	
	function bodyParser (options) {
	  var opts = {}
	
	  // exclude type option
	  if (options) {
	    for (var prop in options) {
	      if (prop !== 'type') {
	        opts[prop] = options[prop]
	      }
	    }
	  }
	
	  var _urlencoded = exports.urlencoded(opts)
	  var _json = exports.json(opts)
	
	  return function bodyParser (req, res, next) {
	    _json(req, res, function (err) {
	      if (err) return next(err)
	      _urlencoded(req, res, next)
	    })
	  }
	}
	
	/**
	 * Create a getter for loading a parser.
	 * @private
	 */
	
	function createParserGetter (name) {
	  return function get () {
	    return loadParser(name)
	  }
	}
	
	/**
	 * Load a parser module.
	 * @private
	 */
	
	function loadParser (parserName) {
	  var parser = parsers[parserName]
	
	  if (parser !== undefined) {
	    return parser
	  }
	
	  // this uses a switch for static require analysis
	  switch (parserName) {
	    case 'json':
	      parser = __webpack_require__(287)
	      break
	    case 'raw':
	      parser = __webpack_require__(331)
	      break
	    case 'text':
	      parser = __webpack_require__(332)
	      break
	    case 'urlencoded':
	      parser = __webpack_require__(333)
	      break
	  }
	
	  // store to prevent invoking require()
	  return (parsers[parserName] = parser)
	}


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * body-parser
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var bytes = __webpack_require__(288)
	var contentType = __webpack_require__(48)
	var createError = __webpack_require__(50)
	var debug = __webpack_require__(13)('body-parser:json')
	var read = __webpack_require__(289)
	var typeis = __webpack_require__(105)
	
	/**
	 * Module exports.
	 */
	
	module.exports = json
	
	/**
	 * RegExp to match the first non-space in a string.
	 *
	 * Allowed whitespace is defined in RFC 7159:
	 *
	 *    ws = *(
	 *            %x20 /              ; Space
	 *            %x09 /              ; Horizontal tab
	 *            %x0A /              ; Line feed or New line
	 *            %x0D )              ; Carriage return
	 */
	
	var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*(.)/ // eslint-disable-line no-control-regex
	
	/**
	 * Create a middleware to parse JSON bodies.
	 *
	 * @param {object} [options]
	 * @return {function}
	 * @public
	 */
	
	function json (options) {
	  var opts = options || {}
	
	  var limit = typeof opts.limit !== 'number'
	    ? bytes.parse(opts.limit || '100kb')
	    : opts.limit
	  var inflate = opts.inflate !== false
	  var reviver = opts.reviver
	  var strict = opts.strict !== false
	  var type = opts.type || 'application/json'
	  var verify = opts.verify || false
	
	  if (verify !== false && typeof verify !== 'function') {
	    throw new TypeError('option verify must be function')
	  }
	
	  // create the appropriate type checking function
	  var shouldParse = typeof type !== 'function'
	    ? typeChecker(type)
	    : type
	
	  function parse (body) {
	    if (body.length === 0) {
	      // special-case empty json body, as it's a common client-side mistake
	      // TODO: maybe make this configurable or part of "strict" option
	      return {}
	    }
	
	    if (strict) {
	      var first = firstchar(body)
	
	      if (first !== '{' && first !== '[') {
	        debug('strict violation')
	        throw new SyntaxError('Unexpected token ' + first)
	      }
	    }
	
	    debug('parse json')
	    return JSON.parse(body, reviver)
	  }
	
	  return function jsonParser (req, res, next) {
	    if (req._body) {
	      debug('body already parsed')
	      next()
	      return
	    }
	
	    req.body = req.body || {}
	
	    // skip requests without bodies
	    if (!typeis.hasBody(req)) {
	      debug('skip empty body')
	      next()
	      return
	    }
	
	    debug('content-type %j', req.headers['content-type'])
	
	    // determine if request should be parsed
	    if (!shouldParse(req)) {
	      debug('skip parsing')
	      next()
	      return
	    }
	
	    // assert charset per RFC 7159 sec 8.1
	    var charset = getCharset(req) || 'utf-8'
	    if (charset.substr(0, 4) !== 'utf-') {
	      debug('invalid charset')
	      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
	        charset: charset
	      }))
	      return
	    }
	
	    // read
	    read(req, res, next, parse, debug, {
	      encoding: charset,
	      inflate: inflate,
	      limit: limit,
	      verify: verify
	    })
	  }
	}
	
	/**
	 * Get the first non-whitespace character in a string.
	 *
	 * @param {string} str
	 * @return {function}
	 * @api public
	 */
	
	function firstchar (str) {
	  var match = FIRST_CHAR_REGEXP.exec(str)
	  return match ? match[1] : ''
	}
	
	/**
	 * Get the charset of a request.
	 *
	 * @param {object} req
	 * @api private
	 */
	
	function getCharset (req) {
	  try {
	    return contentType.parse(req).parameters.charset.toLowerCase()
	  } catch (e) {
	    return undefined
	  }
	}
	
	/**
	 * Get the simple type checker.
	 *
	 * @param {string} type
	 * @return {function}
	 */
	
	function typeChecker (type) {
	  return function checkType (req) {
	    return Boolean(typeis(req, type))
	  }
	}


/***/ },
/* 288 */
/***/ function(module, exports) {

	/*!
	 * bytes
	 * Copyright(c) 2012-2014 TJ Holowaychuk
	 * Copyright(c) 2015 Jed Watson
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = bytes;
	module.exports.format = format;
	module.exports.parse = parse;
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
	
	var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
	
	var map = {
	  b:  1,
	  kb: 1 << 10,
	  mb: 1 << 20,
	  gb: 1 << 30,
	  tb: ((1 << 30) * 1024)
	};
	
	// TODO: use is-finite module?
	var numberIsFinite = Number.isFinite || function (v) { return typeof v === 'number' && isFinite(v); };
	
	var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb)$/i;
	
	/**
	 * Convert the given value in bytes into a string or parse to string to an integer in bytes.
	 *
	 * @param {string|number} value
	 * @param {{
	 *  case: [string],
	 *  decimalPlaces: [number]
	 *  fixedDecimals: [boolean]
	 *  thousandsSeparator: [string]
	 *  unitSeparator: [string]
	 *  }} [options] bytes options.
	 *
	 * @returns {string|number|null}
	 */
	
	function bytes(value, options) {
	  if (typeof value === 'string') {
	    return parse(value);
	  }
	
	  if (typeof value === 'number') {
	    return format(value, options);
	  }
	
	  return null;
	}
	
	/**
	 * Format the given value in bytes into a string.
	 *
	 * If the value is negative, it is kept as such. If it is a float,
	 * it is rounded.
	 *
	 * @param {number} value
	 * @param {object} [options]
	 * @param {number} [options.decimalPlaces=2]
	 * @param {number} [options.fixedDecimals=false]
	 * @param {string} [options.thousandsSeparator=]
	 * @param {string} [options.unitSeparator=]
	 *
	 * @returns {string|null}
	 * @public
	 */
	
	function format(value, options) {
	  if (!numberIsFinite(value)) {
	    return null;
	  }
	
	  var mag = Math.abs(value);
	  var thousandsSeparator = (options && options.thousandsSeparator) || '';
	  var unitSeparator = (options && options.unitSeparator) || '';
	  var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;
	  var fixedDecimals = Boolean(options && options.fixedDecimals);
	  var unit = 'B';
	
	  if (mag >= map.tb) {
	    unit = 'TB';
	  } else if (mag >= map.gb) {
	    unit = 'GB';
	  } else if (mag >= map.mb) {
	    unit = 'MB';
	  } else if (mag >= map.kb) {
	    unit = 'kB';
	  }
	
	  var val = value / map[unit.toLowerCase()];
	  var str = val.toFixed(decimalPlaces);
	
	  if (!fixedDecimals) {
	    str = str.replace(formatDecimalsRegExp, '$1');
	  }
	
	  if (thousandsSeparator) {
	    str = str.replace(formatThousandsRegExp, thousandsSeparator);
	  }
	
	  return str + unitSeparator + unit;
	}
	
	/**
	 * Parse the string value into an integer in bytes.
	 *
	 * If no unit is given, it is assumed the value is in bytes.
	 *
	 * @param {number|string} val
	 *
	 * @returns {number|null}
	 * @public
	 */
	
	function parse(val) {
	  if (typeof val === 'number' && !isNaN(val)) {
	    return val;
	  }
	
	  if (typeof val !== 'string') {
	    return null;
	  }
	
	  // Test if the string passed is valid
	  var results = parseRegExp.exec(val);
	  var floatValue;
	  var unit = 'b';
	
	  if (!results) {
	    // Nothing could be extracted from the given string
	    floatValue = parseInt(val, 10);
	    unit = 'b'
	  } else {
	    // Retrieve the value and the unit
	    floatValue = parseFloat(results[1]);
	    unit = results[4].toLowerCase();
	  }
	
	  return Math.floor(map[unit] * floatValue);
	}


/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * body-parser
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var createError = __webpack_require__(50)
	var getBody = __webpack_require__(290)
	var iconv = __webpack_require__(291)
	var onFinished = __webpack_require__(17)
	var zlib = __webpack_require__(312)
	
	/**
	 * Module exports.
	 */
	
	module.exports = read
	
	/**
	 * Read a request into a buffer and parse.
	 *
	 * @param {object} req
	 * @param {object} res
	 * @param {function} next
	 * @param {function} parse
	 * @param {function} debug
	 * @param {object} [options]
	 * @api private
	 */
	
	function read (req, res, next, parse, debug, options) {
	  var length
	  var opts = options || {}
	  var stream
	
	  // flag as parsed
	  req._body = true
	
	  // read options
	  var encoding = opts.encoding !== null
	    ? opts.encoding || 'utf-8'
	    : null
	  var verify = opts.verify
	
	  try {
	    // get the content stream
	    stream = contentstream(req, debug, opts.inflate)
	    length = stream.length
	    stream.length = undefined
	  } catch (err) {
	    return next(err)
	  }
	
	  // set raw-body options
	  opts.length = length
	  opts.encoding = verify
	    ? null
	    : encoding
	
	  // assert charset is supported
	  if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
	    return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
	      charset: encoding.toLowerCase()
	    }))
	  }
	
	  // read body
	  debug('read body')
	  getBody(stream, opts, function (err, body) {
	    if (err) {
	      // default to 400
	      setErrorStatus(err, 400)
	
	      // echo back charset
	      if (err.type === 'encoding.unsupported') {
	        err = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
	          charset: encoding.toLowerCase()
	        })
	      }
	
	      // read off entire request
	      stream.resume()
	      onFinished(req, function onfinished () {
	        next(err)
	      })
	      return
	    }
	
	    // verify
	    if (verify) {
	      try {
	        debug('verify body')
	        verify(req, res, body, encoding)
	      } catch (err) {
	        // default to 403
	        setErrorStatus(err, 403)
	        next(err)
	        return
	      }
	    }
	
	    // parse
	    var str
	    try {
	      debug('parse body')
	      str = typeof body !== 'string' && encoding !== null
	        ? iconv.decode(body, encoding)
	        : body
	      req.body = parse(str)
	    } catch (err) {
	      err.body = str === undefined
	        ? body
	        : str
	
	      // default to 400
	      setErrorStatus(err, 400)
	
	      next(err)
	      return
	    }
	
	    next()
	  })
	}
	
	/**
	 * Get the content stream of the request.
	 *
	 * @param {object} req
	 * @param {function} debug
	 * @param {boolean} [inflate=true]
	 * @return {object}
	 * @api private
	 */
	
	function contentstream (req, debug, inflate) {
	  var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase()
	  var length = req.headers['content-length']
	  var stream
	
	  debug('content-encoding "%s"', encoding)
	
	  if (inflate === false && encoding !== 'identity') {
	    throw createError(415, 'content encoding unsupported')
	  }
	
	  switch (encoding) {
	    case 'deflate':
	      stream = zlib.createInflate()
	      debug('inflate body')
	      req.pipe(stream)
	      break
	    case 'gzip':
	      stream = zlib.createGunzip()
	      debug('gunzip body')
	      req.pipe(stream)
	      break
	    case 'identity':
	      stream = req
	      stream.length = length
	      break
	    default:
	      throw createError(415, 'unsupported content encoding "' + encoding + '"', {
	        encoding: encoding
	      })
	  }
	
	  return stream
	}
	
	/**
	 * Set a status on an error object, if ones does not exist
	 * @private
	 */
	
	function setErrorStatus (error, status) {
	  if (!error.status && !error.statusCode) {
	    error.status = status
	    error.statusCode = status
	  }
	}


/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process, Buffer) {/*!
	 * raw-body
	 * Copyright(c) 2013-2014 Jonathan Ong
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var bytes = __webpack_require__(288)
	var iconv = __webpack_require__(291)
	var unpipe = __webpack_require__(21)
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = getRawBody
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var iconvEncodingMessageRegExp = /^Encoding not recognized: /
	
	/**
	 * Get the decoder for a given encoding.
	 *
	 * @param {string} encoding
	 * @private
	 */
	
	function getDecoder (encoding) {
	  if (!encoding) return null
	
	  try {
	    return iconv.getDecoder(encoding)
	  } catch (e) {
	    // error getting decoder
	    if (!iconvEncodingMessageRegExp.test(e.message)) throw e
	
	    // the encoding was not found
	    throw createError(415, 'specified encoding unsupported', 'encoding.unsupported', {
	      encoding: encoding
	    })
	  }
	}
	
	/**
	 * Get the raw body of a stream (typically HTTP).
	 *
	 * @param {object} stream
	 * @param {object|string|function} [options]
	 * @param {function} [callback]
	 * @public
	 */
	
	function getRawBody (stream, options, callback) {
	  var done = callback
	  var opts = options || {}
	
	  if (options === true || typeof options === 'string') {
	    // short cut for encoding
	    opts = {
	      encoding: options
	    }
	  }
	
	  if (typeof options === 'function') {
	    done = options
	    opts = {}
	  }
	
	  // validate callback is a function, if provided
	  if (done !== undefined && typeof done !== 'function') {
	    throw new TypeError('argument callback must be a function')
	  }
	
	  // require the callback without promises
	  if (!done && !global.Promise) {
	    throw new TypeError('argument callback is required')
	  }
	
	  // get encoding
	  var encoding = opts.encoding !== true
	    ? opts.encoding
	    : 'utf-8'
	
	  // convert the limit to an integer
	  var limit = bytes.parse(opts.limit)
	
	  // convert the expected length to an integer
	  var length = opts.length != null && !isNaN(opts.length)
	    ? parseInt(opts.length, 10)
	    : null
	
	  if (done) {
	    // classic callback style
	    return readStream(stream, encoding, length, limit, done)
	  }
	
	  return new Promise(function executor (resolve, reject) {
	    readStream(stream, encoding, length, limit, function onRead (err, buf) {
	      if (err) return reject(err)
	      resolve(buf)
	    })
	  })
	}
	
	/**
	 * Halt a stream.
	 *
	 * @param {Object} stream
	 * @private
	 */
	
	function halt (stream) {
	  // unpipe everything from the stream
	  unpipe(stream)
	
	  // pause stream
	  if (typeof stream.pause === 'function') {
	    stream.pause()
	  }
	}
	
	/**
	 * Make a serializable error object.
	 *
	 * To create serializable errors you must re-set message so
	 * that it is enumerable and you must re configure the type
	 * property so that is writable and enumerable.
	 *
	 * @param {number} status
	 * @param {string} message
	 * @param {string} type
	 * @param {object} props
	 * @private
	 */
	
	function createError (status, message, type, props) {
	  var error = new Error()
	
	  // capture stack trace
	  Error.captureStackTrace(error, createError)
	
	  // set free-form properties
	  for (var prop in props) {
	    error[prop] = props[prop]
	  }
	
	  // set message
	  error.message = message
	
	  // set status
	  error.status = status
	  error.statusCode = status
	
	  // set type
	  Object.defineProperty(error, 'type', {
	    value: type,
	    enumerable: true,
	    writable: true,
	    configurable: true
	  })
	
	  return error
	}
	
	/**
	 * Read the data from the stream.
	 *
	 * @param {object} stream
	 * @param {string} encoding
	 * @param {number} length
	 * @param {number} limit
	 * @param {function} callback
	 * @public
	 */
	
	function readStream (stream, encoding, length, limit, callback) {
	  var complete = false
	  var sync = true
	
	  // check the length and limit options.
	  // note: we intentionally leave the stream paused,
	  // so users should handle the stream themselves.
	  if (limit !== null && length !== null && length > limit) {
	    return done(createError(413, 'request entity too large', 'entity.too.large', {
	      expected: length,
	      length: length,
	      limit: limit
	    }))
	  }
	
	  // streams1: assert request encoding is buffer.
	  // streams2+: assert the stream encoding is buffer.
	  //   stream._decoder: streams1
	  //   state.encoding: streams2
	  //   state.decoder: streams2, specifically < 0.10.6
	  var state = stream._readableState
	  if (stream._decoder || (state && (state.encoding || state.decoder))) {
	    // developer error
	    return done(createError(500, 'stream encoding should not be set', 'stream.encoding.set'))
	  }
	
	  var received = 0
	  var decoder
	
	  try {
	    decoder = getDecoder(encoding)
	  } catch (err) {
	    return done(err)
	  }
	
	  var buffer = decoder
	    ? ''
	    : []
	
	  // attach listeners
	  stream.on('aborted', onAborted)
	  stream.on('close', cleanup)
	  stream.on('data', onData)
	  stream.on('end', onEnd)
	  stream.on('error', onEnd)
	
	  // mark sync section complete
	  sync = false
	
	  function done () {
	    var args = new Array(arguments.length)
	
	    // copy arguments
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i]
	    }
	
	    // mark complete
	    complete = true
	
	    if (sync) {
	      process.nextTick(invokeCallback)
	    } else {
	      invokeCallback()
	    }
	
	    function invokeCallback () {
	      cleanup()
	
	      if (args[0]) {
	        // halt the stream on error
	        halt(stream)
	      }
	
	      callback.apply(null, args)
	    }
	  }
	
	  function onAborted () {
	    if (complete) return
	
	    done(createError(400, 'request aborted', 'request.aborted', {
	      code: 'ECONNABORTED',
	      expected: length,
	      length: length,
	      received: received
	    }))
	  }
	
	  function onData (chunk) {
	    if (complete) return
	
	    received += chunk.length
	    decoder
	      ? buffer += decoder.write(chunk)
	      : buffer.push(chunk)
	
	    if (limit !== null && received > limit) {
	      done(createError(413, 'request entity too large', 'entity.too.large', {
	        limit: limit,
	        received: received
	      }))
	    }
	  }
	
	  function onEnd (err) {
	    if (complete) return
	    if (err) return done(err)
	
	    if (length !== null && received !== length) {
	      done(createError(400, 'request size did not match content length', 'request.size.invalid', {
	        expected: length,
	        length: length,
	        received: received
	      }))
	    } else {
	      var string = decoder
	        ? buffer + (decoder.end() || '')
	        : Buffer.concat(buffer)
	      done(null, string)
	    }
	  }
	
	  function cleanup () {
	    buffer = null
	
	    stream.removeListener('aborted', onAborted)
	    stream.removeListener('data', onData)
	    stream.removeListener('end', onEnd)
	    stream.removeListener('error', onEnd)
	    stream.removeListener('close', cleanup)
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(6), __webpack_require__(9).Buffer))

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {"use strict"
	
	var bomHandling = __webpack_require__(292),
	    iconv = module.exports;
	
	// All codecs and aliases are kept here, keyed by encoding name/alias.
	// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
	iconv.encodings = null;
	
	// Characters emitted in case of error.
	iconv.defaultCharUnicode = '';
	iconv.defaultCharSingleByte = '?';
	
	// Public API.
	iconv.encode = function encode(str, encoding, options) {
	    str = "" + (str || ""); // Ensure string.
	
	    var encoder = iconv.getEncoder(encoding, options);
	
	    var res = encoder.write(str);
	    var trail = encoder.end();
	    
	    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
	}
	
	iconv.decode = function decode(buf, encoding, options) {
	    if (typeof buf === 'string') {
	        if (!iconv.skipDecodeWarning) {
	            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
	            iconv.skipDecodeWarning = true;
	        }
	
	        buf = new Buffer("" + (buf || ""), "binary"); // Ensure buffer.
	    }
	
	    var decoder = iconv.getDecoder(encoding, options);
	
	    var res = decoder.write(buf);
	    var trail = decoder.end();
	
	    return trail ? (res + trail) : res;
	}
	
	iconv.encodingExists = function encodingExists(enc) {
	    try {
	        iconv.getCodec(enc);
	        return true;
	    } catch (e) {
	        return false;
	    }
	}
	
	// Legacy aliases to convert functions
	iconv.toEncoding = iconv.encode;
	iconv.fromEncoding = iconv.decode;
	
	// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
	iconv._codecDataCache = {};
	iconv.getCodec = function getCodec(encoding) {
	    if (!iconv.encodings)
	        iconv.encodings = __webpack_require__(293); // Lazy load all encoding definitions.
	    
	    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
	    var enc = (''+encoding).toLowerCase().replace(/[^0-9a-z]|:\d{4}$/g, "");
	
	    // Traverse iconv.encodings to find actual codec.
	    var codecOptions = {};
	    while (true) {
	        var codec = iconv._codecDataCache[enc];
	        if (codec)
	            return codec;
	
	        var codecDef = iconv.encodings[enc];
	
	        switch (typeof codecDef) {
	            case "string": // Direct alias to other encoding.
	                enc = codecDef;
	                break;
	
	            case "object": // Alias with options. Can be layered.
	                for (var key in codecDef)
	                    codecOptions[key] = codecDef[key];
	
	                if (!codecOptions.encodingName)
	                    codecOptions.encodingName = enc;
	                
	                enc = codecDef.type;
	                break;
	
	            case "function": // Codec itself.
	                if (!codecOptions.encodingName)
	                    codecOptions.encodingName = enc;
	
	                // The codec function must load all tables and return object with .encoder and .decoder methods.
	                // It'll be called only once (for each different options object).
	                codec = new codecDef(codecOptions, iconv);
	
	                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
	                return codec;
	
	            default:
	                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
	        }
	    }
	}
	
	iconv.getEncoder = function getEncoder(encoding, options) {
	    var codec = iconv.getCodec(encoding),
	        encoder = new codec.encoder(options, codec);
	
	    if (codec.bomAware && options && options.addBOM)
	        encoder = new bomHandling.PrependBOM(encoder, options);
	
	    return encoder;
	}
	
	iconv.getDecoder = function getDecoder(encoding, options) {
	    var codec = iconv.getCodec(encoding),
	        decoder = new codec.decoder(options, codec);
	
	    if (codec.bomAware && !(options && options.stripBOM === false))
	        decoder = new bomHandling.StripBOM(decoder, options);
	
	    return decoder;
	}
	
	
	// Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
	var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
	if (nodeVer) {
	
	    // Load streaming support in Node v0.10+
	    var nodeVerArr = nodeVer.split(".").map(Number);
	    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
	        __webpack_require__(310)(iconv);
	    }
	
	    // Load Node primitive extensions.
	    __webpack_require__(311)(iconv);
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer, __webpack_require__(6)))

/***/ },
/* 292 */
/***/ function(module, exports) {

	"use strict"
	
	var BOMChar = '\uFEFF';
	
	exports.PrependBOM = PrependBOMWrapper
	function PrependBOMWrapper(encoder, options) {
	    this.encoder = encoder;
	    this.addBOM = true;
	}
	
	PrependBOMWrapper.prototype.write = function(str) {
	    if (this.addBOM) {
	        str = BOMChar + str;
	        this.addBOM = false;
	    }
	
	    return this.encoder.write(str);
	}
	
	PrependBOMWrapper.prototype.end = function() {
	    return this.encoder.end();
	}
	
	
	//------------------------------------------------------------------------------
	
	exports.StripBOM = StripBOMWrapper;
	function StripBOMWrapper(decoder, options) {
	    this.decoder = decoder;
	    this.pass = false;
	    this.options = options || {};
	}
	
	StripBOMWrapper.prototype.write = function(buf) {
	    var res = this.decoder.write(buf);
	    if (this.pass || !res)
	        return res;
	
	    if (res[0] === BOMChar) {
	        res = res.slice(1);
	        if (typeof this.options.stripBOM === 'function')
	            this.options.stripBOM();
	    }
	
	    this.pass = true;
	    return res;
	}
	
	StripBOMWrapper.prototype.end = function() {
	    return this.decoder.end();
	}
	


/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	"use strict"
	
	// Update this array if you add/rename/remove files in this directory.
	// We support Browserify by skipping automatic module discovery and requiring modules directly.
	var modules = [
	    __webpack_require__(294),
	    __webpack_require__(295),
	    __webpack_require__(296),
	    __webpack_require__(297),
	    __webpack_require__(298),
	    __webpack_require__(299),
	    __webpack_require__(300),
	    __webpack_require__(301),
	];
	
	// Put all encoding/alias/codec definitions to single object and export it. 
	for (var i = 0; i < modules.length; i++) {
	    var module = modules[i];
	    for (var enc in module)
	        if (Object.prototype.hasOwnProperty.call(module, enc))
	            exports[enc] = module[enc];
	}


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict"
	
	// Export Node.js internal encodings.
	
	module.exports = {
	    // Encodings
	    utf8:   { type: "_internal", bomAware: true},
	    cesu8:  { type: "_internal", bomAware: true},
	    unicode11utf8: "utf8",
	
	    ucs2:   { type: "_internal", bomAware: true},
	    utf16le: "ucs2",
	
	    binary: { type: "_internal" },
	    base64: { type: "_internal" },
	    hex:    { type: "_internal" },
	
	    // Codec.
	    _internal: InternalCodec,
	};
	
	//------------------------------------------------------------------------------
	
	function InternalCodec(codecOptions, iconv) {
	    this.enc = codecOptions.encodingName;
	    this.bomAware = codecOptions.bomAware;
	
	    if (this.enc === "base64")
	        this.encoder = InternalEncoderBase64;
	    else if (this.enc === "cesu8") {
	        this.enc = "utf8"; // Use utf8 for decoding.
	        this.encoder = InternalEncoderCesu8;
	
	        // Add decoder for versions of Node not supporting CESU-8
	        if (new Buffer("eda080", 'hex').toString().length == 3) {
	            this.decoder = InternalDecoderCesu8;
	            this.defaultCharUnicode = iconv.defaultCharUnicode;
	        }
	    }
	}
	
	InternalCodec.prototype.encoder = InternalEncoder;
	InternalCodec.prototype.decoder = InternalDecoder;
	
	//------------------------------------------------------------------------------
	
	// We use node.js internal decoder. Its signature is the same as ours.
	var StringDecoder = __webpack_require__(59).StringDecoder;
	
	if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
	    StringDecoder.prototype.end = function() {};
	
	
	function InternalDecoder(options, codec) {
	    StringDecoder.call(this, codec.enc);
	}
	
	InternalDecoder.prototype = StringDecoder.prototype;
	
	
	//------------------------------------------------------------------------------
	// Encoder is mostly trivial
	
	function InternalEncoder(options, codec) {
	    this.enc = codec.enc;
	}
	
	InternalEncoder.prototype.write = function(str) {
	    return new Buffer(str, this.enc);
	}
	
	InternalEncoder.prototype.end = function() {
	}
	
	
	//------------------------------------------------------------------------------
	// Except base64 encoder, which must keep its state.
	
	function InternalEncoderBase64(options, codec) {
	    this.prevStr = '';
	}
	
	InternalEncoderBase64.prototype.write = function(str) {
	    str = this.prevStr + str;
	    var completeQuads = str.length - (str.length % 4);
	    this.prevStr = str.slice(completeQuads);
	    str = str.slice(0, completeQuads);
	
	    return new Buffer(str, "base64");
	}
	
	InternalEncoderBase64.prototype.end = function() {
	    return new Buffer(this.prevStr, "base64");
	}
	
	
	//------------------------------------------------------------------------------
	// CESU-8 encoder is also special.
	
	function InternalEncoderCesu8(options, codec) {
	}
	
	InternalEncoderCesu8.prototype.write = function(str) {
	    var buf = new Buffer(str.length * 3), bufIdx = 0;
	    for (var i = 0; i < str.length; i++) {
	        var charCode = str.charCodeAt(i);
	        // Naive implementation, but it works because CESU-8 is especially easy
	        // to convert from UTF-16 (which all JS strings are encoded in).
	        if (charCode < 0x80)
	            buf[bufIdx++] = charCode;
	        else if (charCode < 0x800) {
	            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
	            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
	        }
	        else { // charCode will always be < 0x10000 in javascript.
	            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
	            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
	            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
	        }
	    }
	    return buf.slice(0, bufIdx);
	}
	
	InternalEncoderCesu8.prototype.end = function() {
	}
	
	//------------------------------------------------------------------------------
	// CESU-8 decoder is not implemented in Node v4.0+
	
	function InternalDecoderCesu8(options, codec) {
	    this.acc = 0;
	    this.contBytes = 0;
	    this.accBytes = 0;
	    this.defaultCharUnicode = codec.defaultCharUnicode;
	}
	
	InternalDecoderCesu8.prototype.write = function(buf) {
	    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
	        res = '';
	    for (var i = 0; i < buf.length; i++) {
	        var curByte = buf[i];
	        if ((curByte & 0xC0) !== 0x80) { // Leading byte
	            if (contBytes > 0) { // Previous code is invalid
	                res += this.defaultCharUnicode;
	                contBytes = 0;
	            }
	
	            if (curByte < 0x80) { // Single-byte code
	                res += String.fromCharCode(curByte);
	            } else if (curByte < 0xE0) { // Two-byte code
	                acc = curByte & 0x1F;
	                contBytes = 1; accBytes = 1;
	            } else if (curByte < 0xF0) { // Three-byte code
	                acc = curByte & 0x0F;
	                contBytes = 2; accBytes = 1;
	            } else { // Four or more are not supported for CESU-8.
	                res += this.defaultCharUnicode;
	            }
	        } else { // Continuation byte
	            if (contBytes > 0) { // We're waiting for it.
	                acc = (acc << 6) | (curByte & 0x3f);
	                contBytes--; accBytes++;
	                if (contBytes === 0) {
	                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
	                    if (accBytes === 2 && acc < 0x80 && acc > 0)
	                        res += this.defaultCharUnicode;
	                    else if (accBytes === 3 && acc < 0x800)
	                        res += this.defaultCharUnicode;
	                    else
	                        // Actually add character.
	                        res += String.fromCharCode(acc);
	                }
	            } else { // Unexpected continuation byte
	                res += this.defaultCharUnicode;
	            }
	        }
	    }
	    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
	    return res;
	}
	
	InternalDecoderCesu8.prototype.end = function() {
	    var res = 0;
	    if (this.contBytes > 0)
	        res += this.defaultCharUnicode;
	    return res;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict"
	
	// == UTF16-BE codec. ==========================================================
	
	exports.utf16be = Utf16BECodec;
	function Utf16BECodec() {
	}
	
	Utf16BECodec.prototype.encoder = Utf16BEEncoder;
	Utf16BECodec.prototype.decoder = Utf16BEDecoder;
	Utf16BECodec.prototype.bomAware = true;
	
	
	// -- Encoding
	
	function Utf16BEEncoder() {
	}
	
	Utf16BEEncoder.prototype.write = function(str) {
	    var buf = new Buffer(str, 'ucs2');
	    for (var i = 0; i < buf.length; i += 2) {
	        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
	    }
	    return buf;
	}
	
	Utf16BEEncoder.prototype.end = function() {
	}
	
	
	// -- Decoding
	
	function Utf16BEDecoder() {
	    this.overflowByte = -1;
	}
	
	Utf16BEDecoder.prototype.write = function(buf) {
	    if (buf.length == 0)
	        return '';
	
	    var buf2 = new Buffer(buf.length + 1),
	        i = 0, j = 0;
	
	    if (this.overflowByte !== -1) {
	        buf2[0] = buf[0];
	        buf2[1] = this.overflowByte;
	        i = 1; j = 2;
	    }
	
	    for (; i < buf.length-1; i += 2, j+= 2) {
	        buf2[j] = buf[i+1];
	        buf2[j+1] = buf[i];
	    }
	
	    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;
	
	    return buf2.slice(0, j).toString('ucs2');
	}
	
	Utf16BEDecoder.prototype.end = function() {
	}
	
	
	// == UTF-16 codec =============================================================
	// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
	// Defaults to UTF-16LE, as it's prevalent and default in Node.
	// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
	// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});
	
	// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).
	
	exports.utf16 = Utf16Codec;
	function Utf16Codec(codecOptions, iconv) {
	    this.iconv = iconv;
	}
	
	Utf16Codec.prototype.encoder = Utf16Encoder;
	Utf16Codec.prototype.decoder = Utf16Decoder;
	
	
	// -- Encoding (pass-through)
	
	function Utf16Encoder(options, codec) {
	    options = options || {};
	    if (options.addBOM === undefined)
	        options.addBOM = true;
	    this.encoder = codec.iconv.getEncoder('utf-16le', options);
	}
	
	Utf16Encoder.prototype.write = function(str) {
	    return this.encoder.write(str);
	}
	
	Utf16Encoder.prototype.end = function() {
	    return this.encoder.end();
	}
	
	
	// -- Decoding
	
	function Utf16Decoder(options, codec) {
	    this.decoder = null;
	    this.initialBytes = [];
	    this.initialBytesLen = 0;
	
	    this.options = options || {};
	    this.iconv = codec.iconv;
	}
	
	Utf16Decoder.prototype.write = function(buf) {
	    if (!this.decoder) {
	        // Codec is not chosen yet. Accumulate initial bytes.
	        this.initialBytes.push(buf);
	        this.initialBytesLen += buf.length;
	        
	        if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)
	            return '';
	
	        // We have enough bytes -> detect endianness.
	        var buf = Buffer.concat(this.initialBytes),
	            encoding = detectEncoding(buf, this.options.defaultEncoding);
	        this.decoder = this.iconv.getDecoder(encoding, this.options);
	        this.initialBytes.length = this.initialBytesLen = 0;
	    }
	
	    return this.decoder.write(buf);
	}
	
	Utf16Decoder.prototype.end = function() {
	    if (!this.decoder) {
	        var buf = Buffer.concat(this.initialBytes),
	            encoding = detectEncoding(buf, this.options.defaultEncoding);
	        this.decoder = this.iconv.getDecoder(encoding, this.options);
	
	        var res = this.decoder.write(buf),
	            trail = this.decoder.end();
	
	        return trail ? (res + trail) : res;
	    }
	    return this.decoder.end();
	}
	
	function detectEncoding(buf, defaultEncoding) {
	    var enc = defaultEncoding || 'utf-16le';
	
	    if (buf.length >= 2) {
	        // Check BOM.
	        if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM
	            enc = 'utf-16be';
	        else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM
	            enc = 'utf-16le';
	        else {
	            // No BOM found. Try to deduce encoding from initial content.
	            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
	            // So, we count ASCII as if it was LE or BE, and decide from that.
	            var asciiCharsLE = 0, asciiCharsBE = 0, // Counts of chars in both positions
	                _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.
	
	            for (var i = 0; i < _len; i += 2) {
	                if (buf[i] === 0 && buf[i+1] !== 0) asciiCharsBE++;
	                if (buf[i] !== 0 && buf[i+1] === 0) asciiCharsLE++;
	            }
	
	            if (asciiCharsBE > asciiCharsLE)
	                enc = 'utf-16be';
	            else if (asciiCharsBE < asciiCharsLE)
	                enc = 'utf-16le';
	        }
	    }
	
	    return enc;
	}
	
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict"
	
	// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
	// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3
	
	exports.utf7 = Utf7Codec;
	exports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
	function Utf7Codec(codecOptions, iconv) {
	    this.iconv = iconv;
	};
	
	Utf7Codec.prototype.encoder = Utf7Encoder;
	Utf7Codec.prototype.decoder = Utf7Decoder;
	Utf7Codec.prototype.bomAware = true;
	
	
	// -- Encoding
	
	var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
	
	function Utf7Encoder(options, codec) {
	    this.iconv = codec.iconv;
	}
	
	Utf7Encoder.prototype.write = function(str) {
	    // Naive implementation.
	    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
	    return new Buffer(str.replace(nonDirectChars, function(chunk) {
	        return "+" + (chunk === '+' ? '' : 
	            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
	            + "-";
	    }.bind(this)));
	}
	
	Utf7Encoder.prototype.end = function() {
	}
	
	
	// -- Decoding
	
	function Utf7Decoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = '';
	}
	
	var base64Regex = /[A-Za-z0-9\/+]/;
	var base64Chars = [];
	for (var i = 0; i < 256; i++)
	    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
	
	var plusChar = '+'.charCodeAt(0), 
	    minusChar = '-'.charCodeAt(0),
	    andChar = '&'.charCodeAt(0);
	
	Utf7Decoder.prototype.write = function(buf) {
	    var res = "", lastI = 0,
	        inBase64 = this.inBase64,
	        base64Accum = this.base64Accum;
	
	    // The decoder is more involved as we must handle chunks in stream.
	
	    for (var i = 0; i < buf.length; i++) {
	        if (!inBase64) { // We're in direct mode.
	            // Write direct chars until '+'
	            if (buf[i] == plusChar) {
	                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
	                lastI = i+1;
	                inBase64 = true;
	            }
	        } else { // We decode base64.
	            if (!base64Chars[buf[i]]) { // Base64 ended.
	                if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
	                    res += "+";
	                } else {
	                    var b64str = base64Accum + buf.slice(lastI, i).toString();
	                    res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
	                }
	
	                if (buf[i] != minusChar) // Minus is absorbed after base64.
	                    i--;
	
	                lastI = i+1;
	                inBase64 = false;
	                base64Accum = '';
	            }
	        }
	    }
	
	    if (!inBase64) {
	        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
	    } else {
	        var b64str = base64Accum + buf.slice(lastI).toString();
	
	        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
	        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
	        b64str = b64str.slice(0, canBeDecoded);
	
	        res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
	    }
	
	    this.inBase64 = inBase64;
	    this.base64Accum = base64Accum;
	
	    return res;
	}
	
	Utf7Decoder.prototype.end = function() {
	    var res = "";
	    if (this.inBase64 && this.base64Accum.length > 0)
	        res = this.iconv.decode(new Buffer(this.base64Accum, 'base64'), "utf16-be");
	
	    this.inBase64 = false;
	    this.base64Accum = '';
	    return res;
	}
	
	
	// UTF-7-IMAP codec.
	// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
	// Differences:
	//  * Base64 part is started by "&" instead of "+"
	//  * Direct characters are 0x20-0x7E, except "&" (0x26)
	//  * In Base64, "," is used instead of "/"
	//  * Base64 must not be used to represent direct characters.
	//  * No implicit shift back from Base64 (should always end with '-')
	//  * String must end in non-shifted position.
	//  * "-&" while in base64 is not allowed.
	
	
	exports.utf7imap = Utf7IMAPCodec;
	function Utf7IMAPCodec(codecOptions, iconv) {
	    this.iconv = iconv;
	};
	
	Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
	Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
	Utf7IMAPCodec.prototype.bomAware = true;
	
	
	// -- Encoding
	
	function Utf7IMAPEncoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = new Buffer(6);
	    this.base64AccumIdx = 0;
	}
	
	Utf7IMAPEncoder.prototype.write = function(str) {
	    var inBase64 = this.inBase64,
	        base64Accum = this.base64Accum,
	        base64AccumIdx = this.base64AccumIdx,
	        buf = new Buffer(str.length*5 + 10), bufIdx = 0;
	
	    for (var i = 0; i < str.length; i++) {
	        var uChar = str.charCodeAt(i);
	        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
	            if (inBase64) {
	                if (base64AccumIdx > 0) {
	                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
	                    base64AccumIdx = 0;
	                }
	
	                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
	                inBase64 = false;
	            }
	
	            if (!inBase64) {
	                buf[bufIdx++] = uChar; // Write direct character
	
	                if (uChar === andChar)  // Ampersand -> '&-'
	                    buf[bufIdx++] = minusChar;
	            }
	
	        } else { // Non-direct character
	            if (!inBase64) {
	                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
	                inBase64 = true;
	            }
	            if (inBase64) {
	                base64Accum[base64AccumIdx++] = uChar >> 8;
	                base64Accum[base64AccumIdx++] = uChar & 0xFF;
	
	                if (base64AccumIdx == base64Accum.length) {
	                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
	                    base64AccumIdx = 0;
	                }
	            }
	        }
	    }
	
	    this.inBase64 = inBase64;
	    this.base64AccumIdx = base64AccumIdx;
	
	    return buf.slice(0, bufIdx);
	}
	
	Utf7IMAPEncoder.prototype.end = function() {
	    var buf = new Buffer(10), bufIdx = 0;
	    if (this.inBase64) {
	        if (this.base64AccumIdx > 0) {
	            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
	            this.base64AccumIdx = 0;
	        }
	
	        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
	        this.inBase64 = false;
	    }
	
	    return buf.slice(0, bufIdx);
	}
	
	
	// -- Decoding
	
	function Utf7IMAPDecoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = '';
	}
	
	var base64IMAPChars = base64Chars.slice();
	base64IMAPChars[','.charCodeAt(0)] = true;
	
	Utf7IMAPDecoder.prototype.write = function(buf) {
	    var res = "", lastI = 0,
	        inBase64 = this.inBase64,
	        base64Accum = this.base64Accum;
	
	    // The decoder is more involved as we must handle chunks in stream.
	    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).
	
	    for (var i = 0; i < buf.length; i++) {
	        if (!inBase64) { // We're in direct mode.
	            // Write direct chars until '&'
	            if (buf[i] == andChar) {
	                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
	                lastI = i+1;
	                inBase64 = true;
	            }
	        } else { // We decode base64.
	            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
	                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
	                    res += "&";
	                } else {
	                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
	                    res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
	                }
	
	                if (buf[i] != minusChar) // Minus may be absorbed after base64.
	                    i--;
	
	                lastI = i+1;
	                inBase64 = false;
	                base64Accum = '';
	            }
	        }
	    }
	
	    if (!inBase64) {
	        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
	    } else {
	        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');
	
	        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
	        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
	        b64str = b64str.slice(0, canBeDecoded);
	
	        res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
	    }
	
	    this.inBase64 = inBase64;
	    this.base64Accum = base64Accum;
	
	    return res;
	}
	
	Utf7IMAPDecoder.prototype.end = function() {
	    var res = "";
	    if (this.inBase64 && this.base64Accum.length > 0)
	        res = this.iconv.decode(new Buffer(this.base64Accum, 'base64'), "utf16-be");
	
	    this.inBase64 = false;
	    this.base64Accum = '';
	    return res;
	}
	
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict"
	
	// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
	// correspond to encoded bytes (if 128 - then lower half is ASCII). 
	
	exports._sbcs = SBCSCodec;
	function SBCSCodec(codecOptions, iconv) {
	    if (!codecOptions)
	        throw new Error("SBCS codec is called without the data.")
	    
	    // Prepare char buffer for decoding.
	    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
	        throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
	    
	    if (codecOptions.chars.length === 128) {
	        var asciiString = "";
	        for (var i = 0; i < 128; i++)
	            asciiString += String.fromCharCode(i);
	        codecOptions.chars = asciiString + codecOptions.chars;
	    }
	
	    this.decodeBuf = new Buffer(codecOptions.chars, 'ucs2');
	    
	    // Encoding buffer.
	    var encodeBuf = new Buffer(65536);
	    encodeBuf.fill(iconv.defaultCharSingleByte.charCodeAt(0));
	
	    for (var i = 0; i < codecOptions.chars.length; i++)
	        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
	
	    this.encodeBuf = encodeBuf;
	}
	
	SBCSCodec.prototype.encoder = SBCSEncoder;
	SBCSCodec.prototype.decoder = SBCSDecoder;
	
	
	function SBCSEncoder(options, codec) {
	    this.encodeBuf = codec.encodeBuf;
	}
	
	SBCSEncoder.prototype.write = function(str) {
	    var buf = new Buffer(str.length);
	    for (var i = 0; i < str.length; i++)
	        buf[i] = this.encodeBuf[str.charCodeAt(i)];
	    
	    return buf;
	}
	
	SBCSEncoder.prototype.end = function() {
	}
	
	
	function SBCSDecoder(options, codec) {
	    this.decodeBuf = codec.decodeBuf;
	}
	
	SBCSDecoder.prototype.write = function(buf) {
	    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
	    var decodeBuf = this.decodeBuf;
	    var newBuf = new Buffer(buf.length*2);
	    var idx1 = 0, idx2 = 0;
	    for (var i = 0; i < buf.length; i++) {
	        idx1 = buf[i]*2; idx2 = i*2;
	        newBuf[idx2] = decodeBuf[idx1];
	        newBuf[idx2+1] = decodeBuf[idx1+1];
	    }
	    return newBuf.toString('ucs2');
	}
	
	SBCSDecoder.prototype.end = function() {
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 298 */
/***/ function(module, exports) {

	"use strict"
	
	// Manually added data to be used by sbcs codec in addition to generated one.
	
	module.exports = {
	    // Not supported by iconv, not sure why.
	    "10029": "maccenteuro",
	    "maccenteuro": {
	        "type": "_sbcs",
	        "chars": ""
	    },
	
	    "808": "cp808",
	    "ibm808": "cp808",
	    "cp808": {
	        "type": "_sbcs",
	        "chars": ""
	    },
	
	    // Aliases of generated encodings.
	    "ascii8bit": "ascii",
	    "usascii": "ascii",
	    "ansix34": "ascii",
	    "ansix341968": "ascii",
	    "ansix341986": "ascii",
	    "csascii": "ascii",
	    "cp367": "ascii",
	    "ibm367": "ascii",
	    "isoir6": "ascii",
	    "iso646us": "ascii",
	    "iso646irv": "ascii",
	    "us": "ascii",
	
	    "latin1": "iso88591",
	    "latin2": "iso88592",
	    "latin3": "iso88593",
	    "latin4": "iso88594",
	    "latin5": "iso88599",
	    "latin6": "iso885910",
	    "latin7": "iso885913",
	    "latin8": "iso885914",
	    "latin9": "iso885915",
	    "latin10": "iso885916",
	
	    "csisolatin1": "iso88591",
	    "csisolatin2": "iso88592",
	    "csisolatin3": "iso88593",
	    "csisolatin4": "iso88594",
	    "csisolatincyrillic": "iso88595",
	    "csisolatinarabic": "iso88596",
	    "csisolatingreek" : "iso88597",
	    "csisolatinhebrew": "iso88598",
	    "csisolatin5": "iso88599",
	    "csisolatin6": "iso885910",
	
	    "l1": "iso88591",
	    "l2": "iso88592",
	    "l3": "iso88593",
	    "l4": "iso88594",
	    "l5": "iso88599",
	    "l6": "iso885910",
	    "l7": "iso885913",
	    "l8": "iso885914",
	    "l9": "iso885915",
	    "l10": "iso885916",
	
	    "isoir14": "iso646jp",
	    "isoir57": "iso646cn",
	    "isoir100": "iso88591",
	    "isoir101": "iso88592",
	    "isoir109": "iso88593",
	    "isoir110": "iso88594",
	    "isoir144": "iso88595",
	    "isoir127": "iso88596",
	    "isoir126": "iso88597",
	    "isoir138": "iso88598",
	    "isoir148": "iso88599",
	    "isoir157": "iso885910",
	    "isoir166": "tis620",
	    "isoir179": "iso885913",
	    "isoir199": "iso885914",
	    "isoir203": "iso885915",
	    "isoir226": "iso885916",
	
	    "cp819": "iso88591",
	    "ibm819": "iso88591",
	
	    "cyrillic": "iso88595",
	
	    "arabic": "iso88596",
	    "arabic8": "iso88596",
	    "ecma114": "iso88596",
	    "asmo708": "iso88596",
	
	    "greek" : "iso88597",
	    "greek8" : "iso88597",
	    "ecma118" : "iso88597",
	    "elot928" : "iso88597",
	
	    "hebrew": "iso88598",
	    "hebrew8": "iso88598",
	
	    "turkish": "iso88599",
	    "turkish8": "iso88599",
	
	    "thai": "iso885911",
	    "thai8": "iso885911",
	
	    "celtic": "iso885914",
	    "celtic8": "iso885914",
	    "isoceltic": "iso885914",
	
	    "tis6200": "tis620",
	    "tis62025291": "tis620",
	    "tis62025330": "tis620",
	
	    "10000": "macroman",
	    "10006": "macgreek",
	    "10007": "maccyrillic",
	    "10079": "maciceland",
	    "10081": "macturkish",
	
	    "cspc8codepage437": "cp437",
	    "cspc775baltic": "cp775",
	    "cspc850multilingual": "cp850",
	    "cspcp852": "cp852",
	    "cspc862latinhebrew": "cp862",
	    "cpgr": "cp869",
	
	    "msee": "cp1250",
	    "mscyrl": "cp1251",
	    "msansi": "cp1252",
	    "msgreek": "cp1253",
	    "msturk": "cp1254",
	    "mshebr": "cp1255",
	    "msarab": "cp1256",
	    "winbaltrim": "cp1257",
	
	    "cp20866": "koi8r",
	    "20866": "koi8r",
	    "ibm878": "koi8r",
	    "cskoi8r": "koi8r",
	
	    "cp21866": "koi8u",
	    "21866": "koi8u",
	    "ibm1168": "koi8u",
	
	    "strk10482002": "rk1048",
	
	    "tcvn5712": "tcvn",
	    "tcvn57121": "tcvn",
	
	    "gb198880": "iso646cn",
	    "cn": "iso646cn",
	
	    "csiso14jisc6220ro": "iso646jp",
	    "jisc62201969ro": "iso646jp",
	    "jp": "iso646jp",
	
	    "cshproman8": "hproman8",
	    "r8": "hproman8",
	    "roman8": "hproman8",
	    "xroman8": "hproman8",
	    "ibm1051": "hproman8",
	
	    "mac": "macintosh",
	    "csmacintosh": "macintosh",
	};
	


/***/ },
/* 299 */
/***/ function(module, exports) {

	"use strict"
	
	// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
	module.exports = {
	  "437": "cp437",
	  "737": "cp737",
	  "775": "cp775",
	  "850": "cp850",
	  "852": "cp852",
	  "855": "cp855",
	  "856": "cp856",
	  "857": "cp857",
	  "858": "cp858",
	  "860": "cp860",
	  "861": "cp861",
	  "862": "cp862",
	  "863": "cp863",
	  "864": "cp864",
	  "865": "cp865",
	  "866": "cp866",
	  "869": "cp869",
	  "874": "windows874",
	  "922": "cp922",
	  "1046": "cp1046",
	  "1124": "cp1124",
	  "1125": "cp1125",
	  "1129": "cp1129",
	  "1133": "cp1133",
	  "1161": "cp1161",
	  "1162": "cp1162",
	  "1163": "cp1163",
	  "1250": "windows1250",
	  "1251": "windows1251",
	  "1252": "windows1252",
	  "1253": "windows1253",
	  "1254": "windows1254",
	  "1255": "windows1255",
	  "1256": "windows1256",
	  "1257": "windows1257",
	  "1258": "windows1258",
	  "28591": "iso88591",
	  "28592": "iso88592",
	  "28593": "iso88593",
	  "28594": "iso88594",
	  "28595": "iso88595",
	  "28596": "iso88596",
	  "28597": "iso88597",
	  "28598": "iso88598",
	  "28599": "iso88599",
	  "28600": "iso885910",
	  "28601": "iso885911",
	  "28603": "iso885913",
	  "28604": "iso885914",
	  "28605": "iso885915",
	  "28606": "iso885916",
	  "windows874": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win874": "windows874",
	  "cp874": "windows874",
	  "windows1250": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1250": "windows1250",
	  "cp1250": "windows1250",
	  "windows1251": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1251": "windows1251",
	  "cp1251": "windows1251",
	  "windows1252": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1252": "windows1252",
	  "cp1252": "windows1252",
	  "windows1253": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1253": "windows1253",
	  "cp1253": "windows1253",
	  "windows1254": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1254": "windows1254",
	  "cp1254": "windows1254",
	  "windows1255": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1255": "windows1255",
	  "cp1255": "windows1255",
	  "windows1256": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1256": "windows1256",
	  "cp1256": "windows1256",
	  "windows1257": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1257": "windows1257",
	  "cp1257": "windows1257",
	  "windows1258": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1258": "windows1258",
	  "cp1258": "windows1258",
	  "iso88591": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28591": "iso88591",
	  "iso88592": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28592": "iso88592",
	  "iso88593": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28593": "iso88593",
	  "iso88594": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28594": "iso88594",
	  "iso88595": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28595": "iso88595",
	  "iso88596": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28596": "iso88596",
	  "iso88597": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28597": "iso88597",
	  "iso88598": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28598": "iso88598",
	  "iso88599": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28599": "iso88599",
	  "iso885910": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28600": "iso885910",
	  "iso885911": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28601": "iso885911",
	  "iso885913": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28603": "iso885913",
	  "iso885914": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28604": "iso885914",
	  "iso885915": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28605": "iso885915",
	  "iso885916": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28606": "iso885916",
	  "cp437": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm437": "cp437",
	  "csibm437": "cp437",
	  "cp737": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm737": "cp737",
	  "csibm737": "cp737",
	  "cp775": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm775": "cp775",
	  "csibm775": "cp775",
	  "cp850": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm850": "cp850",
	  "csibm850": "cp850",
	  "cp852": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm852": "cp852",
	  "csibm852": "cp852",
	  "cp855": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm855": "cp855",
	  "csibm855": "cp855",
	  "cp856": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm856": "cp856",
	  "csibm856": "cp856",
	  "cp857": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm857": "cp857",
	  "csibm857": "cp857",
	  "cp858": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm858": "cp858",
	  "csibm858": "cp858",
	  "cp860": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm860": "cp860",
	  "csibm860": "cp860",
	  "cp861": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm861": "cp861",
	  "csibm861": "cp861",
	  "cp862": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm862": "cp862",
	  "csibm862": "cp862",
	  "cp863": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm863": "cp863",
	  "csibm863": "cp863",
	  "cp864": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "ibm864": "cp864",
	  "csibm864": "cp864",
	  "cp865": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm865": "cp865",
	  "csibm865": "cp865",
	  "cp866": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm866": "cp866",
	  "csibm866": "cp866",
	  "cp869": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm869": "cp869",
	  "csibm869": "cp869",
	  "cp922": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm922": "cp922",
	  "csibm922": "cp922",
	  "cp1046": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1046": "cp1046",
	  "csibm1046": "cp1046",
	  "cp1124": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1124": "cp1124",
	  "csibm1124": "cp1124",
	  "cp1125": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1125": "cp1125",
	  "csibm1125": "cp1125",
	  "cp1129": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1129": "cp1129",
	  "csibm1129": "cp1129",
	  "cp1133": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1133": "cp1133",
	  "csibm1133": "cp1133",
	  "cp1161": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1161": "cp1161",
	  "csibm1161": "cp1161",
	  "cp1162": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1162": "cp1162",
	  "csibm1162": "cp1162",
	  "cp1163": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1163": "cp1163",
	  "csibm1163": "cp1163",
	  "maccroatian": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "maccyrillic": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macgreek": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "maciceland": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macroman": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macromania": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macthai": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macturkish": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macukraine": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8r": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8u": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8ru": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8t": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "armscii8": {
	    "type": "_sbcs",
	    "chars": ")(.,-"
	  },
	  "rk1048": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "tcvn": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "georgianacademy": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "georgianps": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "pt154": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "viscii": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "iso646cn": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
	  },
	  "iso646jp": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
	  },
	  "hproman8": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macintosh": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ascii": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "tis620": {
	    "type": "_sbcs",
	    "chars": ""
	  }
	}

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict"
	
	// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
	// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
	// To save memory and loading time, we read table files only when requested.
	
	exports._dbcs = DBCSCodec;
	
	var UNASSIGNED = -1,
	    GB18030_CODE = -2,
	    SEQ_START  = -10,
	    NODE_START = -1000,
	    UNASSIGNED_NODE = new Array(0x100),
	    DEF_CHAR = -1;
	
	for (var i = 0; i < 0x100; i++)
	    UNASSIGNED_NODE[i] = UNASSIGNED;
	
	
	// Class DBCSCodec reads and initializes mapping tables.
	function DBCSCodec(codecOptions, iconv) {
	    this.encodingName = codecOptions.encodingName;
	    if (!codecOptions)
	        throw new Error("DBCS codec is called without the data.")
	    if (!codecOptions.table)
	        throw new Error("Encoding '" + this.encodingName + "' has no data.");
	
	    // Load tables.
	    var mappingTable = codecOptions.table();
	
	
	    // Decode tables: MBCS -> Unicode.
	
	    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
	    // Trie root is decodeTables[0].
	    // Values: >=  0 -> unicode character code. can be > 0xFFFF
	    //         == UNASSIGNED -> unknown/unassigned sequence.
	    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
	    //         <= NODE_START -> index of the next node in our trie to process next byte.
	    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
	    this.decodeTables = [];
	    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.
	
	    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
	    this.decodeTableSeq = [];
	
	    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
	    for (var i = 0; i < mappingTable.length; i++)
	        this._addDecodeChunk(mappingTable[i]);
	
	    this.defaultCharUnicode = iconv.defaultCharUnicode;
	
	    
	    // Encode tables: Unicode -> DBCS.
	
	    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
	    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
	    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
	    //         == UNASSIGNED -> no conversion found. Output a default char.
	    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
	    this.encodeTable = [];
	    
	    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
	    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
	    // means end of sequence (needed when one sequence is a strict subsequence of another).
	    // Objects are kept separately from encodeTable to increase performance.
	    this.encodeTableSeq = [];
	
	    // Some chars can be decoded, but need not be encoded.
	    var skipEncodeChars = {};
	    if (codecOptions.encodeSkipVals)
	        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
	            var val = codecOptions.encodeSkipVals[i];
	            if (typeof val === 'number')
	                skipEncodeChars[val] = true;
	            else
	                for (var j = val.from; j <= val.to; j++)
	                    skipEncodeChars[j] = true;
	        }
	        
	    // Use decode trie to recursively fill out encode tables.
	    this._fillEncodeTable(0, 0, skipEncodeChars);
	
	    // Add more encoding pairs when needed.
	    if (codecOptions.encodeAdd) {
	        for (var uChar in codecOptions.encodeAdd)
	            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
	                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
	    }
	
	    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
	    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
	    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
	
	
	    // Load & create GB18030 tables when needed.
	    if (typeof codecOptions.gb18030 === 'function') {
	        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.
	
	        // Add GB18030 decode tables.
	        var thirdByteNodeIdx = this.decodeTables.length;
	        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
	
	        var fourthByteNodeIdx = this.decodeTables.length;
	        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
	
	        for (var i = 0x81; i <= 0xFE; i++) {
	            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
	            var secondByteNode = this.decodeTables[secondByteNodeIdx];
	            for (var j = 0x30; j <= 0x39; j++)
	                secondByteNode[j] = NODE_START - thirdByteNodeIdx;
	        }
	        for (var i = 0x81; i <= 0xFE; i++)
	            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
	        for (var i = 0x30; i <= 0x39; i++)
	            fourthByteNode[i] = GB18030_CODE
	    }        
	}
	
	DBCSCodec.prototype.encoder = DBCSEncoder;
	DBCSCodec.prototype.decoder = DBCSDecoder;
	
	// Decoder helpers
	DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
	    var bytes = [];
	    for (; addr > 0; addr >>= 8)
	        bytes.push(addr & 0xFF);
	    if (bytes.length == 0)
	        bytes.push(0);
	
	    var node = this.decodeTables[0];
	    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
	        var val = node[bytes[i]];
	
	        if (val == UNASSIGNED) { // Create new node.
	            node[bytes[i]] = NODE_START - this.decodeTables.length;
	            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
	        }
	        else if (val <= NODE_START) { // Existing node.
	            node = this.decodeTables[NODE_START - val];
	        }
	        else
	            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
	    }
	    return node;
	}
	
	
	DBCSCodec.prototype._addDecodeChunk = function(chunk) {
	    // First element of chunk is the hex mbcs code where we start.
	    var curAddr = parseInt(chunk[0], 16);
	
	    // Choose the decoding node where we'll write our chars.
	    var writeTable = this._getDecodeTrieNode(curAddr);
	    curAddr = curAddr & 0xFF;
	
	    // Write all other elements of the chunk to the table.
	    for (var k = 1; k < chunk.length; k++) {
	        var part = chunk[k];
	        if (typeof part === "string") { // String, write as-is.
	            for (var l = 0; l < part.length;) {
	                var code = part.charCodeAt(l++);
	                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
	                    var codeTrail = part.charCodeAt(l++);
	                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
	                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
	                    else
	                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
	                }
	                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
	                    var len = 0xFFF - code + 2;
	                    var seq = [];
	                    for (var m = 0; m < len; m++)
	                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.
	
	                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
	                    this.decodeTableSeq.push(seq);
	                }
	                else
	                    writeTable[curAddr++] = code; // Basic char
	            }
	        } 
	        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
	            var charCode = writeTable[curAddr - 1] + 1;
	            for (var l = 0; l < part; l++)
	                writeTable[curAddr++] = charCode++;
	        }
	        else
	            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
	    }
	    if (curAddr > 0xFF)
	        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
	}
	
	// Encoder helpers
	DBCSCodec.prototype._getEncodeBucket = function(uCode) {
	    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
	    if (this.encodeTable[high] === undefined)
	        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
	    return this.encodeTable[high];
	}
	
	DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
	    var bucket = this._getEncodeBucket(uCode);
	    var low = uCode & 0xFF;
	    if (bucket[low] <= SEQ_START)
	        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
	    else if (bucket[low] == UNASSIGNED)
	        bucket[low] = dbcsCode;
	}
	
	DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
	    
	    // Get the root of character tree according to first character of the sequence.
	    var uCode = seq[0];
	    var bucket = this._getEncodeBucket(uCode);
	    var low = uCode & 0xFF;
	
	    var node;
	    if (bucket[low] <= SEQ_START) {
	        // There's already a sequence with  - use it.
	        node = this.encodeTableSeq[SEQ_START-bucket[low]];
	    }
	    else {
	        // There was no sequence object - allocate a new one.
	        node = {};
	        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
	        bucket[low] = SEQ_START - this.encodeTableSeq.length;
	        this.encodeTableSeq.push(node);
	    }
	
	    // Traverse the character tree, allocating new nodes as needed.
	    for (var j = 1; j < seq.length-1; j++) {
	        var oldVal = node[uCode];
	        if (typeof oldVal === 'object')
	            node = oldVal;
	        else {
	            node = node[uCode] = {}
	            if (oldVal !== undefined)
	                node[DEF_CHAR] = oldVal
	        }
	    }
	
	    // Set the leaf to given dbcsCode.
	    uCode = seq[seq.length-1];
	    node[uCode] = dbcsCode;
	}
	
	DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
	    var node = this.decodeTables[nodeIdx];
	    for (var i = 0; i < 0x100; i++) {
	        var uCode = node[i];
	        var mbCode = prefix + i;
	        if (skipEncodeChars[mbCode])
	            continue;
	
	        if (uCode >= 0)
	            this._setEncodeChar(uCode, mbCode);
	        else if (uCode <= NODE_START)
	            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
	        else if (uCode <= SEQ_START)
	            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
	    }
	}
	
	
	
	// == Encoder ==================================================================
	
	function DBCSEncoder(options, codec) {
	    // Encoder state
	    this.leadSurrogate = -1;
	    this.seqObj = undefined;
	    
	    // Static data
	    this.encodeTable = codec.encodeTable;
	    this.encodeTableSeq = codec.encodeTableSeq;
	    this.defaultCharSingleByte = codec.defCharSB;
	    this.gb18030 = codec.gb18030;
	}
	
	DBCSEncoder.prototype.write = function(str) {
	    var newBuf = new Buffer(str.length * (this.gb18030 ? 4 : 3)), 
	        leadSurrogate = this.leadSurrogate,
	        seqObj = this.seqObj, nextChar = -1,
	        i = 0, j = 0;
	
	    while (true) {
	        // 0. Get next character.
	        if (nextChar === -1) {
	            if (i == str.length) break;
	            var uCode = str.charCodeAt(i++);
	        }
	        else {
	            var uCode = nextChar;
	            nextChar = -1;    
	        }
	
	        // 1. Handle surrogates.
	        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
	            if (uCode < 0xDC00) { // We've got lead surrogate.
	                if (leadSurrogate === -1) {
	                    leadSurrogate = uCode;
	                    continue;
	                } else {
	                    leadSurrogate = uCode;
	                    // Double lead surrogate found.
	                    uCode = UNASSIGNED;
	                }
	            } else { // We've got trail surrogate.
	                if (leadSurrogate !== -1) {
	                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
	                    leadSurrogate = -1;
	                } else {
	                    // Incomplete surrogate pair - only trail surrogate found.
	                    uCode = UNASSIGNED;
	                }
	                
	            }
	        }
	        else if (leadSurrogate !== -1) {
	            // Incomplete surrogate pair - only lead surrogate found.
	            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
	            leadSurrogate = -1;
	        }
	
	        // 2. Convert uCode character.
	        var dbcsCode = UNASSIGNED;
	        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
	            var resCode = seqObj[uCode];
	            if (typeof resCode === 'object') { // Sequence continues.
	                seqObj = resCode;
	                continue;
	
	            } else if (typeof resCode == 'number') { // Sequence finished. Write it.
	                dbcsCode = resCode;
	
	            } else if (resCode == undefined) { // Current character is not part of the sequence.
	
	                // Try default character for this sequence
	                resCode = seqObj[DEF_CHAR];
	                if (resCode !== undefined) {
	                    dbcsCode = resCode; // Found. Write it.
	                    nextChar = uCode; // Current character will be written too in the next iteration.
	
	                } else {
	                    // TODO: What if we have no default? (resCode == undefined)
	                    // Then, we should write first char of the sequence as-is and try the rest recursively.
	                    // Didn't do it for now because no encoding has this situation yet.
	                    // Currently, just skip the sequence and write current char.
	                }
	            }
	            seqObj = undefined;
	        }
	        else if (uCode >= 0) {  // Regular character
	            var subtable = this.encodeTable[uCode >> 8];
	            if (subtable !== undefined)
	                dbcsCode = subtable[uCode & 0xFF];
	            
	            if (dbcsCode <= SEQ_START) { // Sequence start
	                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
	                continue;
	            }
	
	            if (dbcsCode == UNASSIGNED && this.gb18030) {
	                // Use GB18030 algorithm to find character(s) to write.
	                var idx = findIdx(this.gb18030.uChars, uCode);
	                if (idx != -1) {
	                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
	                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
	                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
	                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
	                    newBuf[j++] = 0x30 + dbcsCode;
	                    continue;
	                }
	            }
	        }
	
	        // 3. Write dbcsCode character.
	        if (dbcsCode === UNASSIGNED)
	            dbcsCode = this.defaultCharSingleByte;
	        
	        if (dbcsCode < 0x100) {
	            newBuf[j++] = dbcsCode;
	        }
	        else if (dbcsCode < 0x10000) {
	            newBuf[j++] = dbcsCode >> 8;   // high byte
	            newBuf[j++] = dbcsCode & 0xFF; // low byte
	        }
	        else {
	            newBuf[j++] = dbcsCode >> 16;
	            newBuf[j++] = (dbcsCode >> 8) & 0xFF;
	            newBuf[j++] = dbcsCode & 0xFF;
	        }
	    }
	
	    this.seqObj = seqObj;
	    this.leadSurrogate = leadSurrogate;
	    return newBuf.slice(0, j);
	}
	
	DBCSEncoder.prototype.end = function() {
	    if (this.leadSurrogate === -1 && this.seqObj === undefined)
	        return; // All clean. Most often case.
	
	    var newBuf = new Buffer(10), j = 0;
	
	    if (this.seqObj) { // We're in the sequence.
	        var dbcsCode = this.seqObj[DEF_CHAR];
	        if (dbcsCode !== undefined) { // Write beginning of the sequence.
	            if (dbcsCode < 0x100) {
	                newBuf[j++] = dbcsCode;
	            }
	            else {
	                newBuf[j++] = dbcsCode >> 8;   // high byte
	                newBuf[j++] = dbcsCode & 0xFF; // low byte
	            }
	        } else {
	            // See todo above.
	        }
	        this.seqObj = undefined;
	    }
	
	    if (this.leadSurrogate !== -1) {
	        // Incomplete surrogate pair - only lead surrogate found.
	        newBuf[j++] = this.defaultCharSingleByte;
	        this.leadSurrogate = -1;
	    }
	    
	    return newBuf.slice(0, j);
	}
	
	// Export for testing
	DBCSEncoder.prototype.findIdx = findIdx;
	
	
	// == Decoder ==================================================================
	
	function DBCSDecoder(options, codec) {
	    // Decoder state
	    this.nodeIdx = 0;
	    this.prevBuf = new Buffer(0);
	
	    // Static data
	    this.decodeTables = codec.decodeTables;
	    this.decodeTableSeq = codec.decodeTableSeq;
	    this.defaultCharUnicode = codec.defaultCharUnicode;
	    this.gb18030 = codec.gb18030;
	}
	
	DBCSDecoder.prototype.write = function(buf) {
	    var newBuf = new Buffer(buf.length*2),
	        nodeIdx = this.nodeIdx, 
	        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,
	        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
	        uCode;
	
	    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
	        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
	    
	    for (var i = 0, j = 0; i < buf.length; i++) {
	        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];
	
	        // Lookup in current trie node.
	        var uCode = this.decodeTables[nodeIdx][curByte];
	
	        if (uCode >= 0) { 
	            // Normal character, just use it.
	        }
	        else if (uCode === UNASSIGNED) { // Unknown char.
	            // TODO: Callback with seq.
	            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
	            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
	            uCode = this.defaultCharUnicode.charCodeAt(0);
	        }
	        else if (uCode === GB18030_CODE) {
	            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
	            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);
	            var idx = findIdx(this.gb18030.gbChars, ptr);
	            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
	        }
	        else if (uCode <= NODE_START) { // Go to next trie node.
	            nodeIdx = NODE_START - uCode;
	            continue;
	        }
	        else if (uCode <= SEQ_START) { // Output a sequence of chars.
	            var seq = this.decodeTableSeq[SEQ_START - uCode];
	            for (var k = 0; k < seq.length - 1; k++) {
	                uCode = seq[k];
	                newBuf[j++] = uCode & 0xFF;
	                newBuf[j++] = uCode >> 8;
	            }
	            uCode = seq[seq.length-1];
	        }
	        else
	            throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
	
	        // Write the character to buffer, handling higher planes using surrogate pair.
	        if (uCode > 0xFFFF) { 
	            uCode -= 0x10000;
	            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
	            newBuf[j++] = uCodeLead & 0xFF;
	            newBuf[j++] = uCodeLead >> 8;
	
	            uCode = 0xDC00 + uCode % 0x400;
	        }
	        newBuf[j++] = uCode & 0xFF;
	        newBuf[j++] = uCode >> 8;
	
	        // Reset trie node.
	        nodeIdx = 0; seqStart = i+1;
	    }
	
	    this.nodeIdx = nodeIdx;
	    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
	    return newBuf.slice(0, j).toString('ucs2');
	}
	
	DBCSDecoder.prototype.end = function() {
	    var ret = '';
	
	    // Try to parse all remaining chars.
	    while (this.prevBuf.length > 0) {
	        // Skip 1 character in the buffer.
	        ret += this.defaultCharUnicode;
	        var buf = this.prevBuf.slice(1);
	
	        // Parse remaining as usual.
	        this.prevBuf = new Buffer(0);
	        this.nodeIdx = 0;
	        if (buf.length > 0)
	            ret += this.write(buf);
	    }
	
	    this.nodeIdx = 0;
	    return ret;
	}
	
	// Binary search for GB18030. Returns largest i such that table[i] <= val.
	function findIdx(table, val) {
	    if (table[0] > val)
	        return -1;
	
	    var l = 0, r = table.length;
	    while (l < r-1) { // always table[l] <= val < table[r]
	        var mid = l + Math.floor((r-l+1)/2);
	        if (table[mid] <= val)
	            l = mid;
	        else
	            r = mid;
	    }
	    return l;
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	"use strict"
	
	// Description of supported double byte encodings and aliases.
	// Tables are not require()-d until they are needed to speed up library load.
	// require()-s are direct to support Browserify.
	
	module.exports = {
	    
	    // == Japanese/ShiftJIS ====================================================
	    // All japanese encodings are based on JIS X set of standards:
	    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
	    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
	    //              Has several variations in 1978, 1983, 1990 and 1997.
	    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
	    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
	    //              2 planes, first is superset of 0208, second - revised 0212.
	    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
	
	    // Byte encodings are:
	    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
	    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
	    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
	    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
	    //               0x00-0x7F       - lower part of 0201
	    //               0x8E, 0xA1-0xDF - upper part of 0201
	    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
	    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
	    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
	    //               Used as-is in ISO2022 family.
	    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
	    //                0201-1976 Roman, 0208-1978, 0208-1983.
	    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
	    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
	    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
	    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
	    //
	    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
	    //
	    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
	
	
	    'shiftjis': {
	        type: '_dbcs',
	        table: function() { return __webpack_require__(302) },
	        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
	        encodeSkipVals: [{from: 0xED40, to: 0xF940}],
	    },
	    'csshiftjis': 'shiftjis',
	    'mskanji': 'shiftjis',
	    'sjis': 'shiftjis',
	    'windows31j': 'shiftjis',
	    'xsjis': 'shiftjis',
	    'windows932': 'shiftjis',
	    '932': 'shiftjis',
	    'cp932': 'shiftjis',
	
	    'eucjp': {
	        type: '_dbcs',
	        table: function() { return __webpack_require__(303) },
	        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
	    },
	
	    // TODO: KDDI extension to Shift_JIS
	    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
	    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
	
	    // == Chinese/GBK ==========================================================
	    // http://en.wikipedia.org/wiki/GBK
	
	    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
	    'gb2312': 'cp936',
	    'gb231280': 'cp936',
	    'gb23121980': 'cp936',
	    'csgb2312': 'cp936',
	    'csiso58gb231280': 'cp936',
	    'euccn': 'cp936',
	    'isoir58': 'gbk',
	
	    // Microsoft's CP936 is a subset and approximation of GBK.
	    // TODO: Euro = 0x80 in cp936, but not in GBK (where it's valid but undefined)
	    'windows936': 'cp936',
	    '936': 'cp936',
	    'cp936': {
	        type: '_dbcs',
	        table: function() { return __webpack_require__(304) },
	    },
	
	    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
	    'gbk': {
	        type: '_dbcs',
	        table: function() { return __webpack_require__(304).concat(__webpack_require__(305)) },
	    },
	    'xgbk': 'gbk',
	
	    // GB18030 is an algorithmic extension of GBK.
	    'gb18030': {
	        type: '_dbcs',
	        table: function() { return __webpack_require__(304).concat(__webpack_require__(305)) },
	        gb18030: function() { return __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./tables/gb18030-ranges.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())) },
	    },
	
	    'chinese': 'gb18030',
	
	    // TODO: Support GB18030 (~27000 chars + whole unicode mapping, cp54936)
	    // http://icu-project.org/docs/papers/gb18030.html
	    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
	    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
	
	    // == Korean ===============================================================
	    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
	    'windows949': 'cp949',
	    '949': 'cp949',
	    'cp949': {
	        type: '_dbcs',
	        table: function() { return __webpack_require__(307) },
	    },
	
	    'cseuckr': 'cp949',
	    'csksc56011987': 'cp949',
	    'euckr': 'cp949',
	    'isoir149': 'cp949',
	    'korean': 'cp949',
	    'ksc56011987': 'cp949',
	    'ksc56011989': 'cp949',
	    'ksc5601': 'cp949',
	
	
	    // == Big5/Taiwan/Hong Kong ================================================
	    // There are lots of tables for Big5 and cp950. Please see the following links for history:
	    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
	    // Variations, in roughly number of defined chars:
	    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
	    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
	    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
	    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
	    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
	    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
	    //    Plus, it has 4 combining sequences.
	    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
	    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
	    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
	    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
	    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
	    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
	    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
	    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
	    // 
	    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
	    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
	
	    'windows950': 'cp950',
	    '950': 'cp950',
	    'cp950': {
	        type: '_dbcs',
	        table: function() { return __webpack_require__(308) },
	    },
	
	    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
	    'big5': 'big5hkscs',
	    'big5hkscs': {
	        type: '_dbcs',
	        table: function() { return __webpack_require__(308).concat(__webpack_require__(309)) },
	        encodeSkipVals: [0xa2cc],
	    },
	
	    'cnbig5': 'big5hkscs',
	    'csbig5': 'big5hkscs',
	    'xxbig5': 'big5hkscs',
	
	};


/***/ },
/* 302 */
/***/ function(module, exports) {

	[
	["0","\u0000",128],
	["a1","",62],
	["8140","",9,""],
	["8180",""],
	["81b8",""],
	["81c8",""],
	["81da",""],
	["81f0",""],
	["81fc",""],
	["824f","",9],
	["8260","",25],
	["8281","",25],
	["829f","",82],
	["8340","",62],
	["8380","",22],
	["839f","",16,"",6],
	["83bf","",16,"",6],
	["8440","",5,"",25],
	["8470","",5,"",7],
	["8480","",17],
	["849f",""],
	["8740","",19,"",9],
	["875f",""],
	["877e",""],
	["8780","",4,""],
	["889f",""],
	["8940",""],
	["8980",""],
	["8a40",""],
	["8a80",""],
	["8b40",""],
	["8b80",""],
	["8c40",""],
	["8c80",""],
	["8d40",""],
	["8d80",""],
	["8e40",""],
	["8e80",""],
	["8f40",""],
	["8f80",""],
	["9040",""],
	["9080",""],
	["9140",""],
	["9180",""],
	["9240",""],
	["9280",""],
	["9340",""],
	["9380",""],
	["9440",""],
	["9480",""],
	["9540",""],
	["9580",""],
	["9640",""],
	["9680",""],
	["9740",""],
	["9780",""],
	["9840",""],
	["989f",""],
	["9940",""],
	["9980",""],
	["9a40",""],
	["9a80",""],
	["9b40",""],
	["9b80",""],
	["9c40",""],
	["9c80",""],
	["9d40",""],
	["9d80",""],
	["9e40",""],
	["9e80",""],
	["9f40",""],
	["9f80",""],
	["e040",""],
	["e080",""],
	["e140",""],
	["e180",""],
	["e240",""],
	["e280",""],
	["e340",""],
	["e380",""],
	["e440",""],
	["e480",""],
	["e540",""],
	["e580",""],
	["e640",""],
	["e680",""],
	["e740",""],
	["e780",""],
	["e840",""],
	["e880",""],
	["e940",""],
	["e980",""],
	["ea40",""],
	["ea80",""],
	["ed40",""],
	["ed80",""],
	["ee40",""],
	["ee80",""],
	["eeef","",9,""],
	["f040","",62],
	["f080","",124],
	["f140","",62],
	["f180","",124],
	["f240","",62],
	["f280","",124],
	["f340","",62],
	["f380","",124],
	["f440","",62],
	["f480","",124],
	["f540","",62],
	["f580","",124],
	["f640","",62],
	["f680","",124],
	["f740","",62],
	["f780","",124],
	["f840","",62],
	["f880","",124],
	["f940",""],
	["fa40","",9,"",9,""],
	["fa80",""],
	["fb40",""],
	["fb80",""],
	["fc40",""]
	]


/***/ },
/* 303 */
/***/ function(module, exports) {

	[
	["0","\u0000",127],
	["8ea1","",62],
	["a1a1","",9,""],
	["a2a1",""],
	["a2ba",""],
	["a2ca",""],
	["a2dc",""],
	["a2f2",""],
	["a2fe",""],
	["a3b0","",9],
	["a3c1","",25],
	["a3e1","",25],
	["a4a1","",82],
	["a5a1","",85],
	["a6a1","",16,"",6],
	["a6c1","",16,"",6],
	["a7a1","",5,"",25],
	["a7d1","",5,"",25],
	["a8a1",""],
	["ada1","",19,"",9],
	["adc0",""],
	["addf","",4,""],
	["b0a1",""],
	["b1a1",""],
	["b2a1",""],
	["b3a1",""],
	["b4a1",""],
	["b5a1",""],
	["b6a1",""],
	["b7a1",""],
	["b8a1",""],
	["b9a1",""],
	["baa1",""],
	["bba1",""],
	["bca1",""],
	["bda1",""],
	["bea1",""],
	["bfa1",""],
	["c0a1",""],
	["c1a1",""],
	["c2a1",""],
	["c3a1",""],
	["c4a1",""],
	["c5a1",""],
	["c6a1",""],
	["c7a1",""],
	["c8a1",""],
	["c9a1",""],
	["caa1",""],
	["cba1",""],
	["cca1",""],
	["cda1",""],
	["cea1",""],
	["cfa1",""],
	["d0a1",""],
	["d1a1",""],
	["d2a1",""],
	["d3a1",""],
	["d4a1",""],
	["d5a1",""],
	["d6a1",""],
	["d7a1",""],
	["d8a1",""],
	["d9a1",""],
	["daa1",""],
	["dba1",""],
	["dca1",""],
	["dda1",""],
	["dea1",""],
	["dfa1",""],
	["e0a1",""],
	["e1a1",""],
	["e2a1",""],
	["e3a1",""],
	["e4a1",""],
	["e5a1",""],
	["e6a1",""],
	["e7a1",""],
	["e8a1",""],
	["e9a1",""],
	["eaa1",""],
	["eba1",""],
	["eca1",""],
	["eda1",""],
	["eea1",""],
	["efa1",""],
	["f0a1",""],
	["f1a1",""],
	["f2a1",""],
	["f3a1",""],
	["f4a1",""],
	["f9a1",""],
	["faa1",""],
	["fba1",""],
	["fca1",""],
	["fcf1","",9,""],
	["8fa2af",""],
	["8fa2c2",""],
	["8fa2eb",""],
	["8fa6e1",""],
	["8fa6e7",""],
	["8fa6e9",""],
	["8fa6ec",""],
	["8fa6f1",""],
	["8fa7c2","",10,""],
	["8fa7f2","",10,""],
	["8fa9a1",""],
	["8fa9a4",""],
	["8fa9a6",""],
	["8fa9a8",""],
	["8fa9ab",""],
	["8fa9af",""],
	["8fa9c1",""],
	["8faaa1",""],
	["8faaba",""],
	["8faba1",""],
	["8fabbd",""],
	["8fabc5",""],
	["8fb0a1",""],
	["8fb1a1",""],
	["8fb2a1","",4,""],
	["8fb3a1",""],
	["8fb4a1",""],
	["8fb5a1",""],
	["8fb6a1","",5,"",4,""],
	["8fb7a1","",4,""],
	["8fb8a1",""],
	["8fb9a1",""],
	["8fbaa1","",4,""],
	["8fbba1",""],
	["8fbca1","",4,""],
	["8fbda1","",4,""],
	["8fbea1","",4,""],
	["8fbfa1",""],
	["8fc0a1",""],
	["8fc1a1",""],
	["8fc2a1",""],
	["8fc3a1","",4,""],
	["8fc4a1",""],
	["8fc5a1",""],
	["8fc6a1",""],
	["8fc7a1",""],
	["8fc8a1",""],
	["8fc9a1","",4,"",4,""],
	["8fcaa1",""],
	["8fcba1",""],
	["8fcca1","",9,""],
	["8fcda1","",5,""],
	["8fcea1","",6,""],
	["8fcfa1",""],
	["8fd0a1",""],
	["8fd1a1",""],
	["8fd2a1","",5],
	["8fd3a1",""],
	["8fd4a1","",4,""],
	["8fd5a1",""],
	["8fd6a1",""],
	["8fd7a1",""],
	["8fd8a1",""],
	["8fd9a1","",4,"",6,""],
	["8fdaa1","",4,""],
	["8fdba1","",6,""],
	["8fdca1","",4,""],
	["8fdda1","",4,""],
	["8fdea1","",4,""],
	["8fdfa1",""],
	["8fe0a1",""],
	["8fe1a1","",4,""],
	["8fe2a1",""],
	["8fe3a1","",5,"",4,""],
	["8fe4a1","",4,""],
	["8fe5a1","",4,""],
	["8fe6a1",""],
	["8fe7a1",""],
	["8fe8a1","",4,""],
	["8fe9a1","",4],
	["8feaa1","",4,""],
	["8feba1","",4,""],
	["8feca1",""],
	["8feda1","",4,"",4,""]
	]


/***/ },
/* 304 */
/***/ function(module, exports) {

	[
	["0","\u0000",127,""],
	["8140","",5,"",9,"",6,""],
	["8180","",6,"",4,"",4,"",5,""],
	["8240","",4,"",8,"",4,"",11],
	["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],
	["8340","",17,"",5,"",10,"",4,"",9,""],
	["8380","",5,"",13,"",28,"",4,"",4,"",5],
	["8440","",5,"",5,""],
	["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],
	["8540","",9,""],
	["8580","",4,"",6,"",4,"",4,"",7,""],
	["8640","",4,"",5,"",4,"",5,""],
	["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],
	["8740","",7,"",11,"",4,"",4],
	["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],
	["8840","",9,"",4,"",4,""],
	["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],
	["8940","",5,"",6,"",4,"",5,"",4,"",16,""],
	["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],
	["8a40","",4,"",12,""],
	["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],
	["8b40","",8,"",17,"",6,"",13,""],
	["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],
	["8c40","",7,""],
	["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],
	["8d40","",5,"",5,"",5,"",6,"",9,"",4],
	["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],
	["8e40","",21,"",12,"",6,"",12,""],
	["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],
	["8f40","",5,"",11,"",8,""],
	["8f80","",6,"",14,"",5,"",5,"",4,""],
	["9040","",4,"",4,"",6,""],
	["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],
	["9140","",6,"",6,"",18,"",4,""],
	["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],
	["9240","",6,"",5,""],
	["9280","",5,"",7,"",6,""],
	["9340","",6,"",4,"",4,"",5,""],
	["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],
	["9440","",24,"",7,"",7,"",4,"",8],
	["9480","",4,"",4,"",14,"",7,"",7,""],
	["9540","",4,"",4,"",6,""],
	["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],
	["9640","",5,"",4,""],
	["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],
	["9740","",7,"",8,"",7,"",9,""],
	["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],
	["9840","",4,"",5,"",9,""],
	["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],
	["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],
	["9980","",114,"",6],
	["9a40","",11,"",7,"",13,""],
	["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],
	["9b40","",4,""],
	["9b80","",5,"",4,"",4,"",5,""],
	["9c40","",7,""],
	["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],
	["9d40","",7,"",4,"",9,"",6,""],
	["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],
	["9e40","",7,"",32,"",7,"",6,"",6],
	["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],
	["9f40","",6,"",10,"",4,"",10,"",7,""],
	["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],
	["a040","",9,"",5,"",9,"",11,"",19],
	["a080","",9,"",6,"",4,"",11,"",11,"",6,""],
	["a1a1","",7,""],
	["a2a1","",9],
	["a2b1","",19,"",19,"",9],
	["a2e5","",9],
	["a2f1","",11],
	["a3a1","",88,""],
	["a4a1","",82],
	["a5a1","",85],
	["a6a1","",16,"",6],
	["a6c1","",16,"",6],
	["a6e0",""],
	["a6ee",""],
	["a6f4",""],
	["a7a1","",5,"",25],
	["a7d1","",5,"",25],
	["a840","",35,"",6],
	["a880","",7,""],
	["a8a1",""],
	["a8bd",""],
	["a8c0",""],
	["a8c5","",36],
	["a940","",8,""],
	["a959",""],
	["a95c",""],
	["a960","",9,"",8],
	["a980","",4,""],
	["a996",""],
	["a9a4","",75],
	["aa40","",5,"",5,"",8],
	["aa80","",7,"",10,""],
	["ab40","",11,"",4,"",5,"",4],
	["ab80","",6,"",4],
	["ac40","",10,"",8,"",5,"",4,"",11],
	["ac80","",6,"",12,"",4,""],
	["ad40","",10,"",7,"",15,"",12],
	["ad80","",9,"",8,"",6,""],
	["ae40","",6,"",7,"",4,""],
	["ae80","",7,"",6,"",4,""],
	["af40","",4,""],
	["af80",""],
	["b040","",6,"",5,"",4,"",6,"",7,""],
	["b080","",7,"",8,"",9,""],
	["b140","",4,"",7,"",10,""],
	["b180","",4,"",7,"",7,""],
	["b240","",11,"",5,"",11,"",4],
	["b280","",12,"",8,"",4,""],
	["b340","",5,""],
	["b380","",11,"",7,"",6,""],
	["b440","",7,"",9],
	["b480","",4,"",5,"",6,""],
	["b540","",5,"",9,"",4,"",14,"",4,"",8,""],
	["b580","",6,"",4,""],
	["b640","",6,"",11,"",10,"",4,"",5,""],
	["b680","",6,"",4,""],
	["b740","",14,"",5,"",9,"",4,"",16],
	["b780","",6,""],
	["b840","",4,"",10,"",10,"",9,"",5,""],
	["b880","",4,""],
	["b940","",5,"",10,"",6,""],
	["b980","",7,""],
	["ba40","",4,"",4,"",7,"",5,""],
	["ba80","",4,"",5,"",12,"",5,""],
	["bb40","",9,"",36,"",5,"",9],
	["bb80","",6,"",4,""],
	["bc40","",6,"",6,"",5,"",7,"",13,"",5],
	["bc80","",14,"",6,""],
	["bd40","",54,"",7],
	["bd80","",32,""],
	["be40","",12,"",6,"",42],
	["be80","",32,""],
	["bf40","",62],
	["bf80","",4,"",4,"",21,""],
	["c040","",35,"",23,""],
	["c080","",6,"",9,""],
	["c140","",4,"",7,"",4,"",4,"",6,""],
	["c180","",4,"",4,"",5,""],
	["c240","",6,"",5,""],
	["c280","",13,"",5,"",11,""],
	["c340","",5,"",4,"",6,""],
	["c380","",12,"",4,""],
	["c440","",5,"",4,"",4,"",5,"",4,""],
	["c480","",7,"",5,"",6,""],
	["c540","",14,"",4,"",5,"",4,"",5,""],
	["c580","",7,"",7,""],
	["c640",""],
	["c680","",4,"",9,""],
	["c740","",4,"",4,"",6,"",6,"",6,""],
	["c780",""],
	["c840","",4,"",5,"",5,"",7,"",5,"",7,""],
	["c880","",6,"",4,"",4,""],
	["c940","",4,"",7,"",12,""],
	["c980","",4,"",4,"",10,""],
	["ca40","",8,"",8,"",9,"",4,"",10],
	["ca80","",4,"",8,""],
	["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],
	["cb80","",5,"",6,"",14,""],
	["cc40","",4,"",10,"",15,"",13,""],
	["cc80","",11,"",4,"",7,""],
	["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],
	["cd80",""],
	["ce40","",6,"",5,"",7,""],
	["ce80","",4,"",6,"",4,""],
	["cf40","",4,"",4,"",6,"",9],
	["cf80","",5,"",7,"",4,""],
	["d040","",13,"",5,"",5,"",5,"",6,""],
	["d080","",4,"",4,"",5,""],
	["d140","",4,"",4,"",6,"",5],
	["d180","",4,"",4,"",4,""],
	["d240","",8,"",24,"",5,"",19,""],
	["d280","",26,""],
	["d340","",30,"",6],
	["d380","",4,"",5,"",21,""],
	["d440","",31,"",8,"",21],
	["d480","",25,"",6,""],
	["d540","",7,"",7,"",46],
	["d580","",32,""],
	["d640","",34,"",27],
	["d680","",30,""],
	["d740","",31,"",4,"",25],
	["d780","",24,""],
	["d840","",8,"",7,"",5,"",6,"",6,"",6,""],
	["d880","",6,"",20,""],
	["d940","",62],
	["d980","",32,""],
	["da40","",14,"",8,"",4,"",9,""],
	["da80","",12,""],
	["db40","",6,"",7,"",4,""],
	["db80","",4,"",5,"",11,""],
	["dc40","",4,"",6,"",6,"",11,"",6,"",7],
	["dc80","",10,"",21,""],
	["dd40","",62],
	["dd80","",32,""],
	["de40","",32,""],
	["de80","",4,""],
	["df40","",5,"",4,"",4,"",5,"",4,"",6,""],
	["df80","",4,""],
	["e040","",19,""],
	["e080","",10,"",6,"",8,""],
	["e140","",4,"",6,"",5,"",5,""],
	["e180","",10,"",9,"",8,""],
	["e240","",62],
	["e280","",32,"",5,""],
	["e340","",45,"",16],
	["e380","",7,"",24,""],
	["e440","",5,"",24,"",31],
	["e480","",32,""],
	["e540","",51,"",10],
	["e580","",31,""],
	["e640","",34,"",27],
	["e680","",29,""],
	["e740","",7,"",54],
	["e780","",32,"",6,"",4,""],
	["e840","",14,"",43,""],
	["e880","",20,""],
	["e940","",7,"",42],
	["e980","",32,""],
	["ea40","",27,"",6,""],
	["ea80","",4,"",12,""],
	["eb40","",9,"",7,"",9,"",6,""],
	["eb80","",4,""],
	["ec40","",8,"",4,"",18,"",7],
	["ec80","",4,"",7,"",4,"",4,""],
	["ed40","",6,"",46],
	["ed80","",4,"",23,""],
	["ee40","",62],
	["ee80","",32,"",4,"",6,""],
	["ef40","",5,"",37,"",4],
	["ef80","",30,"",4,"",8,""],
	["f040","",4,"",28,"",26],
	["f080","",9,"",12,"",4,"",6,""],
	["f140","",10,"",47],
	["f180","",32,""],
	["f240","",62],
	["f280","",32,""],
	["f340","",17,"",6,"",4,""],
	["f380","",8,"",6,""],
	["f440","",5,"",10,"",10,"",7,"",5],
	["f480","",32,""],
	["f540","",62],
	["f580","",32,""],
	["f640","",62],
	["f680","",32,"",5,"",5,"",4,"",7,""],
	["f740","",62],
	["f780","",4,"",4,""],
	["f840","",62],
	["f880","",32],
	["f940","",62],
	["f980","",32],
	["fa40","",62],
	["fa80","",32],
	["fb40","",27,"",9,""],
	["fb80","",5,"",8,"",5,""],
	["fc40","",8,"",4,"",8,"",6],
	["fc80","",4,"",5,"",8,""],
	["fd40","",4,"",4,"",10,"",38],
	["fd80","",5,"",11,"",4,""],
	["fe40",""]
	]


/***/ },
/* 305 */
/***/ function(module, exports) {

	[
	["a140","",62],
	["a180","",32],
	["a240","",62],
	["a280","",32],
	["a2ab","",5],
	["a2e3",""],
	["a2ef",""],
	["a2fd",""],
	["a340","",62],
	["a380","",31,""],
	["a440","",62],
	["a480","",32],
	["a4f4","",10],
	["a540","",62],
	["a580","",32],
	["a5f7","",7],
	["a640","",62],
	["a680","",32],
	["a6b9","",7],
	["a6d9","",6],
	["a6ec",""],
	["a6f3",""],
	["a6f6","",8],
	["a740","",62],
	["a780","",32],
	["a7c2","",14],
	["a7f2","",12],
	["a896","",10],
	["a8bc",""],
	["a8bf",""],
	["a8c1",""],
	["a8ea","",20],
	["a958",""],
	["a95b",""],
	["a95d",""],
	["a989","",11],
	["a997","",12],
	["a9f0","",14],
	["aaa1","",93],
	["aba1","",93],
	["aca1","",93],
	["ada1","",93],
	["aea1","",93],
	["afa1","",93],
	["d7fa","",4],
	["f8a1","",93],
	["f9a1","",93],
	["faa1","",93],
	["fba1","",93],
	["fca1","",93],
	["fda1","",93],
	["fe50",""],
	["fe80","",6,"",93]
	]


/***/ },
/* 306 */,
/* 307 */
/***/ function(module, exports) {

	[
	["0","\u0000",127],
	["8141","",4,"",6,""],
	["8161","",9,"",5,""],
	["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],
	["8241","",7,"",5],
	["8261","",6,"",5,""],
	["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],
	["8341","",5,"",5,"",7],
	["8361","",18,""],
	["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],
	["8441","",5,"",8],
	["8461","",18],
	["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],
	["8541","",5,"",4,"",6,"",4],
	["8561","",5,"",5,"",6,""],
	["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],
	["8641","",6,"",5,""],
	["8661","",6,"",10],
	["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],
	["8741","",9,"",15],
	["8761","",18,""],
	["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],
	["8841","",4,"",5,"",6,"",4],
	["8861","",4,""],
	["8881","",15,"",4,"",6,"",5,"",54,""],
	["8941","",6,"",5,""],
	["8961","",10,"",5,""],
	["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],
	["8a41","",10,"",6,""],
	["8a61","",4,"",18,""],
	["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],
	["8b41","",5,"",4,"",6,""],
	["8b61","",6,"",8],
	["8b81","",52,"",4,"",6,"",5,"",18,"",18],
	["8c41","",15,"",4],
	["8c61","",6,"",5,"",6,"",5],
	["8c81","",12,"",26,"",50,"",5,"",16],
	["8d41","",16,"",8],
	["8d61","",17,""],
	["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],
	["8e41","",6,"",5,"",8],
	["8e61","",4,"",19],
	["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],
	["8f41","",7,"",17],
	["8f61","",7,"",6,"",4],
	["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],
	["9041","",6,"",5,""],
	["9061","",5,"",15],
	["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],
	["9141","",6,"",5],
	["9161","",9,"",5],
	["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],
	["9241","",7,"",4,""],
	["9261","",7,"",7,"",4],
	["9281","",21,"",18,"",6,"",7,"",6,"",35,""],
	["9341","",4,""],
	["9361","",6,"",8],
	["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],
	["9441","",5,"",5,"",8],
	["9461","",5,"",6,"",12],
	["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],
	["9541","",11,"",5,""],
	["9561","",6,"",5,""],
	["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],
	["9641","",23,""],
	["9661","",6,"",5,"",8],
	["9681","",10,"",5,"",13,"",33,"",6,"",44],
	["9741","",16,"",8],
	["9761","",17,"",7],
	["9781","",11,"",5,"",6,"",89,""],
	["9841","",16,"",5,""],
	["9861","",6,"",15],
	["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],
	["9941","",6,"",5,""],
	["9961","",6,"",5,""],
	["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],
	["9a41","",16],
	["9a61","",6,"",6,""],
	["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],
	["9b41","",6,"",8],
	["9b61","",17,"",7],
	["9b81","",25,"",4,"",5,"",50,"",22,""],
	["9c41","",4,"",5,"",5],
	["9c61","",8,"",6,"",9],
	["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],
	["9d41","",13,"",8],
	["9d61","",25],
	["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],
	["9e41","",7,"",9,""],
	["9e61","",4,"",6,""],
	["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],
	["9f41","",5,"",4,"",5,""],
	["9f61","",6,"",5,""],
	["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],
	["a041","",5,"",6,""],
	["a061","",5,"",13],
	["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],
	["a141","",18,""],
	["a161","",6,"",5,""],
	["a181","",14,"",5,"",4,"",9,""],
	["a241","",5,"",18],
	["a261","",6,"",18],
	["a281","",7,"",6,"",7,""],
	["a341","",6,"",10,""],
	["a361","",6,"",16],
	["a381","",16,"",4,"",58,"",32,""],
	["a441","",5,""],
	["a461","",5,"",12],
	["a481","",28,"",93],
	["a541","",4,"",6,"",5,""],
	["a561","",17,"",5,""],
	["a581","",16,"",14,"",9],
	["a5b0","",9],
	["a5c1","",16,"",6],
	["a5e1","",16,"",6],
	["a641","",19,""],
	["a661","",5,"",5,"",6],
	["a681","",6,"",18,"",7],
	["a741","",4,"",6,"",7],
	["a761","",22,""],
	["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],
	["a841","",10,"",14],
	["a861","",18,"",6],
	["a881","",19,"",11,""],
	["a8a6",""],
	["a8a8",""],
	["a8b1","",27,"",25,"",14,""],
	["a941","",14,"",10],
	["a961","",18],
	["a981","",14,"",6,"",27,"",25,"",14,""],
	["aa41","",6,"",4,""],
	["aa61","",4,"",5,"",6,""],
	["aa81","",29,"",82],
	["ab41","",6,"",5,""],
	["ab61","",6,"",5,"",5],
	["ab81","",8,"",6,"",12,"",85],
	["ac41","",5,"",6,""],
	["ac61","",11,"",4],
	["ac81","",28,"",5,"",25],
	["acd1","",5,"",25],
	["ad41","",6,"",5,"",7],
	["ad61","",6,"",10,""],
	["ad81","",5,"",18,""],
	["ae41","",5,"",16],
	["ae61","",5,"",6,"",4],
	["ae81","",6,"",5,""],
	["af41","",19],
	["af61","",13,"",5,""],
	["af81","",5,"",6,"",5,""],
	["b041","",5,"",5,"",12],
	["b061","",5,"",19],
	["b081","",13,"",6,"",5,"",7,"",4,""],
	["b141","",6,"",5,""],
	["b161","",6,"",5,"",11],
	["b181","",14,"",6,""],
	["b241","",6,"",5,""],
	["b261","",18,"",5,""],
	["b281","",5,"",18,"",6,""],
	["b341","",19,""],
	["b361","",5,"",5,"",5],
	["b381","",5,"",5,"",19,"",4,""],
	["b441","",5,"",6,"",5],
	["b461","",6,"",10,""],
	["b481","",6,"",18,"",4,"",4,""],
	["b541","",14,"",5],
	["b561","",5,"",5,"",4],
	["b581","",6,"",5,"",11,""],
	["b641","",7,"",17],
	["b661","",15,""],
	["b681","",5,"",6,"",5,""],
	["b741","",13,"",6,""],
	["b761","",20,""],
	["b781","",6,"",14,""],
	["b841","",7,"",17],
	["b861","",8,"",13],
	["b881","",5,"",24,"",4,""],
	["b941","",6,"",5,""],
	["b961","",14,"",6,""],
	["b981","",22,"",4,"",4,""],
	["ba41","",5,"",6,""],
	["ba61","",5,"",4,"",5],
	["ba81","",6,"",9,""],
	["bb41","",4,"",5,"",4,""],
	["bb61","",6,"",5,""],
	["bb81","",31,""],
	["bc41","",17,""],
	["bc61","",5,"",6,""],
	["bc81","",4,"",6,"",5,"",5,"",4,""],
	["bd41","",7,"",7,""],
	["bd61","",5,"",13],
	["bd81","",5,"",25,""],
	["be41","",7,"",14],
	["be61","",7,"",7,""],
	["be81","",4,"",4,"",5,"",8,"",6,""],
	["bf41","",10,"",14],
	["bf61","",18,""],
	["bf81","",5,"",7,"",6,"",5,""],
	["c041","",5,"",6,"",5],
	["c061","",25],
	["c081","",6,"",5,"",7,""],
	["c141","",5,"",6,""],
	["c161","",19,""],
	["c181","",31,""],
	["c241","",4,"",5,""],
	["c261","",4,"",5,"",6,""],
	["c281","",5,"",7,"",9,""],
	["c341","",4],
	["c361","",4,"",5,"",11],
	["c381","",5,"",7,"",5,""],
	["c441","",7,"",7,""],
	["c461","",5,"",4],
	["c481","",5,"",11,""],
	["c541","",6,"",5,""],
	["c561","",6,"",5,"",4],
	["c581","",6,"",5,""],
	["c641","",6,"",5],
	["c6a1",""],
	["c7a1",""],
	["c8a1",""],
	["caa1",""],
	["cba1",""],
	["cca1",""],
	["cda1",""],
	["cea1",""],
	["cfa1",""],
	["d0a1",""],
	["d1a1","",5,"",4,""],
	["d2a1","",4,"",5,"",10,"",7,"",5,""],
	["d3a1",""],
	["d4a1",""],
	["d5a1",""],
	["d6a1",""],
	["d7a1",""],
	["d8a1",""],
	["d9a1",""],
	["daa1",""],
	["dba1",""],
	["dca1",""],
	["dda1",""],
	["dea1",""],
	["dfa1",""],
	["e0a1",""],
	["e1a1",""],
	["e2a1",""],
	["e3a1",""],
	["e4a1",""],
	["e5a1",""],
	["e6a1",""],
	["e7a1",""],
	["e8a1",""],
	["e9a1",""],
	["eaa1",""],
	["eba1",""],
	["eca1",""],
	["eda1",""],
	["eea1",""],
	["efa1",""],
	["f0a1",""],
	["f1a1",""],
	["f2a1",""],
	["f3a1",""],
	["f4a1",""],
	["f5a1",""],
	["f6a1",""],
	["f7a1",""],
	["f8a1",""],
	["f9a1",""],
	["faa1",""],
	["fba1",""],
	["fca1",""],
	["fda1",""]
	]


/***/ },
/* 308 */
/***/ function(module, exports) {

	[
	["0","\u0000",127],
	["a140",""],
	["a1a1","",4,""],
	["a240","",7,""],
	["a2a1","",9,"",9,"",8,"",25,"",21],
	["a340","",16,"",6,"",16,"",6,"",10],
	["a3a1","",25,""],
	["a3e1",""],
	["a440",""],
	["a4a1",""],
	["a540",""],
	["a5a1",""],
	["a640",""],
	["a6a1",""],
	["a740",""],
	["a7a1",""],
	["a840",""],
	["a8a1",""],
	["a940",""],
	["a9a1",""],
	["aa40",""],
	["aaa1",""],
	["ab40",""],
	["aba1",""],
	["ac40",""],
	["aca1",""],
	["ad40",""],
	["ada1",""],
	["ae40",""],
	["aea1",""],
	["af40",""],
	["afa1",""],
	["b040",""],
	["b0a1",""],
	["b140",""],
	["b1a1",""],
	["b240",""],
	["b2a1",""],
	["b340",""],
	["b3a1",""],
	["b440",""],
	["b4a1",""],
	["b540",""],
	["b5a1",""],
	["b640",""],
	["b6a1",""],
	["b740",""],
	["b7a1",""],
	["b840",""],
	["b8a1",""],
	["b940",""],
	["b9a1",""],
	["ba40",""],
	["baa1",""],
	["bb40",""],
	["bba1",""],
	["bc40",""],
	["bca1",""],
	["bd40",""],
	["bda1",""],
	["be40",""],
	["bea1",""],
	["bf40",""],
	["bfa1",""],
	["c040",""],
	["c0a1",""],
	["c140",""],
	["c1a1",""],
	["c240",""],
	["c2a1",""],
	["c340",""],
	["c3a1",""],
	["c440",""],
	["c4a1",""],
	["c540",""],
	["c5a1",""],
	["c640",""],
	["c940",""],
	["c9a1",""],
	["ca40",""],
	["caa1",""],
	["cb40",""],
	["cba1",""],
	["cc40",""],
	["cca1",""],
	["cd40",""],
	["cda1",""],
	["ce40",""],
	["cea1",""],
	["cf40",""],
	["cfa1",""],
	["d040",""],
	["d0a1",""],
	["d140",""],
	["d1a1",""],
	["d240",""],
	["d2a1",""],
	["d340",""],
	["d3a1",""],
	["d440",""],
	["d4a1",""],
	["d540",""],
	["d5a1",""],
	["d640",""],
	["d6a1",""],
	["d740",""],
	["d7a1",""],
	["d840",""],
	["d8a1",""],
	["d940",""],
	["d9a1",""],
	["da40",""],
	["daa1",""],
	["db40",""],
	["dba1",""],
	["dc40",""],
	["dca1",""],
	["dd40",""],
	["dda1",""],
	["de40",""],
	["dea1",""],
	["df40",""],
	["dfa1",""],
	["e040",""],
	["e0a1",""],
	["e140",""],
	["e1a1",""],
	["e240",""],
	["e2a1",""],
	["e340",""],
	["e3a1",""],
	["e440",""],
	["e4a1",""],
	["e540",""],
	["e5a1",""],
	["e640",""],
	["e6a1",""],
	["e740",""],
	["e7a1",""],
	["e840",""],
	["e8a1",""],
	["e940",""],
	["e9a1",""],
	["ea40",""],
	["eaa1",""],
	["eb40",""],
	["eba1",""],
	["ec40",""],
	["eca1",""],
	["ed40",""],
	["eda1",""],
	["ee40",""],
	["eea1",""],
	["ef40",""],
	["efa1",""],
	["f040",""],
	["f0a1",""],
	["f140",""],
	["f1a1",""],
	["f240",""],
	["f2a1",""],
	["f340",""],
	["f3a1",""],
	["f440",""],
	["f4a1",""],
	["f540",""],
	["f5a1",""],
	["f640",""],
	["f6a1",""],
	["f740",""],
	["f7a1",""],
	["f840",""],
	["f8a1",""],
	["f940",""],
	["f9a1",""]
	]


/***/ },
/* 309 */
/***/ function(module, exports) {

	[
	["8740",""],
	["8767",""],
	["87a1",""],
	["8840","",4,""],
	["88a1",""],
	["8940",""],
	["8943",""],
	["8946",""],
	["894c",""],
	["89a1",""],
	["89ab",""],
	["89b0",""],
	["89b5",""],
	["89c1",""],
	["89c5",""],
	["8a40",""],
	["8a43",""],
	["8a64",""],
	["8a76",""],
	["8aa1",""],
	["8aac",""],
	["8ab2",""],
	["8abb",""],
	["8ac9",""],
	["8ace",""],
	["8adf",""],
	["8af6",""],
	["8b40",""],
	["8b55",""],
	["8ba1",""],
	["8bde",""],
	["8c40",""],
	["8ca1",""],
	["8ca7",""],
	["8cc9",""],
	["8cce",""],
	["8ce6",""],
	["8d40",""],
	["8d42",""],
	["8da1",""],
	["8e40",""],
	["8ea1",""],
	["8f40",""],
	["8fa1",""],
	["9040",""],
	["90a1",""],
	["9140",""],
	["91a1",""],
	["9240",""],
	["92a1",""],
	["9340",""],
	["93a1",""],
	["9440",""],
	["94a1",""],
	["9540",""],
	["95a1",""],
	["9640",""],
	["96a1",""],
	["9740",""],
	["97a1",""],
	["9840",""],
	["98a1",""],
	["9940",""],
	["99a1",""],
	["9a40",""],
	["9aa1",""],
	["9b40",""],
	["9b62",""],
	["9ba1",""],
	["9c40",""],
	["9ca1",""],
	["9d40",""],
	["9da1",""],
	["9e40",""],
	["9ea1",""],
	["9ead",""],
	["9ec5",""],
	["9ef5",""],
	["9f40",""],
	["9f4f",""],
	["9fa1",""],
	["9fae",""],
	["9fb2",""],
	["9fc1",""],
	["9fc9",""],
	["9fdb",""],
	["9fe7",""],
	["9feb",""],
	["9ff0",""],
	["a040",""],
	["a055",""],
	["a058",""],
	["a05b",""],
	["a063",""],
	["a073",""],
	["a0a1",""],
	["a0a6",""],
	["a0ae",""],
	["a0b0",""],
	["a0d4",""],
	["a0e2",""],
	["a3c0","",31,""],
	["c6a1","",9,"",9,"",9,"",23],
	["c740","",58,""],
	["c7a1","",81,"",5,"",4],
	["c840","",26,"",25,""],
	["c8a1",""],
	["c8cd",""],
	["c8f5",""],
	["f9fe",""],
	["fa40",""],
	["faa1",""],
	["fb40",""],
	["fba1",""],
	["fc40",""],
	["fca1",""],
	["fd40",""],
	["fda1",""],
	["fe40",""],
	["fea1",""]
	]


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict"
	
	var Transform = __webpack_require__(54).Transform;
	
	
	// == Exports ==================================================================
	module.exports = function(iconv) {
	    
	    // Additional Public API.
	    iconv.encodeStream = function encodeStream(encoding, options) {
	        return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
	    }
	
	    iconv.decodeStream = function decodeStream(encoding, options) {
	        return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
	    }
	
	    iconv.supportsStreams = true;
	
	
	    // Not published yet.
	    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
	    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
	    iconv._collect = IconvLiteDecoderStream.prototype.collect;
	};
	
	
	// == Encoder stream =======================================================
	function IconvLiteEncoderStream(conv, options) {
	    this.conv = conv;
	    options = options || {};
	    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
	    Transform.call(this, options);
	}
	
	IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
	    constructor: { value: IconvLiteEncoderStream }
	});
	
	IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
	    if (typeof chunk != 'string')
	        return done(new Error("Iconv encoding stream needs strings as its input."));
	    try {
	        var res = this.conv.write(chunk);
	        if (res && res.length) this.push(res);
	        done();
	    }
	    catch (e) {
	        done(e);
	    }
	}
	
	IconvLiteEncoderStream.prototype._flush = function(done) {
	    try {
	        var res = this.conv.end();
	        if (res && res.length) this.push(res);
	        done();
	    }
	    catch (e) {
	        done(e);
	    }
	}
	
	IconvLiteEncoderStream.prototype.collect = function(cb) {
	    var chunks = [];
	    this.on('error', cb);
	    this.on('data', function(chunk) { chunks.push(chunk); });
	    this.on('end', function() {
	        cb(null, Buffer.concat(chunks));
	    });
	    return this;
	}
	
	
	// == Decoder stream =======================================================
	function IconvLiteDecoderStream(conv, options) {
	    this.conv = conv;
	    options = options || {};
	    options.encoding = this.encoding = 'utf8'; // We output strings.
	    Transform.call(this, options);
	}
	
	IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
	    constructor: { value: IconvLiteDecoderStream }
	});
	
	IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
	    if (!Buffer.isBuffer(chunk))
	        return done(new Error("Iconv decoding stream needs buffers as its input."));
	    try {
	        var res = this.conv.write(chunk);
	        if (res && res.length) this.push(res, this.encoding);
	        done();
	    }
	    catch (e) {
	        done(e);
	    }
	}
	
	IconvLiteDecoderStream.prototype._flush = function(done) {
	    try {
	        var res = this.conv.end();
	        if (res && res.length) this.push(res, this.encoding);                
	        done();
	    }
	    catch (e) {
	        done(e);
	    }
	}
	
	IconvLiteDecoderStream.prototype.collect = function(cb) {
	    var res = '';
	    this.on('error', cb);
	    this.on('data', function(chunk) { res += chunk; });
	    this.on('end', function() {
	        cb(null, res);
	    });
	    return this;
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict"
	
	// == Extend Node primitives to use iconv-lite =================================
	
	module.exports = function (iconv) {
	    var original = undefined; // Place to keep original methods.
	
	    // Node authors rewrote Buffer internals to make it compatible with
	    // Uint8Array and we cannot patch key functions since then.
	    iconv.supportsNodeEncodingsExtension = !(new Buffer(0) instanceof Uint8Array);
	
	    iconv.extendNodeEncodings = function extendNodeEncodings() {
	        if (original) return;
	        original = {};
	
	        if (!iconv.supportsNodeEncodingsExtension) {
	            console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
	            console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
	            return;
	        }
	
	        var nodeNativeEncodings = {
	            'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true, 
	            'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true,
	        };
	
	        Buffer.isNativeEncoding = function(enc) {
	            return enc && nodeNativeEncodings[enc.toLowerCase()];
	        }
	
	        // -- SlowBuffer -----------------------------------------------------------
	        var SlowBuffer = __webpack_require__(9).SlowBuffer;
	
	        original.SlowBufferToString = SlowBuffer.prototype.toString;
	        SlowBuffer.prototype.toString = function(encoding, start, end) {
	            encoding = String(encoding || 'utf8').toLowerCase();
	
	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding))
	                return original.SlowBufferToString.call(this, encoding, start, end);
	
	            // Otherwise, use our decoding method.
	            if (typeof start == 'undefined') start = 0;
	            if (typeof end == 'undefined') end = this.length;
	            return iconv.decode(this.slice(start, end), encoding);
	        }
	
	        original.SlowBufferWrite = SlowBuffer.prototype.write;
	        SlowBuffer.prototype.write = function(string, offset, length, encoding) {
	            // Support both (string, offset, length, encoding)
	            // and the legacy (string, encoding, offset, length)
	            if (isFinite(offset)) {
	                if (!isFinite(length)) {
	                    encoding = length;
	                    length = undefined;
	                }
	            } else {  // legacy
	                var swap = encoding;
	                encoding = offset;
	                offset = length;
	                length = swap;
	            }
	
	            offset = +offset || 0;
	            var remaining = this.length - offset;
	            if (!length) {
	                length = remaining;
	            } else {
	                length = +length;
	                if (length > remaining) {
	                    length = remaining;
	                }
	            }
	            encoding = String(encoding || 'utf8').toLowerCase();
	
	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding))
	                return original.SlowBufferWrite.call(this, string, offset, length, encoding);
	
	            if (string.length > 0 && (length < 0 || offset < 0))
	                throw new RangeError('attempt to write beyond buffer bounds');
	
	            // Otherwise, use our encoding method.
	            var buf = iconv.encode(string, encoding);
	            if (buf.length < length) length = buf.length;
	            buf.copy(this, offset, 0, length);
	            return length;
	        }
	
	        // -- Buffer ---------------------------------------------------------------
	
	        original.BufferIsEncoding = Buffer.isEncoding;
	        Buffer.isEncoding = function(encoding) {
	            return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
	        }
	
	        original.BufferByteLength = Buffer.byteLength;
	        Buffer.byteLength = SlowBuffer.byteLength = function(str, encoding) {
	            encoding = String(encoding || 'utf8').toLowerCase();
	
	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding))
	                return original.BufferByteLength.call(this, str, encoding);
	
	            // Slow, I know, but we don't have a better way yet.
	            return iconv.encode(str, encoding).length;
	        }
	
	        original.BufferToString = Buffer.prototype.toString;
	        Buffer.prototype.toString = function(encoding, start, end) {
	            encoding = String(encoding || 'utf8').toLowerCase();
	
	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding))
	                return original.BufferToString.call(this, encoding, start, end);
	
	            // Otherwise, use our decoding method.
	            if (typeof start == 'undefined') start = 0;
	            if (typeof end == 'undefined') end = this.length;
	            return iconv.decode(this.slice(start, end), encoding);
	        }
	
	        original.BufferWrite = Buffer.prototype.write;
	        Buffer.prototype.write = function(string, offset, length, encoding) {
	            var _offset = offset, _length = length, _encoding = encoding;
	            // Support both (string, offset, length, encoding)
	            // and the legacy (string, encoding, offset, length)
	            if (isFinite(offset)) {
	                if (!isFinite(length)) {
	                    encoding = length;
	                    length = undefined;
	                }
	            } else {  // legacy
	                var swap = encoding;
	                encoding = offset;
	                offset = length;
	                length = swap;
	            }
	
	            encoding = String(encoding || 'utf8').toLowerCase();
	
	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding))
	                return original.BufferWrite.call(this, string, _offset, _length, _encoding);
	
	            offset = +offset || 0;
	            var remaining = this.length - offset;
	            if (!length) {
	                length = remaining;
	            } else {
	                length = +length;
	                if (length > remaining) {
	                    length = remaining;
	                }
	            }
	
	            if (string.length > 0 && (length < 0 || offset < 0))
	                throw new RangeError('attempt to write beyond buffer bounds');
	
	            // Otherwise, use our encoding method.
	            var buf = iconv.encode(string, encoding);
	            if (buf.length < length) length = buf.length;
	            buf.copy(this, offset, 0, length);
	            return length;
	
	            // TODO: Set _charsWritten.
	        }
	
	
	        // -- Readable -------------------------------------------------------------
	        if (iconv.supportsStreams) {
	            var Readable = __webpack_require__(54).Readable;
	
	            original.ReadableSetEncoding = Readable.prototype.setEncoding;
	            Readable.prototype.setEncoding = function setEncoding(enc, options) {
	                // Use our own decoder, it has the same interface.
	                // We cannot use original function as it doesn't handle BOM-s.
	                this._readableState.decoder = iconv.getDecoder(enc, options);
	                this._readableState.encoding = enc;
	            }
	
	            Readable.prototype.collect = iconv._collect;
	        }
	    }
	
	    // Remove iconv-lite Node primitive extensions.
	    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
	        if (!iconv.supportsNodeEncodingsExtension)
	            return;
	        if (!original)
	            throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.")
	
	        delete Buffer.isNativeEncoding;
	
	        var SlowBuffer = __webpack_require__(9).SlowBuffer;
	
	        SlowBuffer.prototype.toString = original.SlowBufferToString;
	        SlowBuffer.prototype.write = original.SlowBufferWrite;
	
	        Buffer.isEncoding = original.BufferIsEncoding;
	        Buffer.byteLength = original.BufferByteLength;
	        Buffer.prototype.toString = original.BufferToString;
	        Buffer.prototype.write = original.BufferWrite;
	
	        if (iconv.supportsStreams) {
	            var Readable = __webpack_require__(54).Readable;
	
	            Readable.prototype.setEncoding = original.ReadableSetEncoding;
	            delete Readable.prototype.collect;
	        }
	
	        original = undefined;
	    }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Transform = __webpack_require__(313);
	
	var binding = __webpack_require__(319);
	var util = __webpack_require__(77);
	var assert = __webpack_require__(185).ok;
	
	// zlib doesn't provide these, so kludge them in following the same
	// const naming scheme zlib uses.
	binding.Z_MIN_WINDOWBITS = 8;
	binding.Z_MAX_WINDOWBITS = 15;
	binding.Z_DEFAULT_WINDOWBITS = 15;
	
	// fewer than 64 bytes per chunk is stupid.
	// technically it could work with as few as 8, but even 64 bytes
	// is absurdly low.  Usually a MB or more is best.
	binding.Z_MIN_CHUNK = 64;
	binding.Z_MAX_CHUNK = Infinity;
	binding.Z_DEFAULT_CHUNK = (16 * 1024);
	
	binding.Z_MIN_MEMLEVEL = 1;
	binding.Z_MAX_MEMLEVEL = 9;
	binding.Z_DEFAULT_MEMLEVEL = 8;
	
	binding.Z_MIN_LEVEL = -1;
	binding.Z_MAX_LEVEL = 9;
	binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
	
	// expose all the zlib constants
	Object.keys(binding).forEach(function(k) {
	  if (k.match(/^Z/)) exports[k] = binding[k];
	});
	
	// translation table for return codes.
	exports.codes = {
	  Z_OK: binding.Z_OK,
	  Z_STREAM_END: binding.Z_STREAM_END,
	  Z_NEED_DICT: binding.Z_NEED_DICT,
	  Z_ERRNO: binding.Z_ERRNO,
	  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
	  Z_DATA_ERROR: binding.Z_DATA_ERROR,
	  Z_MEM_ERROR: binding.Z_MEM_ERROR,
	  Z_BUF_ERROR: binding.Z_BUF_ERROR,
	  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
	};
	
	Object.keys(exports.codes).forEach(function(k) {
	  exports.codes[exports.codes[k]] = k;
	});
	
	exports.Deflate = Deflate;
	exports.Inflate = Inflate;
	exports.Gzip = Gzip;
	exports.Gunzip = Gunzip;
	exports.DeflateRaw = DeflateRaw;
	exports.InflateRaw = InflateRaw;
	exports.Unzip = Unzip;
	
	exports.createDeflate = function(o) {
	  return new Deflate(o);
	};
	
	exports.createInflate = function(o) {
	  return new Inflate(o);
	};
	
	exports.createDeflateRaw = function(o) {
	  return new DeflateRaw(o);
	};
	
	exports.createInflateRaw = function(o) {
	  return new InflateRaw(o);
	};
	
	exports.createGzip = function(o) {
	  return new Gzip(o);
	};
	
	exports.createGunzip = function(o) {
	  return new Gunzip(o);
	};
	
	exports.createUnzip = function(o) {
	  return new Unzip(o);
	};
	
	
	// Convenience methods.
	// compress/decompress a string or buffer in one step.
	exports.deflate = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Deflate(opts), buffer, callback);
	};
	
	exports.deflateSync = function(buffer, opts) {
	  return zlibBufferSync(new Deflate(opts), buffer);
	};
	
	exports.gzip = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Gzip(opts), buffer, callback);
	};
	
	exports.gzipSync = function(buffer, opts) {
	  return zlibBufferSync(new Gzip(opts), buffer);
	};
	
	exports.deflateRaw = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
	};
	
	exports.deflateRawSync = function(buffer, opts) {
	  return zlibBufferSync(new DeflateRaw(opts), buffer);
	};
	
	exports.unzip = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Unzip(opts), buffer, callback);
	};
	
	exports.unzipSync = function(buffer, opts) {
	  return zlibBufferSync(new Unzip(opts), buffer);
	};
	
	exports.inflate = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Inflate(opts), buffer, callback);
	};
	
	exports.inflateSync = function(buffer, opts) {
	  return zlibBufferSync(new Inflate(opts), buffer);
	};
	
	exports.gunzip = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Gunzip(opts), buffer, callback);
	};
	
	exports.gunzipSync = function(buffer, opts) {
	  return zlibBufferSync(new Gunzip(opts), buffer);
	};
	
	exports.inflateRaw = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new InflateRaw(opts), buffer, callback);
	};
	
	exports.inflateRawSync = function(buffer, opts) {
	  return zlibBufferSync(new InflateRaw(opts), buffer);
	};
	
	function zlibBuffer(engine, buffer, callback) {
	  var buffers = [];
	  var nread = 0;
	
	  engine.on('error', onError);
	  engine.on('end', onEnd);
	
	  engine.end(buffer);
	  flow();
	
	  function flow() {
	    var chunk;
	    while (null !== (chunk = engine.read())) {
	      buffers.push(chunk);
	      nread += chunk.length;
	    }
	    engine.once('readable', flow);
	  }
	
	  function onError(err) {
	    engine.removeListener('end', onEnd);
	    engine.removeListener('readable', flow);
	    callback(err);
	  }
	
	  function onEnd() {
	    var buf = Buffer.concat(buffers, nread);
	    buffers = [];
	    callback(null, buf);
	    engine.close();
	  }
	}
	
	function zlibBufferSync(engine, buffer) {
	  if (typeof buffer === 'string')
	    buffer = new Buffer(buffer);
	  if (!Buffer.isBuffer(buffer))
	    throw new TypeError('Not a string or buffer');
	
	  var flushFlag = binding.Z_FINISH;
	
	  return engine._processChunk(buffer, flushFlag);
	}
	
	// generic zlib
	// minimal 2-byte header
	function Deflate(opts) {
	  if (!(this instanceof Deflate)) return new Deflate(opts);
	  Zlib.call(this, opts, binding.DEFLATE);
	}
	
	function Inflate(opts) {
	  if (!(this instanceof Inflate)) return new Inflate(opts);
	  Zlib.call(this, opts, binding.INFLATE);
	}
	
	
	
	// gzip - bigger header, same deflate compression
	function Gzip(opts) {
	  if (!(this instanceof Gzip)) return new Gzip(opts);
	  Zlib.call(this, opts, binding.GZIP);
	}
	
	function Gunzip(opts) {
	  if (!(this instanceof Gunzip)) return new Gunzip(opts);
	  Zlib.call(this, opts, binding.GUNZIP);
	}
	
	
	
	// raw - no header
	function DeflateRaw(opts) {
	  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
	  Zlib.call(this, opts, binding.DEFLATERAW);
	}
	
	function InflateRaw(opts) {
	  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
	  Zlib.call(this, opts, binding.INFLATERAW);
	}
	
	
	// auto-detect header.
	function Unzip(opts) {
	  if (!(this instanceof Unzip)) return new Unzip(opts);
	  Zlib.call(this, opts, binding.UNZIP);
	}
	
	
	// the Zlib class they all inherit from
	// This thing manages the queue of requests, and returns
	// true or false if there is anything in the queue when
	// you call the .write() method.
	
	function Zlib(opts, mode) {
	  this._opts = opts = opts || {};
	  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
	
	  Transform.call(this, opts);
	
	  if (opts.flush) {
	    if (opts.flush !== binding.Z_NO_FLUSH &&
	        opts.flush !== binding.Z_PARTIAL_FLUSH &&
	        opts.flush !== binding.Z_SYNC_FLUSH &&
	        opts.flush !== binding.Z_FULL_FLUSH &&
	        opts.flush !== binding.Z_FINISH &&
	        opts.flush !== binding.Z_BLOCK) {
	      throw new Error('Invalid flush flag: ' + opts.flush);
	    }
	  }
	  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
	
	  if (opts.chunkSize) {
	    if (opts.chunkSize < exports.Z_MIN_CHUNK ||
	        opts.chunkSize > exports.Z_MAX_CHUNK) {
	      throw new Error('Invalid chunk size: ' + opts.chunkSize);
	    }
	  }
	
	  if (opts.windowBits) {
	    if (opts.windowBits < exports.Z_MIN_WINDOWBITS ||
	        opts.windowBits > exports.Z_MAX_WINDOWBITS) {
	      throw new Error('Invalid windowBits: ' + opts.windowBits);
	    }
	  }
	
	  if (opts.level) {
	    if (opts.level < exports.Z_MIN_LEVEL ||
	        opts.level > exports.Z_MAX_LEVEL) {
	      throw new Error('Invalid compression level: ' + opts.level);
	    }
	  }
	
	  if (opts.memLevel) {
	    if (opts.memLevel < exports.Z_MIN_MEMLEVEL ||
	        opts.memLevel > exports.Z_MAX_MEMLEVEL) {
	      throw new Error('Invalid memLevel: ' + opts.memLevel);
	    }
	  }
	
	  if (opts.strategy) {
	    if (opts.strategy != exports.Z_FILTERED &&
	        opts.strategy != exports.Z_HUFFMAN_ONLY &&
	        opts.strategy != exports.Z_RLE &&
	        opts.strategy != exports.Z_FIXED &&
	        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
	      throw new Error('Invalid strategy: ' + opts.strategy);
	    }
	  }
	
	  if (opts.dictionary) {
	    if (!Buffer.isBuffer(opts.dictionary)) {
	      throw new Error('Invalid dictionary: it should be a Buffer instance');
	    }
	  }
	
	  this._binding = new binding.Zlib(mode);
	
	  var self = this;
	  this._hadError = false;
	  this._binding.onerror = function(message, errno) {
	    // there is no way to cleanly recover.
	    // continuing only obscures problems.
	    self._binding = null;
	    self._hadError = true;
	
	    var error = new Error(message);
	    error.errno = errno;
	    error.code = exports.codes[errno];
	    self.emit('error', error);
	  };
	
	  var level = exports.Z_DEFAULT_COMPRESSION;
	  if (typeof opts.level === 'number') level = opts.level;
	
	  var strategy = exports.Z_DEFAULT_STRATEGY;
	  if (typeof opts.strategy === 'number') strategy = opts.strategy;
	
	  this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
	                     level,
	                     opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
	                     strategy,
	                     opts.dictionary);
	
	  this._buffer = new Buffer(this._chunkSize);
	  this._offset = 0;
	  this._closed = false;
	  this._level = level;
	  this._strategy = strategy;
	
	  this.once('end', this.close);
	}
	
	util.inherits(Zlib, Transform);
	
	Zlib.prototype.params = function(level, strategy, callback) {
	  if (level < exports.Z_MIN_LEVEL ||
	      level > exports.Z_MAX_LEVEL) {
	    throw new RangeError('Invalid compression level: ' + level);
	  }
	  if (strategy != exports.Z_FILTERED &&
	      strategy != exports.Z_HUFFMAN_ONLY &&
	      strategy != exports.Z_RLE &&
	      strategy != exports.Z_FIXED &&
	      strategy != exports.Z_DEFAULT_STRATEGY) {
	    throw new TypeError('Invalid strategy: ' + strategy);
	  }
	
	  if (this._level !== level || this._strategy !== strategy) {
	    var self = this;
	    this.flush(binding.Z_SYNC_FLUSH, function() {
	      self._binding.params(level, strategy);
	      if (!self._hadError) {
	        self._level = level;
	        self._strategy = strategy;
	        if (callback) callback();
	      }
	    });
	  } else {
	    process.nextTick(callback);
	  }
	};
	
	Zlib.prototype.reset = function() {
	  return this._binding.reset();
	};
	
	// This is the _flush function called by the transform class,
	// internally, when the last chunk has been written.
	Zlib.prototype._flush = function(callback) {
	  this._transform(new Buffer(0), '', callback);
	};
	
	Zlib.prototype.flush = function(kind, callback) {
	  var ws = this._writableState;
	
	  if (typeof kind === 'function' || (kind === void 0 && !callback)) {
	    callback = kind;
	    kind = binding.Z_FULL_FLUSH;
	  }
	
	  if (ws.ended) {
	    if (callback)
	      process.nextTick(callback);
	  } else if (ws.ending) {
	    if (callback)
	      this.once('end', callback);
	  } else if (ws.needDrain) {
	    var self = this;
	    this.once('drain', function() {
	      self.flush(callback);
	    });
	  } else {
	    this._flushFlag = kind;
	    this.write(new Buffer(0), '', callback);
	  }
	};
	
	Zlib.prototype.close = function(callback) {
	  if (callback)
	    process.nextTick(callback);
	
	  if (this._closed)
	    return;
	
	  this._closed = true;
	
	  this._binding.close();
	
	  var self = this;
	  process.nextTick(function() {
	    self.emit('close');
	  });
	};
	
	Zlib.prototype._transform = function(chunk, encoding, cb) {
	  var flushFlag;
	  var ws = this._writableState;
	  var ending = ws.ending || ws.ended;
	  var last = ending && (!chunk || ws.length === chunk.length);
	
	  if (!chunk === null && !Buffer.isBuffer(chunk))
	    return cb(new Error('invalid input'));
	
	  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.
	  // If it's explicitly flushing at some other time, then we use
	  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
	  // goodness.
	  if (last)
	    flushFlag = binding.Z_FINISH;
	  else {
	    flushFlag = this._flushFlag;
	    // once we've flushed the last of the queue, stop flushing and
	    // go back to the normal behavior.
	    if (chunk.length >= ws.length) {
	      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
	    }
	  }
	
	  var self = this;
	  this._processChunk(chunk, flushFlag, cb);
	};
	
	Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
	  var availInBefore = chunk && chunk.length;
	  var availOutBefore = this._chunkSize - this._offset;
	  var inOff = 0;
	
	  var self = this;
	
	  var async = typeof cb === 'function';
	
	  if (!async) {
	    var buffers = [];
	    var nread = 0;
	
	    var error;
	    this.on('error', function(er) {
	      error = er;
	    });
	
	    do {
	      var res = this._binding.writeSync(flushFlag,
	                                        chunk, // in
	                                        inOff, // in_off
	                                        availInBefore, // in_len
	                                        this._buffer, // out
	                                        this._offset, //out_off
	                                        availOutBefore); // out_len
	    } while (!this._hadError && callback(res[0], res[1]));
	
	    if (this._hadError) {
	      throw error;
	    }
	
	    var buf = Buffer.concat(buffers, nread);
	    this.close();
	
	    return buf;
	  }
	
	  var req = this._binding.write(flushFlag,
	                                chunk, // in
	                                inOff, // in_off
	                                availInBefore, // in_len
	                                this._buffer, // out
	                                this._offset, //out_off
	                                availOutBefore); // out_len
	
	  req.buffer = chunk;
	  req.callback = callback;
	
	  function callback(availInAfter, availOutAfter) {
	    if (self._hadError)
	      return;
	
	    var have = availOutBefore - availOutAfter;
	    assert(have >= 0, 'have should not go down');
	
	    if (have > 0) {
	      var out = self._buffer.slice(self._offset, self._offset + have);
	      self._offset += have;
	      // serve some output to the consumer.
	      if (async) {
	        self.push(out);
	      } else {
	        buffers.push(out);
	        nread += out.length;
	      }
	    }
	
	    // exhausted the output buffer, or used all the input create a new one.
	    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
	      availOutBefore = self._chunkSize;
	      self._offset = 0;
	      self._buffer = new Buffer(self._chunkSize);
	    }
	
	    if (availOutAfter === 0) {
	      // Not actually done.  Need to reprocess.
	      // Also, update the availInBefore to the availInAfter value,
	      // so that if we have to hit it a third (fourth, etc.) time,
	      // it'll have the correct byte counts.
	      inOff += (availInBefore - availInAfter);
	      availInBefore = availInAfter;
	
	      if (!async)
	        return true;
	
	      var newReq = self._binding.write(flushFlag,
	                                       chunk,
	                                       inOff,
	                                       availInBefore,
	                                       self._buffer,
	                                       self._offset,
	                                       self._chunkSize);
	      newReq.callback = callback; // this same function
	      newReq.buffer = chunk;
	      return;
	    }
	
	    if (!async)
	      return false;
	
	    // finished with the chunk.
	    cb();
	  }
	};
	
	util.inherits(Deflate, Zlib);
	util.inherits(Inflate, Zlib);
	util.inherits(Gzip, Zlib);
	util.inherits(Gunzip, Zlib);
	util.inherits(DeflateRaw, Zlib);
	util.inherits(InflateRaw, Zlib);
	util.inherits(Unzip, Zlib);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer, __webpack_require__(6)))

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(314)


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(315);
	
	/*<replacement>*/
	var util = __webpack_require__(58);
	util.inherits = __webpack_require__(52);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	
	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (!util.isNullOrUndefined(data))
	    stream.push(data);
	
	  if (cb)
	    cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	
	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(options, this);
	
	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}
	
	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};
	
	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;
	
	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	
	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');
	
	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');
	
	  return stream.push(null);
	}


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/
	
	
	/*<replacement>*/
	var util = __webpack_require__(58);
	util.inherits = __webpack_require__(52);
	/*</replacement>*/
	
	var Readable = __webpack_require__(316);
	var Writable = __webpack_require__(318);
	
	util.inherits(Duplex, Readable);
	
	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});
	
	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false)
	    this.readable = false;
	
	  if (options && options.writable === false)
	    this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Readable;
	
	/*<replacement>*/
	var isArray = __webpack_require__(57);
	/*</replacement>*/
	
	
	/*<replacement>*/
	var Buffer = __webpack_require__(9).Buffer;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	var EE = __webpack_require__(3).EventEmitter;
	
	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	var Stream = __webpack_require__(54);
	
	/*<replacement>*/
	var util = __webpack_require__(58);
	util.inherits = __webpack_require__(52);
	/*</replacement>*/
	
	var StringDecoder;
	
	
	/*<replacement>*/
	var debug = __webpack_require__(317);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	
	util.inherits(Readable, Stream);
	
	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(315);
	
	  options = options || {};
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(59).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  var Duplex = __webpack_require__(315);
	
	  if (!(this instanceof Readable))
	    return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;
	
	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);
	
	      if (!addToFront)
	        state.reading = false;
	
	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);
	
	        if (state.needReadable)
	          emitReadable(stream);
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(59).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}
	
	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;
	
	  if (state.objectMode)
	    return n === 0 ? 0 : 1;
	
	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }
	
	  if (n <= 0)
	    return 0;
	
	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);
	
	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }
	
	  return n;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }
	
	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }
	
	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);
	
	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;
	
	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }
	
	  state.length -= n;
	
	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;
	
	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);
	
	  if (!util.isNull(ret))
	    this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	
	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};
	
	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }
	
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];
	
	
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	
	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;
	
	    if (!dest)
	      dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }
	
	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;
	
	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }
	
	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}
	
	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}
	
	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;
	
	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;
	
	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);
	
	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);
	
	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);
	
	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();
	
	        c += cpy;
	      }
	    }
	  }
	
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 317 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.
	
	module.exports = Writable;
	
	/*<replacement>*/
	var Buffer = __webpack_require__(9).Buffer;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	
	/*<replacement>*/
	var util = __webpack_require__(58);
	util.inherits = __webpack_require__(52);
	/*</replacement>*/
	
	var Stream = __webpack_require__(54);
	
	util.inherits(Writable, Stream);
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}
	
	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(315);
	
	  options = options || {};
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.buffer = [];
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}
	
	function Writable(options) {
	  var Duplex = __webpack_require__(315);
	
	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};
	
	
	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;
	
	  if (!util.isFunction(cb))
	    cb = function() {};
	
	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function() {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function() {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;
	
	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);
	
	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	
	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);
	
	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });
	
	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }
	
	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }
	
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};
	
	
	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {var msg = __webpack_require__(320);
	var zstream = __webpack_require__(321);
	var zlib_deflate = __webpack_require__(322);
	var zlib_inflate = __webpack_require__(327);
	var constants = __webpack_require__(330);
	
	for (var key in constants) {
	  exports[key] = constants[key];
	}
	
	// zlib modes
	exports.NONE = 0;
	exports.DEFLATE = 1;
	exports.INFLATE = 2;
	exports.GZIP = 3;
	exports.GUNZIP = 4;
	exports.DEFLATERAW = 5;
	exports.INFLATERAW = 6;
	exports.UNZIP = 7;
	
	/**
	 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
	 */
	function Zlib(mode) {
	  if (mode < exports.DEFLATE || mode > exports.UNZIP)
	    throw new TypeError("Bad argument");
	    
	  this.mode = mode;
	  this.init_done = false;
	  this.write_in_progress = false;
	  this.pending_close = false;
	  this.windowBits = 0;
	  this.level = 0;
	  this.memLevel = 0;
	  this.strategy = 0;
	  this.dictionary = null;
	}
	
	Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
	  this.windowBits = windowBits;
	  this.level = level;
	  this.memLevel = memLevel;
	  this.strategy = strategy;
	  // dictionary not supported.
	  
	  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP)
	    this.windowBits += 16;
	    
	  if (this.mode === exports.UNZIP)
	    this.windowBits += 32;
	    
	  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)
	    this.windowBits = -this.windowBits;
	    
	  this.strm = new zstream();
	  
	  switch (this.mode) {
	    case exports.DEFLATE:
	    case exports.GZIP:
	    case exports.DEFLATERAW:
	      var status = zlib_deflate.deflateInit2(
	        this.strm,
	        this.level,
	        exports.Z_DEFLATED,
	        this.windowBits,
	        this.memLevel,
	        this.strategy
	      );
	      break;
	    case exports.INFLATE:
	    case exports.GUNZIP:
	    case exports.INFLATERAW:
	    case exports.UNZIP:
	      var status  = zlib_inflate.inflateInit2(
	        this.strm,
	        this.windowBits
	      );
	      break;
	    default:
	      throw new Error("Unknown mode " + this.mode);
	  }
	  
	  if (status !== exports.Z_OK) {
	    this._error(status);
	    return;
	  }
	  
	  this.write_in_progress = false;
	  this.init_done = true;
	};
	
	Zlib.prototype.params = function() {
	  throw new Error("deflateParams Not supported");
	};
	
	Zlib.prototype._writeCheck = function() {
	  if (!this.init_done)
	    throw new Error("write before init");
	    
	  if (this.mode === exports.NONE)
	    throw new Error("already finalized");
	    
	  if (this.write_in_progress)
	    throw new Error("write already in progress");
	    
	  if (this.pending_close)
	    throw new Error("close is pending");
	};
	
	Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {    
	  this._writeCheck();
	  this.write_in_progress = true;
	  
	  var self = this;
	  process.nextTick(function() {
	    self.write_in_progress = false;
	    var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
	    self.callback(res[0], res[1]);
	    
	    if (self.pending_close)
	      self.close();
	  });
	  
	  return this;
	};
	
	// set method for Node buffers, used by pako
	function bufferSet(data, offset) {
	  for (var i = 0; i < data.length; i++) {
	    this[offset + i] = data[i];
	  }
	}
	
	Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
	  this._writeCheck();
	  return this._write(flush, input, in_off, in_len, out, out_off, out_len);
	};
	
	Zlib.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {
	  this.write_in_progress = true;
	  
	  if (flush !== exports.Z_NO_FLUSH &&
	      flush !== exports.Z_PARTIAL_FLUSH &&
	      flush !== exports.Z_SYNC_FLUSH &&
	      flush !== exports.Z_FULL_FLUSH &&
	      flush !== exports.Z_FINISH &&
	      flush !== exports.Z_BLOCK) {
	    throw new Error("Invalid flush value");
	  }
	  
	  if (input == null) {
	    input = new Buffer(0);
	    in_len = 0;
	    in_off = 0;
	  }
	  
	  if (out._set)
	    out.set = out._set;
	  else
	    out.set = bufferSet;
	  
	  var strm = this.strm;
	  strm.avail_in = in_len;
	  strm.input = input;
	  strm.next_in = in_off;
	  strm.avail_out = out_len;
	  strm.output = out;
	  strm.next_out = out_off;
	  
	  switch (this.mode) {
	    case exports.DEFLATE:
	    case exports.GZIP:
	    case exports.DEFLATERAW:
	      var status = zlib_deflate.deflate(strm, flush);
	      break;
	    case exports.UNZIP:
	    case exports.INFLATE:
	    case exports.GUNZIP:
	    case exports.INFLATERAW:
	      var status = zlib_inflate.inflate(strm, flush);
	      break;
	    default:
	      throw new Error("Unknown mode " + this.mode);
	  }
	  
	  if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {
	    this._error(status);
	  }
	  
	  this.write_in_progress = false;
	  return [strm.avail_in, strm.avail_out];
	};
	
	Zlib.prototype.close = function() {
	  if (this.write_in_progress) {
	    this.pending_close = true;
	    return;
	  }
	  
	  this.pending_close = false;
	  
	  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
	    zlib_deflate.deflateEnd(this.strm);
	  } else {
	    zlib_inflate.inflateEnd(this.strm);
	  }
	  
	  this.mode = exports.NONE;
	};
	
	Zlib.prototype.reset = function() {
	  switch (this.mode) {
	    case exports.DEFLATE:
	    case exports.DEFLATERAW:
	      var status = zlib_deflate.deflateReset(this.strm);
	      break;
	    case exports.INFLATE:
	    case exports.INFLATERAW:
	      var status = zlib_inflate.inflateReset(this.strm);
	      break;
	  }
	  
	  if (status !== exports.Z_OK) {
	    this._error(status);
	  }
	};
	
	Zlib.prototype._error = function(status) {
	  this.onerror(msg[status] + ': ' + this.strm.msg, status);
	  
	  this.write_in_progress = false;
	  if (this.pending_close)
	    this.close();
	};
	
	exports.Zlib = Zlib;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), __webpack_require__(9).Buffer))

/***/ },
/* 320 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  2:      'need dictionary',     /* Z_NEED_DICT       2  */
	  1:      'stream end',          /* Z_STREAM_END      1  */
	  0:      '',                    /* Z_OK              0  */
	  '-1':   'file error',          /* Z_ERRNO         (-1) */
	  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
	  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
	  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
	  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
	  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
	};


/***/ },
/* 321 */
/***/ function(module, exports) {

	'use strict';
	
	
	function ZStream() {
	  /* next input byte */
	  this.input = null; // JS specific, because we have no pointers
	  this.next_in = 0;
	  /* number of bytes available at input */
	  this.avail_in = 0;
	  /* total number of input bytes read so far */
	  this.total_in = 0;
	  /* next output byte should be put there */
	  this.output = null; // JS specific, because we have no pointers
	  this.next_out = 0;
	  /* remaining free space at output */
	  this.avail_out = 0;
	  /* total number of bytes output so far */
	  this.total_out = 0;
	  /* last error message, NULL if no error */
	  this.msg = ''/*Z_NULL*/;
	  /* not visible by applications */
	  this.state = null;
	  /* best guess about the data type: binary or text */
	  this.data_type = 2/*Z_UNKNOWN*/;
	  /* adler32 value of the uncompressed data */
	  this.adler = 0;
	}
	
	module.exports = ZStream;


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils   = __webpack_require__(323);
	var trees   = __webpack_require__(324);
	var adler32 = __webpack_require__(325);
	var crc32   = __webpack_require__(326);
	var msg     = __webpack_require__(320);
	
	/* Public constants ==========================================================*/
	/* ===========================================================================*/
	
	
	/* Allowed flush values; see deflate() and inflate() below for details */
	var Z_NO_FLUSH      = 0;
	var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	//var Z_TREES         = 6;
	
	
	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	//var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	//var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;
	
	
	/* compression levels */
	//var Z_NO_COMPRESSION      = 0;
	//var Z_BEST_SPEED          = 1;
	//var Z_BEST_COMPRESSION    = 9;
	var Z_DEFAULT_COMPRESSION = -1;
	
	
	var Z_FILTERED            = 1;
	var Z_HUFFMAN_ONLY        = 2;
	var Z_RLE                 = 3;
	var Z_FIXED               = 4;
	var Z_DEFAULT_STRATEGY    = 0;
	
	/* Possible values of the data_type field (though see inflate()) */
	//var Z_BINARY              = 0;
	//var Z_TEXT                = 1;
	//var Z_ASCII               = 1; // = Z_TEXT
	var Z_UNKNOWN             = 2;
	
	
	/* The deflate compression method */
	var Z_DEFLATED  = 8;
	
	/*============================================================================*/
	
	
	var MAX_MEM_LEVEL = 9;
	/* Maximum value for memLevel in deflateInit2 */
	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_MEM_LEVEL = 8;
	
	
	var LENGTH_CODES  = 29;
	/* number of length codes, not counting the special END_BLOCK code */
	var LITERALS      = 256;
	/* number of literal bytes 0..255 */
	var L_CODES       = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */
	var D_CODES       = 30;
	/* number of distance codes */
	var BL_CODES      = 19;
	/* number of codes used to transfer the bit lengths */
	var HEAP_SIZE     = 2 * L_CODES + 1;
	/* maximum heap size */
	var MAX_BITS  = 15;
	/* All codes must not exceed MAX_BITS bits */
	
	var MIN_MATCH = 3;
	var MAX_MATCH = 258;
	var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);
	
	var PRESET_DICT = 0x20;
	
	var INIT_STATE = 42;
	var EXTRA_STATE = 69;
	var NAME_STATE = 73;
	var COMMENT_STATE = 91;
	var HCRC_STATE = 103;
	var BUSY_STATE = 113;
	var FINISH_STATE = 666;
	
	var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
	var BS_BLOCK_DONE     = 2; /* block flush performed */
	var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
	var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */
	
	var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.
	
	function err(strm, errorCode) {
	  strm.msg = msg[errorCode];
	  return errorCode;
	}
	
	function rank(f) {
	  return ((f) << 1) - ((f) > 4 ? 9 : 0);
	}
	
	function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }
	
	
	/* =========================================================================
	 * Flush as much pending output as possible. All deflate() output goes
	 * through this function so some applications may wish to modify it
	 * to avoid allocating a large strm->output buffer and copying into it.
	 * (See also read_buf()).
	 */
	function flush_pending(strm) {
	  var s = strm.state;
	
	  //_tr_flush_bits(s);
	  var len = s.pending;
	  if (len > strm.avail_out) {
	    len = strm.avail_out;
	  }
	  if (len === 0) { return; }
	
	  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
	  strm.next_out += len;
	  s.pending_out += len;
	  strm.total_out += len;
	  strm.avail_out -= len;
	  s.pending -= len;
	  if (s.pending === 0) {
	    s.pending_out = 0;
	  }
	}
	
	
	function flush_block_only(s, last) {
	  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
	  s.block_start = s.strstart;
	  flush_pending(s.strm);
	}
	
	
	function put_byte(s, b) {
	  s.pending_buf[s.pending++] = b;
	}
	
	
	/* =========================================================================
	 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
	 * IN assertion: the stream state is correct and there is enough room in
	 * pending_buf.
	 */
	function putShortMSB(s, b) {
	//  put_byte(s, (Byte)(b >> 8));
	//  put_byte(s, (Byte)(b & 0xff));
	  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
	  s.pending_buf[s.pending++] = b & 0xff;
	}
	
	
	/* ===========================================================================
	 * Read a new buffer from the current input stream, update the adler32
	 * and total number of bytes read.  All deflate() input goes through
	 * this function so some applications may wish to modify it to avoid
	 * allocating a large strm->input buffer and copying from it.
	 * (See also flush_pending()).
	 */
	function read_buf(strm, buf, start, size) {
	  var len = strm.avail_in;
	
	  if (len > size) { len = size; }
	  if (len === 0) { return 0; }
	
	  strm.avail_in -= len;
	
	  // zmemcpy(buf, strm->next_in, len);
	  utils.arraySet(buf, strm.input, strm.next_in, len, start);
	  if (strm.state.wrap === 1) {
	    strm.adler = adler32(strm.adler, buf, len, start);
	  }
	
	  else if (strm.state.wrap === 2) {
	    strm.adler = crc32(strm.adler, buf, len, start);
	  }
	
	  strm.next_in += len;
	  strm.total_in += len;
	
	  return len;
	}
	
	
	/* ===========================================================================
	 * Set match_start to the longest match starting at the given string and
	 * return its length. Matches shorter or equal to prev_length are discarded,
	 * in which case the result is equal to prev_length and match_start is
	 * garbage.
	 * IN assertions: cur_match is the head of the hash chain for the current
	 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
	 * OUT assertion: the match length is not greater than s->lookahead.
	 */
	function longest_match(s, cur_match) {
	  var chain_length = s.max_chain_length;      /* max hash chain length */
	  var scan = s.strstart; /* current string */
	  var match;                       /* matched string */
	  var len;                           /* length of current match */
	  var best_len = s.prev_length;              /* best match length so far */
	  var nice_match = s.nice_match;             /* stop if match long enough */
	  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
	      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;
	
	  var _win = s.window; // shortcut
	
	  var wmask = s.w_mask;
	  var prev  = s.prev;
	
	  /* Stop when cur_match becomes <= limit. To simplify the code,
	   * we prevent matches with the string of window index 0.
	   */
	
	  var strend = s.strstart + MAX_MATCH;
	  var scan_end1  = _win[scan + best_len - 1];
	  var scan_end   = _win[scan + best_len];
	
	  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
	   * It is easy to get rid of this optimization if necessary.
	   */
	  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
	
	  /* Do not waste too much time if we already have a good match: */
	  if (s.prev_length >= s.good_match) {
	    chain_length >>= 2;
	  }
	  /* Do not look for matches beyond the end of the input. This is necessary
	   * to make deflate deterministic.
	   */
	  if (nice_match > s.lookahead) { nice_match = s.lookahead; }
	
	  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
	
	  do {
	    // Assert(cur_match < s->strstart, "no future");
	    match = cur_match;
	
	    /* Skip to next match if the match length cannot increase
	     * or if the match length is less than 2.  Note that the checks below
	     * for insufficient lookahead only occur occasionally for performance
	     * reasons.  Therefore uninitialized memory will be accessed, and
	     * conditional jumps will be made that depend on those values.
	     * However the length of the match is limited to the lookahead, so
	     * the output of deflate is not affected by the uninitialized values.
	     */
	
	    if (_win[match + best_len]     !== scan_end  ||
	        _win[match + best_len - 1] !== scan_end1 ||
	        _win[match]                !== _win[scan] ||
	        _win[++match]              !== _win[scan + 1]) {
	      continue;
	    }
	
	    /* The check at best_len-1 can be removed because it will be made
	     * again later. (This heuristic is not always a win.)
	     * It is not necessary to compare scan[2] and match[2] since they
	     * are always equal when the other bytes match, given that
	     * the hash keys are equal and that HASH_BITS >= 8.
	     */
	    scan += 2;
	    match++;
	    // Assert(*scan == *match, "match[2]?");
	
	    /* We check for insufficient lookahead only every 8th comparison;
	     * the 256th check will be made at strstart+258.
	     */
	    do {
	      /*jshint noempty:false*/
	    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             scan < strend);
	
	    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
	
	    len = MAX_MATCH - (strend - scan);
	    scan = strend - MAX_MATCH;
	
	    if (len > best_len) {
	      s.match_start = cur_match;
	      best_len = len;
	      if (len >= nice_match) {
	        break;
	      }
	      scan_end1  = _win[scan + best_len - 1];
	      scan_end   = _win[scan + best_len];
	    }
	  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
	
	  if (best_len <= s.lookahead) {
	    return best_len;
	  }
	  return s.lookahead;
	}
	
	
	/* ===========================================================================
	 * Fill the window when the lookahead becomes insufficient.
	 * Updates strstart and lookahead.
	 *
	 * IN assertion: lookahead < MIN_LOOKAHEAD
	 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
	 *    At least one byte has been read, or avail_in == 0; reads are
	 *    performed for at least two bytes (required for the zip translate_eol
	 *    option -- not supported here).
	 */
	function fill_window(s) {
	  var _w_size = s.w_size;
	  var p, n, m, more, str;
	
	  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
	
	  do {
	    more = s.window_size - s.lookahead - s.strstart;
	
	    // JS ints have 32 bit, block below not needed
	    /* Deal with !@#$% 64K limit: */
	    //if (sizeof(int) <= 2) {
	    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
	    //        more = wsize;
	    //
	    //  } else if (more == (unsigned)(-1)) {
	    //        /* Very unlikely, but possible on 16 bit machine if
	    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
	    //         */
	    //        more--;
	    //    }
	    //}
	
	
	    /* If the window is almost full and there is insufficient lookahead,
	     * move the upper half to the lower one to make room in the upper half.
	     */
	    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
	
	      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
	      s.match_start -= _w_size;
	      s.strstart -= _w_size;
	      /* we now have strstart >= MAX_DIST */
	      s.block_start -= _w_size;
	
	      /* Slide the hash table (could be avoided with 32 bit values
	       at the expense of memory usage). We slide even when level == 0
	       to keep the hash table consistent if we switch back to level > 0
	       later. (Using level 0 permanently is not an optimal usage of
	       zlib, so we don't care about this pathological case.)
	       */
	
	      n = s.hash_size;
	      p = n;
	      do {
	        m = s.head[--p];
	        s.head[p] = (m >= _w_size ? m - _w_size : 0);
	      } while (--n);
	
	      n = _w_size;
	      p = n;
	      do {
	        m = s.prev[--p];
	        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
	        /* If n is not on any hash chain, prev[n] is garbage but
	         * its value will never be used.
	         */
	      } while (--n);
	
	      more += _w_size;
	    }
	    if (s.strm.avail_in === 0) {
	      break;
	    }
	
	    /* If there was no sliding:
	     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
	     *    more == window_size - lookahead - strstart
	     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
	     * => more >= window_size - 2*WSIZE + 2
	     * In the BIG_MEM or MMAP case (not yet supported),
	     *   window_size == input_size + MIN_LOOKAHEAD  &&
	     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
	     * Otherwise, window_size == 2*WSIZE so more >= 2.
	     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
	     */
	    //Assert(more >= 2, "more < 2");
	    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
	    s.lookahead += n;
	
	    /* Initialize the hash value now that we have some input: */
	    if (s.lookahead + s.insert >= MIN_MATCH) {
	      str = s.strstart - s.insert;
	      s.ins_h = s.window[str];
	
	      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
	//#if MIN_MATCH != 3
	//        Call update_hash() MIN_MATCH-3 more times
	//#endif
	      while (s.insert) {
	        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
	
	        s.prev[str & s.w_mask] = s.head[s.ins_h];
	        s.head[s.ins_h] = str;
	        str++;
	        s.insert--;
	        if (s.lookahead + s.insert < MIN_MATCH) {
	          break;
	        }
	      }
	    }
	    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
	     * but this is not important since only literal bytes will be emitted.
	     */
	
	  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
	
	  /* If the WIN_INIT bytes after the end of the current data have never been
	   * written, then zero those bytes in order to avoid memory check reports of
	   * the use of uninitialized (or uninitialised as Julian writes) bytes by
	   * the longest match routines.  Update the high water mark for the next
	   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
	   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
	   */
	//  if (s.high_water < s.window_size) {
	//    var curr = s.strstart + s.lookahead;
	//    var init = 0;
	//
	//    if (s.high_water < curr) {
	//      /* Previous high water mark below current data -- zero WIN_INIT
	//       * bytes or up to end of window, whichever is less.
	//       */
	//      init = s.window_size - curr;
	//      if (init > WIN_INIT)
	//        init = WIN_INIT;
	//      zmemzero(s->window + curr, (unsigned)init);
	//      s->high_water = curr + init;
	//    }
	//    else if (s->high_water < (ulg)curr + WIN_INIT) {
	//      /* High water mark at or above current data, but below current data
	//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
	//       * to end of window, whichever is less.
	//       */
	//      init = (ulg)curr + WIN_INIT - s->high_water;
	//      if (init > s->window_size - s->high_water)
	//        init = s->window_size - s->high_water;
	//      zmemzero(s->window + s->high_water, (unsigned)init);
	//      s->high_water += init;
	//    }
	//  }
	//
	//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
	//    "not enough room for search");
	}
	
	/* ===========================================================================
	 * Copy without compression as much as possible from the input stream, return
	 * the current block state.
	 * This function does not insert new strings in the dictionary since
	 * uncompressible data is probably not useful. This function is used
	 * only for the level=0 compression option.
	 * NOTE: this function should be optimized to avoid extra copying from
	 * window to pending_buf.
	 */
	function deflate_stored(s, flush) {
	  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
	   * to pending_buf_size, and each stored block has a 5 byte header:
	   */
	  var max_block_size = 0xffff;
	
	  if (max_block_size > s.pending_buf_size - 5) {
	    max_block_size = s.pending_buf_size - 5;
	  }
	
	  /* Copy as much as possible from input to output: */
	  for (;;) {
	    /* Fill the window as much as possible: */
	    if (s.lookahead <= 1) {
	
	      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
	      //  s->block_start >= (long)s->w_size, "slide too late");
	//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
	//        s.block_start >= s.w_size)) {
	//        throw  new Error("slide too late");
	//      }
	
	      fill_window(s);
	      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	
	      if (s.lookahead === 0) {
	        break;
	      }
	      /* flush the current block */
	    }
	    //Assert(s->block_start >= 0L, "block gone");
	//    if (s.block_start < 0) throw new Error("block gone");
	
	    s.strstart += s.lookahead;
	    s.lookahead = 0;
	
	    /* Emit a stored block if pending_buf will be full: */
	    var max_start = s.block_start + max_block_size;
	
	    if (s.strstart === 0 || s.strstart >= max_start) {
	      /* strstart == 0 is possible when wraparound on 16-bit machine */
	      s.lookahead = s.strstart - max_start;
	      s.strstart = max_start;
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	
	
	    }
	    /* Flush if we may have to slide, otherwise block_start may become
	     * negative and the data will be gone:
	     */
	    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	
	  s.insert = 0;
	
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	
	  if (s.strstart > s.block_start) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	
	  return BS_NEED_MORE;
	}
	
	/* ===========================================================================
	 * Compress as much as possible from the input stream, return the current
	 * block state.
	 * This function does not perform lazy evaluation of matches and inserts
	 * new strings in the dictionary only for unmatched strings or for short
	 * matches. It is used only for the fast compression options.
	 */
	function deflate_fast(s, flush) {
	  var hash_head;        /* head of the hash chain */
	  var bflush;           /* set if current block must be flushed */
	
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) {
	        break; /* flush the current block */
	      }
	    }
	
	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }
	
	    /* Find the longest match, discarding those <= prev_length.
	     * At this point we have always match_length < MIN_MATCH
	     */
	    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */
	    }
	    if (s.match_length >= MIN_MATCH) {
	      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only
	
	      /*** _tr_tally_dist(s, s.strstart - s.match_start,
	                     s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
	
	      s.lookahead -= s.match_length;
	
	      /* Insert new strings in the hash table only if the match length
	       * is not too large. This saves time but degrades compression.
	       */
	      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
	        s.match_length--; /* string at strstart already in table */
	        do {
	          s.strstart++;
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
	           * always MIN_MATCH bytes ahead.
	           */
	        } while (--s.match_length !== 0);
	        s.strstart++;
	      } else
	      {
	        s.strstart += s.match_length;
	        s.match_length = 0;
	        s.ins_h = s.window[s.strstart];
	        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;
	
	//#if MIN_MATCH != 3
	//                Call UPDATE_HASH() MIN_MATCH-3 more times
	//#endif
	        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
	         * matter since it will be recomputed at next deflate call.
	         */
	      }
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s.window[s.strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	
	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}
	
	/* ===========================================================================
	 * Same as above, but achieves better compression. We use a lazy
	 * evaluation for matches: a match is finally adopted only if there is
	 * no better match at the next window position.
	 */
	function deflate_slow(s, flush) {
	  var hash_head;          /* head of hash chain */
	  var bflush;              /* set if current block must be flushed */
	
	  var max_insert;
	
	  /* Process the input block. */
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }
	
	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }
	
	    /* Find the longest match, discarding those <= prev_length.
	     */
	    s.prev_length = s.match_length;
	    s.prev_match = s.match_start;
	    s.match_length = MIN_MATCH - 1;
	
	    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
	        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */
	
	      if (s.match_length <= 5 &&
	         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {
	
	        /* If prev_match is also MIN_MATCH, match_start is garbage
	         * but we will ignore the current match anyway.
	         */
	        s.match_length = MIN_MATCH - 1;
	      }
	    }
	    /* If there was a match at the previous step and the current
	     * match is not better, output the previous match:
	     */
	    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
	      max_insert = s.strstart + s.lookahead - MIN_MATCH;
	      /* Do not insert strings in hash table beyond this. */
	
	      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);
	
	      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
	                     s.prev_length - MIN_MATCH, bflush);***/
	      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
	      /* Insert in hash table all strings up to the end of the match.
	       * strstart-1 and strstart are already inserted. If there is not
	       * enough lookahead, the last two strings are not inserted in
	       * the hash table.
	       */
	      s.lookahead -= s.prev_length - 1;
	      s.prev_length -= 2;
	      do {
	        if (++s.strstart <= max_insert) {
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	        }
	      } while (--s.prev_length !== 0);
	      s.match_available = 0;
	      s.match_length = MIN_MATCH - 1;
	      s.strstart++;
	
	      if (bflush) {
	        /*** FLUSH_BLOCK(s, 0); ***/
	        flush_block_only(s, false);
	        if (s.strm.avail_out === 0) {
	          return BS_NEED_MORE;
	        }
	        /***/
	      }
	
	    } else if (s.match_available) {
	      /* If there was no match at the previous position, output a
	       * single literal. If there was a match but the current match
	       * is longer, truncate the previous match to a single literal.
	       */
	      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
	
	      if (bflush) {
	        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
	        flush_block_only(s, false);
	        /***/
	      }
	      s.strstart++;
	      s.lookahead--;
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	    } else {
	      /* There is no previous match to compare with, wait for
	       * the next step to decide.
	       */
	      s.match_available = 1;
	      s.strstart++;
	      s.lookahead--;
	    }
	  }
	  //Assert (flush != Z_NO_FLUSH, "no flush?");
	  if (s.match_available) {
	    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
	
	    s.match_available = 0;
	  }
	  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	
	  return BS_BLOCK_DONE;
	}
	
	
	/* ===========================================================================
	 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
	 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
	 * deflate switches away from Z_RLE.)
	 */
	function deflate_rle(s, flush) {
	  var bflush;            /* set if current block must be flushed */
	  var prev;              /* byte at distance one to match */
	  var scan, strend;      /* scan goes up to strend for length of run */
	
	  var _win = s.window;
	
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the longest run, plus one for the unrolled loop.
	     */
	    if (s.lookahead <= MAX_MATCH) {
	      fill_window(s);
	      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }
	
	    /* See how many times the previous byte repeats */
	    s.match_length = 0;
	    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
	      scan = s.strstart - 1;
	      prev = _win[scan];
	      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
	        strend = s.strstart + MAX_MATCH;
	        do {
	          /*jshint noempty:false*/
	        } while (prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 scan < strend);
	        s.match_length = MAX_MATCH - (strend - scan);
	        if (s.match_length > s.lookahead) {
	          s.match_length = s.lookahead;
	        }
	      }
	      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
	    }
	
	    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
	    if (s.match_length >= MIN_MATCH) {
	      //check_match(s, s.strstart, s.strstart - 1, s.match_length);
	
	      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
	
	      s.lookahead -= s.match_length;
	      s.strstart += s.match_length;
	      s.match_length = 0;
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s->window[s->strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	
	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}
	
	/* ===========================================================================
	 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
	 * (It will be regenerated if this run of deflate switches away from Huffman.)
	 */
	function deflate_huff(s, flush) {
	  var bflush;             /* set if current block must be flushed */
	
	  for (;;) {
	    /* Make sure that we have a literal to write. */
	    if (s.lookahead === 0) {
	      fill_window(s);
	      if (s.lookahead === 0) {
	        if (flush === Z_NO_FLUSH) {
	          return BS_NEED_MORE;
	        }
	        break;      /* flush the current block */
	      }
	    }
	
	    /* Output a literal byte */
	    s.match_length = 0;
	    //Tracevv((stderr,"%c", s->window[s->strstart]));
	    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	    s.lookahead--;
	    s.strstart++;
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}
	
	/* Values for max_lazy_match, good_match and max_chain_length, depending on
	 * the desired pack level (0..9). The values given below have been tuned to
	 * exclude worst case performance for pathological files. Better values may be
	 * found for specific files.
	 */
	function Config(good_length, max_lazy, nice_length, max_chain, func) {
	  this.good_length = good_length;
	  this.max_lazy = max_lazy;
	  this.nice_length = nice_length;
	  this.max_chain = max_chain;
	  this.func = func;
	}
	
	var configuration_table;
	
	configuration_table = [
	  /*      good lazy nice chain */
	  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
	  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
	  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
	  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */
	
	  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
	  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
	  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
	  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
	  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
	  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
	];
	
	
	/* ===========================================================================
	 * Initialize the "longest match" routines for a new zlib stream
	 */
	function lm_init(s) {
	  s.window_size = 2 * s.w_size;
	
	  /*** CLEAR_HASH(s); ***/
	  zero(s.head); // Fill with NIL (= 0);
	
	  /* Set the default configuration parameters:
	   */
	  s.max_lazy_match = configuration_table[s.level].max_lazy;
	  s.good_match = configuration_table[s.level].good_length;
	  s.nice_match = configuration_table[s.level].nice_length;
	  s.max_chain_length = configuration_table[s.level].max_chain;
	
	  s.strstart = 0;
	  s.block_start = 0;
	  s.lookahead = 0;
	  s.insert = 0;
	  s.match_length = s.prev_length = MIN_MATCH - 1;
	  s.match_available = 0;
	  s.ins_h = 0;
	}
	
	
	function DeflateState() {
	  this.strm = null;            /* pointer back to this zlib stream */
	  this.status = 0;            /* as the name implies */
	  this.pending_buf = null;      /* output still pending */
	  this.pending_buf_size = 0;  /* size of pending_buf */
	  this.pending_out = 0;       /* next pending byte to output to the stream */
	  this.pending = 0;           /* nb of bytes in the pending buffer */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.gzhead = null;         /* gzip header information to write */
	  this.gzindex = 0;           /* where in extra, name, or comment */
	  this.method = Z_DEFLATED; /* can only be DEFLATED */
	  this.last_flush = -1;   /* value of flush param for previous deflate call */
	
	  this.w_size = 0;  /* LZ77 window size (32K by default) */
	  this.w_bits = 0;  /* log2(w_size)  (8..16) */
	  this.w_mask = 0;  /* w_size - 1 */
	
	  this.window = null;
	  /* Sliding window. Input bytes are read into the second half of the window,
	   * and move to the first half later to keep a dictionary of at least wSize
	   * bytes. With this organization, matches are limited to a distance of
	   * wSize-MAX_MATCH bytes, but this ensures that IO is always
	   * performed with a length multiple of the block size.
	   */
	
	  this.window_size = 0;
	  /* Actual size of window: 2*wSize, except when the user input buffer
	   * is directly used as sliding window.
	   */
	
	  this.prev = null;
	  /* Link to older string with same hash index. To limit the size of this
	   * array to 64K, this link is maintained only for the last 32K strings.
	   * An index in this array is thus a window index modulo 32K.
	   */
	
	  this.head = null;   /* Heads of the hash chains or NIL. */
	
	  this.ins_h = 0;       /* hash index of string to be inserted */
	  this.hash_size = 0;   /* number of elements in hash table */
	  this.hash_bits = 0;   /* log2(hash_size) */
	  this.hash_mask = 0;   /* hash_size-1 */
	
	  this.hash_shift = 0;
	  /* Number of bits by which ins_h must be shifted at each input
	   * step. It must be such that after MIN_MATCH steps, the oldest
	   * byte no longer takes part in the hash key, that is:
	   *   hash_shift * MIN_MATCH >= hash_bits
	   */
	
	  this.block_start = 0;
	  /* Window position at the beginning of the current output block. Gets
	   * negative when the window is moved backwards.
	   */
	
	  this.match_length = 0;      /* length of best match */
	  this.prev_match = 0;        /* previous match */
	  this.match_available = 0;   /* set if previous match exists */
	  this.strstart = 0;          /* start of string to insert */
	  this.match_start = 0;       /* start of matching string */
	  this.lookahead = 0;         /* number of valid bytes ahead in window */
	
	  this.prev_length = 0;
	  /* Length of the best match at previous step. Matches not greater than this
	   * are discarded. This is used in the lazy match evaluation.
	   */
	
	  this.max_chain_length = 0;
	  /* To speed up deflation, hash chains are never searched beyond this
	   * length.  A higher limit improves compression ratio but degrades the
	   * speed.
	   */
	
	  this.max_lazy_match = 0;
	  /* Attempt to find a better match only when the current match is strictly
	   * smaller than this value. This mechanism is used only for compression
	   * levels >= 4.
	   */
	  // That's alias to max_lazy_match, don't use directly
	  //this.max_insert_length = 0;
	  /* Insert new strings in the hash table only if the match length is not
	   * greater than this length. This saves time but degrades compression.
	   * max_insert_length is used only for compression levels <= 3.
	   */
	
	  this.level = 0;     /* compression level (1..9) */
	  this.strategy = 0;  /* favor or force Huffman coding*/
	
	  this.good_match = 0;
	  /* Use a faster search when the previous match is longer than this */
	
	  this.nice_match = 0; /* Stop searching when current match exceeds this */
	
	              /* used by trees.c: */
	
	  /* Didn't use ct_data typedef below to suppress compiler warning */
	
	  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
	  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
	  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
	
	  // Use flat array of DOUBLE size, with interleaved fata,
	  // because JS does not support effective
	  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
	  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
	  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
	  zero(this.dyn_ltree);
	  zero(this.dyn_dtree);
	  zero(this.bl_tree);
	
	  this.l_desc   = null;         /* desc. for literal tree */
	  this.d_desc   = null;         /* desc. for distance tree */
	  this.bl_desc  = null;         /* desc. for bit length tree */
	
	  //ush bl_count[MAX_BITS+1];
	  this.bl_count = new utils.Buf16(MAX_BITS + 1);
	  /* number of codes at each bit length for an optimal tree */
	
	  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
	  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
	  zero(this.heap);
	
	  this.heap_len = 0;               /* number of elements in the heap */
	  this.heap_max = 0;               /* element of largest frequency */
	  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
	   * The same heap array is used to build all trees.
	   */
	
	  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
	  zero(this.depth);
	  /* Depth of each subtree used as tie breaker for trees of equal frequency
	   */
	
	  this.l_buf = 0;          /* buffer index for literals or lengths */
	
	  this.lit_bufsize = 0;
	  /* Size of match buffer for literals/lengths.  There are 4 reasons for
	   * limiting lit_bufsize to 64K:
	   *   - frequencies can be kept in 16 bit counters
	   *   - if compression is not successful for the first block, all input
	   *     data is still in the window so we can still emit a stored block even
	   *     when input comes from standard input.  (This can also be done for
	   *     all blocks if lit_bufsize is not greater than 32K.)
	   *   - if compression is not successful for a file smaller than 64K, we can
	   *     even emit a stored file instead of a stored block (saving 5 bytes).
	   *     This is applicable only for zip (not gzip or zlib).
	   *   - creating new Huffman trees less frequently may not provide fast
	   *     adaptation to changes in the input data statistics. (Take for
	   *     example a binary file with poorly compressible code followed by
	   *     a highly compressible string table.) Smaller buffer sizes give
	   *     fast adaptation but have of course the overhead of transmitting
	   *     trees more frequently.
	   *   - I can't count above 4
	   */
	
	  this.last_lit = 0;      /* running index in l_buf */
	
	  this.d_buf = 0;
	  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
	   * the same number of elements. To use different lengths, an extra flag
	   * array would be necessary.
	   */
	
	  this.opt_len = 0;       /* bit length of current block with optimal trees */
	  this.static_len = 0;    /* bit length of current block with static trees */
	  this.matches = 0;       /* number of string matches in current block */
	  this.insert = 0;        /* bytes at end of window left to insert */
	
	
	  this.bi_buf = 0;
	  /* Output buffer. bits are inserted starting at the bottom (least
	   * significant bits).
	   */
	  this.bi_valid = 0;
	  /* Number of valid bits in bi_buf.  All bits above the last valid bit
	   * are always zero.
	   */
	
	  // Used for window memory init. We safely ignore it for JS. That makes
	  // sense only for pointers and memory check tools.
	  //this.high_water = 0;
	  /* High water mark offset in window for initialized bytes -- bytes above
	   * this are set to zero in order to avoid memory check warnings when
	   * longest match routines access bytes past the input.  This is then
	   * updated to the new high water mark.
	   */
	}
	
	
	function deflateResetKeep(strm) {
	  var s;
	
	  if (!strm || !strm.state) {
	    return err(strm, Z_STREAM_ERROR);
	  }
	
	  strm.total_in = strm.total_out = 0;
	  strm.data_type = Z_UNKNOWN;
	
	  s = strm.state;
	  s.pending = 0;
	  s.pending_out = 0;
	
	  if (s.wrap < 0) {
	    s.wrap = -s.wrap;
	    /* was made negative by deflate(..., Z_FINISH); */
	  }
	  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
	  strm.adler = (s.wrap === 2) ?
	    0  // crc32(0, Z_NULL, 0)
	  :
	    1; // adler32(0, Z_NULL, 0)
	  s.last_flush = Z_NO_FLUSH;
	  trees._tr_init(s);
	  return Z_OK;
	}
	
	
	function deflateReset(strm) {
	  var ret = deflateResetKeep(strm);
	  if (ret === Z_OK) {
	    lm_init(strm.state);
	  }
	  return ret;
	}
	
	
	function deflateSetHeader(strm, head) {
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
	  strm.state.gzhead = head;
	  return Z_OK;
	}
	
	
	function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
	  if (!strm) { // === Z_NULL
	    return Z_STREAM_ERROR;
	  }
	  var wrap = 1;
	
	  if (level === Z_DEFAULT_COMPRESSION) {
	    level = 6;
	  }
	
	  if (windowBits < 0) { /* suppress zlib wrapper */
	    wrap = 0;
	    windowBits = -windowBits;
	  }
	
	  else if (windowBits > 15) {
	    wrap = 2;           /* write gzip wrapper instead */
	    windowBits -= 16;
	  }
	
	
	  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
	    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
	    strategy < 0 || strategy > Z_FIXED) {
	    return err(strm, Z_STREAM_ERROR);
	  }
	
	
	  if (windowBits === 8) {
	    windowBits = 9;
	  }
	  /* until 256-byte window bug fixed */
	
	  var s = new DeflateState();
	
	  strm.state = s;
	  s.strm = strm;
	
	  s.wrap = wrap;
	  s.gzhead = null;
	  s.w_bits = windowBits;
	  s.w_size = 1 << s.w_bits;
	  s.w_mask = s.w_size - 1;
	
	  s.hash_bits = memLevel + 7;
	  s.hash_size = 1 << s.hash_bits;
	  s.hash_mask = s.hash_size - 1;
	  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
	
	  s.window = new utils.Buf8(s.w_size * 2);
	  s.head = new utils.Buf16(s.hash_size);
	  s.prev = new utils.Buf16(s.w_size);
	
	  // Don't need mem init magic for JS.
	  //s.high_water = 0;  /* nothing written to s->window yet */
	
	  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
	
	  s.pending_buf_size = s.lit_bufsize * 4;
	
	  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
	  //s->pending_buf = (uchf *) overlay;
	  s.pending_buf = new utils.Buf8(s.pending_buf_size);
	
	  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
	  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
	  s.d_buf = 1 * s.lit_bufsize;
	
	  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
	  s.l_buf = (1 + 2) * s.lit_bufsize;
	
	  s.level = level;
	  s.strategy = strategy;
	  s.method = method;
	
	  return deflateReset(strm);
	}
	
	function deflateInit(strm, level) {
	  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
	}
	
	
	function deflate(strm, flush) {
	  var old_flush, s;
	  var beg, val; // for gzip header write only
	
	  if (!strm || !strm.state ||
	    flush > Z_BLOCK || flush < 0) {
	    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
	  }
	
	  s = strm.state;
	
	  if (!strm.output ||
	      (!strm.input && strm.avail_in !== 0) ||
	      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
	    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
	  }
	
	  s.strm = strm; /* just in case */
	  old_flush = s.last_flush;
	  s.last_flush = flush;
	
	  /* Write the header */
	  if (s.status === INIT_STATE) {
	
	    if (s.wrap === 2) { // GZIP header
	      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
	      put_byte(s, 31);
	      put_byte(s, 139);
	      put_byte(s, 8);
	      if (!s.gzhead) { // s->gzhead == Z_NULL
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, OS_CODE);
	        s.status = BUSY_STATE;
	      }
	      else {
	        put_byte(s, (s.gzhead.text ? 1 : 0) +
	                    (s.gzhead.hcrc ? 2 : 0) +
	                    (!s.gzhead.extra ? 0 : 4) +
	                    (!s.gzhead.name ? 0 : 8) +
	                    (!s.gzhead.comment ? 0 : 16)
	                );
	        put_byte(s, s.gzhead.time & 0xff);
	        put_byte(s, (s.gzhead.time >> 8) & 0xff);
	        put_byte(s, (s.gzhead.time >> 16) & 0xff);
	        put_byte(s, (s.gzhead.time >> 24) & 0xff);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, s.gzhead.os & 0xff);
	        if (s.gzhead.extra && s.gzhead.extra.length) {
	          put_byte(s, s.gzhead.extra.length & 0xff);
	          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
	        }
	        if (s.gzhead.hcrc) {
	          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
	        }
	        s.gzindex = 0;
	        s.status = EXTRA_STATE;
	      }
	    }
	    else // DEFLATE header
	    {
	      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
	      var level_flags = -1;
	
	      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
	        level_flags = 0;
	      } else if (s.level < 6) {
	        level_flags = 1;
	      } else if (s.level === 6) {
	        level_flags = 2;
	      } else {
	        level_flags = 3;
	      }
	      header |= (level_flags << 6);
	      if (s.strstart !== 0) { header |= PRESET_DICT; }
	      header += 31 - (header % 31);
	
	      s.status = BUSY_STATE;
	      putShortMSB(s, header);
	
	      /* Save the adler32 of the preset dictionary: */
	      if (s.strstart !== 0) {
	        putShortMSB(s, strm.adler >>> 16);
	        putShortMSB(s, strm.adler & 0xffff);
	      }
	      strm.adler = 1; // adler32(0L, Z_NULL, 0);
	    }
	  }
	
	//#ifdef GZIP
	  if (s.status === EXTRA_STATE) {
	    if (s.gzhead.extra/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	
	      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            break;
	          }
	        }
	        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
	        s.gzindex++;
	      }
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (s.gzindex === s.gzhead.extra.length) {
	        s.gzindex = 0;
	        s.status = NAME_STATE;
	      }
	    }
	    else {
	      s.status = NAME_STATE;
	    }
	  }
	  if (s.status === NAME_STATE) {
	    if (s.gzhead.name/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;
	
	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.name.length) {
	          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);
	
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.gzindex = 0;
	        s.status = COMMENT_STATE;
	      }
	    }
	    else {
	      s.status = COMMENT_STATE;
	    }
	  }
	  if (s.status === COMMENT_STATE) {
	    if (s.gzhead.comment/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;
	
	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.comment.length) {
	          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);
	
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.status = HCRC_STATE;
	      }
	    }
	    else {
	      s.status = HCRC_STATE;
	    }
	  }
	  if (s.status === HCRC_STATE) {
	    if (s.gzhead.hcrc) {
	      if (s.pending + 2 > s.pending_buf_size) {
	        flush_pending(strm);
	      }
	      if (s.pending + 2 <= s.pending_buf_size) {
	        put_byte(s, strm.adler & 0xff);
	        put_byte(s, (strm.adler >> 8) & 0xff);
	        strm.adler = 0; //crc32(0L, Z_NULL, 0);
	        s.status = BUSY_STATE;
	      }
	    }
	    else {
	      s.status = BUSY_STATE;
	    }
	  }
	//#endif
	
	  /* Flush as much pending output as possible */
	  if (s.pending !== 0) {
	    flush_pending(strm);
	    if (strm.avail_out === 0) {
	      /* Since avail_out is 0, deflate will be called again with
	       * more output space, but possibly with both pending and
	       * avail_in equal to zero. There won't be anything to do,
	       * but this is not an error situation so make sure we
	       * return OK instead of BUF_ERROR at next call of deflate:
	       */
	      s.last_flush = -1;
	      return Z_OK;
	    }
	
	    /* Make sure there is something to do and avoid duplicate consecutive
	     * flushes. For repeated and useless calls with Z_FINISH, we keep
	     * returning Z_STREAM_END instead of Z_BUF_ERROR.
	     */
	  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
	    flush !== Z_FINISH) {
	    return err(strm, Z_BUF_ERROR);
	  }
	
	  /* User must not provide more input after the first FINISH: */
	  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
	    return err(strm, Z_BUF_ERROR);
	  }
	
	  /* Start a new block or continue the current one.
	   */
	  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
	    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
	    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
	      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
	        configuration_table[s.level].func(s, flush));
	
	    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
	      s.status = FINISH_STATE;
	    }
	    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
	      if (strm.avail_out === 0) {
	        s.last_flush = -1;
	        /* avoid BUF_ERROR next call, see above */
	      }
	      return Z_OK;
	      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
	       * of deflate should use the same flush parameter to make sure
	       * that the flush is complete. So we don't have to output an
	       * empty block here, this will be done at next call. This also
	       * ensures that for a very small output buffer, we emit at most
	       * one empty block.
	       */
	    }
	    if (bstate === BS_BLOCK_DONE) {
	      if (flush === Z_PARTIAL_FLUSH) {
	        trees._tr_align(s);
	      }
	      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
	
	        trees._tr_stored_block(s, 0, 0, false);
	        /* For a full flush, this empty block will be recognized
	         * as a special marker by inflate_sync().
	         */
	        if (flush === Z_FULL_FLUSH) {
	          /*** CLEAR_HASH(s); ***/             /* forget history */
	          zero(s.head); // Fill with NIL (= 0);
	
	          if (s.lookahead === 0) {
	            s.strstart = 0;
	            s.block_start = 0;
	            s.insert = 0;
	          }
	        }
	      }
	      flush_pending(strm);
	      if (strm.avail_out === 0) {
	        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
	        return Z_OK;
	      }
	    }
	  }
	  //Assert(strm->avail_out > 0, "bug2");
	  //if (strm.avail_out <= 0) { throw new Error("bug2");}
	
	  if (flush !== Z_FINISH) { return Z_OK; }
	  if (s.wrap <= 0) { return Z_STREAM_END; }
	
	  /* Write the trailer */
	  if (s.wrap === 2) {
	    put_byte(s, strm.adler & 0xff);
	    put_byte(s, (strm.adler >> 8) & 0xff);
	    put_byte(s, (strm.adler >> 16) & 0xff);
	    put_byte(s, (strm.adler >> 24) & 0xff);
	    put_byte(s, strm.total_in & 0xff);
	    put_byte(s, (strm.total_in >> 8) & 0xff);
	    put_byte(s, (strm.total_in >> 16) & 0xff);
	    put_byte(s, (strm.total_in >> 24) & 0xff);
	  }
	  else
	  {
	    putShortMSB(s, strm.adler >>> 16);
	    putShortMSB(s, strm.adler & 0xffff);
	  }
	
	  flush_pending(strm);
	  /* If avail_out is zero, the application will call deflate again
	   * to flush the rest.
	   */
	  if (s.wrap > 0) { s.wrap = -s.wrap; }
	  /* write the trailer only once! */
	  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
	}
	
	function deflateEnd(strm) {
	  var status;
	
	  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
	    return Z_STREAM_ERROR;
	  }
	
	  status = strm.state.status;
	  if (status !== INIT_STATE &&
	    status !== EXTRA_STATE &&
	    status !== NAME_STATE &&
	    status !== COMMENT_STATE &&
	    status !== HCRC_STATE &&
	    status !== BUSY_STATE &&
	    status !== FINISH_STATE
	  ) {
	    return err(strm, Z_STREAM_ERROR);
	  }
	
	  strm.state = null;
	
	  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
	}
	
	
	/* =========================================================================
	 * Initializes the compression dictionary from the given byte
	 * sequence without producing any compressed output.
	 */
	function deflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;
	
	  var s;
	  var str, n;
	  var wrap;
	  var avail;
	  var next;
	  var input;
	  var tmpDict;
	
	  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
	    return Z_STREAM_ERROR;
	  }
	
	  s = strm.state;
	  wrap = s.wrap;
	
	  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
	    return Z_STREAM_ERROR;
	  }
	
	  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
	  if (wrap === 1) {
	    /* adler32(strm->adler, dictionary, dictLength); */
	    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
	  }
	
	  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */
	
	  /* if dictionary would fill window, just replace the history */
	  if (dictLength >= s.w_size) {
	    if (wrap === 0) {            /* already empty otherwise */
	      /*** CLEAR_HASH(s); ***/
	      zero(s.head); // Fill with NIL (= 0);
	      s.strstart = 0;
	      s.block_start = 0;
	      s.insert = 0;
	    }
	    /* use the tail */
	    // dictionary = dictionary.slice(dictLength - s.w_size);
	    tmpDict = new utils.Buf8(s.w_size);
	    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
	    dictionary = tmpDict;
	    dictLength = s.w_size;
	  }
	  /* insert dictionary into window and hash */
	  avail = strm.avail_in;
	  next = strm.next_in;
	  input = strm.input;
	  strm.avail_in = dictLength;
	  strm.next_in = 0;
	  strm.input = dictionary;
	  fill_window(s);
	  while (s.lookahead >= MIN_MATCH) {
	    str = s.strstart;
	    n = s.lookahead - (MIN_MATCH - 1);
	    do {
	      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
	
	      s.prev[str & s.w_mask] = s.head[s.ins_h];
	
	      s.head[s.ins_h] = str;
	      str++;
	    } while (--n);
	    s.strstart = str;
	    s.lookahead = MIN_MATCH - 1;
	    fill_window(s);
	  }
	  s.strstart += s.lookahead;
	  s.block_start = s.strstart;
	  s.insert = s.lookahead;
	  s.lookahead = 0;
	  s.match_length = s.prev_length = MIN_MATCH - 1;
	  s.match_available = 0;
	  strm.next_in = next;
	  strm.input = input;
	  strm.avail_in = avail;
	  s.wrap = wrap;
	  return Z_OK;
	}
	
	
	exports.deflateInit = deflateInit;
	exports.deflateInit2 = deflateInit2;
	exports.deflateReset = deflateReset;
	exports.deflateResetKeep = deflateResetKeep;
	exports.deflateSetHeader = deflateSetHeader;
	exports.deflate = deflate;
	exports.deflateEnd = deflateEnd;
	exports.deflateSetDictionary = deflateSetDictionary;
	exports.deflateInfo = 'pako deflate (from Nodeca project)';
	
	/* Not implemented
	exports.deflateBound = deflateBound;
	exports.deflateCopy = deflateCopy;
	exports.deflateParams = deflateParams;
	exports.deflatePending = deflatePending;
	exports.deflatePrime = deflatePrime;
	exports.deflateTune = deflateTune;
	*/


/***/ },
/* 323 */
/***/ function(module, exports) {

	'use strict';
	
	
	var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
	                (typeof Uint16Array !== 'undefined') &&
	                (typeof Int32Array !== 'undefined');
	
	
	exports.assign = function (obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);
	  while (sources.length) {
	    var source = sources.shift();
	    if (!source) { continue; }
	
	    if (typeof source !== 'object') {
	      throw new TypeError(source + 'must be non-object');
	    }
	
	    for (var p in source) {
	      if (source.hasOwnProperty(p)) {
	        obj[p] = source[p];
	      }
	    }
	  }
	
	  return obj;
	};
	
	
	// reduce buffer size, avoiding mem copy
	exports.shrinkBuf = function (buf, size) {
	  if (buf.length === size) { return buf; }
	  if (buf.subarray) { return buf.subarray(0, size); }
	  buf.length = size;
	  return buf;
	};
	
	
	var fnTyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    if (src.subarray && dest.subarray) {
	      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
	      return;
	    }
	    // Fallback to ordinary array
	    for (var i = 0; i < len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function (chunks) {
	    var i, l, len, pos, chunk, result;
	
	    // calculate data length
	    len = 0;
	    for (i = 0, l = chunks.length; i < l; i++) {
	      len += chunks[i].length;
	    }
	
	    // join chunks
	    result = new Uint8Array(len);
	    pos = 0;
	    for (i = 0, l = chunks.length; i < l; i++) {
	      chunk = chunks[i];
	      result.set(chunk, pos);
	      pos += chunk.length;
	    }
	
	    return result;
	  }
	};
	
	var fnUntyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    for (var i = 0; i < len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function (chunks) {
	    return [].concat.apply([], chunks);
	  }
	};
	
	
	// Enable/Disable typed arrays use, for testing
	//
	exports.setTyped = function (on) {
	  if (on) {
	    exports.Buf8  = Uint8Array;
	    exports.Buf16 = Uint16Array;
	    exports.Buf32 = Int32Array;
	    exports.assign(exports, fnTyped);
	  } else {
	    exports.Buf8  = Array;
	    exports.Buf16 = Array;
	    exports.Buf32 = Array;
	    exports.assign(exports, fnUntyped);
	  }
	};
	
	exports.setTyped(TYPED_OK);


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	var utils = __webpack_require__(323);
	
	/* Public constants ==========================================================*/
	/* ===========================================================================*/
	
	
	//var Z_FILTERED          = 1;
	//var Z_HUFFMAN_ONLY      = 2;
	//var Z_RLE               = 3;
	var Z_FIXED               = 4;
	//var Z_DEFAULT_STRATEGY  = 0;
	
	/* Possible values of the data_type field (though see inflate()) */
	var Z_BINARY              = 0;
	var Z_TEXT                = 1;
	//var Z_ASCII             = 1; // = Z_TEXT
	var Z_UNKNOWN             = 2;
	
	/*============================================================================*/
	
	
	function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }
	
	// From zutil.h
	
	var STORED_BLOCK = 0;
	var STATIC_TREES = 1;
	var DYN_TREES    = 2;
	/* The three kinds of block type */
	
	var MIN_MATCH    = 3;
	var MAX_MATCH    = 258;
	/* The minimum and maximum match lengths */
	
	// From deflate.h
	/* ===========================================================================
	 * Internal compression state.
	 */
	
	var LENGTH_CODES  = 29;
	/* number of length codes, not counting the special END_BLOCK code */
	
	var LITERALS      = 256;
	/* number of literal bytes 0..255 */
	
	var L_CODES       = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */
	
	var D_CODES       = 30;
	/* number of distance codes */
	
	var BL_CODES      = 19;
	/* number of codes used to transfer the bit lengths */
	
	var HEAP_SIZE     = 2 * L_CODES + 1;
	/* maximum heap size */
	
	var MAX_BITS      = 15;
	/* All codes must not exceed MAX_BITS bits */
	
	var Buf_size      = 16;
	/* size of bit buffer in bi_buf */
	
	
	/* ===========================================================================
	 * Constants
	 */
	
	var MAX_BL_BITS = 7;
	/* Bit length codes must not exceed MAX_BL_BITS bits */
	
	var END_BLOCK   = 256;
	/* end of block literal code */
	
	var REP_3_6     = 16;
	/* repeat previous bit length 3-6 times (2 bits of repeat count) */
	
	var REPZ_3_10   = 17;
	/* repeat a zero length 3-10 times  (3 bits of repeat count) */
	
	var REPZ_11_138 = 18;
	/* repeat a zero length 11-138 times  (7 bits of repeat count) */
	
	/* eslint-disable comma-spacing,array-bracket-spacing */
	var extra_lbits =   /* extra bits for each length code */
	  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];
	
	var extra_dbits =   /* extra bits for each distance code */
	  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];
	
	var extra_blbits =  /* extra bits for each bit length code */
	  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];
	
	var bl_order =
	  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
	/* eslint-enable comma-spacing,array-bracket-spacing */
	
	/* The lengths of the bit length codes are sent in order of decreasing
	 * probability, to avoid transmitting the lengths for unused bit length codes.
	 */
	
	/* ===========================================================================
	 * Local data. These are initialized only once.
	 */
	
	// We pre-fill arrays with 0 to avoid uninitialized gaps
	
	var DIST_CODE_LEN = 512; /* see definition of array dist_code below */
	
	// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
	var static_ltree  = new Array((L_CODES + 2) * 2);
	zero(static_ltree);
	/* The static literal tree. Since the bit lengths are imposed, there is no
	 * need for the L_CODES extra codes used during heap construction. However
	 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
	 * below).
	 */
	
	var static_dtree  = new Array(D_CODES * 2);
	zero(static_dtree);
	/* The static distance tree. (Actually a trivial tree since all codes use
	 * 5 bits.)
	 */
	
	var _dist_code    = new Array(DIST_CODE_LEN);
	zero(_dist_code);
	/* Distance codes. The first 256 values correspond to the distances
	 * 3 .. 258, the last 256 values correspond to the top 8 bits of
	 * the 15 bit distances.
	 */
	
	var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
	zero(_length_code);
	/* length code for each normalized match length (0 == MIN_MATCH) */
	
	var base_length   = new Array(LENGTH_CODES);
	zero(base_length);
	/* First normalized length for each code (0 = MIN_MATCH) */
	
	var base_dist     = new Array(D_CODES);
	zero(base_dist);
	/* First normalized distance for each code (0 = distance of 1) */
	
	
	function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
	
	  this.static_tree  = static_tree;  /* static tree or NULL */
	  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
	  this.extra_base   = extra_base;   /* base index for extra_bits */
	  this.elems        = elems;        /* max number of elements in the tree */
	  this.max_length   = max_length;   /* max bit length for the codes */
	
	  // show if `static_tree` has data or dummy - needed for monomorphic objects
	  this.has_stree    = static_tree && static_tree.length;
	}
	
	
	var static_l_desc;
	var static_d_desc;
	var static_bl_desc;
	
	
	function TreeDesc(dyn_tree, stat_desc) {
	  this.dyn_tree = dyn_tree;     /* the dynamic tree */
	  this.max_code = 0;            /* largest code with non zero frequency */
	  this.stat_desc = stat_desc;   /* the corresponding static tree */
	}
	
	
	
	function d_code(dist) {
	  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
	}
	
	
	/* ===========================================================================
	 * Output a short LSB first on the stream.
	 * IN assertion: there is enough room in pendingBuf.
	 */
	function put_short(s, w) {
	//    put_byte(s, (uch)((w) & 0xff));
	//    put_byte(s, (uch)((ush)(w) >> 8));
	  s.pending_buf[s.pending++] = (w) & 0xff;
	  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
	}
	
	
	/* ===========================================================================
	 * Send a value on a given number of bits.
	 * IN assertion: length <= 16 and value fits in length bits.
	 */
	function send_bits(s, value, length) {
	  if (s.bi_valid > (Buf_size - length)) {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    put_short(s, s.bi_buf);
	    s.bi_buf = value >> (Buf_size - s.bi_valid);
	    s.bi_valid += length - Buf_size;
	  } else {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    s.bi_valid += length;
	  }
	}
	
	
	function send_code(s, c, tree) {
	  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
	}
	
	
	/* ===========================================================================
	 * Reverse the first len bits of a code, using straightforward code (a faster
	 * method would use a table)
	 * IN assertion: 1 <= len <= 15
	 */
	function bi_reverse(code, len) {
	  var res = 0;
	  do {
	    res |= code & 1;
	    code >>>= 1;
	    res <<= 1;
	  } while (--len > 0);
	  return res >>> 1;
	}
	
	
	/* ===========================================================================
	 * Flush the bit buffer, keeping at most 7 bits in it.
	 */
	function bi_flush(s) {
	  if (s.bi_valid === 16) {
	    put_short(s, s.bi_buf);
	    s.bi_buf = 0;
	    s.bi_valid = 0;
	
	  } else if (s.bi_valid >= 8) {
	    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
	    s.bi_buf >>= 8;
	    s.bi_valid -= 8;
	  }
	}
	
	
	/* ===========================================================================
	 * Compute the optimal bit lengths for a tree and update the total bit length
	 * for the current block.
	 * IN assertion: the fields freq and dad are set, heap[heap_max] and
	 *    above are the tree nodes sorted by increasing frequency.
	 * OUT assertions: the field len is set to the optimal bit length, the
	 *     array bl_count contains the frequencies for each bit length.
	 *     The length opt_len is updated; static_len is also updated if stree is
	 *     not null.
	 */
	function gen_bitlen(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc;    /* the tree descriptor */
	{
	  var tree            = desc.dyn_tree;
	  var max_code        = desc.max_code;
	  var stree           = desc.stat_desc.static_tree;
	  var has_stree       = desc.stat_desc.has_stree;
	  var extra           = desc.stat_desc.extra_bits;
	  var base            = desc.stat_desc.extra_base;
	  var max_length      = desc.stat_desc.max_length;
	  var h;              /* heap index */
	  var n, m;           /* iterate over the tree elements */
	  var bits;           /* bit length */
	  var xbits;          /* extra bits */
	  var f;              /* frequency */
	  var overflow = 0;   /* number of elements with bit length too large */
	
	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    s.bl_count[bits] = 0;
	  }
	
	  /* In a first pass, compute the optimal bit lengths (which may
	   * overflow in the case of the bit length tree).
	   */
	  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */
	
	  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
	    n = s.heap[h];
	    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
	    if (bits > max_length) {
	      bits = max_length;
	      overflow++;
	    }
	    tree[n * 2 + 1]/*.Len*/ = bits;
	    /* We overwrite tree[n].Dad which is no longer needed */
	
	    if (n > max_code) { continue; } /* not a leaf node */
	
	    s.bl_count[bits]++;
	    xbits = 0;
	    if (n >= base) {
	      xbits = extra[n - base];
	    }
	    f = tree[n * 2]/*.Freq*/;
	    s.opt_len += f * (bits + xbits);
	    if (has_stree) {
	      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
	    }
	  }
	  if (overflow === 0) { return; }
	
	  // Trace((stderr,"\nbit length overflow\n"));
	  /* This happens for example on obj2 and pic of the Calgary corpus */
	
	  /* Find the first bit length which could increase: */
	  do {
	    bits = max_length - 1;
	    while (s.bl_count[bits] === 0) { bits--; }
	    s.bl_count[bits]--;      /* move one leaf down the tree */
	    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
	    s.bl_count[max_length]--;
	    /* The brother of the overflow item also moves one step up,
	     * but this does not affect bl_count[max_length]
	     */
	    overflow -= 2;
	  } while (overflow > 0);
	
	  /* Now recompute all bit lengths, scanning in increasing frequency.
	   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
	   * lengths instead of fixing only the wrong ones. This idea is taken
	   * from 'ar' written by Haruhiko Okumura.)
	   */
	  for (bits = max_length; bits !== 0; bits--) {
	    n = s.bl_count[bits];
	    while (n !== 0) {
	      m = s.heap[--h];
	      if (m > max_code) { continue; }
	      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
	        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
	        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
	        tree[m * 2 + 1]/*.Len*/ = bits;
	      }
	      n--;
	    }
	  }
	}
	
	
	/* ===========================================================================
	 * Generate the codes for a given tree and bit counts (which need not be
	 * optimal).
	 * IN assertion: the array bl_count contains the bit length statistics for
	 * the given tree and the field len is set for all tree elements.
	 * OUT assertion: the field code is set for all tree elements of non
	 *     zero code length.
	 */
	function gen_codes(tree, max_code, bl_count)
	//    ct_data *tree;             /* the tree to decorate */
	//    int max_code;              /* largest code with non zero frequency */
	//    ushf *bl_count;            /* number of codes at each bit length */
	{
	  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
	  var code = 0;              /* running code value */
	  var bits;                  /* bit index */
	  var n;                     /* code index */
	
	  /* The distribution counts are first used to generate the code values
	   * without bit reversal.
	   */
	  for (bits = 1; bits <= MAX_BITS; bits++) {
	    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
	  }
	  /* Check that the bit counts in bl_count are consistent. The last code
	   * must be all ones.
	   */
	  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
	  //        "inconsistent bit counts");
	  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
	
	  for (n = 0;  n <= max_code; n++) {
	    var len = tree[n * 2 + 1]/*.Len*/;
	    if (len === 0) { continue; }
	    /* Now reverse the bits */
	    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);
	
	    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
	    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
	  }
	}
	
	
	/* ===========================================================================
	 * Initialize the various 'constant' tables.
	 */
	function tr_static_init() {
	  var n;        /* iterates over tree elements */
	  var bits;     /* bit counter */
	  var length;   /* length value */
	  var code;     /* code value */
	  var dist;     /* distance index */
	  var bl_count = new Array(MAX_BITS + 1);
	  /* number of codes at each bit length for an optimal tree */
	
	  // do check in _tr_init()
	  //if (static_init_done) return;
	
	  /* For some embedded targets, global variables are not initialized: */
	/*#ifdef NO_INIT_GLOBAL_POINTERS
	  static_l_desc.static_tree = static_ltree;
	  static_l_desc.extra_bits = extra_lbits;
	  static_d_desc.static_tree = static_dtree;
	  static_d_desc.extra_bits = extra_dbits;
	  static_bl_desc.extra_bits = extra_blbits;
	#endif*/
	
	  /* Initialize the mapping length (0..255) -> length code (0..28) */
	  length = 0;
	  for (code = 0; code < LENGTH_CODES - 1; code++) {
	    base_length[code] = length;
	    for (n = 0; n < (1 << extra_lbits[code]); n++) {
	      _length_code[length++] = code;
	    }
	  }
	  //Assert (length == 256, "tr_static_init: length != 256");
	  /* Note that the length 255 (match length 258) can be represented
	   * in two different ways: code 284 + 5 bits or code 285, so we
	   * overwrite length_code[255] to use the best encoding:
	   */
	  _length_code[length - 1] = code;
	
	  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
	  dist = 0;
	  for (code = 0; code < 16; code++) {
	    base_dist[code] = dist;
	    for (n = 0; n < (1 << extra_dbits[code]); n++) {
	      _dist_code[dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: dist != 256");
	  dist >>= 7; /* from now on, all distances are divided by 128 */
	  for (; code < D_CODES; code++) {
	    base_dist[code] = dist << 7;
	    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
	      _dist_code[256 + dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: 256+dist != 512");
	
	  /* Construct the codes of the static literal tree */
	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    bl_count[bits] = 0;
	  }
	
	  n = 0;
	  while (n <= 143) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  while (n <= 255) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 9;
	    n++;
	    bl_count[9]++;
	  }
	  while (n <= 279) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 7;
	    n++;
	    bl_count[7]++;
	  }
	  while (n <= 287) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  /* Codes 286 and 287 do not exist, but we must include them in the
	   * tree construction to get a canonical Huffman tree (longest code
	   * all ones)
	   */
	  gen_codes(static_ltree, L_CODES + 1, bl_count);
	
	  /* The static distance tree is trivial: */
	  for (n = 0; n < D_CODES; n++) {
	    static_dtree[n * 2 + 1]/*.Len*/ = 5;
	    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
	  }
	
	  // Now data ready and we can init static trees
	  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
	  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
	  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);
	
	  //static_init_done = true;
	}
	
	
	/* ===========================================================================
	 * Initialize a new block.
	 */
	function init_block(s) {
	  var n; /* iterates over tree elements */
	
	  /* Initialize the trees. */
	  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
	  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
	  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }
	
	  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
	  s.opt_len = s.static_len = 0;
	  s.last_lit = s.matches = 0;
	}
	
	
	/* ===========================================================================
	 * Flush the bit buffer and align the output on a byte boundary
	 */
	function bi_windup(s)
	{
	  if (s.bi_valid > 8) {
	    put_short(s, s.bi_buf);
	  } else if (s.bi_valid > 0) {
	    //put_byte(s, (Byte)s->bi_buf);
	    s.pending_buf[s.pending++] = s.bi_buf;
	  }
	  s.bi_buf = 0;
	  s.bi_valid = 0;
	}
	
	/* ===========================================================================
	 * Copy a stored block, storing first the length and its
	 * one's complement if requested.
	 */
	function copy_block(s, buf, len, header)
	//DeflateState *s;
	//charf    *buf;    /* the input data */
	//unsigned len;     /* its length */
	//int      header;  /* true if block header must be written */
	{
	  bi_windup(s);        /* align on byte boundary */
	
	  if (header) {
	    put_short(s, len);
	    put_short(s, ~len);
	  }
	//  while (len--) {
	//    put_byte(s, *buf++);
	//  }
	  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
	  s.pending += len;
	}
	
	/* ===========================================================================
	 * Compares to subtrees, using the tree depth as tie breaker when
	 * the subtrees have equal frequency. This minimizes the worst case length.
	 */
	function smaller(tree, n, m, depth) {
	  var _n2 = n * 2;
	  var _m2 = m * 2;
	  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
	         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
	}
	
	/* ===========================================================================
	 * Restore the heap property by moving down the tree starting at node k,
	 * exchanging a node with the smallest of its two sons if necessary, stopping
	 * when the heap property is re-established (each father smaller than its
	 * two sons).
	 */
	function pqdownheap(s, tree, k)
	//    deflate_state *s;
	//    ct_data *tree;  /* the tree to restore */
	//    int k;               /* node to move down */
	{
	  var v = s.heap[k];
	  var j = k << 1;  /* left son of k */
	  while (j <= s.heap_len) {
	    /* Set j to the smallest of the two sons: */
	    if (j < s.heap_len &&
	      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
	      j++;
	    }
	    /* Exit if v is smaller than both sons */
	    if (smaller(tree, v, s.heap[j], s.depth)) { break; }
	
	    /* Exchange v with the smallest son */
	    s.heap[k] = s.heap[j];
	    k = j;
	
	    /* And continue down the tree, setting j to the left son of k */
	    j <<= 1;
	  }
	  s.heap[k] = v;
	}
	
	
	// inlined manually
	// var SMALLEST = 1;
	
	/* ===========================================================================
	 * Send the block data compressed using the given Huffman trees
	 */
	function compress_block(s, ltree, dtree)
	//    deflate_state *s;
	//    const ct_data *ltree; /* literal tree */
	//    const ct_data *dtree; /* distance tree */
	{
	  var dist;           /* distance of matched string */
	  var lc;             /* match length or unmatched char (if dist == 0) */
	  var lx = 0;         /* running index in l_buf */
	  var code;           /* the code to send */
	  var extra;          /* number of extra bits to send */
	
	  if (s.last_lit !== 0) {
	    do {
	      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
	      lc = s.pending_buf[s.l_buf + lx];
	      lx++;
	
	      if (dist === 0) {
	        send_code(s, lc, ltree); /* send a literal byte */
	        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
	      } else {
	        /* Here, lc is the match length - MIN_MATCH */
	        code = _length_code[lc];
	        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
	        extra = extra_lbits[code];
	        if (extra !== 0) {
	          lc -= base_length[code];
	          send_bits(s, lc, extra);       /* send the extra length bits */
	        }
	        dist--; /* dist is now the match distance - 1 */
	        code = d_code(dist);
	        //Assert (code < D_CODES, "bad d_code");
	
	        send_code(s, code, dtree);       /* send the distance code */
	        extra = extra_dbits[code];
	        if (extra !== 0) {
	          dist -= base_dist[code];
	          send_bits(s, dist, extra);   /* send the extra distance bits */
	        }
	      } /* literal or match pair ? */
	
	      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
	      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
	      //       "pendingBuf overflow");
	
	    } while (lx < s.last_lit);
	  }
	
	  send_code(s, END_BLOCK, ltree);
	}
	
	
	/* ===========================================================================
	 * Construct one Huffman tree and assigns the code bit strings and lengths.
	 * Update the total bit length for the current block.
	 * IN assertion: the field freq is set for all tree elements.
	 * OUT assertions: the fields len and code are set to the optimal bit length
	 *     and corresponding code. The length opt_len is updated; static_len is
	 *     also updated if stree is not null. The field max_code is set.
	 */
	function build_tree(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc; /* the tree descriptor */
	{
	  var tree     = desc.dyn_tree;
	  var stree    = desc.stat_desc.static_tree;
	  var has_stree = desc.stat_desc.has_stree;
	  var elems    = desc.stat_desc.elems;
	  var n, m;          /* iterate over heap elements */
	  var max_code = -1; /* largest code with non zero frequency */
	  var node;          /* new node being created */
	
	  /* Construct the initial heap, with least frequent element in
	   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
	   * heap[0] is not used.
	   */
	  s.heap_len = 0;
	  s.heap_max = HEAP_SIZE;
	
	  for (n = 0; n < elems; n++) {
	    if (tree[n * 2]/*.Freq*/ !== 0) {
	      s.heap[++s.heap_len] = max_code = n;
	      s.depth[n] = 0;
	
	    } else {
	      tree[n * 2 + 1]/*.Len*/ = 0;
	    }
	  }
	
	  /* The pkzip format requires that at least one distance code exists,
	   * and that at least one bit should be sent even if there is only one
	   * possible code. So to avoid special checks later on we force at least
	   * two codes of non zero frequency.
	   */
	  while (s.heap_len < 2) {
	    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
	    tree[node * 2]/*.Freq*/ = 1;
	    s.depth[node] = 0;
	    s.opt_len--;
	
	    if (has_stree) {
	      s.static_len -= stree[node * 2 + 1]/*.Len*/;
	    }
	    /* node is 0 or 1 so it does not have extra bits */
	  }
	  desc.max_code = max_code;
	
	  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
	   * establish sub-heaps of increasing lengths:
	   */
	  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }
	
	  /* Construct the Huffman tree by repeatedly combining the least two
	   * frequent nodes.
	   */
	  node = elems;              /* next internal node of the tree */
	  do {
	    //pqremove(s, tree, n);  /* n = node of least frequency */
	    /*** pqremove ***/
	    n = s.heap[1/*SMALLEST*/];
	    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
	    pqdownheap(s, tree, 1/*SMALLEST*/);
	    /***/
	
	    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */
	
	    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
	    s.heap[--s.heap_max] = m;
	
	    /* Create a new node father of n and m */
	    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
	    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
	    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;
	
	    /* and insert the new node in the heap */
	    s.heap[1/*SMALLEST*/] = node++;
	    pqdownheap(s, tree, 1/*SMALLEST*/);
	
	  } while (s.heap_len >= 2);
	
	  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];
	
	  /* At this point, the fields freq and dad are set. We can now
	   * generate the bit lengths.
	   */
	  gen_bitlen(s, desc);
	
	  /* The field len is now set, we can generate the bit codes */
	  gen_codes(tree, max_code, s.bl_count);
	}
	
	
	/* ===========================================================================
	 * Scan a literal or distance tree to determine the frequencies of the codes
	 * in the bit length tree.
	 */
	function scan_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree;   /* the tree to be scanned */
	//    int max_code;    /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */
	
	  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */
	
	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */
	
	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }
	  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */
	
	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;
	
	    if (++count < max_count && curlen === nextlen) {
	      continue;
	
	    } else if (count < min_count) {
	      s.bl_tree[curlen * 2]/*.Freq*/ += count;
	
	    } else if (curlen !== 0) {
	
	      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
	      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;
	
	    } else if (count <= 10) {
	      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;
	
	    } else {
	      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
	    }
	
	    count = 0;
	    prevlen = curlen;
	
	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;
	
	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;
	
	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}
	
	
	/* ===========================================================================
	 * Send a literal or distance tree in compressed form, using the codes in
	 * bl_tree.
	 */
	function send_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree; /* the tree to be scanned */
	//    int max_code;       /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */
	
	  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */
	
	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */
	
	  /* tree[max_code+1].Len = -1; */  /* guard already set */
	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }
	
	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;
	
	    if (++count < max_count && curlen === nextlen) {
	      continue;
	
	    } else if (count < min_count) {
	      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);
	
	    } else if (curlen !== 0) {
	      if (curlen !== prevlen) {
	        send_code(s, curlen, s.bl_tree);
	        count--;
	      }
	      //Assert(count >= 3 && count <= 6, " 3_6?");
	      send_code(s, REP_3_6, s.bl_tree);
	      send_bits(s, count - 3, 2);
	
	    } else if (count <= 10) {
	      send_code(s, REPZ_3_10, s.bl_tree);
	      send_bits(s, count - 3, 3);
	
	    } else {
	      send_code(s, REPZ_11_138, s.bl_tree);
	      send_bits(s, count - 11, 7);
	    }
	
	    count = 0;
	    prevlen = curlen;
	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;
	
	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;
	
	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}
	
	
	/* ===========================================================================
	 * Construct the Huffman tree for the bit lengths and return the index in
	 * bl_order of the last bit length code to send.
	 */
	function build_bl_tree(s) {
	  var max_blindex;  /* index of last bit length code of non zero freq */
	
	  /* Determine the bit length frequencies for literal and distance trees */
	  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
	  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
	
	  /* Build the bit length tree: */
	  build_tree(s, s.bl_desc);
	  /* opt_len now includes the length of the tree representations, except
	   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
	   */
	
	  /* Determine the number of bit length codes to send. The pkzip format
	   * requires that at least 4 bit length codes be sent. (appnote.txt says
	   * 3 but the actual value used is 4.)
	   */
	  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
	    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
	      break;
	    }
	  }
	  /* Update opt_len to include the bit length tree and counts */
	  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
	  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
	  //        s->opt_len, s->static_len));
	
	  return max_blindex;
	}
	
	
	/* ===========================================================================
	 * Send the header for a block using dynamic Huffman trees: the counts, the
	 * lengths of the bit length codes, the literal tree and the distance tree.
	 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	 */
	function send_all_trees(s, lcodes, dcodes, blcodes)
	//    deflate_state *s;
	//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
	{
	  var rank;                    /* index in bl_order */
	
	  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
	  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
	  //        "too many codes");
	  //Tracev((stderr, "\nbl counts: "));
	  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
	  send_bits(s, dcodes - 1,   5);
	  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
	  for (rank = 0; rank < blcodes; rank++) {
	    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
	    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
	  }
	  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
	
	  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
	  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
	
	  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
	  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
	}
	
	
	/* ===========================================================================
	 * Check if the data type is TEXT or BINARY, using the following algorithm:
	 * - TEXT if the two conditions below are satisfied:
	 *    a) There are no non-portable control characters belonging to the
	 *       "black list" (0..6, 14..25, 28..31).
	 *    b) There is at least one printable character belonging to the
	 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
	 * - BINARY otherwise.
	 * - The following partially-portable control characters form a
	 *   "gray list" that is ignored in this detection algorithm:
	 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
	 * IN assertion: the fields Freq of dyn_ltree are set.
	 */
	function detect_data_type(s) {
	  /* black_mask is the bit mask of black-listed bytes
	   * set bits 0..6, 14..25, and 28..31
	   * 0xf3ffc07f = binary 11110011111111111100000001111111
	   */
	  var black_mask = 0xf3ffc07f;
	  var n;
	
	  /* Check for non-textual ("black-listed") bytes. */
	  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
	    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
	      return Z_BINARY;
	    }
	  }
	
	  /* Check for textual ("white-listed") bytes. */
	  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
	      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
	    return Z_TEXT;
	  }
	  for (n = 32; n < LITERALS; n++) {
	    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
	      return Z_TEXT;
	    }
	  }
	
	  /* There are no "black-listed" or "white-listed" bytes:
	   * this stream either is empty or has tolerated ("gray-listed") bytes only.
	   */
	  return Z_BINARY;
	}
	
	
	var static_init_done = false;
	
	/* ===========================================================================
	 * Initialize the tree data structures for a new zlib stream.
	 */
	function _tr_init(s)
	{
	
	  if (!static_init_done) {
	    tr_static_init();
	    static_init_done = true;
	  }
	
	  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
	  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
	  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
	
	  s.bi_buf = 0;
	  s.bi_valid = 0;
	
	  /* Initialize the first block of the first file: */
	  init_block(s);
	}
	
	
	/* ===========================================================================
	 * Send a stored block
	 */
	function _tr_stored_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
	  copy_block(s, buf, stored_len, true); /* with header */
	}
	
	
	/* ===========================================================================
	 * Send one empty static block to give enough lookahead for inflate.
	 * This takes 10 bits, of which 7 may remain in the bit buffer.
	 */
	function _tr_align(s) {
	  send_bits(s, STATIC_TREES << 1, 3);
	  send_code(s, END_BLOCK, static_ltree);
	  bi_flush(s);
	}
	
	
	/* ===========================================================================
	 * Determine the best encoding for the current block: dynamic trees, static
	 * trees or store, and output the encoded block to the zip file.
	 */
	function _tr_flush_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block, or NULL if too old */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
	  var max_blindex = 0;        /* index of last bit length code of non zero freq */
	
	  /* Build the Huffman trees unless a stored block is forced */
	  if (s.level > 0) {
	
	    /* Check if the file is binary or text */
	    if (s.strm.data_type === Z_UNKNOWN) {
	      s.strm.data_type = detect_data_type(s);
	    }
	
	    /* Construct the literal and distance trees */
	    build_tree(s, s.l_desc);
	    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));
	
	    build_tree(s, s.d_desc);
	    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));
	    /* At this point, opt_len and static_len are the total bit lengths of
	     * the compressed block data, excluding the tree representations.
	     */
	
	    /* Build the bit length tree for the above two trees, and get the index
	     * in bl_order of the last bit length code to send.
	     */
	    max_blindex = build_bl_tree(s);
	
	    /* Determine the best encoding. Compute the block lengths in bytes. */
	    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
	    static_lenb = (s.static_len + 3 + 7) >>> 3;
	
	    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
	    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
	    //        s->last_lit));
	
	    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }
	
	  } else {
	    // Assert(buf != (char*)0, "lost buf");
	    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
	  }
	
	  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
	    /* 4: two words for the lengths */
	
	    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
	     * Otherwise we can't have processed more than WSIZE input bytes since
	     * the last block flush, because compression would have been
	     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
	     * transform a block into a stored block.
	     */
	    _tr_stored_block(s, buf, stored_len, last);
	
	  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
	
	    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
	    compress_block(s, static_ltree, static_dtree);
	
	  } else {
	    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
	    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
	    compress_block(s, s.dyn_ltree, s.dyn_dtree);
	  }
	  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
	  /* The above check is made mod 2^32, for files larger than 512 MB
	   * and uLong implemented on 32 bits.
	   */
	  init_block(s);
	
	  if (last) {
	    bi_windup(s);
	  }
	  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
	  //       s->compressed_len-7*last));
	}
	
	/* ===========================================================================
	 * Save the match info and tally the frequency counts. Return true if
	 * the current block must be flushed.
	 */
	function _tr_tally(s, dist, lc)
	//    deflate_state *s;
	//    unsigned dist;  /* distance of matched string */
	//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
	{
	  //var out_length, in_length, dcode;
	
	  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
	  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
	
	  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
	  s.last_lit++;
	
	  if (dist === 0) {
	    /* lc is the unmatched char */
	    s.dyn_ltree[lc * 2]/*.Freq*/++;
	  } else {
	    s.matches++;
	    /* Here, lc is the match length - MIN_MATCH */
	    dist--;             /* dist = match distance - 1 */
	    //Assert((ush)dist < (ush)MAX_DIST(s) &&
	    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
	    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
	
	    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
	    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
	  }
	
	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	
	//#ifdef TRUNCATE_BLOCK
	//  /* Try to guess if it is profitable to stop the current block here */
	//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
	//    /* Compute an upper bound for the compressed length */
	//    out_length = s.last_lit*8;
	//    in_length = s.strstart - s.block_start;
	//
	//    for (dcode = 0; dcode < D_CODES; dcode++) {
	//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
	//    }
	//    out_length >>>= 3;
	//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
	//    //       s->last_lit, in_length, out_length,
	//    //       100L - out_length*100L/in_length));
	//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
	//      return true;
	//    }
	//  }
	//#endif
	
	  return (s.last_lit === s.lit_bufsize - 1);
	  /* We avoid equality with lit_bufsize because of wraparound at 64K
	   * on 16 bit machines and because stored blocks are restricted to
	   * 64K-1 bytes.
	   */
	}
	
	exports._tr_init  = _tr_init;
	exports._tr_stored_block = _tr_stored_block;
	exports._tr_flush_block  = _tr_flush_block;
	exports._tr_tally = _tr_tally;
	exports._tr_align = _tr_align;


/***/ },
/* 325 */
/***/ function(module, exports) {

	'use strict';
	
	// Note: adler32 takes 12% for level 0 and 2% for level 6.
	// It doesn't worth to make additional optimizationa as in original.
	// Small size is preferable.
	
	function adler32(adler, buf, len, pos) {
	  var s1 = (adler & 0xffff) |0,
	      s2 = ((adler >>> 16) & 0xffff) |0,
	      n = 0;
	
	  while (len !== 0) {
	    // Set limit ~ twice less than 5552, to keep
	    // s2 in 31-bits, because we force signed ints.
	    // in other case %= will fail.
	    n = len > 2000 ? 2000 : len;
	    len -= n;
	
	    do {
	      s1 = (s1 + buf[pos++]) |0;
	      s2 = (s2 + s1) |0;
	    } while (--n);
	
	    s1 %= 65521;
	    s2 %= 65521;
	  }
	
	  return (s1 | (s2 << 16)) |0;
	}
	
	
	module.exports = adler32;


/***/ },
/* 326 */
/***/ function(module, exports) {

	'use strict';
	
	// Note: we can't get significant speed boost here.
	// So write code to minimize size - no pregenerated tables
	// and array tools dependencies.
	
	
	// Use ordinary array, since untyped makes no boost here
	function makeTable() {
	  var c, table = [];
	
	  for (var n = 0; n < 256; n++) {
	    c = n;
	    for (var k = 0; k < 8; k++) {
	      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
	    }
	    table[n] = c;
	  }
	
	  return table;
	}
	
	// Create table on load. Just 255 signed longs. Not a problem.
	var crcTable = makeTable();
	
	
	function crc32(crc, buf, len, pos) {
	  var t = crcTable,
	      end = pos + len;
	
	  crc ^= -1;
	
	  for (var i = pos; i < end; i++) {
	    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
	  }
	
	  return (crc ^ (-1)); // >>> 0;
	}
	
	
	module.exports = crc32;


/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	var utils         = __webpack_require__(323);
	var adler32       = __webpack_require__(325);
	var crc32         = __webpack_require__(326);
	var inflate_fast  = __webpack_require__(328);
	var inflate_table = __webpack_require__(329);
	
	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;
	
	/* Public constants ==========================================================*/
	/* ===========================================================================*/
	
	
	/* Allowed flush values; see deflate() and inflate() below for details */
	//var Z_NO_FLUSH      = 0;
	//var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	//var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	var Z_TREES         = 6;
	
	
	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;
	
	/* The deflate compression method */
	var Z_DEFLATED  = 8;
	
	
	/* STATES ====================================================================*/
	/* ===========================================================================*/
	
	
	var    HEAD = 1;       /* i: waiting for magic header */
	var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
	var    TIME = 3;       /* i: waiting for modification time (gzip) */
	var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
	var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
	var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
	var    NAME = 7;       /* i: waiting for end of file name (gzip) */
	var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
	var    HCRC = 9;       /* i: waiting for header crc (gzip) */
	var    DICTID = 10;    /* i: waiting for dictionary check value */
	var    DICT = 11;      /* waiting for inflateSetDictionary() call */
	var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
	var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
	var        STORED = 14;    /* i: waiting for stored size (length and complement) */
	var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
	var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
	var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
	var        LENLENS = 18;   /* i: waiting for code length code lengths */
	var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
	var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
	var            LEN = 21;       /* i: waiting for length/lit/eob code */
	var            LENEXT = 22;    /* i: waiting for length extra bits */
	var            DIST = 23;      /* i: waiting for distance code */
	var            DISTEXT = 24;   /* i: waiting for distance extra bits */
	var            MATCH = 25;     /* o: waiting for output space to copy string */
	var            LIT = 26;       /* o: waiting for output space to write literal */
	var    CHECK = 27;     /* i: waiting for 32-bit check value */
	var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
	var    DONE = 29;      /* finished check, done -- remain here until reset */
	var    BAD = 30;       /* got a data error -- remain here until reset */
	var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
	var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */
	
	/* ===========================================================================*/
	
	
	
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);
	
	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_WBITS = MAX_WBITS;
	
	
	function zswap32(q) {
	  return  (((q >>> 24) & 0xff) +
	          ((q >>> 8) & 0xff00) +
	          ((q & 0xff00) << 8) +
	          ((q & 0xff) << 24));
	}
	
	
	function InflateState() {
	  this.mode = 0;             /* current inflate mode */
	  this.last = false;          /* true if processing last block */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.havedict = false;      /* true if dictionary provided */
	  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
	  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
	  this.check = 0;             /* protected copy of check value */
	  this.total = 0;             /* protected copy of output count */
	  // TODO: may be {}
	  this.head = null;           /* where to save gzip header information */
	
	  /* sliding window */
	  this.wbits = 0;             /* log base 2 of requested window size */
	  this.wsize = 0;             /* window size or zero if not using window */
	  this.whave = 0;             /* valid bytes in the window */
	  this.wnext = 0;             /* window write index */
	  this.window = null;         /* allocated sliding window, if needed */
	
	  /* bit accumulator */
	  this.hold = 0;              /* input bit accumulator */
	  this.bits = 0;              /* number of bits in "in" */
	
	  /* for string and stored block copying */
	  this.length = 0;            /* literal or length of data to copy */
	  this.offset = 0;            /* distance back to copy string from */
	
	  /* for table and code decoding */
	  this.extra = 0;             /* extra bits needed */
	
	  /* fixed and dynamic code tables */
	  this.lencode = null;          /* starting table for length/literal codes */
	  this.distcode = null;         /* starting table for distance codes */
	  this.lenbits = 0;           /* index bits for lencode */
	  this.distbits = 0;          /* index bits for distcode */
	
	  /* dynamic table building */
	  this.ncode = 0;             /* number of code length code lengths */
	  this.nlen = 0;              /* number of length code lengths */
	  this.ndist = 0;             /* number of distance code lengths */
	  this.have = 0;              /* number of code lengths in lens[] */
	  this.next = null;              /* next available space in codes[] */
	
	  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
	  this.work = new utils.Buf16(288); /* work area for code table building */
	
	  /*
	   because we don't have pointers in js, we use lencode and distcode directly
	   as buffers so we don't need codes
	  */
	  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
	  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
	  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
	  this.sane = 0;                   /* if false, allow invalid distance too far */
	  this.back = 0;                   /* bits back of last unprocessed length/lit */
	  this.was = 0;                    /* initial length of match */
	}
	
	function inflateResetKeep(strm) {
	  var state;
	
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  strm.total_in = strm.total_out = state.total = 0;
	  strm.msg = ''; /*Z_NULL*/
	  if (state.wrap) {       /* to support ill-conceived Java test suite */
	    strm.adler = state.wrap & 1;
	  }
	  state.mode = HEAD;
	  state.last = 0;
	  state.havedict = 0;
	  state.dmax = 32768;
	  state.head = null/*Z_NULL*/;
	  state.hold = 0;
	  state.bits = 0;
	  //state.lencode = state.distcode = state.next = state.codes;
	  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
	  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
	
	  state.sane = 1;
	  state.back = -1;
	  //Tracev((stderr, "inflate: reset\n"));
	  return Z_OK;
	}
	
	function inflateReset(strm) {
	  var state;
	
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  state.wsize = 0;
	  state.whave = 0;
	  state.wnext = 0;
	  return inflateResetKeep(strm);
	
	}
	
	function inflateReset2(strm, windowBits) {
	  var wrap;
	  var state;
	
	  /* get the state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	
	  /* extract wrap request from windowBits parameter */
	  if (windowBits < 0) {
	    wrap = 0;
	    windowBits = -windowBits;
	  }
	  else {
	    wrap = (windowBits >> 4) + 1;
	    if (windowBits < 48) {
	      windowBits &= 15;
	    }
	  }
	
	  /* set number of window bits, free window if different */
	  if (windowBits && (windowBits < 8 || windowBits > 15)) {
	    return Z_STREAM_ERROR;
	  }
	  if (state.window !== null && state.wbits !== windowBits) {
	    state.window = null;
	  }
	
	  /* update state and reset the rest of it */
	  state.wrap = wrap;
	  state.wbits = windowBits;
	  return inflateReset(strm);
	}
	
	function inflateInit2(strm, windowBits) {
	  var ret;
	  var state;
	
	  if (!strm) { return Z_STREAM_ERROR; }
	  //strm.msg = Z_NULL;                 /* in case we return an error */
	
	  state = new InflateState();
	
	  //if (state === Z_NULL) return Z_MEM_ERROR;
	  //Tracev((stderr, "inflate: allocated\n"));
	  strm.state = state;
	  state.window = null/*Z_NULL*/;
	  ret = inflateReset2(strm, windowBits);
	  if (ret !== Z_OK) {
	    strm.state = null/*Z_NULL*/;
	  }
	  return ret;
	}
	
	function inflateInit(strm) {
	  return inflateInit2(strm, DEF_WBITS);
	}
	
	
	/*
	 Return state with length and distance decoding tables and index sizes set to
	 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
	 If BUILDFIXED is defined, then instead this routine builds the tables the
	 first time it's called, and returns those tables the first time and
	 thereafter.  This reduces the size of the code by about 2K bytes, in
	 exchange for a little execution time.  However, BUILDFIXED should not be
	 used for threaded applications, since the rewriting of the tables and virgin
	 may not be thread-safe.
	 */
	var virgin = true;
	
	var lenfix, distfix; // We have no pointers in JS, so keep tables separate
	
	function fixedtables(state) {
	  /* build fixed huffman tables if first call (may not be thread safe) */
	  if (virgin) {
	    var sym;
	
	    lenfix = new utils.Buf32(512);
	    distfix = new utils.Buf32(32);
	
	    /* literal/length table */
	    sym = 0;
	    while (sym < 144) { state.lens[sym++] = 8; }
	    while (sym < 256) { state.lens[sym++] = 9; }
	    while (sym < 280) { state.lens[sym++] = 7; }
	    while (sym < 288) { state.lens[sym++] = 8; }
	
	    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });
	
	    /* distance table */
	    sym = 0;
	    while (sym < 32) { state.lens[sym++] = 5; }
	
	    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });
	
	    /* do this just once */
	    virgin = false;
	  }
	
	  state.lencode = lenfix;
	  state.lenbits = 9;
	  state.distcode = distfix;
	  state.distbits = 5;
	}
	
	
	/*
	 Update the window with the last wsize (normally 32K) bytes written before
	 returning.  If window does not exist yet, create it.  This is only called
	 when a window is already in use, or when output has been written during this
	 inflate call, but the end of the deflate stream has not been reached yet.
	 It is also called to create a window for dictionary data when a dictionary
	 is loaded.
	
	 Providing output buffers larger than 32K to inflate() should provide a speed
	 advantage, since only the last 32K of output is copied to the sliding window
	 upon return from inflate(), and since all distances after the first 32K of
	 output will fall in the output data, making match copies simpler and faster.
	 The advantage may be dependent on the size of the processor's data caches.
	 */
	function updatewindow(strm, src, end, copy) {
	  var dist;
	  var state = strm.state;
	
	  /* if it hasn't been done already, allocate space for the window */
	  if (state.window === null) {
	    state.wsize = 1 << state.wbits;
	    state.wnext = 0;
	    state.whave = 0;
	
	    state.window = new utils.Buf8(state.wsize);
	  }
	
	  /* copy state->wsize or less output bytes into the circular window */
	  if (copy >= state.wsize) {
	    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
	    state.wnext = 0;
	    state.whave = state.wsize;
	  }
	  else {
	    dist = state.wsize - state.wnext;
	    if (dist > copy) {
	      dist = copy;
	    }
	    //zmemcpy(state->window + state->wnext, end - copy, dist);
	    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
	    copy -= dist;
	    if (copy) {
	      //zmemcpy(state->window, end - copy, copy);
	      utils.arraySet(state.window, src, end - copy, copy, 0);
	      state.wnext = copy;
	      state.whave = state.wsize;
	    }
	    else {
	      state.wnext += dist;
	      if (state.wnext === state.wsize) { state.wnext = 0; }
	      if (state.whave < state.wsize) { state.whave += dist; }
	    }
	  }
	  return 0;
	}
	
	function inflate(strm, flush) {
	  var state;
	  var input, output;          // input/output buffers
	  var next;                   /* next input INDEX */
	  var put;                    /* next output INDEX */
	  var have, left;             /* available input and output */
	  var hold;                   /* bit buffer */
	  var bits;                   /* bits in bit buffer */
	  var _in, _out;              /* save starting available input and output */
	  var copy;                   /* number of stored or match bytes to copy */
	  var from;                   /* where to copy match bytes from */
	  var from_source;
	  var here = 0;               /* current decoding table entry */
	  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
	  //var last;                   /* parent table entry */
	  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
	  var len;                    /* length to copy for repeats, bits to drop */
	  var ret;                    /* return code */
	  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
	  var opts;
	
	  var n; // temporary var for NEED_BITS
	
	  var order = /* permutation of code lengths */
	    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
	
	
	  if (!strm || !strm.state || !strm.output ||
	      (!strm.input && strm.avail_in !== 0)) {
	    return Z_STREAM_ERROR;
	  }
	
	  state = strm.state;
	  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */
	
	
	  //--- LOAD() ---
	  put = strm.next_out;
	  output = strm.output;
	  left = strm.avail_out;
	  next = strm.next_in;
	  input = strm.input;
	  have = strm.avail_in;
	  hold = state.hold;
	  bits = state.bits;
	  //---
	
	  _in = have;
	  _out = left;
	  ret = Z_OK;
	
	  inf_leave: // goto emulation
	  for (;;) {
	    switch (state.mode) {
	    case HEAD:
	      if (state.wrap === 0) {
	        state.mode = TYPEDO;
	        break;
	      }
	      //=== NEEDBITS(16);
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
	        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = FLAGS;
	        break;
	      }
	      state.flags = 0;           /* expect zlib header */
	      if (state.head) {
	        state.head.done = false;
	      }
	      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
	        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
	        strm.msg = 'incorrect header check';
	        state.mode = BAD;
	        break;
	      }
	      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
	        strm.msg = 'unknown compression method';
	        state.mode = BAD;
	        break;
	      }
	      //--- DROPBITS(4) ---//
	      hold >>>= 4;
	      bits -= 4;
	      //---//
	      len = (hold & 0x0f)/*BITS(4)*/ + 8;
	      if (state.wbits === 0) {
	        state.wbits = len;
	      }
	      else if (len > state.wbits) {
	        strm.msg = 'invalid window size';
	        state.mode = BAD;
	        break;
	      }
	      state.dmax = 1 << len;
	      //Tracev((stderr, "inflate:   zlib header ok\n"));
	      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	      state.mode = hold & 0x200 ? DICTID : TYPE;
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      break;
	    case FLAGS:
	      //=== NEEDBITS(16); */
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.flags = hold;
	      if ((state.flags & 0xff) !== Z_DEFLATED) {
	        strm.msg = 'unknown compression method';
	        state.mode = BAD;
	        break;
	      }
	      if (state.flags & 0xe000) {
	        strm.msg = 'unknown header flags set';
	        state.mode = BAD;
	        break;
	      }
	      if (state.head) {
	        state.head.text = ((hold >> 8) & 1);
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = TIME;
	      /* falls through */
	    case TIME:
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if (state.head) {
	        state.head.time = hold;
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC4(state.check, hold)
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        hbuf[2] = (hold >>> 16) & 0xff;
	        hbuf[3] = (hold >>> 24) & 0xff;
	        state.check = crc32(state.check, hbuf, 4, 0);
	        //===
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = OS;
	      /* falls through */
	    case OS:
	      //=== NEEDBITS(16); */
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if (state.head) {
	        state.head.xflags = (hold & 0xff);
	        state.head.os = (hold >> 8);
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = EXLEN;
	      /* falls through */
	    case EXLEN:
	      if (state.flags & 0x0400) {
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.length = hold;
	        if (state.head) {
	          state.head.extra_len = hold;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	      }
	      else if (state.head) {
	        state.head.extra = null/*Z_NULL*/;
	      }
	      state.mode = EXTRA;
	      /* falls through */
	    case EXTRA:
	      if (state.flags & 0x0400) {
	        copy = state.length;
	        if (copy > have) { copy = have; }
	        if (copy) {
	          if (state.head) {
	            len = state.head.extra_len - state.length;
	            if (!state.head.extra) {
	              // Use untyped array for more conveniend processing later
	              state.head.extra = new Array(state.head.extra_len);
	            }
	            utils.arraySet(
	              state.head.extra,
	              input,
	              next,
	              // extra field is limited to 65536 bytes
	              // - no need for additional size check
	              copy,
	              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
	              len
	            );
	            //zmemcpy(state.head.extra + len, next,
	            //        len + copy > state.head.extra_max ?
	            //        state.head.extra_max - len : copy);
	          }
	          if (state.flags & 0x0200) {
	            state.check = crc32(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          state.length -= copy;
	        }
	        if (state.length) { break inf_leave; }
	      }
	      state.length = 0;
	      state.mode = NAME;
	      /* falls through */
	    case NAME:
	      if (state.flags & 0x0800) {
	        if (have === 0) { break inf_leave; }
	        copy = 0;
	        do {
	          // TODO: 2 or 1 bytes?
	          len = input[next + copy++];
	          /* use constant limit because in js we should not preallocate memory */
	          if (state.head && len &&
	              (state.length < 65536 /*state.head.name_max*/)) {
	            state.head.name += String.fromCharCode(len);
	          }
	        } while (len && copy < have);
	
	        if (state.flags & 0x0200) {
	          state.check = crc32(state.check, input, copy, next);
	        }
	        have -= copy;
	        next += copy;
	        if (len) { break inf_leave; }
	      }
	      else if (state.head) {
	        state.head.name = null;
	      }
	      state.length = 0;
	      state.mode = COMMENT;
	      /* falls through */
	    case COMMENT:
	      if (state.flags & 0x1000) {
	        if (have === 0) { break inf_leave; }
	        copy = 0;
	        do {
	          len = input[next + copy++];
	          /* use constant limit because in js we should not preallocate memory */
	          if (state.head && len &&
	              (state.length < 65536 /*state.head.comm_max*/)) {
	            state.head.comment += String.fromCharCode(len);
	          }
	        } while (len && copy < have);
	        if (state.flags & 0x0200) {
	          state.check = crc32(state.check, input, copy, next);
	        }
	        have -= copy;
	        next += copy;
	        if (len) { break inf_leave; }
	      }
	      else if (state.head) {
	        state.head.comment = null;
	      }
	      state.mode = HCRC;
	      /* falls through */
	    case HCRC:
	      if (state.flags & 0x0200) {
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (hold !== (state.check & 0xffff)) {
	          strm.msg = 'header crc mismatch';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	      }
	      if (state.head) {
	        state.head.hcrc = ((state.flags >> 9) & 1);
	        state.head.done = true;
	      }
	      strm.adler = state.check = 0;
	      state.mode = TYPE;
	      break;
	    case DICTID:
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      strm.adler = state.check = zswap32(hold);
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = DICT;
	      /* falls through */
	    case DICT:
	      if (state.havedict === 0) {
	        //--- RESTORE() ---
	        strm.next_out = put;
	        strm.avail_out = left;
	        strm.next_in = next;
	        strm.avail_in = have;
	        state.hold = hold;
	        state.bits = bits;
	        //---
	        return Z_NEED_DICT;
	      }
	      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	      state.mode = TYPE;
	      /* falls through */
	    case TYPE:
	      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case TYPEDO:
	      if (state.last) {
	        //--- BYTEBITS() ---//
	        hold >>>= bits & 7;
	        bits -= bits & 7;
	        //---//
	        state.mode = CHECK;
	        break;
	      }
	      //=== NEEDBITS(3); */
	      while (bits < 3) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.last = (hold & 0x01)/*BITS(1)*/;
	      //--- DROPBITS(1) ---//
	      hold >>>= 1;
	      bits -= 1;
	      //---//
	
	      switch ((hold & 0x03)/*BITS(2)*/) {
	      case 0:                             /* stored block */
	        //Tracev((stderr, "inflate:     stored block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = STORED;
	        break;
	      case 1:                             /* fixed block */
	        fixedtables(state);
	        //Tracev((stderr, "inflate:     fixed codes block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = LEN_;             /* decode codes */
	        if (flush === Z_TREES) {
	          //--- DROPBITS(2) ---//
	          hold >>>= 2;
	          bits -= 2;
	          //---//
	          break inf_leave;
	        }
	        break;
	      case 2:                             /* dynamic block */
	        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = TABLE;
	        break;
	      case 3:
	        strm.msg = 'invalid block type';
	        state.mode = BAD;
	      }
	      //--- DROPBITS(2) ---//
	      hold >>>= 2;
	      bits -= 2;
	      //---//
	      break;
	    case STORED:
	      //--- BYTEBITS() ---// /* go to byte boundary */
	      hold >>>= bits & 7;
	      bits -= bits & 7;
	      //---//
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
	        strm.msg = 'invalid stored block lengths';
	        state.mode = BAD;
	        break;
	      }
	      state.length = hold & 0xffff;
	      //Tracev((stderr, "inflate:       stored length %u\n",
	      //        state.length));
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = COPY_;
	      if (flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case COPY_:
	      state.mode = COPY;
	      /* falls through */
	    case COPY:
	      copy = state.length;
	      if (copy) {
	        if (copy > have) { copy = have; }
	        if (copy > left) { copy = left; }
	        if (copy === 0) { break inf_leave; }
	        //--- zmemcpy(put, next, copy); ---
	        utils.arraySet(output, input, next, copy, put);
	        //---//
	        have -= copy;
	        next += copy;
	        left -= copy;
	        put += copy;
	        state.length -= copy;
	        break;
	      }
	      //Tracev((stderr, "inflate:       stored end\n"));
	      state.mode = TYPE;
	      break;
	    case TABLE:
	      //=== NEEDBITS(14); */
	      while (bits < 14) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
	      //--- DROPBITS(5) ---//
	      hold >>>= 5;
	      bits -= 5;
	      //---//
	      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
	      //--- DROPBITS(5) ---//
	      hold >>>= 5;
	      bits -= 5;
	      //---//
	      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
	      //--- DROPBITS(4) ---//
	      hold >>>= 4;
	      bits -= 4;
	      //---//
	//#ifndef PKZIP_BUG_WORKAROUND
	      if (state.nlen > 286 || state.ndist > 30) {
	        strm.msg = 'too many length or distance symbols';
	        state.mode = BAD;
	        break;
	      }
	//#endif
	      //Tracev((stderr, "inflate:       table sizes ok\n"));
	      state.have = 0;
	      state.mode = LENLENS;
	      /* falls through */
	    case LENLENS:
	      while (state.have < state.ncode) {
	        //=== NEEDBITS(3);
	        while (bits < 3) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
	        //--- DROPBITS(3) ---//
	        hold >>>= 3;
	        bits -= 3;
	        //---//
	      }
	      while (state.have < 19) {
	        state.lens[order[state.have++]] = 0;
	      }
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      //state.next = state.codes;
	      //state.lencode = state.next;
	      // Switch to use dynamic table
	      state.lencode = state.lendyn;
	      state.lenbits = 7;
	
	      opts = { bits: state.lenbits };
	      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
	      state.lenbits = opts.bits;
	
	      if (ret) {
	        strm.msg = 'invalid code lengths set';
	        state.mode = BAD;
	        break;
	      }
	      //Tracev((stderr, "inflate:       code lengths ok\n"));
	      state.have = 0;
	      state.mode = CODELENS;
	      /* falls through */
	    case CODELENS:
	      while (state.have < state.nlen + state.ndist) {
	        for (;;) {
	          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;
	
	          if ((here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        if (here_val < 16) {
	          //--- DROPBITS(here.bits) ---//
	          hold >>>= here_bits;
	          bits -= here_bits;
	          //---//
	          state.lens[state.have++] = here_val;
	        }
	        else {
	          if (here_val === 16) {
	            //=== NEEDBITS(here.bits + 2);
	            n = here_bits + 2;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            if (state.have === 0) {
	              strm.msg = 'invalid bit length repeat';
	              state.mode = BAD;
	              break;
	            }
	            len = state.lens[state.have - 1];
	            copy = 3 + (hold & 0x03);//BITS(2);
	            //--- DROPBITS(2) ---//
	            hold >>>= 2;
	            bits -= 2;
	            //---//
	          }
	          else if (here_val === 17) {
	            //=== NEEDBITS(here.bits + 3);
	            n = here_bits + 3;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            len = 0;
	            copy = 3 + (hold & 0x07);//BITS(3);
	            //--- DROPBITS(3) ---//
	            hold >>>= 3;
	            bits -= 3;
	            //---//
	          }
	          else {
	            //=== NEEDBITS(here.bits + 7);
	            n = here_bits + 7;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            len = 0;
	            copy = 11 + (hold & 0x7f);//BITS(7);
	            //--- DROPBITS(7) ---//
	            hold >>>= 7;
	            bits -= 7;
	            //---//
	          }
	          if (state.have + copy > state.nlen + state.ndist) {
	            strm.msg = 'invalid bit length repeat';
	            state.mode = BAD;
	            break;
	          }
	          while (copy--) {
	            state.lens[state.have++] = len;
	          }
	        }
	      }
	
	      /* handle error breaks in while */
	      if (state.mode === BAD) { break; }
	
	      /* check for end-of-block code (better have one) */
	      if (state.lens[256] === 0) {
	        strm.msg = 'invalid code -- missing end-of-block';
	        state.mode = BAD;
	        break;
	      }
	
	      /* build code tables -- note: do not change the lenbits or distbits
	         values here (9 and 6) without reading the comments in inftrees.h
	         concerning the ENOUGH constants, which depend on those values */
	      state.lenbits = 9;
	
	      opts = { bits: state.lenbits };
	      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      // state.next_index = opts.table_index;
	      state.lenbits = opts.bits;
	      // state.lencode = state.next;
	
	      if (ret) {
	        strm.msg = 'invalid literal/lengths set';
	        state.mode = BAD;
	        break;
	      }
	
	      state.distbits = 6;
	      //state.distcode.copy(state.codes);
	      // Switch to use dynamic table
	      state.distcode = state.distdyn;
	      opts = { bits: state.distbits };
	      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      // state.next_index = opts.table_index;
	      state.distbits = opts.bits;
	      // state.distcode = state.next;
	
	      if (ret) {
	        strm.msg = 'invalid distances set';
	        state.mode = BAD;
	        break;
	      }
	      //Tracev((stderr, 'inflate:       codes ok\n'));
	      state.mode = LEN_;
	      if (flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case LEN_:
	      state.mode = LEN;
	      /* falls through */
	    case LEN:
	      if (have >= 6 && left >= 258) {
	        //--- RESTORE() ---
	        strm.next_out = put;
	        strm.avail_out = left;
	        strm.next_in = next;
	        strm.avail_in = have;
	        state.hold = hold;
	        state.bits = bits;
	        //---
	        inflate_fast(strm, _out);
	        //--- LOAD() ---
	        put = strm.next_out;
	        output = strm.output;
	        left = strm.avail_out;
	        next = strm.next_in;
	        input = strm.input;
	        have = strm.avail_in;
	        hold = state.hold;
	        bits = state.bits;
	        //---
	
	        if (state.mode === TYPE) {
	          state.back = -1;
	        }
	        break;
	      }
	      state.back = 0;
	      for (;;) {
	        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
	        here_bits = here >>> 24;
	        here_op = (here >>> 16) & 0xff;
	        here_val = here & 0xffff;
	
	        if (here_bits <= bits) { break; }
	        //--- PULLBYTE() ---//
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	        //---//
	      }
	      if (here_op && (here_op & 0xf0) === 0) {
	        last_bits = here_bits;
	        last_op = here_op;
	        last_val = here_val;
	        for (;;) {
	          here = state.lencode[last_val +
	                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;
	
	          if ((last_bits + here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        //--- DROPBITS(last.bits) ---//
	        hold >>>= last_bits;
	        bits -= last_bits;
	        //---//
	        state.back += last_bits;
	      }
	      //--- DROPBITS(here.bits) ---//
	      hold >>>= here_bits;
	      bits -= here_bits;
	      //---//
	      state.back += here_bits;
	      state.length = here_val;
	      if (here_op === 0) {
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        state.mode = LIT;
	        break;
	      }
	      if (here_op & 32) {
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.back = -1;
	        state.mode = TYPE;
	        break;
	      }
	      if (here_op & 64) {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break;
	      }
	      state.extra = here_op & 15;
	      state.mode = LENEXT;
	      /* falls through */
	    case LENEXT:
	      if (state.extra) {
	        //=== NEEDBITS(state.extra);
	        n = state.extra;
	        while (bits < n) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	        //--- DROPBITS(state.extra) ---//
	        hold >>>= state.extra;
	        bits -= state.extra;
	        //---//
	        state.back += state.extra;
	      }
	      //Tracevv((stderr, "inflate:         length %u\n", state.length));
	      state.was = state.length;
	      state.mode = DIST;
	      /* falls through */
	    case DIST:
	      for (;;) {
	        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
	        here_bits = here >>> 24;
	        here_op = (here >>> 16) & 0xff;
	        here_val = here & 0xffff;
	
	        if ((here_bits) <= bits) { break; }
	        //--- PULLBYTE() ---//
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	        //---//
	      }
	      if ((here_op & 0xf0) === 0) {
	        last_bits = here_bits;
	        last_op = here_op;
	        last_val = here_val;
	        for (;;) {
	          here = state.distcode[last_val +
	                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;
	
	          if ((last_bits + here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        //--- DROPBITS(last.bits) ---//
	        hold >>>= last_bits;
	        bits -= last_bits;
	        //---//
	        state.back += last_bits;
	      }
	      //--- DROPBITS(here.bits) ---//
	      hold >>>= here_bits;
	      bits -= here_bits;
	      //---//
	      state.back += here_bits;
	      if (here_op & 64) {
	        strm.msg = 'invalid distance code';
	        state.mode = BAD;
	        break;
	      }
	      state.offset = here_val;
	      state.extra = (here_op) & 15;
	      state.mode = DISTEXT;
	      /* falls through */
	    case DISTEXT:
	      if (state.extra) {
	        //=== NEEDBITS(state.extra);
	        n = state.extra;
	        while (bits < n) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	        //--- DROPBITS(state.extra) ---//
	        hold >>>= state.extra;
	        bits -= state.extra;
	        //---//
	        state.back += state.extra;
	      }
	//#ifdef INFLATE_STRICT
	      if (state.offset > state.dmax) {
	        strm.msg = 'invalid distance too far back';
	        state.mode = BAD;
	        break;
	      }
	//#endif
	      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
	      state.mode = MATCH;
	      /* falls through */
	    case MATCH:
	      if (left === 0) { break inf_leave; }
	      copy = _out - left;
	      if (state.offset > copy) {         /* copy from window */
	        copy = state.offset - copy;
	        if (copy > state.whave) {
	          if (state.sane) {
	            strm.msg = 'invalid distance too far back';
	            state.mode = BAD;
	            break;
	          }
	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//          Trace((stderr, "inflate.c too far\n"));
	//          copy -= state.whave;
	//          if (copy > state.length) { copy = state.length; }
	//          if (copy > left) { copy = left; }
	//          left -= copy;
	//          state.length -= copy;
	//          do {
	//            output[put++] = 0;
	//          } while (--copy);
	//          if (state.length === 0) { state.mode = LEN; }
	//          break;
	//#endif
	        }
	        if (copy > state.wnext) {
	          copy -= state.wnext;
	          from = state.wsize - copy;
	        }
	        else {
	          from = state.wnext - copy;
	        }
	        if (copy > state.length) { copy = state.length; }
	        from_source = state.window;
	      }
	      else {                              /* copy from output */
	        from_source = output;
	        from = put - state.offset;
	        copy = state.length;
	      }
	      if (copy > left) { copy = left; }
	      left -= copy;
	      state.length -= copy;
	      do {
	        output[put++] = from_source[from++];
	      } while (--copy);
	      if (state.length === 0) { state.mode = LEN; }
	      break;
	    case LIT:
	      if (left === 0) { break inf_leave; }
	      output[put++] = state.length;
	      left--;
	      state.mode = LEN;
	      break;
	    case CHECK:
	      if (state.wrap) {
	        //=== NEEDBITS(32);
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          // Use '|' insdead of '+' to make sure that result is signed
	          hold |= input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        _out -= left;
	        strm.total_out += _out;
	        state.total += _out;
	        if (_out) {
	          strm.adler = state.check =
	              /*UPDATE(state.check, put - _out, _out);*/
	              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));
	
	        }
	        _out = left;
	        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
	        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
	          strm.msg = 'incorrect data check';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        //Tracev((stderr, "inflate:   check matches trailer\n"));
	      }
	      state.mode = LENGTH;
	      /* falls through */
	    case LENGTH:
	      if (state.wrap && state.flags) {
	        //=== NEEDBITS(32);
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (hold !== (state.total & 0xffffffff)) {
	          strm.msg = 'incorrect length check';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        //Tracev((stderr, "inflate:   length matches trailer\n"));
	      }
	      state.mode = DONE;
	      /* falls through */
	    case DONE:
	      ret = Z_STREAM_END;
	      break inf_leave;
	    case BAD:
	      ret = Z_DATA_ERROR;
	      break inf_leave;
	    case MEM:
	      return Z_MEM_ERROR;
	    case SYNC:
	      /* falls through */
	    default:
	      return Z_STREAM_ERROR;
	    }
	  }
	
	  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"
	
	  /*
	     Return from inflate(), updating the total counts and the check value.
	     If there was no progress during the inflate() call, return a buffer
	     error.  Call updatewindow() to create and/or update the window state.
	     Note: a memory error from inflate() is non-recoverable.
	   */
	
	  //--- RESTORE() ---
	  strm.next_out = put;
	  strm.avail_out = left;
	  strm.next_in = next;
	  strm.avail_in = have;
	  state.hold = hold;
	  state.bits = bits;
	  //---
	
	  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
	                      (state.mode < CHECK || flush !== Z_FINISH))) {
	    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
	      state.mode = MEM;
	      return Z_MEM_ERROR;
	    }
	  }
	  _in -= strm.avail_in;
	  _out -= strm.avail_out;
	  strm.total_in += _in;
	  strm.total_out += _out;
	  state.total += _out;
	  if (state.wrap && _out) {
	    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
	      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
	  }
	  strm.data_type = state.bits + (state.last ? 64 : 0) +
	                    (state.mode === TYPE ? 128 : 0) +
	                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
	  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
	    ret = Z_BUF_ERROR;
	  }
	  return ret;
	}
	
	function inflateEnd(strm) {
	
	  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
	    return Z_STREAM_ERROR;
	  }
	
	  var state = strm.state;
	  if (state.window) {
	    state.window = null;
	  }
	  strm.state = null;
	  return Z_OK;
	}
	
	function inflateGetHeader(strm, head) {
	  var state;
	
	  /* check state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }
	
	  /* save header structure */
	  state.head = head;
	  head.done = false;
	  return Z_OK;
	}
	
	function inflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;
	
	  var state;
	  var dictid;
	  var ret;
	
	  /* check state */
	  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
	  state = strm.state;
	
	  if (state.wrap !== 0 && state.mode !== DICT) {
	    return Z_STREAM_ERROR;
	  }
	
	  /* check for correct dictionary identifier */
	  if (state.mode === DICT) {
	    dictid = 1; /* adler32(0, null, 0)*/
	    /* dictid = adler32(dictid, dictionary, dictLength); */
	    dictid = adler32(dictid, dictionary, dictLength, 0);
	    if (dictid !== state.check) {
	      return Z_DATA_ERROR;
	    }
	  }
	  /* copy dictionary to window using updatewindow(), which will amend the
	   existing dictionary if appropriate */
	  ret = updatewindow(strm, dictionary, dictLength, dictLength);
	  if (ret) {
	    state.mode = MEM;
	    return Z_MEM_ERROR;
	  }
	  state.havedict = 1;
	  // Tracev((stderr, "inflate:   dictionary set\n"));
	  return Z_OK;
	}
	
	exports.inflateReset = inflateReset;
	exports.inflateReset2 = inflateReset2;
	exports.inflateResetKeep = inflateResetKeep;
	exports.inflateInit = inflateInit;
	exports.inflateInit2 = inflateInit2;
	exports.inflate = inflate;
	exports.inflateEnd = inflateEnd;
	exports.inflateGetHeader = inflateGetHeader;
	exports.inflateSetDictionary = inflateSetDictionary;
	exports.inflateInfo = 'pako inflate (from Nodeca project)';
	
	/* Not implemented
	exports.inflateCopy = inflateCopy;
	exports.inflateGetDictionary = inflateGetDictionary;
	exports.inflateMark = inflateMark;
	exports.inflatePrime = inflatePrime;
	exports.inflateSync = inflateSync;
	exports.inflateSyncPoint = inflateSyncPoint;
	exports.inflateUndermine = inflateUndermine;
	*/


/***/ },
/* 328 */
/***/ function(module, exports) {

	'use strict';
	
	// See state defs from inflate.js
	var BAD = 30;       /* got a data error -- remain here until reset */
	var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
	
	/*
	   Decode literal, length, and distance codes and write out the resulting
	   literal and match bytes until either not enough input or output is
	   available, an end-of-block is encountered, or a data error is encountered.
	   When large enough input and output buffers are supplied to inflate(), for
	   example, a 16K input buffer and a 64K output buffer, more than 95% of the
	   inflate execution time is spent in this routine.
	
	   Entry assumptions:
	
	        state.mode === LEN
	        strm.avail_in >= 6
	        strm.avail_out >= 258
	        start >= strm.avail_out
	        state.bits < 8
	
	   On return, state.mode is one of:
	
	        LEN -- ran out of enough output space or enough available input
	        TYPE -- reached end of block code, inflate() to interpret next block
	        BAD -- error in block data
	
	   Notes:
	
	    - The maximum input bits used by a length/distance pair is 15 bits for the
	      length code, 5 bits for the length extra, 15 bits for the distance code,
	      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
	      Therefore if strm.avail_in >= 6, then there is enough input to avoid
	      checking for available input while decoding.
	
	    - The maximum bytes that a single length/distance pair can output is 258
	      bytes, which is the maximum length that can be coded.  inflate_fast()
	      requires strm.avail_out >= 258 for each loop to avoid checking for
	      output space.
	 */
	module.exports = function inflate_fast(strm, start) {
	  var state;
	  var _in;                    /* local strm.input */
	  var last;                   /* have enough input while in < last */
	  var _out;                   /* local strm.output */
	  var beg;                    /* inflate()'s initial strm.output */
	  var end;                    /* while out < end, enough space available */
	//#ifdef INFLATE_STRICT
	  var dmax;                   /* maximum distance from zlib header */
	//#endif
	  var wsize;                  /* window size or zero if not using window */
	  var whave;                  /* valid bytes in the window */
	  var wnext;                  /* window write index */
	  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
	  var s_window;               /* allocated sliding window, if wsize != 0 */
	  var hold;                   /* local strm.hold */
	  var bits;                   /* local strm.bits */
	  var lcode;                  /* local strm.lencode */
	  var dcode;                  /* local strm.distcode */
	  var lmask;                  /* mask for first level of length codes */
	  var dmask;                  /* mask for first level of distance codes */
	  var here;                   /* retrieved table entry */
	  var op;                     /* code bits, operation, extra bits, or */
	                              /*  window position, window bytes to copy */
	  var len;                    /* match length, unused bytes */
	  var dist;                   /* match distance */
	  var from;                   /* where to copy match from */
	  var from_source;
	
	
	  var input, output; // JS specific, because we have no pointers
	
	  /* copy state to local variables */
	  state = strm.state;
	  //here = state.here;
	  _in = strm.next_in;
	  input = strm.input;
	  last = _in + (strm.avail_in - 5);
	  _out = strm.next_out;
	  output = strm.output;
	  beg = _out - (start - strm.avail_out);
	  end = _out + (strm.avail_out - 257);
	//#ifdef INFLATE_STRICT
	  dmax = state.dmax;
	//#endif
	  wsize = state.wsize;
	  whave = state.whave;
	  wnext = state.wnext;
	  s_window = state.window;
	  hold = state.hold;
	  bits = state.bits;
	  lcode = state.lencode;
	  dcode = state.distcode;
	  lmask = (1 << state.lenbits) - 1;
	  dmask = (1 << state.distbits) - 1;
	
	
	  /* decode literals and length/distances until end-of-block or not enough
	     input data or output space */
	
	  top:
	  do {
	    if (bits < 15) {
	      hold += input[_in++] << bits;
	      bits += 8;
	      hold += input[_in++] << bits;
	      bits += 8;
	    }
	
	    here = lcode[hold & lmask];
	
	    dolen:
	    for (;;) { // Goto emulation
	      op = here >>> 24/*here.bits*/;
	      hold >>>= op;
	      bits -= op;
	      op = (here >>> 16) & 0xff/*here.op*/;
	      if (op === 0) {                          /* literal */
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        output[_out++] = here & 0xffff/*here.val*/;
	      }
	      else if (op & 16) {                     /* length base */
	        len = here & 0xffff/*here.val*/;
	        op &= 15;                           /* number of extra bits */
	        if (op) {
	          if (bits < op) {
	            hold += input[_in++] << bits;
	            bits += 8;
	          }
	          len += hold & ((1 << op) - 1);
	          hold >>>= op;
	          bits -= op;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", len));
	        if (bits < 15) {
	          hold += input[_in++] << bits;
	          bits += 8;
	          hold += input[_in++] << bits;
	          bits += 8;
	        }
	        here = dcode[hold & dmask];
	
	        dodist:
	        for (;;) { // goto emulation
	          op = here >>> 24/*here.bits*/;
	          hold >>>= op;
	          bits -= op;
	          op = (here >>> 16) & 0xff/*here.op*/;
	
	          if (op & 16) {                      /* distance base */
	            dist = here & 0xffff/*here.val*/;
	            op &= 15;                       /* number of extra bits */
	            if (bits < op) {
	              hold += input[_in++] << bits;
	              bits += 8;
	              if (bits < op) {
	                hold += input[_in++] << bits;
	                bits += 8;
	              }
	            }
	            dist += hold & ((1 << op) - 1);
	//#ifdef INFLATE_STRICT
	            if (dist > dmax) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD;
	              break top;
	            }
	//#endif
	            hold >>>= op;
	            bits -= op;
	            //Tracevv((stderr, "inflate:         distance %u\n", dist));
	            op = _out - beg;                /* max distance in output */
	            if (dist > op) {                /* see if copy from window */
	              op = dist - op;               /* distance back in window */
	              if (op > whave) {
	                if (state.sane) {
	                  strm.msg = 'invalid distance too far back';
	                  state.mode = BAD;
	                  break top;
	                }
	
	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//                if (len <= op - whave) {
	//                  do {
	//                    output[_out++] = 0;
	//                  } while (--len);
	//                  continue top;
	//                }
	//                len -= op - whave;
	//                do {
	//                  output[_out++] = 0;
	//                } while (--op > whave);
	//                if (op === 0) {
	//                  from = _out - dist;
	//                  do {
	//                    output[_out++] = output[from++];
	//                  } while (--len);
	//                  continue top;
	//                }
	//#endif
	              }
	              from = 0; // window index
	              from_source = s_window;
	              if (wnext === 0) {           /* very common case */
	                from += wsize - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              else if (wnext < op) {      /* wrap around window */
	                from += wsize + wnext - op;
	                op -= wnext;
	                if (op < len) {         /* some from end of window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = 0;
	                  if (wnext < len) {  /* some from start of window */
	                    op = wnext;
	                    len -= op;
	                    do {
	                      output[_out++] = s_window[from++];
	                    } while (--op);
	                    from = _out - dist;      /* rest from output */
	                    from_source = output;
	                  }
	                }
	              }
	              else {                      /* contiguous in window */
	                from += wnext - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              while (len > 2) {
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                len -= 3;
	              }
	              if (len) {
	                output[_out++] = from_source[from++];
	                if (len > 1) {
	                  output[_out++] = from_source[from++];
	                }
	              }
	            }
	            else {
	              from = _out - dist;          /* copy direct from output */
	              do {                        /* minimum length is three */
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                len -= 3;
	              } while (len > 2);
	              if (len) {
	                output[_out++] = output[from++];
	                if (len > 1) {
	                  output[_out++] = output[from++];
	                }
	              }
	            }
	          }
	          else if ((op & 64) === 0) {          /* 2nd level distance code */
	            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	            continue dodist;
	          }
	          else {
	            strm.msg = 'invalid distance code';
	            state.mode = BAD;
	            break top;
	          }
	
	          break; // need to emulate goto via "continue"
	        }
	      }
	      else if ((op & 64) === 0) {              /* 2nd level length code */
	        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	        continue dolen;
	      }
	      else if (op & 32) {                     /* end-of-block */
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.mode = TYPE;
	        break top;
	      }
	      else {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break top;
	      }
	
	      break; // need to emulate goto via "continue"
	    }
	  } while (_in < last && _out < end);
	
	  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
	  len = bits >> 3;
	  _in -= len;
	  bits -= len << 3;
	  hold &= (1 << bits) - 1;
	
	  /* update state and return */
	  strm.next_in = _in;
	  strm.next_out = _out;
	  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
	  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
	  state.hold = hold;
	  state.bits = bits;
	  return;
	};


/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	var utils = __webpack_require__(323);
	
	var MAXBITS = 15;
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);
	
	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;
	
	var lbase = [ /* Length codes 257..285 base */
	  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
	  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
	];
	
	var lext = [ /* Length codes 257..285 extra */
	  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
	  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
	];
	
	var dbase = [ /* Distance codes 0..29 base */
	  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
	  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
	  8193, 12289, 16385, 24577, 0, 0
	];
	
	var dext = [ /* Distance codes 0..29 extra */
	  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
	  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
	  28, 28, 29, 29, 64, 64
	];
	
	module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
	{
	  var bits = opts.bits;
	      //here = opts.here; /* table entry for duplication */
	
	  var len = 0;               /* a code's length in bits */
	  var sym = 0;               /* index of code symbols */
	  var min = 0, max = 0;          /* minimum and maximum code lengths */
	  var root = 0;              /* number of index bits for root table */
	  var curr = 0;              /* number of index bits for current table */
	  var drop = 0;              /* code bits to drop for sub-table */
	  var left = 0;                   /* number of prefix codes available */
	  var used = 0;              /* code entries in table used */
	  var huff = 0;              /* Huffman code */
	  var incr;              /* for incrementing code, index */
	  var fill;              /* index for replicating entries */
	  var low;               /* low bits for current root entry */
	  var mask;              /* mask for low root bits */
	  var next;             /* next available space in table */
	  var base = null;     /* base value table to use */
	  var base_index = 0;
	//  var shoextra;    /* extra bits table to use */
	  var end;                    /* use base and extra for symbol > end */
	  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
	  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
	  var extra = null;
	  var extra_index = 0;
	
	  var here_bits, here_op, here_val;
	
	  /*
	   Process a set of code lengths to create a canonical Huffman code.  The
	   code lengths are lens[0..codes-1].  Each length corresponds to the
	   symbols 0..codes-1.  The Huffman code is generated by first sorting the
	   symbols by length from short to long, and retaining the symbol order
	   for codes with equal lengths.  Then the code starts with all zero bits
	   for the first code of the shortest length, and the codes are integer
	   increments for the same length, and zeros are appended as the length
	   increases.  For the deflate format, these bits are stored backwards
	   from their more natural integer increment ordering, and so when the
	   decoding tables are built in the large loop below, the integer codes
	   are incremented backwards.
	
	   This routine assumes, but does not check, that all of the entries in
	   lens[] are in the range 0..MAXBITS.  The caller must assure this.
	   1..MAXBITS is interpreted as that code length.  zero means that that
	   symbol does not occur in this code.
	
	   The codes are sorted by computing a count of codes for each length,
	   creating from that a table of starting indices for each length in the
	   sorted table, and then entering the symbols in order in the sorted
	   table.  The sorted table is work[], with that space being provided by
	   the caller.
	
	   The length counts are used for other purposes as well, i.e. finding
	   the minimum and maximum length codes, determining if there are any
	   codes at all, checking for a valid set of lengths, and looking ahead
	   at length counts to determine sub-table sizes when building the
	   decoding tables.
	   */
	
	  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
	  for (len = 0; len <= MAXBITS; len++) {
	    count[len] = 0;
	  }
	  for (sym = 0; sym < codes; sym++) {
	    count[lens[lens_index + sym]]++;
	  }
	
	  /* bound code lengths, force root to be within code lengths */
	  root = bits;
	  for (max = MAXBITS; max >= 1; max--) {
	    if (count[max] !== 0) { break; }
	  }
	  if (root > max) {
	    root = max;
	  }
	  if (max === 0) {                     /* no symbols to code at all */
	    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
	    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
	    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;
	
	
	    //table.op[opts.table_index] = 64;
	    //table.bits[opts.table_index] = 1;
	    //table.val[opts.table_index++] = 0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;
	
	    opts.bits = 1;
	    return 0;     /* no symbols, but wait for decoding to report error */
	  }
	  for (min = 1; min < max; min++) {
	    if (count[min] !== 0) { break; }
	  }
	  if (root < min) {
	    root = min;
	  }
	
	  /* check for an over-subscribed or incomplete set of lengths */
	  left = 1;
	  for (len = 1; len <= MAXBITS; len++) {
	    left <<= 1;
	    left -= count[len];
	    if (left < 0) {
	      return -1;
	    }        /* over-subscribed */
	  }
	  if (left > 0 && (type === CODES || max !== 1)) {
	    return -1;                      /* incomplete set */
	  }
	
	  /* generate offsets into symbol table for each length for sorting */
	  offs[1] = 0;
	  for (len = 1; len < MAXBITS; len++) {
	    offs[len + 1] = offs[len] + count[len];
	  }
	
	  /* sort symbols by length, by symbol order within each length */
	  for (sym = 0; sym < codes; sym++) {
	    if (lens[lens_index + sym] !== 0) {
	      work[offs[lens[lens_index + sym]]++] = sym;
	    }
	  }
	
	  /*
	   Create and fill in decoding tables.  In this loop, the table being
	   filled is at next and has curr index bits.  The code being used is huff
	   with length len.  That code is converted to an index by dropping drop
	   bits off of the bottom.  For codes where len is less than drop + curr,
	   those top drop + curr - len bits are incremented through all values to
	   fill the table with replicated entries.
	
	   root is the number of index bits for the root table.  When len exceeds
	   root, sub-tables are created pointed to by the root entry with an index
	   of the low root bits of huff.  This is saved in low to check for when a
	   new sub-table should be started.  drop is zero when the root table is
	   being filled, and drop is root when sub-tables are being filled.
	
	   When a new sub-table is needed, it is necessary to look ahead in the
	   code lengths to determine what size sub-table is needed.  The length
	   counts are used for this, and so count[] is decremented as codes are
	   entered in the tables.
	
	   used keeps track of how many table entries have been allocated from the
	   provided *table space.  It is checked for LENS and DIST tables against
	   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
	   the initial root table size constants.  See the comments in inftrees.h
	   for more information.
	
	   sym increments through all symbols, and the loop terminates when
	   all codes of length max, i.e. all codes, have been processed.  This
	   routine permits incomplete codes, so another loop after this one fills
	   in the rest of the decoding tables with invalid code markers.
	   */
	
	  /* set up for code type */
	  // poor man optimization - use if-else instead of switch,
	  // to avoid deopts in old v8
	  if (type === CODES) {
	    base = extra = work;    /* dummy value--not used */
	    end = 19;
	
	  } else if (type === LENS) {
	    base = lbase;
	    base_index -= 257;
	    extra = lext;
	    extra_index -= 257;
	    end = 256;
	
	  } else {                    /* DISTS */
	    base = dbase;
	    extra = dext;
	    end = -1;
	  }
	
	  /* initialize opts for loop */
	  huff = 0;                   /* starting code */
	  sym = 0;                    /* starting code symbol */
	  len = min;                  /* starting code length */
	  next = table_index;              /* current table to fill in */
	  curr = root;                /* current table index bits */
	  drop = 0;                   /* current bits to drop from code for index */
	  low = -1;                   /* trigger new sub-table when len > root */
	  used = 1 << root;          /* use root table entries */
	  mask = used - 1;            /* mask for comparing low */
	
	  /* check available table space */
	  if ((type === LENS && used > ENOUGH_LENS) ||
	    (type === DISTS && used > ENOUGH_DISTS)) {
	    return 1;
	  }
	
	  var i = 0;
	  /* process all codes and make table entries */
	  for (;;) {
	    i++;
	    /* create table entry */
	    here_bits = len - drop;
	    if (work[sym] < end) {
	      here_op = 0;
	      here_val = work[sym];
	    }
	    else if (work[sym] > end) {
	      here_op = extra[extra_index + work[sym]];
	      here_val = base[base_index + work[sym]];
	    }
	    else {
	      here_op = 32 + 64;         /* end of block */
	      here_val = 0;
	    }
	
	    /* replicate for those indices with low len bits equal to huff */
	    incr = 1 << (len - drop);
	    fill = 1 << curr;
	    min = fill;                 /* save offset to next table */
	    do {
	      fill -= incr;
	      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
	    } while (fill !== 0);
	
	    /* backwards increment the len-bit code huff */
	    incr = 1 << (len - 1);
	    while (huff & incr) {
	      incr >>= 1;
	    }
	    if (incr !== 0) {
	      huff &= incr - 1;
	      huff += incr;
	    } else {
	      huff = 0;
	    }
	
	    /* go to next symbol, update count, len */
	    sym++;
	    if (--count[len] === 0) {
	      if (len === max) { break; }
	      len = lens[lens_index + work[sym]];
	    }
	
	    /* create new sub-table if needed */
	    if (len > root && (huff & mask) !== low) {
	      /* if first time, transition to sub-tables */
	      if (drop === 0) {
	        drop = root;
	      }
	
	      /* increment past last table */
	      next += min;            /* here min is 1 << curr */
	
	      /* determine length of next table */
	      curr = len - drop;
	      left = 1 << curr;
	      while (curr + drop < max) {
	        left -= count[curr + drop];
	        if (left <= 0) { break; }
	        curr++;
	        left <<= 1;
	      }
	
	      /* check for enough space */
	      used += 1 << curr;
	      if ((type === LENS && used > ENOUGH_LENS) ||
	        (type === DISTS && used > ENOUGH_DISTS)) {
	        return 1;
	      }
	
	      /* point entry in root table to sub-table */
	      low = huff & mask;
	      /*table.op[low] = curr;
	      table.bits[low] = root;
	      table.val[low] = next - opts.table_index;*/
	      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
	    }
	  }
	
	  /* fill in remaining table entry if code is incomplete (guaranteed to have
	   at most one remaining entry, since if the code is incomplete, the
	   maximum code length that was allowed to get this far is one bit) */
	  if (huff !== 0) {
	    //table.op[next + huff] = 64;            /* invalid code marker */
	    //table.bits[next + huff] = len - drop;
	    //table.val[next + huff] = 0;
	    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
	  }
	
	  /* set return parameters */
	  //opts.table_index += used;
	  opts.bits = root;
	  return 0;
	};


/***/ },
/* 330 */
/***/ function(module, exports) {

	'use strict';
	
	
	module.exports = {
	
	  /* Allowed flush values; see deflate() and inflate() below for details */
	  Z_NO_FLUSH:         0,
	  Z_PARTIAL_FLUSH:    1,
	  Z_SYNC_FLUSH:       2,
	  Z_FULL_FLUSH:       3,
	  Z_FINISH:           4,
	  Z_BLOCK:            5,
	  Z_TREES:            6,
	
	  /* Return codes for the compression/decompression functions. Negative values
	  * are errors, positive values are used for special but normal events.
	  */
	  Z_OK:               0,
	  Z_STREAM_END:       1,
	  Z_NEED_DICT:        2,
	  Z_ERRNO:           -1,
	  Z_STREAM_ERROR:    -2,
	  Z_DATA_ERROR:      -3,
	  //Z_MEM_ERROR:     -4,
	  Z_BUF_ERROR:       -5,
	  //Z_VERSION_ERROR: -6,
	
	  /* compression levels */
	  Z_NO_COMPRESSION:         0,
	  Z_BEST_SPEED:             1,
	  Z_BEST_COMPRESSION:       9,
	  Z_DEFAULT_COMPRESSION:   -1,
	
	
	  Z_FILTERED:               1,
	  Z_HUFFMAN_ONLY:           2,
	  Z_RLE:                    3,
	  Z_FIXED:                  4,
	  Z_DEFAULT_STRATEGY:       0,
	
	  /* Possible values of the data_type field (though see inflate()) */
	  Z_BINARY:                 0,
	  Z_TEXT:                   1,
	  //Z_ASCII:                1, // = Z_TEXT (deprecated)
	  Z_UNKNOWN:                2,
	
	  /* The deflate compression method */
	  Z_DEFLATED:               8
	  //Z_NULL:                 null // Use -1 or null inline, depending on var type
	};


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * body-parser
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 */
	
	var bytes = __webpack_require__(288)
	var debug = __webpack_require__(13)('body-parser:raw')
	var read = __webpack_require__(289)
	var typeis = __webpack_require__(105)
	
	/**
	 * Module exports.
	 */
	
	module.exports = raw
	
	/**
	 * Create a middleware to parse raw bodies.
	 *
	 * @param {object} [options]
	 * @return {function}
	 * @api public
	 */
	
	function raw (options) {
	  var opts = options || {}
	
	  var inflate = opts.inflate !== false
	  var limit = typeof opts.limit !== 'number'
	    ? bytes.parse(opts.limit || '100kb')
	    : opts.limit
	  var type = opts.type || 'application/octet-stream'
	  var verify = opts.verify || false
	
	  if (verify !== false && typeof verify !== 'function') {
	    throw new TypeError('option verify must be function')
	  }
	
	  // create the appropriate type checking function
	  var shouldParse = typeof type !== 'function'
	    ? typeChecker(type)
	    : type
	
	  function parse (buf) {
	    return buf
	  }
	
	  return function rawParser (req, res, next) {
	    if (req._body) {
	      debug('body already parsed')
	      next()
	      return
	    }
	
	    req.body = req.body || {}
	
	    // skip requests without bodies
	    if (!typeis.hasBody(req)) {
	      debug('skip empty body')
	      next()
	      return
	    }
	
	    debug('content-type %j', req.headers['content-type'])
	
	    // determine if request should be parsed
	    if (!shouldParse(req)) {
	      debug('skip parsing')
	      next()
	      return
	    }
	
	    // read
	    read(req, res, next, parse, debug, {
	      encoding: null,
	      inflate: inflate,
	      limit: limit,
	      verify: verify
	    })
	  }
	}
	
	/**
	 * Get the simple type checker.
	 *
	 * @param {string} type
	 * @return {function}
	 */
	
	function typeChecker (type) {
	  return function checkType (req) {
	    return Boolean(typeis(req, type))
	  }
	}


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * body-parser
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 */
	
	var bytes = __webpack_require__(288)
	var contentType = __webpack_require__(48)
	var debug = __webpack_require__(13)('body-parser:text')
	var read = __webpack_require__(289)
	var typeis = __webpack_require__(105)
	
	/**
	 * Module exports.
	 */
	
	module.exports = text
	
	/**
	 * Create a middleware to parse text bodies.
	 *
	 * @param {object} [options]
	 * @return {function}
	 * @api public
	 */
	
	function text (options) {
	  var opts = options || {}
	
	  var defaultCharset = opts.defaultCharset || 'utf-8'
	  var inflate = opts.inflate !== false
	  var limit = typeof opts.limit !== 'number'
	    ? bytes.parse(opts.limit || '100kb')
	    : opts.limit
	  var type = opts.type || 'text/plain'
	  var verify = opts.verify || false
	
	  if (verify !== false && typeof verify !== 'function') {
	    throw new TypeError('option verify must be function')
	  }
	
	  // create the appropriate type checking function
	  var shouldParse = typeof type !== 'function'
	    ? typeChecker(type)
	    : type
	
	  function parse (buf) {
	    return buf
	  }
	
	  return function textParser (req, res, next) {
	    if (req._body) {
	      debug('body already parsed')
	      next()
	      return
	    }
	
	    req.body = req.body || {}
	
	    // skip requests without bodies
	    if (!typeis.hasBody(req)) {
	      debug('skip empty body')
	      next()
	      return
	    }
	
	    debug('content-type %j', req.headers['content-type'])
	
	    // determine if request should be parsed
	    if (!shouldParse(req)) {
	      debug('skip parsing')
	      next()
	      return
	    }
	
	    // get charset
	    var charset = getCharset(req) || defaultCharset
	
	    // read
	    read(req, res, next, parse, debug, {
	      encoding: charset,
	      inflate: inflate,
	      limit: limit,
	      verify: verify
	    })
	  }
	}
	
	/**
	 * Get the charset of a request.
	 *
	 * @param {object} req
	 * @api private
	 */
	
	function getCharset (req) {
	  try {
	    return contentType.parse(req).parameters.charset.toLowerCase()
	  } catch (e) {
	    return undefined
	  }
	}
	
	/**
	 * Get the simple type checker.
	 *
	 * @param {string} type
	 * @return {function}
	 */
	
	function typeChecker (type) {
	  return function checkType (req) {
	    return Boolean(typeis(req, type))
	  }
	}


/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * body-parser
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var bytes = __webpack_require__(288)
	var contentType = __webpack_require__(48)
	var createError = __webpack_require__(50)
	var debug = __webpack_require__(13)('body-parser:urlencoded')
	var deprecate = __webpack_require__(30)('body-parser')
	var read = __webpack_require__(289)
	var typeis = __webpack_require__(105)
	
	/**
	 * Module exports.
	 */
	
	module.exports = urlencoded
	
	/**
	 * Cache of parser modules.
	 */
	
	var parsers = Object.create(null)
	
	/**
	 * Create a middleware to parse urlencoded bodies.
	 *
	 * @param {object} [options]
	 * @return {function}
	 * @public
	 */
	
	function urlencoded (options) {
	  var opts = options || {}
	
	  // notice because option default will flip in next major
	  if (opts.extended === undefined) {
	    deprecate('undefined extended: provide extended option')
	  }
	
	  var extended = opts.extended !== false
	  var inflate = opts.inflate !== false
	  var limit = typeof opts.limit !== 'number'
	    ? bytes.parse(opts.limit || '100kb')
	    : opts.limit
	  var type = opts.type || 'application/x-www-form-urlencoded'
	  var verify = opts.verify || false
	
	  if (verify !== false && typeof verify !== 'function') {
	    throw new TypeError('option verify must be function')
	  }
	
	  // create the appropriate query parser
	  var queryparse = extended
	    ? extendedparser(opts)
	    : simpleparser(opts)
	
	  // create the appropriate type checking function
	  var shouldParse = typeof type !== 'function'
	    ? typeChecker(type)
	    : type
	
	  function parse (body) {
	    return body.length
	      ? queryparse(body)
	      : {}
	  }
	
	  return function urlencodedParser (req, res, next) {
	    if (req._body) {
	      debug('body already parsed')
	      next()
	      return
	    }
	
	    req.body = req.body || {}
	
	    // skip requests without bodies
	    if (!typeis.hasBody(req)) {
	      debug('skip empty body')
	      next()
	      return
	    }
	
	    debug('content-type %j', req.headers['content-type'])
	
	    // determine if request should be parsed
	    if (!shouldParse(req)) {
	      debug('skip parsing')
	      next()
	      return
	    }
	
	    // assert charset
	    var charset = getCharset(req) || 'utf-8'
	    if (charset !== 'utf-8') {
	      debug('invalid charset')
	      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
	        charset: charset
	      }))
	      return
	    }
	
	    // read
	    read(req, res, next, parse, debug, {
	      debug: debug,
	      encoding: charset,
	      inflate: inflate,
	      limit: limit,
	      verify: verify
	    })
	  }
	}
	
	/**
	 * Get the extended query parser.
	 *
	 * @param {object} options
	 */
	
	function extendedparser (options) {
	  var parameterLimit = options.parameterLimit !== undefined
	    ? options.parameterLimit
	    : 1000
	  var parse = parser('qs')
	
	  if (isNaN(parameterLimit) || parameterLimit < 1) {
	    throw new TypeError('option parameterLimit must be a positive number')
	  }
	
	  if (isFinite(parameterLimit)) {
	    parameterLimit = parameterLimit | 0
	  }
	
	  return function queryparse (body) {
	    var paramCount = parameterCount(body, parameterLimit)
	
	    if (paramCount === undefined) {
	      debug('too many parameters')
	      throw createError(413, 'too many parameters')
	    }
	
	    var arrayLimit = Math.max(100, paramCount)
	
	    debug('parse extended urlencoding')
	    return parse(body, {
	      allowPrototypes: true,
	      arrayLimit: arrayLimit,
	      depth: Infinity,
	      parameterLimit: parameterLimit
	    })
	  }
	}
	
	/**
	 * Get the charset of a request.
	 *
	 * @param {object} req
	 * @api private
	 */
	
	function getCharset (req) {
	  try {
	    return contentType.parse(req).parameters.charset.toLowerCase()
	  } catch (e) {
	    return undefined
	  }
	}
	
	/**
	 * Count the number of parameters, stopping once limit reached
	 *
	 * @param {string} body
	 * @param {number} limit
	 * @api private
	 */
	
	function parameterCount (body, limit) {
	  var count = 0
	  var index = 0
	
	  while ((index = body.indexOf('&', index)) !== -1) {
	    count++
	    index++
	
	    if (count === limit) {
	      return undefined
	    }
	  }
	
	  return count
	}
	
	/**
	 * Get parser for module name dynamically.
	 *
	 * @param {string} name
	 * @return {function}
	 * @api private
	 */
	
	function parser (name) {
	  var mod = parsers[name]
	
	  if (mod !== undefined) {
	    return mod.parse
	  }
	
	  // this uses a switch for static require analysis
	  switch (name) {
	    case 'qs':
	      mod = __webpack_require__(40)
	      break
	    case 'querystring':
	      mod = __webpack_require__(35)
	      break
	  }
	
	  // store to prevent invoking require()
	  parsers[name] = mod
	
	  return mod.parse
	}
	
	/**
	 * Get the simple query parser.
	 *
	 * @param {object} options
	 */
	
	function simpleparser (options) {
	  var parameterLimit = options.parameterLimit !== undefined
	    ? options.parameterLimit
	    : 1000
	  var parse = parser('querystring')
	
	  if (isNaN(parameterLimit) || parameterLimit < 1) {
	    throw new TypeError('option parameterLimit must be a positive number')
	  }
	
	  if (isFinite(parameterLimit)) {
	    parameterLimit = parameterLimit | 0
	  }
	
	  return function queryparse (body) {
	    var paramCount = parameterCount(body, parameterLimit)
	
	    if (paramCount === undefined) {
	      debug('too many parameters')
	      throw createError(413, 'too many parameters')
	    }
	
	    debug('parse urlencoding')
	    return parse(body, undefined, undefined, {maxKeys: parameterLimit})
	  }
	}
	
	/**
	 * Get the simple type checker.
	 *
	 * @param {string} type
	 * @return {function}
	 */
	
	function typeChecker (type) {
	  return function checkType (req) {
	    return Boolean(typeis(req, type))
	  }
	}


/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	var userRouter = __webpack_require__(335);
	var mainRouter = __webpack_require__(338);
	
	module.exports = function(app) {
	  app.use('/', mainRouter);
	  app.use('/users', userRouter);
	}


/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	var express = __webpack_require__(1);
	var router = express.Router();
	var controller = __webpack_require__(336);
	
	router.get('/', controller.getUsers)
	  .get('/:id', controller.getUser)
	  .post('/', controller.createUser)
	  .put('/:id', controller.editUser)
	  .delete('/:id', controller.removeUser)
	
	module.exports = router;


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	var User = __webpack_require__(337);
	var mongoose = __webpack_require__(118);
	
	function UserController() {}
	
	UserController.prototype.getUsers = function(req, res) {
	  return new Promise(function(resolve, reject) {
	    User.find({}, function(error, users) {
	      if(error) {
	        reject(error);
	      } else {
	        resolve(users);
	      }
	    });
	  }).then(function(users) {
	    res.status(200).json(users);
	  }).catch(function(error) {
	    console.log(error);
	  });
	}
	
	UserController.prototype.getUser = function(req, res) {
	  return new Promise(function(resolve, reject) {
	    var user_id = { _id: req.params.id };
	    User.findOne(user_id, function(error, user) {
	      if(error) {
	        reject(error);
	      } else {
	        resolve(user);
	      }
	    });
	  }).then(function(user) {
	      res.status(200).json(user);
	    }).catch(function(error) {
	      console.log(error);
	    });
	}
	
	UserController.prototype.createUser = function(req, res) {
	  return new Promise(function(resolve, reject) {
	    var newUser = {
	      name: req.body.name,
	      message: req.body.message
	    };
	    User.create(newUser, function(error, user) {
	      if(error) {
	        reject(error);
	      } else {
	        resolve(user);
	      }
	    });
	  }).then(function(user) {
	      res.status(201).json(user);
	    }).catch(function(error) {
	      console.log(error);
	    });
	}
	
	UserController.prototype.editUser = function(req, res) {
	  return new Promise(function(resolve, reject) {
	    var _id = { _id: req.params.id };
	    console.log(req.body);
	    User.findOneAndUpdate(_id, function(error, user) {
	      if(error) {
	        reject(error);
	      } else {
	        resolve(user);
	      }
	    });
	  }).then(function(user) {
	      user.name = req.body.name;
	      user.message = req.body.message;
	      user.save(function(err, user) {
	        if(err) {
	          console.log(err);
	        } else {
	          console.log('successful edit' + user);
	        }
	      });
	      res.status(204).json(user);
	    }).catch(function(error) {
	      console.log(error);
	    });
	}
	
	UserController.prototype.removeUser = function(req, res) {
	  return new Promise(function(resolve, reject) {
	    User.findOneAndRemove({ _id: req.params.id }, function(error, user) {
	      if(error) {
	        reject(error);
	      } else {
	        resolve(user);
	      }
	    })
	  }).then(function(user) {
	      res.status(204).end();
	    }).catch(function(error) {
	      console.log(error);
	  });
	}
	
	
	module.exports = UserController.prototype;
	
	


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	var mongoose = __webpack_require__(118);
	
	var userSchema = mongoose.Schema({
	  name: String,
	  message: String
	});
	
	// animalSchema.statics.findByName = function(name, cb) {
	//   return this.find({ name: new RegExp(name, 'i') }, cb);
	// };
	
	// kittySchema.methods.speak = function () {
	//   var greeting = this.name
	//     ? "Meow name is " + this.name
	//     : "I don't have a name";
	//   console.log(greeting);
	// }
	
	// // var Kitten = mongoose.model('Kitten', kittySchema);
	// var fluffy = new Kitten({ name: 'fluffy' });
	// fluffy.speak(); // "Meow name is fluffy"
	
	module.exports = mongoose.model('User', userSchema);
	


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	var express = __webpack_require__(1);
	var router = express.Router();
	var controller = __webpack_require__(339);
	
	router.get('/', controller.getRoot);
	
	module.exports = router;
	


/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {var path = __webpack_require__(45);
	
	function MainController() {}
	
	MainController.prototype.getRoot = function(req, res) {
	  res.sendFile(path.join(__dirname, '../../../public/index'));
	}
	
	module.exports = MainController.prototype;
	
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ }
/******/ ]);
//# sourceMappingURL=node_react_project.1.0.0.js.map